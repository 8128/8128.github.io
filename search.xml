<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Node.JS exports用法</title>
      <link href="/2020/04/17/Node.JS%20exports%E7%94%A8%E6%B3%95/"/>
      <url>/2020/04/17/Node.JS%20exports%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自：<a href="https://gywbd.github.io/posts/2014/11/using-exports-nodejs-interface-design-pattern.html" target="_blank" rel="noopener">https://gywbd.github.io/posts/2014/11/using-exports-nodejs-interface-design-pattern.html</a></p><p>当我刚开始接触node的时候，我很困惑于为什么一个模块中即可以用<code>exports</code>，也可以用<code>module.exports</code>暴露接口，另外javascript的灵活性也导致暴露接口的写法多种多样，假设我们要定义一个输出<code>“hello world”</code>的模块，下面有两种写法来定义这个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘world’);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">var</span> f = &#123;</span><br><span class="line">    hello : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(‘world’);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = f;</span><br></pre></td></tr></table></figure><p>假设我们写的这个模块的文件名为<code>hello.js</code>，执行下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="built_in">require</span>(‘hello’);</span><br><span class="line">h.hello();</span><br></pre></td></tr></table></figure><p>对于上面的两种写法，执行这段代码后得出的结果是一样的。</p><p>理论上这两种写法没有什么区别。如果一个接口只是提供者一个函数，那么这两种写法在实质上也没有什么区别，这就是javascript灵活之所在。不过既然有这么多不同的写法，我们就不免要问在什么情况下这些不同的写法会有不同的含义？或者我们用一种更高大上的语言来描述，对于通过<code>exports</code>或者<code>module.exports</code>来暴露的接口，我们要怎么设计这些接口才是最合适的呢，这也就是这篇文章所要谈论的主题。根据个人经验，我提炼了7种模式：</p><ul><li>exports命名空间</li><li>exports一个工厂方法</li><li>exports一个偏函数</li><li>exports构造函数</li><li>exports单例</li><li>扩展全局对象</li><li>实现Monkey Patch</li></ul><h3 id="require、exports和module-exports"><a href="#require、exports和module-exports" class="headerlink" title="require、exports和module.exports"></a>require、exports和module.exports</h3><p>在开始介绍上面7种模式之前，有必要先介绍点基础知识。</p><p>我们都知道在node的代码中使用<code>require</code>加载模块，在模块中使用<code>exports</code>或者<code>module.exports</code>导出接口，<code>require</code>、<code>module</code>、<code>exports</code>都是node的全局对象，我们不需要在模块中定义它们就可以直接使用，不过实际它们都不是全局的，而是模块对象，node的文档中有说明，此外还有<code>__dirname</code>和<code>__filename</code>这两个变量也是模块对象，它们的具体作用请参见文档。所谓模块对象就是它们的作用域仅限于当前模块，这就引出了一个问题，既然作用域仅限于当前模块，那又为什么可以直接使用呢？为了回答这个问题，我们先看一个模块的代码，我们编写了一个<code>bar.js</code>的文件，这是一个node模块，然后再<code>use-bar.js</code>中使用这个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bar.js</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘it is bar’);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports = bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use-bar.js</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="built_in">require</span>(‘./bar.js’);</span><br><span class="line">bar();  <span class="comment">//这个会报错：TypeError: object is not a function</span></span><br></pre></td></tr></table></figure><p>执行上面的<code>use-bar.js</code>会抛出类型错误的错误，这个错误提示对象不是一个函数，但在<code>bar.js</code>中很明显是将exports赋值给了一个函数啊？ok，我们改一下<code>bar.js</code>，改成下面的样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bar.js</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘it is bar’);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = bar;</span><br></pre></td></tr></table></figure><p>然后再执行<code>use-bar.js</code>，这个时候会正常执行并输出<code>it is bar</code>。why？</p><p>对于这个问题我们先要了解下node是怎么编译javascript模块的（node还可以用c++写模块，这就是另外一个话题了），上面说了<code>require</code>，<code>exports</code>和<code>module</code>都是模块对象，但之所以可以在模块中不先声明就可以直接使用，是因为node在编译js模块的时候，将我们所写的代码进行了包装，将整个代码放进了一个函数中，具体是这个样子：</p><p>(function(exports,require,module,<strong>filename,</strong>dirname){ var bar = function(){ console.log(‘it is bar’); } module.exports = bar; });</p><p>然后在调用模块的时候会传入这些变量，这样我们在编写模块的时候就可以直接使用这些变量（这里我们又看到了<code>__filename</code>和<code>__dirname</code>），那为什么使用<code>exports=bar</code>会报错，而使用<code>module.exports=bar</code>又是正确的呢？这是因为<code>exports</code>本身就只是<code>module.exports</code>的引用，而使用<code>require</code>加载模块的时候返回的是<code>module.exports</code>，<code>exports=bar</code>改变了<code>exports</code>的引用，所以最终返回的<code>module.exports</code>只是一个空对象，所以会报<code>TypeError</code>的错误。</p><p><code>require</code>还有一个重要的行为就是缓存加载的模块，我们在上面的<code>globals</code>的文档中可以看到一个<code>require.cache</code>的对象，这个就是用于缓存加载的模块的对象，node是根据模块的绝对路径进行模块加载的，我们在REPL上看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; f1 = <span class="built_in">require</span>(‘/Users/lscm/node/test/<span class="function"><span class="keyword">function</span>’);</span></span><br><span class="line">[Function]</span><br><span class="line">&gt; f2 = <span class="built_in">require</span>(‘./<span class="function"><span class="keyword">function</span>’);</span></span><br><span class="line">[Function]</span><br><span class="line">&gt; f1 === f2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; f1() === f2()</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>我们可以看到<code>require</code>返回的实例是一样的，但如果调用<code>f1()</code>和<code>f2()</code>返回的也是对象的话（如果返回的不是对象，例如是字符串或者<code>int</code>型的值，<code>f1()===f2()</code>还是会返回<code>true</code>），它们返回的值不一样，这是因为第二次调用<code>require</code>返回的对象是第一次调用<code>require</code>返回的同一个对象，第一次调用的时候将它缓存起来了。</p><p>我们可以在node提供的<a href="http://nodejs.org/api/modules.html" target="_blank" rel="noopener">文档</a>中了解到更多细节，在此就不在深究了，下面我们开始接口设计模式的旅程吧。</p><h3 id="exports命名空间"><a href="#exports命名空间" class="headerlink" title="exports命名空间"></a>exports命名空间</h3><p>node中没有命名空间的概念，模块和包就是组织代码的唯一方式，另外根据我们上面介绍的node编译javascript模块的方式，它本身就会将模块中不用暴露出来的变量限制在当前模块的作用域中，这就实现了避免变量污染的作用，但通过<code>exports</code>我们可以实现类似命名空间的东西。我们先看下node的文件系统核心模块，下面这段代码使用了文件系统模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’),</span><br><span class="line">    readFile = fs.readFile,</span><br><span class="line">    ReadStream = fs.ReadStream.</span><br><span class="line"></span><br><span class="line">readFile(‘./file.txt’,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘readFile contents: %s’,data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ReadStream(‘./file.txt’).on(‘data’,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘ReadStream contents: %s’,data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码先使用<code>require(‘fs’)</code>加载fs模块，并将其赋值给变量<code>fs</code>，然后将<code>fs</code>模块中的<code>readFile</code>和<code>ReadStream</code>两个变量赋值给<code>readFile</code>和<code>ReadStream</code>两个本地变量，我们可以将<code>fs</code>理解成一个命名空间，而其中的<code>readFile</code>和<code>ReadStream</code>这两个变量则是<code>fs</code>这个命名空间下的变量。我们再看看node的<code>fs</code>核心模块是怎么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = exports;</span><br></pre></td></tr></table></figure><p>它首先将<code>exports</code>的引用赋值给一个本地变量<code>fs</code>，这样<code>fs</code>这个本地变量就跟<code>exports</code>都引用同一个对象，也就是<code>module.exports</code>，所以<code>fs</code>这个对象的所有成员变量和成员函数最终都是<code>module.exports</code>的成员变量和成员函数，这些成员变量和成员函数都会暴露出来，通过<code>require</code>加载这个模块后就可以直接使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path, options, callback_</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里导出了<code>readFile</code>这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.ReadStream = ReadStream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadStream</code>是一个构造函数，也是通过赋值给<code>fs</code>导出。</p><p>如果要用<code>exports</code>导出一个命名空间，既可以像<code>fs</code>模块这样，将<code>exports</code>赋值给<code>fs</code>，也可以通过将一个新对象赋值给<code>module.exports</code>实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  version: <span class="string">'1.0'</span>,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个通常用于暴露命名空间的方式，就是将命名空间作为一个根模块，然后在这个根模块中载入很多子模块，再将这些子模块加入到命名空间中。这个方式可以用于模型(model)的设计，我们先定义一个<code>models</code>的模块，这里包括所有子模块，每个子模块就是一个特定的模型，假设这个我们有用户(User)、用户信息(UserProfile)、产品(Product)等几个具体的模型，那么使用<code>require</code>引入<code>models</code>这个模块后，就可以通过<code>models</code>这个模块使用这些模型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> models = <span class="built_in">require</span>(<span class="string">'./models'</span>),</span><br><span class="line">    User = models.User,</span><br><span class="line">    Product = models.Product;</span><br></pre></td></tr></table></figure><p><code>models</code>模块的<code>index.js</code>可能是下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.User = <span class="built_in">require</span>(<span class="string">'./user'</span>);</span><br><span class="line">exports.Person = <span class="built_in">require</span>(<span class="string">'./person'</span>);</span><br></pre></td></tr></table></figure><p>实际工程中，如果这些模型的模块文件都在同一个目录下面，我们可以使用一条语句就可以全部加载进行并赋值给<code>module.exports</code>进行暴露。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'../lib/require_siblings'</span>)(__filename);</span><br></pre></td></tr></table></figure><h3 id="exports一个工厂方法"><a href="#exports一个工厂方法" class="headerlink" title="exports一个工厂方法"></a>exports一个工厂方法</h3><p>另外一种模式就是通过<code>exports</code>暴露一个函数，这个函数是一个工厂方法，调用这个工厂方法后会创建一个对象，这个对象会用于完成我们的工作，express就是这么干的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send <span class="string">"Hi there! We're using Express v"</span> + express.version;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你用过express的话，相信你会都很熟悉，也会很陌生上面的代码，说熟悉是因为我们用express的话都会使用这段代码，说模式是因为我们基本上这段代码都是用工具直接生成的，或者是直接copy的，很少会自己写，至少我通常都是这么干的。这个段代码中<code>require(‘express’)</code>会返回一个工厂方法，调用这个方法就会创建express的<code>Application</code>对象。</p><p>这个模式实际是暴露了一个函数，在使用<code>exports</code>暴露函数的时候，我们建议对这个函数命名，这样在抛出错误的时候会在错误栈中输出这个函数名称，我们看下下面两个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bomb1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bomb2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bomb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们现在在REPL中分别引入这两个模块，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; bomb = <span class="built_in">require</span>(<span class="string">'./bomb1'</span>);</span><br><span class="line">[<span class="built_in">Function</span>]</span><br><span class="line">&gt; bomb()</span><br><span class="line"><span class="built_in">Error</span>: boom</span><br><span class="line">    at <span class="built_in">module</span>.exports (<span class="regexp">/Users/</span>alon/Projects/export_this/bomb1.js:<span class="number">2</span>:<span class="number">9</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&gt; bomb = <span class="built_in">require</span>(<span class="string">'./bomb2'</span>);</span><br><span class="line">[<span class="built_in">Function</span>: bomb]</span><br><span class="line">&gt; bomb()</span><br><span class="line"><span class="built_in">Error</span>: boom</span><br><span class="line">    at bomb (<span class="regexp">/Users/</span>alon/Projects/export_this/bomb2.js:<span class="number">2</span>:<span class="number">9</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我们可以看到第一个调用第一个模块，输出的错误信息是<code>at module.exports (/Users/alon/Projects/export_this/bomb1.js:2:9)</code>，而第二个模块被调用的时候输出<code>at bomb (/Users/alon/Projects/export_this/bomb2.js:2:9)</code>。</p><h3 id="exports一个偏函数"><a href="#exports一个偏函数" class="headerlink" title="exports一个偏函数"></a>exports一个偏函数</h3><p>首先解释下什么是偏函数，深入浅出nodejs中对此做了很好的定义，而且也举了一个很经典的例子，我们先看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == ‘[object <span class="built_in">String</span>]’;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == ‘[object <span class="built_in">Function</span>]’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中的<code>isString</code>和<code>isFunction</code>这两个函数分别用于判断变量的类型是字符串和函数，对于这种函数，如果要添加其他类型的判断，就需要写更多的函数，但是因为这些函数都有一些共同的特征，所以只需要写一个函数，然后让这个函数返回判断某个类型的函数就可以了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString.call(obj) == ‘[object ‘ + type + ’]’; </span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(‘<span class="built_in">String</span>’);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(‘<span class="built_in">Function</span>’);</span><br></pre></td></tr></table></figure><p><code>isString</code>和<code>isFunction</code>这种类型的函数很容易创建，这里通过指定参数返回一个新定制函数的形式就叫做偏函数，简单点说偏函数就是返回函数的函数，这种模式在node的模块接口设置中很有价值。</p><p>用过express的人都应该知道中间件这个东西，express用的是Connect的中间件。Connect提供了一套中间件用于Web开发，中间件就是一个函数，这个函数会有三个参数——<code>(req,res,next)</code>，我们看下Express是怎么使用Connect的<code>query</code>中间件的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'connect'</span>),</span><br><span class="line">    query = <span class="built_in">require</span>(<span class="string">'connect/lib/middleware/query'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(query(&#123;<span class="attr">maxKeys</span>: <span class="number">100</span>&#125;));</span><br></pre></td></tr></table></figure><p>调用<code>query</code>函数会返回一个参数为<code>(req,res,next)</code>的函数，<code>app.use</code>就可以使用这个中间件，<code>query</code>函数可以根据传入的参数返回不同的中间件，我们看下<code>query</code>的源代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>)</span><br><span class="line">  , parse = <span class="built_in">require</span>(<span class="string">'../utils'</span>).parseUrl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req.query) &#123;</span><br><span class="line">      req.query = ~req.url.indexOf(<span class="string">'?'</span>)</span><br><span class="line">        ? qs.parse(parse(req).query, options)</span><br><span class="line">        : &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中<code>query</code>函数会接受一个<code>options</code>的参数，并且会返回一个<code>query(req,res,next)</code>的函数，Express使用这个中间件就是实现将url中的查询字符串转换为一个<code>query</code>对象，并且赋值给<code>req</code>，我们通过<code>req.query</code>访问查询字符串的值。</p><p>这种暴露接口的模式非常灵活有效，会给我们的工作带来很多便利。</p><h3 id="exports构造函数"><a href="#exports构造函数" class="headerlink" title="exports构造函数"></a>exports构造函数</h3><p>先看下javascript中怎么定义构造函数，以及怎么通过<code>new</code>关键字来创建新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi, I'm Jane."</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.greet()); <span class="comment">// prints: Hi, I'm Jane</span></span><br></pre></td></tr></table></figure><p>第一个<code>Person</code>函数就是<code>Person</code>这个类的构造函数，跟普通的函数定义没什么差别，然后再<code>Person</code>的<code>prototype</code>上定义了一个<code>greet</code>函数，再使用<code>new Person(&#39;&#39;)</code>来创建<code>Person</code>类的对象，这个对象就可以访问<code>greet</code>方法，这就是javascript里面的构造函数的定义和使用，既然构造函数是一个普通函数，那么我们也直接在模块中使用<code>exports</code>暴露这个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi, I'm "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Person;</span><br></pre></td></tr></table></figure><p>然后商用上面的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="built_in">require</span>(<span class="string">'./person'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br></pre></td></tr></table></figure><p>通过暴露构造函数，我们可以创建多个对象，这种方式在node的模块设计中非常常见。</p><h3 id="exports一个单例"><a href="#exports一个单例" class="headerlink" title="exports一个单例"></a>exports一个单例</h3><p>有时候我们希望通过<code>require()</code>加载的模块能够在所有调用地方共享这个模块的状态和行为，这就是单例对象的应用模式。</p><p>我们来看看<code>Mongoose</code>这个模块，<code>Mongoose</code>是一个对象文档映射库(Object-Document Mapping)，从名字可以看出这个库是跟MongoDB有关的，它可以用于为存储在MongoDB中的数据创建富领域模型(Rich domain model)。</p><p>如果我们要使用它，必须先建立数据库连接，一般的web应用都是在程序启动的时候建立数据库连接，假设我们是在Express搭建一个Web应用，我们可以在入口文件<code>app.js</code>中先用<code>Mongoose</code>建立数据库连接，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure><p>然后我们在<code>cat.js</code>这个文件中要使用mongoDB的数据，代码可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cat = mongoose.model(<span class="string">'Cat'</span>, &#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kitty = <span class="keyword">new</span> Cat(&#123; <span class="attr">name</span>: <span class="string">'Zildjian'</span> &#125;);</span><br><span class="line">kitty.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'meow'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以看到这里没有再连接数据库了。这说明在<code>app.js</code>中加载mongoose模块，并且使用这个模块连接数据库，然后再在<code>cat.js</code>中<code>require</code>这个模块的时候，这个模块对于mongoDB数据库还是处于连接状态，这就是一种单例对象。这是怎么实现的呢？我们先看下<code>mongoose</code>这个模块是怎么使用<code>exports</code>导出的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mongoose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = exports = <span class="keyword">new</span> Mongoose();</span><br></pre></td></tr></table></figure><p><code>exports</code>是一个对象，这个对象是<code>Mongoose</code>的实例。还记得前面我们说过的node的模块缓存机制么？每次<code>require</code>某个模块的时候，node都会将这个<code>require</code>返回的对象缓存起来，缓存的key就是这个模块的绝对路径，所以因为<code>mongoose</code>这个模块<code>exports</code>的是<code>Mongoose</code>的实例，所以每次<code>require</code>这个模块的时候都是返回同一个对象，这样就实现了在所有使用<code>mongoose</code>模块的地方都使用同一个对象，这就是单例模式的经典应用。</p><p><code>mongoose</code>这个模块还是提供了命名空间的应用模式</p><p>在<code>mongoose</code>的源代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mongoose.prototype.Mongoose = Mongoose;</span><br></pre></td></tr></table></figure><p>所以我们可以在代码中直接创建<code>mongoose</code>的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>),</span><br><span class="line">    Mongoose = mongoose.Mongoose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMongoose = <span class="keyword">new</span> Mongoose();</span><br><span class="line">myMongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure><h3 id="exports全局对象"><a href="#exports全局对象" class="headerlink" title="exports全局对象"></a>exports全局对象</h3><p>在node的模块中，不仅仅只是可以<code>exports</code>一个值，还可以修改全局对象。当你需要扩展全局对象，或者是修改全局对象的行为时，可以使用这种模式。通常而言，我们并不建议扩展或者修改全局对象，但是对于一些特殊情况或者应用场景，使用这种模式还是很有价值的。</p><p><code>Should.js</code>就是使用这种模式的典型，它是一个用于单元测试的断言库，我们一般会这么使用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">'Jane'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.name.should.equal(<span class="string">'Jane'</span>);</span><br></pre></td></tr></table></figure><p><code>Should.js</code>通过扩展全局对象，为其添加了一个non-enumerable的属性——<code>should</code>，这让编写单元测试非常清晰方便，我们看看它是怎么实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Assertion(util.isWrapperType(obj) ? obj.valueOf(): obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">exports = <span class="built_in">module</span>.exports = should;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'should'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function()&#123;&#125;,</span><br><span class="line">  <span class="keyword">get</span>: function()&#123;</span><br><span class="line">    <span class="keyword">return</span> should(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码的上面一部分实际上是将<code>should</code>作为一个函数导出，这么做是为了实现通过调用<code>should</code>函数也可以实现单元测试的作用，而后面的部分就是扩展全局对象<code>Object</code>。</p><h3 id="实现Monkey-Patch"><a href="#实现Monkey-Patch" class="headerlink" title="实现Monkey Patch"></a>实现Monkey Patch</h3><p>什么是Monkey Patch呢？直译出来是猴子补丁，它的意思是：在运行时动态修改某个类或者模块，多用于给第三方代码打补丁，一般用于修改第三方代码的bug，或者是添加一些没有的功能，至于为什么要用这个名字，我也不知道为什么，有兴趣的可以查看<a href="http://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="noopener">wiki</a>上的定义。我们可以定义一个模块用于给一个已存在的模块打补丁，特别是当这个已存在的模块并未提供接口定制它的行为。这个模式实际上是上一个模式的变体，</p><p>我们还是来看下<code>mongoose</code>这个模块，默认情况<code>mongoose</code>这个模块会将<code>model</code>的名称转换为小写和复数的形式作为MongoDB的collection的名称，例如如果我们将模块的名称命名为<code>CreditCardAccountEntry</code>，那么它对应的collection的名称就是<code>creditcardaccountentries</code>，但实际上这个名称非常难以阅读，通常我更喜欢使用<code>credit_card_account_entries</code>，而且我希望这能够作为一种通用模式。</p><p>这里我只有给<code>mongoose.model</code>打补丁，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>).Mongoose;</span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = Mongoose.prototype.model;</span><br><span class="line"><span class="keyword">var</span> modelWithUnderScoreCollectionName = <span class="function"><span class="keyword">function</span>(<span class="params">name, schema, collection, skipInit</span>) </span>&#123;</span><br><span class="line">  collection = collection || _(name).chain().underscore().pluralize().value();</span><br><span class="line">  model.call(<span class="keyword">this</span>, name, schema, collection, skipInit);</span><br><span class="line">&#125;;</span><br><span class="line">Mongoose.prototype.model = modelWithUnderScoreCollectionName;</span><br></pre></td></tr></table></figure><p>当这个模块第一次被加载的时候，它会加载<code>mongoose</code>，重新定义<code>Mongoose.prototype.model</code>，这里使用了代理模式，最终这个新的<code>model</code>方法也会使用原来的<code>model</code>方式来实现对应的功能。现在所有<code>Mongoose</code>的实例都有这个新的行为。注意，这里没有给<code>exports</code>赋值，所以使用<code>require</code>加载这个模块是时候返回是空对象，这也说<code>exports</code>所表示的默认值。</p><p>这里有一点需要注意的，当你要采用这种模式来改变第三方模块的行为的时候，最好是采用这里所用的方式，采用代理模式，尽可能用第三方模块提供的默认行为了完成你的行为，这可以保证在第三方模块更新后还可以继续使用更新后的功能。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这篇文章中7种模式只是我个人总结的几种<code>exports</code>模块的策略，方便我们设计node的模块，当然肯定还有其他不同的模式，欢迎大家提供更多更好的模式。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS显示隐藏文件</title>
      <link href="/2020/04/14/MacOS%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
      <url>/2020/04/14/MacOS%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快捷键切换显示"><a href="#快捷键切换显示" class="headerlink" title="快捷键切换显示"></a>快捷键切换显示</h2><p><code>command+shift+.</code></p><p>可以显示隐藏文件、文件夹，再按一次，恢复隐藏</p><h2 id="切换始终显示隐藏文件-始终不显示隐藏文件"><a href="#切换始终显示隐藏文件-始终不显示隐藏文件" class="headerlink" title="切换始终显示隐藏文件/始终不显示隐藏文件"></a>切换始终显示隐藏文件/始终不显示隐藏文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span>;</span><br><span class="line">KillAll Finder</span><br></pre></td></tr></table></figure><p>将 true 改成 false, 就可恢复隐藏状态</p><p>这种方法在你关闭finder之后不会失效</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker快速入门</title>
      <link href="/2020/04/14/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2020/04/14/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自 <a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a></p><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://yeasy.gitbooks.io/docker_practice/repository/nexus3_registry.html" target="_blank" rel="noopener">Sonatype Nexus</a>。</p><h2 id="Mac安装docker"><a href="#Mac安装docker" class="headerlink" title="Mac安装docker"></a>Mac安装docker</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h3><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的 <a href="https://github.com/Homebrew/homebrew-cask" target="_blank" rel="noopener">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install docker</span><br></pre></td></tr></table></figure><p>查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 19.03.1, build 74b1e89</span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">$ docker-machine --version</span><br><span class="line">docker-machine version 0.16.1, build cce350d7</span><br></pre></td></tr></table></figure><p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">Nginx 服务器</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure><p>服务运行后，可以访问 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200414014820.png"  alt=""></p><p>要停止 Nginx 服务器并删除执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop webserver</span><br><span class="line">$ docker rm webserver</span><br></pre></td></tr></table></figure><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/search?q=&type=image" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">镜像加速器</a> 一节配置加速器。</em></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"18.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu               latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/_/ubuntu?tab=tags" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 ``。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>。除了 `docker pull` 可能导致这种情况，`docker build` 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure><h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">f753707788c5</span><br><span class="line">f753707788c5</span><br><span class="line">1e0c3dd64ccd</span><br></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/introduction/" target="_blank" rel="noopener">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">1e0c3dd64ccd: ubuntu</span><br></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">f753707788c5        ubuntu              18.04</span><br><span class="line">f753707788c5        ubuntu              latest</span><br></pre></td></tr></table></figure><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h3 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h3><h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h4 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> docker </tag>
            
            <tag> microservices </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JWT</title>
      <link href="/2020/04/13/%E5%85%B3%E4%BA%8EJWT/"/>
      <url>/2020/04/13/%E5%85%B3%E4%BA%8EJWT/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文传送门：<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a> <a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></p><h2 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="string">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="string">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200413225140.png"  alt=""></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure></blockquote><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200413225200.png"  alt=""></p><p>下面依次介绍这三个部分。</p><h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a>， by Auth0</li><li><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c" target="_blank" rel="noopener">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele</li><li><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md" target="_blank" rel="noopener">Learn how to use JSON Web Tokens</a>, by dwyl</li></ul><p>（完）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript数据结构</title>
      <link href="/2020/04/10/TypeScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/04/10/TypeScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><p>如前文所提及，类型注解使用 <code>:TypeAnnotation</code> 语法。在类型声明空间中可用的任何内容都可以用作类型注解。</p><p>在下面这个例子中，使用了变量、函数参数以及函数返回值的类型注解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 <code>string</code>、<code>number</code>、<code>boolean</code> 也可以被用作类型注解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line">num = <span class="number">123.456</span>;</span><br><span class="line">num = <span class="string">'123'</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">'123'</span>;</span><br><span class="line">str = <span class="number">123</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">bool = <span class="literal">true</span>;</span><br><span class="line">bool = <span class="literal">false</span>;</span><br><span class="line">bool = <span class="string">'false'</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>来源：<a href="https://jkchao.github.io/typescript-book-chinese/typings/overview.html" target="_blank" rel="noopener">深入理解typescript</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>TypeScript 为数组提供了专用的类型语法，因此你可以很轻易的注解数组。它使用后缀 <code>[]</code>， 接着你可以根据需要补充任何有效的类型注解（如：<code>:boolean[]</code>）。它能让你安全的使用任何有关数组的操作，而且它也能防止一些类似于赋值错误类型给成员的行为。如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boolArray: <span class="built_in">boolean</span>[];</span><br><span class="line"></span><br><span class="line">boolArray = [<span class="literal">true</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="built_in">console</span>.log(boolArray[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(boolArray.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">boolArray[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">boolArray = [<span class="literal">false</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">boolArray[<span class="number">0</span>] = <span class="string">'false'</span>; <span class="comment">// Error</span></span><br><span class="line">boolArray = <span class="string">'false'</span>; <span class="comment">// Error</span></span><br><span class="line">boolArray = [<span class="literal">true</span>, <span class="string">'false'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>Add to the end of an Array</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newLength = fruits.push(<span class="string">'Orange'</span>)</span><br><span class="line"><span class="comment">// ["Apple", "Banana", "Orange"]</span></span><br></pre></td></tr></table></figure><p><strong>Remove from the end of an Array</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> last = fruits.pop() <span class="comment">// remove Orange (from the end)</span></span><br><span class="line"><span class="comment">// ["Apple", "Banana"]</span></span><br></pre></td></tr></table></figure><p><strong>Remove from the front of an Array</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = fruits.shift() <span class="comment">// remove Apple from the front</span></span><br><span class="line"><span class="comment">// ["Banana"]</span></span><br></pre></td></tr></table></figure><p><strong>Add to the front of an Array</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newLength = fruits.unshift(<span class="string">'Strawberry'</span>) <span class="comment">// add to the front</span></span><br><span class="line"><span class="comment">// ["Strawberry", "Banana"]</span></span><br></pre></td></tr></table></figure><p><strong>Find the index of an item in the Array</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits.push(<span class="string">'Mango'</span>)</span><br><span class="line"><span class="comment">// ["Strawberry", "Banana", "Mango"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pos = fruits.indexOf(<span class="string">'Banana'</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>Remove an item by index position</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> removedItem = fruits.splice(pos, <span class="number">1</span>) <span class="comment">// this is how to remove an item</span></span><br><span class="line">                                        </span><br><span class="line"><span class="comment">// ["Strawberry", "Mango"]</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是 TypeScript 的一个核心知识，它能合并众多类型声明至一个类型声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  second: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name: Name;</span><br><span class="line">name = &#123;</span><br><span class="line">  first: <span class="string">'John'</span>,</span><br><span class="line">  second: <span class="string">'Doe'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  <span class="comment">// Error: 'Second is missing'</span></span><br><span class="line">  first: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  <span class="comment">// Error: 'Second is the wrong type'</span></span><br><span class="line">  first: <span class="string">'John'</span>,</span><br><span class="line">  second: <span class="number">1337</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，我们把类型注解：<code>first: string</code> + <code>second: string</code> 合并到了一个新的类型注解里 <code>Name</code>，这样能强制对每个成员进行类型检查。接口在 TypeScript 拥有强大的力量，稍后，我们将会用一个内容专门阐述如何更好的使用它。</p><h2 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h2><p>与创建一个接口不同，你可以使用内联注解语法注解任何内容：<code>:{ /*Structure*/ }</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  second: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  first: <span class="string">'John'</span>,</span><br><span class="line">  second: <span class="string">'Doe'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  <span class="comment">// Error: 'Second is missing'</span></span><br><span class="line">  first: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  <span class="comment">// Error: 'Second is the wrong type'</span></span><br><span class="line">  first: <span class="string">'John'</span>,</span><br><span class="line">  second: <span class="number">1337</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦（你可能会使用一个很糟糕的名称）。然而，如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 <code>type alias</code>，它会在接下来的部分提到）是一个不错的主意。</p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><p>除了被提到的一些原始类型，在 TypeScript 中，还存在一些特殊的类型，它们是 <code>any</code>、 <code>null</code>、 <code>undefined</code> 以及 <code>void</code>。</p><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><code>any</code> 类型在 TypeScript 类型系统中占有特殊的地位。它提供给你一个类型系统的「后门」,TypeScript 将会把类型检查关闭。在类型系统里 <code>any</code> 能够兼容所有的类型（包括它自己）。因此，所有类型都能被赋值给它，它也能被赋值给其他任何类型。以下有一个证明例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> power: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值任意类型</span></span><br><span class="line">power = <span class="string">'123'</span>;</span><br><span class="line">power = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它也兼容任何类型</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span>;</span><br><span class="line">power = num;</span><br><span class="line">num = power;</span><br></pre></td></tr></table></figure><p>当你把 JavaScript 迁移至 TypeScript 时，你将会经常性使用 <code>any</code>。但你必须减少对它的依赖，因为你需要确保类型安全。当使用 <code>any</code> 时，你基本上是在告诉 TypeScript 编译器不要进行任何的类型检查。</p><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>在类型系统中，JavaScript 中的 null 和 undefined 字面量和其他被标注了 <code>any</code> 类型的变量一样，都能被赋值给任意类型的变量，如下例子所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strictNullChecks: false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些类型能被赋予</span></span><br><span class="line">num = <span class="literal">null</span>;</span><br><span class="line">str = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>使用 <code>:void</code> 来表示一个函数没有一个返回值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在计算机科学中，许多算法和数据结构并不会依赖于对象的实际类型。但是，你仍然会想在每个变量里强制提供约束。例如：在一个函数中，它接受一个列表，并且返回这个列表的反向排序，这里的约束是指传入至函数的参数与函数的返回值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> toreturn = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = items.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    toreturn.push(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toreturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sample = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> reversed = reverse(sample);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reversed); <span class="comment">// 3, 2, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Safety</span></span><br><span class="line">reversed[<span class="number">0</span>] = <span class="string">'1'</span>; <span class="comment">// Error</span></span><br><span class="line">reversed = [<span class="string">'1'</span>, <span class="string">'2'</span>]; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">reversed[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">reversed = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>在上个例子中，函数 <code>reverse</code> 接受一个类型为 <code>T</code>（注意在 <code>reverse</code> 中的类型参数） 的数组（<code>items: T[]</code>），返回值为类型 T 的一个数组（注意：T[]），函数 <code>reverse</code> 的返回值类型与它接受的参数的类型一样。当你传入 <code>const sample = [1, 2, 3]</code> 时，TypeScript 能推断出 <code>reverse</code> 为 <code>number[]</code> 类型，从而能给你类型安全。与此相似，当你传入一个类型为 <code>string[]</code> 类型的数组时，TypeScript 能推断 <code>reverse</code> 为 <code>string</code>[] 类型，如下例子所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strArr = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">let</span> reversedStrs = reverse(strArr);</span><br><span class="line"></span><br><span class="line">reversedStrs = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>事实上，JavaScript 数组已经拥有了 <code>reverse</code> 的方法，TypeScript 也确实使用了泛型来定义其结构：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">  reverse(): T[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着，当你在数组上调用 <code>.reverse</code> 方法时，将会获得类型安全：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> reversedNums = numArr.reverse();</span><br><span class="line"></span><br><span class="line">reversedNums = [<span class="string">'1'</span>, <span class="string">'2'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当稍后在 <a href="https://jkchao.github.io/typescript-book-chinese/typings/ambient.html" target="_blank" rel="noopener">环境声明</a> 章节中提及 <code>lib.d.ts</code> 时，我们会讨论更多关于 <code>Array</code> 的信息。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>在 JavaScript 中，你可能希望属性为多种类型之一，如字符串或者数组。这正是 TypeScript 中联合类型能派上用场的地方（它使用 <code>|</code> 作为标记，如 <code>string | number</code>）。关于联合类型，一个常见的用例是一个可以接受字符串数组或单个字符串的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">'string'</span>) &#123;</span><br><span class="line">    line = command.trim();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.join(<span class="string">' '</span>).trim();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do stuff with line: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>在 JavaScript 中， <code>extend</code> 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象会拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = extend(&#123; a: <span class="string">'hello'</span> &#125;, &#123; b: <span class="number">42</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 x 拥有了 a 属性与 b 属性</span></span><br><span class="line"><span class="keyword">const</span> a = x.a;</span><br><span class="line"><span class="keyword">const</span> b = x.b;</span><br></pre></td></tr></table></figure><h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><p>JavaScript 并不支持元组，开发者们通常只能使用数组来表示元组。而 TypeScript 支持它，开发者可以使用 <code>:[typeofmember1, typeofmember2]</code> 的形式，为元组添加类型注解，元组可以包含任意数量的成员，示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nameNumber: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line">nameNumber = [<span class="string">'Jenny'</span>, <span class="number">221345</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">nameNumber = [<span class="string">'Jenny'</span>, <span class="string">'221345'</span>];</span><br></pre></td></tr></table></figure><p>将其与 TypeScript 中的解构一起使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nameNumber: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">nameNumber = [<span class="string">'Jenny'</span>, <span class="number">322134</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [name, num] = nameNumber;</span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <code>type SomeName = someValidTypeAnnotation</code> 来创建别名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrOrNum = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> sample: StrOrNum;</span><br><span class="line">sample = <span class="number">123</span>;</span><br><span class="line">sample = <span class="string">'123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会检查类型</span></span><br><span class="line">sample = <span class="literal">true</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>与接口不同，你可以为任意的类型注解提供类型别名（在联合类型和交叉类型中比较实用），下面是一些能让你熟悉类型别名语法的示例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; text: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Coordinates = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> Callback = <span class="function">(<span class="params">data: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>TIP</p><ul><li>如果你需要使用类型注解的层次结构，请使用接口。它能使用 <code>implements</code> 和 <code>extends</code></li><li>为一个简单的对象类型（如上面例子中的 Coordinates）使用类型别名，只需要给它一个语义化的名字即可。另外，当你想给联合类型和交叉类型提供一个语义化的名称时，一个类型别名将会是一个好的选择。</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Rosie快速上手</title>
      <link href="/2020/04/06/JavaScript-Rosie%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2020/04/06/JavaScript-Rosie%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>传送门：<a href="https://github.com/rosiejs/rosie" target="_blank" rel="noopener">Github</a>,只是给readme稍微加了点注释</p><h1 id="Rosie"><a href="#Rosie" class="headerlink" title="Rosie"></a>Rosie</h1><p>是个工厂工具，用来生产js对象，对于生产test数据最好用</p><p>Rosie is a factory for building JavaScript objects, mostly useful for setting up test data. </p><p>To use Rosie you first define a <em>factory</em>. The <em>factory</em> is defined in terms of <em>attributes</em>, <em>sequences</em>, <em>options</em>, <em>callbacks</em>, and can inherit from other factories. Once the factory is defined you use it to build <em>objects</em>.</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>There are two phases of use:</p><p>首先你要先定义factory工厂，其次构建对象</p><ol><li>Factory definition</li><li>Object building</li></ol><p><strong>Factory Definition:</strong> Define your factory, giving it a name and optionally a constructor function (<code>game</code> in this example):</p><p>定义工厂：使用define方法先定义好工厂的各个properties等内容。sequence表示递增数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Factory.define(<span class="string">'game'</span>)</span><br><span class="line">  .sequence(<span class="string">'id'</span>)</span><br><span class="line">  .attr(<span class="string">'is_over'</span>, <span class="literal">false</span>)</span><br><span class="line">  .attr(<span class="string">'created_at'</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  .attr(<span class="string">'random_seed'</span>, () =&gt; <span class="built_in">Math</span>.random())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default to two players. If players were given, fill in</span></span><br><span class="line">  <span class="comment">// whatever attributes might be missing.</span></span><br><span class="line">  .attr(<span class="string">'players'</span>, [<span class="string">'players'</span>], players =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!players) &#123;</span><br><span class="line">      players = [&#123;&#125;, &#123;&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> players.map(<span class="function"><span class="params">data</span> =&gt;</span> Factory.attributes(<span class="string">'player'</span>, data));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Factory.define(<span class="string">'player'</span>)</span><br><span class="line">  .sequence(<span class="string">'id'</span>)</span><br><span class="line">  .sequence(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'player'</span> + i;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define `position` to depend on `id`.</span></span><br><span class="line">  .attr(<span class="string">'position'</span>, [<span class="string">'id'</span>], id =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> positions = [<span class="string">'pitcher'</span>, <span class="string">'1st base'</span>, <span class="string">'2nd base'</span>, <span class="string">'3rd base'</span>];</span><br><span class="line">    <span class="keyword">return</span> positions[id % positions.length];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Factory.define(<span class="string">'disabled-player'</span>)</span><br><span class="line">  .extend(<span class="string">'player'</span>)</span><br><span class="line">  .attr(<span class="string">'state'</span>, <span class="string">'disabled'</span>);</span><br></pre></td></tr></table></figure><p><strong>Object Building:</strong> Build an object, passing in attributes that you want to override:</p><p>假如你想要override其中的一些attribute，你可以自己传入值强制覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> game = Factory.build(<span class="string">'game'</span>, &#123; <span class="attr">is_over</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// Built object (note scores are random):</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    id:           1,</span></span><br><span class="line"><span class="comment">//    is_over:      true,   // overriden when building</span></span><br><span class="line"><span class="comment">//    created_at:   Fri Apr 15 2011 12:02:25 GMT-0400 (EDT),</span></span><br><span class="line"><span class="comment">//    random_seed:  0.8999513240996748,</span></span><br><span class="line"><span class="comment">//    players: [</span></span><br><span class="line"><span class="comment">//                &#123;id: 1, name:'Player 1'&#125;,</span></span><br><span class="line"><span class="comment">//                &#123;id: 2, name:'Player 2'&#125;</span></span><br><span class="line"><span class="comment">//    ]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>For a factory with a constructor, if you want just the attributes:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Factory.attributes(<span class="string">'game'</span>); <span class="comment">// return just the attributes</span></span><br></pre></td></tr></table></figure><h3 id="Programmatic-Generation-of-Attributes"><a href="#Programmatic-Generation-of-Attributes" class="headerlink" title="Programmatic Generation of Attributes"></a>Programmatic Generation of Attributes</h3><p>You can specify options that are used to programmatically generate the attributes:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"></span><br><span class="line">Factory.define(<span class="string">'matches'</span>)</span><br><span class="line">  .attr(<span class="string">'seasonStart'</span>, <span class="string">'2016-01-01'</span>)</span><br><span class="line">  .option(<span class="string">'numMatches'</span>, <span class="number">2</span>)</span><br><span class="line">  .attr(<span class="string">'matches'</span>, [<span class="string">'numMatches'</span>, <span class="string">'seasonStart'</span>], (numMatches, seasonStart) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> matches = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">1</span>; i &lt;= numMatches; i++) &#123;</span><br><span class="line">      matches.push(&#123;</span><br><span class="line">        matchDate: moment(seasonStart)</span><br><span class="line">          .add(i, <span class="string">'week'</span>)</span><br><span class="line">          .format(<span class="string">'YYYY-MM-DD'</span>),</span><br><span class="line">        homeScore: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>),</span><br><span class="line">        awayScore: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Factory.build(<span class="string">'matches'</span>, &#123; <span class="attr">seasonStart</span>: <span class="string">'2016-03-12'</span> &#125;, &#123; <span class="attr">numMatches</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// Built object (note scores are random):</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  seasonStart: '2016-03-12',</span></span><br><span class="line"><span class="comment">//  matches: [</span></span><br><span class="line"><span class="comment">//    &#123; matchDate: '2016-03-19', homeScore: 3, awayScore: 1 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; matchDate: '2016-03-26', homeScore: 0, awayScore: 4 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; matchDate: '2016-04-02', homeScore: 1, awayScore: 0 &#125;</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>In the example <code>numMatches</code> is defined as an <code>option</code>, not as an <code>attribute</code>. Therefore <code>numMatches</code> is not part of the output, it is only used to generate the <code>matches</code> array.</p><p>In the same example <code>seasonStart</code> is defined as an <code>attribute</code>, therefore it appears in the output, and can also be used in the generator function that creates the <code>matches</code> array.</p><h3 id="Batch-Specification-of-Attributes"><a href="#Batch-Specification-of-Attributes" class="headerlink" title="Batch Specification of Attributes"></a>Batch Specification of Attributes</h3><p>The convenience function <code>attrs</code> simplifies the common case of specifying multiple attributes in a batch. Rewriting the <code>game</code> example from above:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Factory.define(<span class="string">'game'</span>)</span><br><span class="line">  .sequence(<span class="string">'id'</span>)</span><br><span class="line">  .attrs(&#123;</span><br><span class="line">    is_over: <span class="literal">false</span>,</span><br><span class="line">    created_at: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    random_seed: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random()</span><br><span class="line">  &#125;)</span><br><span class="line">  .attr(<span class="string">'players'</span>, [<span class="string">'players'</span>], players =&gt; &#123;</span><br><span class="line">    <span class="comment">/* etc. */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Post-Build-Callback"><a href="#Post-Build-Callback" class="headerlink" title="Post Build Callback"></a>Post Build Callback</h3><p>You can also define a callback function to be run after building an object:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Factory.define(<span class="string">'coach'</span>)</span><br><span class="line">  .option(<span class="string">'buildPlayer'</span>, <span class="literal">false</span>)</span><br><span class="line">  .sequence(<span class="string">'id'</span>)</span><br><span class="line">  .attr(<span class="string">'players'</span>, [<span class="string">'id'</span>, <span class="string">'buildPlayer'</span>], (id, buildPlayer) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (buildPlayer) &#123;</span><br><span class="line">      <span class="keyword">return</span> [Factory.build(<span class="string">'player'</span>, &#123; <span class="attr">coach_id</span>: id &#125;)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .after(<span class="function">(<span class="params">coach, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.buildPlayer) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'built player:'</span>, coach.players[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Factory.build(<span class="string">'coach'</span>, &#123;&#125;, &#123; <span class="attr">buildPlayer</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>Multiple callbacks can be registered, and they will be executed in the order they are registered. The callbacks can manipulate the built object before it is returned to the callee.</p><p>If the callback doesn’t return anything, rosie will return build object as final result. If the callback returns a value, rosie will use that as final result instead.</p><h3 id="Associate-a-Factory-with-an-existing-Class"><a href="#Associate-a-Factory-with-an-existing-Class" class="headerlink" title="Associate a Factory with an existing Class"></a>Associate a Factory with an existing Class</h3><p>This is an advanced use case that you can probably happily ignore, but store this away in case you need it.</p><p>When you define a factory you can optionally provide a class definition, and anything built by the factory will be passed through the constructor of the provided class.</p><p>Specifically, the output of <code>.build</code> is used as the input to the constructor function, so the returned object is an instance of the specified class:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.moops = <span class="string">'correct'</span>;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isMoopsCorrect() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.moops;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testFactory = Factory.define(<span class="string">'test'</span>, SimpleClass).attr(<span class="string">'some_var'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">testInstance = testFactory.build(&#123; <span class="attr">stuff</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(testInstance, &#123;&#125;, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   "moops": "correct",</span></span><br><span class="line"><span class="comment">//   "args": &#123;</span></span><br><span class="line"><span class="comment">//     "stuff": 2,</span></span><br><span class="line"><span class="comment">//     "some_var": 4</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testInstance.isMoopsCorrect());</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>Mind. Blown.</p><h2 id="Usage-in-Node-js"><a href="#Usage-in-Node-js" class="headerlink" title="Usage in Node.js"></a>Usage in Node.js</h2><p>To use Rosie in node, you’ll need to import it first:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Factory &#125; <span class="keyword">from</span> <span class="string">'rosie'</span>;</span><br><span class="line"><span class="comment">// or with `require`</span></span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'rosie'</span>).Factory;</span><br></pre></td></tr></table></figure><p>You might also choose to use unregistered factories, as it fits better with node’s module pattern:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factories/game.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Factory &#125; <span class="keyword">from</span> <span class="string">'rosie'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Factory().sequence(<span class="string">'id'</span>).attr(<span class="string">'is_over'</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// etc</span></span><br></pre></td></tr></table></figure><p>To use the unregistered <code>Game</code> factory defined above:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Game <span class="keyword">from</span> <span class="string">'./factories/game'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = Game.build(&#123; <span class="attr">is_over</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>A tool like <a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a> is currently required to use this syntax.</p><p>You can also extend an existing unregistered factory:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factories/scored-game.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Factory &#125; <span class="keyword">from</span> <span class="string">'rosie'</span>;</span><br><span class="line"><span class="keyword">import</span> Game <span class="keyword">from</span> <span class="string">'./game'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Factory().extend(Game).attrs(&#123;</span><br><span class="line">  score: <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Rosie-API"><a href="#Rosie-API" class="headerlink" title="Rosie API"></a>Rosie API</h2><p>As stated above the rosie factory signatures can be broken into factory definition and object creation.</p><p>Additionally factories can be defined and accessed via the Factory singleton, or they can be created and maintained by the callee.</p><h3 id="Factory-declaration-functions"><a href="#Factory-declaration-functions" class="headerlink" title="Factory declaration functions"></a>Factory declaration functions</h3><p>Once you have an instance returned from a <code>Factory.define</code> or a <code>new Factory()</code> call, you do the actual of work of defining the objects. This is done using the methods below (note these are typically chained together as in the examples above):</p><h4 id="Factory-define"><a href="#Factory-define" class="headerlink" title="Factory.define"></a>Factory.define</h4><ul><li><strong>Factory.define(<code>factory_name</code>)</strong> - Defines a factory by name. Return an instance of a Factory that you call <code>.attr</code>, <code>.option</code>, <code>.sequence</code>, and <code>.after</code> on the result to define the properties of this factory.</li><li><strong>Factory.define(<code>factory_name</code>, <code>constructor</code>)</strong> - Optionally pass a constuctor function, and the objects produced by <code>.build</code> will be passed through the <code>constructor</code> function.</li></ul><h4 id="instance-attr"><a href="#instance-attr" class="headerlink" title="instance.attr:"></a>instance.attr:</h4><p>Use this to define attributes of your objects</p><ul><li><strong>instance.attr(<code>attribute_name</code>, <code>default_value</code>)</strong> - <code>attribute_name</code> is required and is a string, <code>default_value</code> is the value to use by default for the attribute</li><li><strong>instance.attr(<code>attribute_name</code>, <code>generator_function</code>)</strong> - <code>generator_function</code> is called to generate the value of the attribute</li><li><strong>instance.attr(<code>attribute_name</code>, <code>dependencies</code>, <code>generator_function</code>)</strong> - <code>dependencies</code> is an array of strings, each string is the name of an attribute or option that is required by the <code>generator_function</code> to generate the value of the attribute. This list of <code>dependencies</code> will match the parameters that are passed to the <code>generator_function</code></li></ul><h4 id="instance-attrs"><a href="#instance-attrs" class="headerlink" title="instance.attrs:"></a>instance.attrs:</h4><p>Use this as a convenience function instead of calling <code>instance.attr</code> multiple times</p><ul><li><strong>instance.attrs(<code>{attribute_1: value_1, attribute_2: value_2, ...}</code>)</strong> - <code>attribute_i</code> is a string, <code>value_i</code> is either an object or generator function.</li></ul><p>See <code>instance.attr</code> above for details. Note: there is no way to specify dependencies using this method, so if you need that, you should use <code>instance.attr</code> instead.</p><h4 id="instance-option"><a href="#instance-option" class="headerlink" title="instance.option:"></a>instance.option:</h4><p>Use this to define options. Options do not appear in the generated object, but they can be used in a <code>generator_function</code> that is used to configure an attribute or sequence that appears in the generated object. See the <a href="https://github.com/rosiejs/rosie#programmatic-generation-of-attributes" target="_blank" rel="noopener">Programmatic Generation Of Attributes</a> section for examples.</p><ul><li><strong>instance.option(<code>option_name</code>, <code>default_value</code>)</strong> - <code>option_name</code> is required and is a string, <code>default_value</code> is the value to use by default for the option</li><li><strong>instance.option(<code>option_name</code>, <code>generator_function</code>)</strong> - <code>generator_function</code> is called to generate the value of the option</li><li><strong>instance.option(<code>option_name</code>, <code>dependencies</code>, <code>generator_function</code>)</strong> - <code>dependencies</code> is an array of strings, each string is the name of an option that is required by the <code>generator_function</code> to generate the value of the option. This list of <code>dependencies</code> will match the parameters that are passed to the <code>generator_function</code></li></ul><h4 id="instance-sequence"><a href="#instance-sequence" class="headerlink" title="instance.sequence:"></a>instance.sequence:</h4><p>Use this to define an auto incrementing sequence field in your object</p><ul><li><strong>instance.sequence(<code>sequence_name</code>)</strong> - define a sequence called <code>sequence_name</code>, set the start value to 1</li><li><strong>instance.sequence(<code>sequence_name</code>, <code>generator_function</code>)</strong> - <code>generator_function</code> is called to generate the value of the sequence. When the <code>generator_function</code> is called the pre-incremented sequence number will be passed as the first parameter, followed by any dependencies that have been specified.</li><li><strong>instance.sequence(<code>sequence_name</code>, <code>dependencies</code>, <code>generator_function</code>)</strong> - <code>dependencies</code> is an array of strings, each string is the name of an attribute or option that is required by the <code>generator_function</code> to generate the value of the option. The value of each specified dependency will be passed as parameters 2..N to the <code>generator_function</code>, noting again that the pre-incremented sequence number is passed as the first parameter.</li></ul><h4 id="instance-after"><a href="#instance-after" class="headerlink" title="instance.after:"></a>instance.after:</h4><ul><li><strong>instance.after(<code>callback</code>)</strong> - register a <code>callback</code> function that will be called at the end of the object build process. The <code>callback</code> is invoked with two params: (<code>build_object</code>, <code>object_options</code>). See the <a href="https://github.com/rosiejs/rosie#post-build-callback" target="_blank" rel="noopener">Post Build Callback</a> section for examples.</li></ul><h3 id="Object-building-functions"><a href="#Object-building-functions" class="headerlink" title="Object building functions"></a>Object building functions</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>Returns an object that is generated by the named factory. <code>attributes</code> and <code>options</code> are optional parameters. The <code>factory_name</code> is required when calling against the rosie Factory singleton.</p><ul><li><strong>Factory.build(<code>factory_name</code>, <code>attributes</code>, <code>options</code>)</strong> - when build is called against the rosie Factory singleton, the first param is the name of the factory to use to build the object. The second is an object containing attribute override key value pairs, and the third is a object containing option key value pairs</li><li><strong>instance.build(<code>attributes</code>, <code>options</code>)</strong> - when build is called on a factory instance only the <code>attributes</code> and <code>options</code> objects are necessary</li></ul><h4 id="buildList"><a href="#buildList" class="headerlink" title="buildList"></a>buildList</h4><p>Identical to <code>.build</code> except it returns an array of built objects. <code>size</code> is required, <code>attributes</code> and <code>options</code> are optional</p><ul><li><strong>Factory.buildList(<code>factory_name</code>, size, <code>attributes</code>, <code>options</code>)</strong> - when buildList is called against the rosie Factory singleton, the first param is the name of the factory to use to build the object. The <code>attributes</code> and <code>options</code> behave the same as the call to <code>.build</code>.</li><li><strong>instance.buildList(size, <code>attributes</code>, <code>options</code>)</strong> - when buildList is called on a factory instance only the size, <code>attributes</code> and <code>options</code> objects are necessary (strictly speaking only the size is necessary)</li></ul><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><ol><li>Fork it</li><li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li><li>Install the test dependencies (<code>yarn install</code> - requires NodeJS and yarn)</li><li>Make your changes and make sure the tests pass (<code>yarn test</code>)</li><li>Commit your changes (<code>git commit -am &#39;Added some feature&#39;</code>)</li><li>Push to the branch (<code>git push origin my-new-feature</code>)</li><li>Create new Pull Request</li></ol><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>Thanks to <a href="http://twitter.com/danielmorrison/status/58883772040486912" target="_blank" rel="noopener">Daniel Morrison</a> for the name and <a href="http://twitter.com/jonmagic" target="_blank" rel="noopener">Jon Hoyt</a> for inspiration and brainstorming the idea.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令集</title>
      <link href="/2020/04/03/Linux%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
      <url>/2020/04/03/Linux%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>命令大全：<a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">菜鸟教程传送门</a></p><p><a href="https://www.jianshu.com/p/0056d671ea6d" target="_blank" rel="noopener">部分来源Mark_Ming</a></p><h2 id="关于ctrl-z-d-c"><a href="#关于ctrl-z-d-c" class="headerlink" title="关于ctrl z,d,c"></a>关于ctrl z,d,c</h2><p><strong>ctrl-c</strong>: ( kill foreground process ) 发送 SIGINT 信号给前台进程组中的所有进程，强制终止程序的执行；</p><p><strong>ctrl-z</strong>: ( suspend foreground process ) 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程，而并非结束进程，用户可以使用使用fg/bg操作恢复执行前台或后台的进程。fg命令在前台恢复执行被挂起的进程，此时可以使用ctrl-z再次挂起该进程，bg命令在后台恢复执行被挂起的进程，而此时将无法使用ctrl-z再次挂起该进程；</p><p>一个比较常用的功能：</p><p>正在使用vi编辑一个文件时，需要执行shell命令查询一些需要的信息，可以使用ctrl-z挂起vi，等执行完shell命令后再使用fg恢复vi继续编辑你的文件（当然，也可以在vi中使用！command方式执行shell命令，但是没有该方法方便）。</p><p><strong>ctrl-d</strong>: ( Terminate input, or exit shell ) 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入exit后回车；</p><p>比如说你从一个终端远程access到另一个终端，你就可以用ctrl-d退回你原终端</p><p>还有以下几个：</p><p><strong>ctrl-/</strong>    发送 SIGQUIT 信号给前台进程组中的所有进程，终止前台进程并生成 core 文件</p><p><strong>ctrl-s</strong>   中断控制台输出</p><p><strong>ctrl-q</strong>   恢复控制台输出</p><p><strong>ctrl-l</strong>    清屏</p><h2 id="常用命令集"><a href="#常用命令集" class="headerlink" title="常用命令集"></a>常用命令集</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出文件及文件夹，不包含隐藏文件</p><ul><li>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul><p>个人习惯：在<code>.zshrc</code>中添加<code>alias ll=&#39;ls -al&#39;</code>，按<code>ll</code>即可输出所有文件</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>Make Directory</p><p>mkdir 用于新建一个新目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure><ul><li>-p 确保目录名称存在，不存在的就建一个。</li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>Print Working Directory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>显示当前工作目录</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>Change Directory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [dirName]</span><br></pre></td></tr></table></figure><p>切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录。</p><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>Remove Directory删除给定的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] dirName</span><br></pre></td></tr></table></figure><ul><li>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。</li></ul><p>创建的文件夹会被删除</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>Remove</p><p>rm命令用于删除一个文件或者目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li><li>-r 将目录及以下之档案亦逐一删除。</li></ul><p>一般使用<code>rm -rf</code>快速删除一个文件夹</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>Copy</p><p>cp 命令对文件进行复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source dest</span><br></pre></td></tr></table></figure><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件。</li></ul><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>Move</p><p>mv 命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure><ul><li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>concatenate and print files</p><p>cat 用于在标准输出（监控器或屏幕）上查看文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure><ul><li><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</p></li><li><p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</p></li><li><p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p></li><li><p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p></li><li><p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p></li><li><p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p></li><li><p><strong>-A, –show-all</strong>：等价于 -vET。</p></li><li><p><strong>-e：</strong>等价于”-vE”选项；</p></li><li><p><strong>-t：</strong>等价于”-vT”选项；</p></li></ul><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>print TAIL(from last)</p><p>ail 默认在标准输出上显示给定文件的最后10行内容，可以使用tail -n N 指定在标准输出上显示文件的最后N行内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [参数] [文件]</span><br></pre></td></tr></table></figure><ul><li>f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c&lt;数目&gt; 显示的字节数</li><li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li><li>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束</li><li>-q, –quiet, –silent 从不输出给出文件名的首部</li><li>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>print LESS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件</span><br></pre></td></tr></table></figure><p>less 按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。</p><ul><li><p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</p></li><li><p>-e 当文件显示结束后，自动离开</p></li><li><p>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</p></li><li><p>-g 只标志最后搜索的关键词</p></li><li><p>-i 忽略搜索时的大小写</p></li><li><p>-m 显示类似more命令的百分比</p></li><li><p>-N 显示每行的行号</p></li><li><p>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</p></li><li><p>-Q 不使用警告音</p></li><li><p>-s 显示连续空行为一行</p></li><li><p>-S 行过长时间将超出部分舍弃</p></li><li><p>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格</p></li><li><p>/字符串：向下搜索”字符串”的功能</p></li><li><p>?字符串：向上搜索”字符串”的功能</p></li><li><p>n：重复前一个搜索（与 / 或 ? 有关）</p></li><li><p>N：反向重复前一个搜索（与 / 或 ? 有关）</p></li><li><p>b 向上翻一页</p></li><li><p>d 向后翻半页</p></li><li><p>h 显示帮助界面</p></li><li><p>Q 退出less 命令</p></li><li><p>u 向前滚动半页</p></li><li><p>y 向前滚动一行</p></li><li><p>空格键 滚动一页</p></li><li><p>回车键 滚动一行</p></li><li><p>[pagedown]： 向下翻动一页</p></li><li><p>[pageup]： 向上翻动一页</p></li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep 在给定的文件中搜寻指定的字符串。grep -i “” 在搜寻时会忽略字符串的大小写，而grep -r “” 则会在当前工作目录的文件中递归搜寻指定的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure><ul><li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。</li><li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-c 或 –count</strong> : 计算符合样式的列数。</li><li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li><li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的正则表达式来使用。</li><li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。</li><li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。</li><li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li><li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。</li><li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。</li><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li><li><strong>-s 或 –no-messages</strong> : 不显示错误信息。</li><li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。</li><li><strong>-V 或 –version</strong> : 显示版本信息。</li><li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。</li><li><strong>-x –line-regexp</strong> : 只显示全列符合的列。</li><li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find -name 的-name选项来进行区分大小写的搜寻，find -iname 来进行不区分大小写的搜寻。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2</p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar命令能创建、查看和提取tar压缩文件。tar -cvf 是创建对应压缩文件，tar -tvf 来查看对应压缩文件，tar -xvf 来提取对应压缩文件。</p><p>这玩意极其多<a href="https://www.runoob.com/linux/linux-comm-tar.html" target="_blank" rel="noopener">传送门</a></p><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip 命令创建和提取gzip压缩文件，还可以用gzip -d 来提取压缩文件。</p><p><a href="https://www.runoob.com/linux/linux-comm-gzip.html" target="_blank" rel="noopener">传送门</a></p><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>unzip 对gzip文档进行解压。在解压之前，可以使用unzip -l 命令查看文件内容。</p><h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3><p>whatis 会用单行来描述给定的命令，就是解释当前命令。</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit用于结束当前的终端会话。</p><p>结束当前终端会话</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。</p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>Who Is logged in</p><p>who能列出当前登录的用户名。</p><p>当前用户列表</p><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>Switch User</p><p>su 用于切换不同的用户。即使没有使用密码，超级用户也能切换到其它用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>可以切换到root</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>uname会显示出关于系统的重要信息，如内核名称、主机名、内核版本、处理机类型等等，使用uname -a可以查看所有信息。</p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>Disk space Free</p><p>df查看文件系统中磁盘的使用情况–硬盘已用和可用的存储空间以及其它存储设备。你可以使用df -h将结果以人类可读的方式显示。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ProcesseS</p><p>ps显示系统的运行进程</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>Top processes</p><p>top命令会默认按照CPU的占用情况，显示占用量较大的进程,可以使用top -u 查看某个用户的CPU使用排名情况。</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>shutdown用于关闭计算机，而shutdown -r用于重启计算机。这个我就不试了……</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> shell </tag>
            
            <tag> note </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-zsh技巧集</title>
      <link href="/2020/04/02/oh-my-zsh%E6%8A%80%E5%B7%A7%E9%9B%86/"/>
      <url>/2020/04/02/oh-my-zsh%E6%8A%80%E5%B7%A7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问oh-my-zsh的怎么装的出门左转看我这篇文章：<a href="[https://8128.me/2020/04/02/Mac%E7%BB%88%E7%AB%AFagnoster%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/](https://8128.me/2020/04/02/Mac终端agnoster主题配置/)">传送门</a></p><p>我<code>.zshrc</code>中插件部分的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git </span><br><span class="line">  bundler </span><br><span class="line">  dotenv</span><br><span class="line">  osx </span><br><span class="line">  rake</span><br><span class="line">  last-working-dir</span><br><span class="line">  brew</span><br><span class="line">  extract # 解压文件 x filename</span><br><span class="line">  history # h 唤出历史</span><br><span class="line">  sudo #双击esc在前方加sudo</span><br><span class="line">  yarn</span><br><span class="line">  zsh-autosuggestions #需要额外操作见下方</span><br><span class="line">  autojump #需要额外操作见下方</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">source /Users/tty/git/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure><p>上面的plugins你基本都能直接在这里找到相关信息，我就不多提了。</p><p>下面需要source的部分稍微讲一下</p><p><strong>别直接抄我的路径，换成相对应的你的路径</strong></p><h2 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h2><p>官方<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">GitHub</a></p><p>这是最底下那行source带来的，安装方法见：<a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md" target="_blank" rel="noopener">安装传送门</a></p><p>作用：</p><p>总之就是有特殊的高亮技巧，标出重要的文字符号，避免你的错误</p><p>his package provides syntax highlighting for the shell zsh. It enables highlighting of commands whilst they are typed at a zsh prompt into an interactive terminal. This helps in reviewing commands before running them, particularly in catching syntax errors.</p><h2 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h2><p>官方<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">GitHub</a></p><p><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">安装传送门</a></p><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>官方<a href="https://github.com/wting/autojump" target="_blank" rel="noopener">GitHub</a></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install autojump</span></span><br></pre></td></tr></table></figure><p>在plugin里加上autojump</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac终端agnoster主题配置</title>
      <link href="/2020/04/02/Mac%E7%BB%88%E7%AB%AFagnoster%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/04/02/Mac%E7%BB%88%E7%AB%AFagnoster%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源English version：<a href="https://gist.github.com/ZenLulz/c812f70fc86ebdbb189d9fb82f98197e" target="_blank" rel="noopener">ZenLulz</a></p><p>最终效果:</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200402183141.png"  alt=""></p><h2 id="安装-iTerm2"><a href="#安装-iTerm2" class="headerlink" title="安装 iTerm2"></a>安装 iTerm2</h2><p>iTerm2是一个不错的终端</p><p>使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>进行安装（没有homebrew官网有一键安装命令）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install iterm2</span></span><br></pre></td></tr></table></figure><h2 id="用-oh-my-zsh-安装-zsh"><a href="#用-oh-my-zsh-安装-zsh" class="headerlink" title="用 oh-my-zsh 安装 zsh"></a>用 oh-my-zsh 安装 zsh</h2><p><a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-My-Zsh</a> 是一个开源的，社区驱动的框架，用于管理您的ZSH配置。它捆绑了许多有用的功能，助手，插件，主题等牛逼哄哄的东西。安装：</p><p>用curl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span></span><br></pre></td></tr></table></figure><p>用wget:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh -c <span class="string">"<span class="variable">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>"</span></span></span><br></pre></td></tr></table></figure><h2 id="应用Solarized"><a href="#应用Solarized" class="headerlink" title="应用Solarized"></a>应用Solarized</h2><h3 id="把zsh的主题设置为agnoster"><a href="#把zsh的主题设置为agnoster" class="headerlink" title="把zsh的主题设置为agnoster"></a>把zsh的主题设置为agnoster</h3><p>打开zsh设置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nano ~/.zshrc</span></span><br></pre></td></tr></table></figure><p>在其中搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;robbyrussell&quot;</span><br></pre></td></tr></table></figure><p>将这行改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><p>退出保存</p><h3 id="安装所需要的字体"><a href="#安装所需要的字体" class="headerlink" title="安装所需要的字体"></a>安装所需要的字体</h3><p>我们需要为iTerm2提供特定的字体，以正确处理主题<em>agnoster</em>。为此，我们将安装<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">Powerline字体</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Cloning</span></span><br><span class="line">git clone https://github.com/powerline/fonts.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Installation</span></span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Clean up</span></span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><h3 id="应用刚刚安装的字体"><a href="#应用刚刚安装的字体" class="headerlink" title="应用刚刚安装的字体"></a>应用刚刚安装的字体</h3><p>打开iTerm2的preference（Ctrl +，)，依次单击“ <em>Profiles</em> ”选项卡和<em>“</em> <em>Text</em> ”选项卡，最后单击“Change font”按钮，<strong>为Powerline</strong>选择Meslo <strong>LG S DZ Regular</strong>，默认大小为<strong>12pt</strong> 。</p><h3 id="配置iTerm2中终端颜色"><a href="#配置iTerm2中终端颜色" class="headerlink" title="配置iTerm2中终端颜色"></a>配置iTerm2中终端颜色</h3><p>打开iTerm2的首选项（Ctrl +，），依次单击“ <strong>Profiles</strong> ”选项卡和“<strong>Colors</strong>”，最后单击下拉列表“ <em>Color Presets…”</em>。选择项目<em>Solarized Dark</em>。</p><h2 id="设置系统中iTerm2热键"><a href="#设置系统中iTerm2热键" class="headerlink" title="设置系统中iTerm2热键"></a>设置系统中iTerm2热键</h2><p>可以使用系统级热键在屏幕上给定位置调用iTerm2。要启用该功能，请打开iTerm2的preference（Ctrl +，），然后单击“ <em>Keys</em> ”选项卡，然后选中“ <em>Show/hide iTerm2</em>”和“<em>system-wide hotkey</em>”，然后“Hotkey toggles a dedicated window with profile“。</p><h2 id="在Finder右键菜单中添加-New-Terminal-Here"><a href="#在Finder右键菜单中添加-New-Terminal-Here" class="headerlink" title="在Finder右键菜单中添加 New Terminal Here"></a>在Finder右键菜单中添加 <em>New Terminal Here</em></h2><p>传送门 <a href="https://hbang.ws/apps/termhere/" target="_blank" rel="noopener">TermHere</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 自学笔记</title>
      <link href="/2020/04/01/JavaScript-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/01/JavaScript-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="joi"><a href="#joi" class="headerlink" title="joi"></a>joi</h1><p><strong>joi</strong> lets you describe your data using a simple, intuitive, and readable language. Like the rest of the <a href="https://hapi.dev/" target="_blank" rel="noopener">hapi ecosystem</a> it fits in, <strong>joi</strong> allows you to describe your data for both input and output validation, as part of a hapi HTTP server or standalone.</p><p>总的来说就是个数据验证的工具，可以给properties设置一些限制和数据格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">'@hapi/joi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    username: Joi.string()</span><br><span class="line">        .alphanum()</span><br><span class="line">        .min(<span class="number">3</span>)</span><br><span class="line">        .max(<span class="number">30</span>)</span><br><span class="line">        .required(),</span><br><span class="line"></span><br><span class="line">    password: Joi.string()</span><br><span class="line">        .pattern(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^[a-zA-Z0-9]&#123;3,30&#125;$'</span>)),</span><br><span class="line"></span><br><span class="line">    repeat_password: Joi.ref(<span class="string">'password'</span>),</span><br><span class="line"></span><br><span class="line">    access_token: [</span><br><span class="line">        Joi.string(),</span><br><span class="line">        Joi.number()</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    birth_year: Joi.number()</span><br><span class="line">        .integer()</span><br><span class="line">        .min(<span class="number">1900</span>)</span><br><span class="line">        .max(<span class="number">2013</span>),</span><br><span class="line"></span><br><span class="line">    email: Joi.string()</span><br><span class="line">        .email(&#123; <span class="attr">minDomainSegments</span>: <span class="number">2</span>, <span class="attr">tlds</span>: &#123; <span class="attr">allow</span>: [<span class="string">'com'</span>, <span class="string">'net'</span>] &#125; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    .with(<span class="string">'username'</span>, <span class="string">'birth_year'</span>)</span><br><span class="line">    .xor(<span class="string">'password'</span>, <span class="string">'access_token'</span>)</span><br><span class="line">    .with(<span class="string">'password'</span>, <span class="string">'repeat_password'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schema.validate(&#123; <span class="attr">username</span>: <span class="string">'abc'</span>, <span class="attr">birth_year</span>: <span class="number">1994</span> &#125;);</span><br><span class="line"><span class="comment">// -&gt; &#123; value: &#123; username: 'abc', birth_year: 1994 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">schema.validate(&#123;&#125;);</span><br><span class="line"><span class="comment">// -&gt; &#123; value: &#123;&#125;, error: '"username" is required' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Also -</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">await</span> schema.validateAsync(&#123; <span class="attr">username</span>: <span class="string">'abc'</span>, <span class="attr">birth_year</span>: <span class="number">1994</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123; &#125;</span><br></pre></td></tr></table></figure><p>The above schema defines the following constraints:</p><ul><li><p><code>username</code></p><ul><li>a required string</li><li>must contain only alphanumeric characters</li><li>at least 3 characters long but no more than 30</li><li>must be accompanied by <code>birth_year</code></li></ul></li><li><p><code>password</code></p><ul><li>an optional string</li><li>must satisfy the custom regex pattern</li><li>cannot appear together with <code>access_token</code></li><li>must be accompanied by <code>repeat_password</code> and equal to it</li></ul></li><li><p><code>access_token</code></p><ul><li>an optional, unconstrained string or number</li></ul></li><li><p><code>birth_year</code></p><ul><li>an integer between 1900 and 2013</li></ul></li><li><p><code>email</code></p><ul><li>a valid email address string</li><li>must have two domain parts e.g. <code>example.com</code></li><li>TLD must be <code>.com</code> or <code>.net</code></li></ul></li></ul><h3 id="General-Usage"><a href="#General-Usage" class="headerlink" title="General Usage"></a>General Usage</h3><p>Usage is a two steps process:</p><p>First, a schema is constructed using the provided types and constraints:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    a: Joi.string()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note that <strong>joi</strong> schema objects are immutable which means every additional rule added (e.g. <code>.min(5)</code>) will return a new schema object.</p><p>Second, the value is validated against the defined schema:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; error, value &#125; = schema.validate(&#123; <span class="attr">a</span>: <span class="string">'a string'</span> &#125;);</span><br></pre></td></tr></table></figure><p>If the input is valid, then the <code>error</code> will be <code>undefined</code>. If the input is invalid, <code>error</code> is assigned a <a href="https://github.com/hapijs/joi/blob/master/API.md#validationerror" target="_blank" rel="noopener"><code>ValidationError</code></a> object providing more information.</p><p>The schema can be a plain JavaScript object where every key is assigned a <strong>joi</strong> type, or it can be a <strong>joi</strong> type directly:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = Joi.string().min(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>If the schema is a <strong>joi</strong> type, the <code>schema.validate(value)</code> can be called directly on the type. When passing a non-type schema object, the module converts it internally to an object() type equivalent to:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = Joi.object().keys(&#123;</span><br><span class="line">    a: Joi.string()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>When validating a schema:</p><ul><li><p>Values (or keys in case of objects) are optional by default.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Joi.string().validate(<span class="literal">undefined</span>); <span class="comment">// validates fine</span></span><br></pre></td></tr></table></figure><p>To disallow this behavior, you can either set the schema as <code>required()</code>, or set <code>presence</code> to <code>&quot;required&quot;</code> when passing <code>options</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Joi.string().required().validate(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Joi.string().validate(<span class="literal">undefined</span>, <span class="comment">/* options */</span> &#123; <span class="attr">presence</span>: <span class="string">"required"</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Strings are utf-8 encoded by default.</p></li><li><p>Rules are defined in an additive fashion and evaluated in order, first the inclusive rules, then the exclusive rules.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 笔记</title>
      <link href="/2020/04/01/TypeScript%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/01/TypeScript%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是个笔记向文档，并非教程</p><p>来源：</p><ul><li><a href="https://ts.xcatliu.com/basics" target="_blank" rel="noopener">TypeScript入门教程</a></li><li><a href="https://jkchao.github.io/" target="_blank" rel="noopener">深入理解TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">TypeScript官方教程</a></li><li><a href="https://www.tslang.cn/docs/handbook/generics.html" target="_blank" rel="noopener">tslang.cn</a></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>就一个代码中的ts函数进行分析</p><p>一个较为简单的案例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，identity为函数名，arg为输入的parameter (A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method’s parameters.， parameter是写在函数里的名字，当这个函数被使用的时候，你传进去的真正的参数被称作是方法的arguments)，第一个number为输入的格式，第二个number为输出的格式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里实际上只有右侧的匿名函数有对各个数据类型有所规范，mysum本身是没有被规范的，是因为被赋值了我们才知道它是什么类型的，这样并不好。假如需要对mysum进行规范，则应该：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p><p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛</p><h2 id="较为复杂的函数表达式"><a href="#较为复杂的函数表达式" class="headerlink" title="较为复杂的函数表达式"></a>较为复杂的函数表达式</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了类型变量，确保了前后传入类型相同，而避免使用了any。这样的identity函数就被称作是泛型，因为它可以被运用于多种数据类型，不会丢失信息</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overrideFnName</span>&lt;<span class="title">T</span> <span class="title">extends</span> (<span class="params">req: Ireq, res: Response, next: NextFunction</span>) =&gt; <span class="title">void</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  wrappedFn: AsyncExpressHandler,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isEmpty(wrappedFn.name) &amp;&amp; wrappedFn.name !== <span class="string">'anonymous'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(fn, <span class="string">'name'</span>, &#123; value: wrappedFn.name &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尼玛的这个我到现在都还没看懂，啥玩意啊这，<code>&lt;T extends (req: Ireq, res: Response, next: NextFunction) =&gt; void&gt;</code>是啥</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><p>接口运行时的影响为 0。在 TypeScript 接口中有很多方式来声明变量的结构。</p><p>下面两个是<strong>等效</strong>的声明, 示例 A 使用内联注解，示例 B 使用接口形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 A</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> myPoint: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 B</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> myPoint: Point;</span><br></pre></td></tr></table></figure><p>示例 B 的好处在于，如果有人创建了一个基于 <code>myPoint</code> 的库来添加新成员, 那么他可以轻松将此成员添加到 <code>myPoint</code> 的现有声明中:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lib a.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>,</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> myPoint: Point</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lib b.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code</span></span><br><span class="line">myPoint.z <span class="comment">// Allowed!</span></span><br></pre></td></tr></table></figure><p>TypeScript 接口是开放式的，这是 TypeScript 的一个重要原则，它允许你使用接口来模仿 JavaScript 的可扩展性。</p><h2 id="类可以实现接口"><a href="#类可以实现接口" class="headerlink" title="类可以实现接口"></a>类可以实现接口</h2><p>如果你希望在类中使用必须要被遵循的接口（类）或别人定义的对象结构，可以使用 <code>implements</code> 关键字来确保其兼容性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyPoint <span class="keyword">implements</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>; <span class="comment">// Same as Point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，在 <code>implements（实现）</code> 存在的情况下，该外部 <code>Point</code> 接口的任何更改都将导致代码库中的编译错误，因此可以轻松地使其保持同步：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>; <span class="comment">// New member</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyPoint <span class="keyword">implements</span> Point &#123;</span><br><span class="line">  <span class="comment">// ERROR : missing member `z`</span></span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>implements</code> 限制了类实例的结构，如下所示:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: Point = <span class="keyword">new</span> MyPoint();</span><br></pre></td></tr></table></figure><p>但像 <code>foo: Point = MyPoint</code> 这样的代码，与其并不是一回事。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="并非每个接口都是很容易实现的"><a href="#并非每个接口都是很容易实现的" class="headerlink" title="并非每个接口都是很容易实现的"></a>并非每个接口都是很容易实现的</h3><p>接口旨在声明 JavaScript 中可能存在的任意结构。</p><p>思考以下例子，可以使用 <code>new</code> 调用某些内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Crazy &#123;</span><br><span class="line">  <span class="keyword">new</span> (): &#123;</span><br><span class="line">    hello: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会有下面这样的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CrazyClass <span class="keyword">implements</span> Crazy &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; hello: <span class="number">123</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Because</span></span><br><span class="line"><span class="keyword">const</span> crazy = <span class="keyword">new</span> CrazyClass(); <span class="comment">// crazy would be &#123; hello:123 &#125;</span></span><br></pre></td></tr></table></figure><p>你可以使用接口声明所有“疯狂的”的 JavaScript 代码，甚至可以安全地在 TypeScript 中使用它们。但这并不意味着你可以使用 TypeScript 类来实现它们。</p><h1 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h1><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt</a></p><ul><li>Partial&lt;T&gt;</li></ul><p>Constructs a type with all properties of <code>T</code> set to optional. This utility will return a type that represents all subsets of a given type.</p><p>Example </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">    title: <span class="string">'organize desk'</span>,</span><br><span class="line">    description: <span class="string">'clear clutter'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">    description: <span class="string">'throw out trash'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Omit&lt;T,K&gt;</li></ul><p>Constructs a type by picking all properties from <code>T</code> and then removing <code>K</code>.</p><p>Example</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">'description'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">    title: <span class="string">'Clean room'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Pick&lt;T,K&gt;</li></ul><p>Constructs a type by picking the set of properties <code>K</code> from <code>T</code>.</p><p>Example</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Pick&lt;Todo, <span class="string">'title'</span> | <span class="string">'completed'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">    title: <span class="string">'Clean room'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Type 'boolean' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。</p><p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p><h2 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p><p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p><h1 id="泛型1"><a href="#泛型1" class="headerlink" title="泛型1"></a>泛型1</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><h2 id="泛型之Hello-World"><a href="#泛型之Hello-World" class="headerlink" title="泛型之Hello World"></a>泛型之Hello World</h2><p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code>命令。</p><p>不用泛型的话，这个函数可能是下面这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们使用<code>any</code>类型来定义函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>any</code>类型会导致这个函数可以接收任何类型的<code>arg</code>参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p><p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 <em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p><p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p><p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">"myString"</span>);  <span class="comment">// type of output will be 'string'</span></span><br></pre></td></tr></table></figure><p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p><p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity(<span class="string">"myString"</span>);  <span class="comment">// type of output will be 'string'</span></span><br></pre></td></tr></table></figure><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p><h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h2><p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p><p>看下之前<code>identity</code>例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想同时打印出<code>arg</code>的长度。 我们很可能会这样做：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn't have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p><p>现在假设我们想操作<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code>的的类型为<code>number</code>。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><p>我们也可以这样实现上面的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 <code>Array</code>一样。</p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</span><br></pre></td></tr></table></figure><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</span><br></pre></td></tr></table></figure><p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity;</span><br></pre></td></tr></table></figure><p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure><p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code>的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p><p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><p><code>GenericNumber</code>类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用<code>number</code>类型。 也可以使用字符串或其它更复杂的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">stringNumeric.zeroValue = <span class="string">""</span>;</span><br><span class="line">stringNumeric.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class="string">"test"</span>));</span><br></pre></td></tr></table></figure><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p><p>我们在<a href="https://www.tslang.cn/docs/handbook/classes.html" target="_blank" rel="noopener">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn't have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p><p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字来实现约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn't have a .length property</span></span><br></pre></td></tr></table></figure><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code>上，因此我们需要在这两个类型之间使用约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// okay</span></span><br><span class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></span><br></pre></td></tr></table></figure><h3 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h3><p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123;<span class="keyword">new</span>(): T; &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">    nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;  <span class="comment">// typechecks!</span></span><br><span class="line">createInstance(Bee).keeper.hasMask;   <span class="comment">// typechecks!</span></span><br></pre></td></tr></table></figure><h1 id="泛型2"><a href="#泛型2" class="headerlink" title="泛型2"></a>泛型2</h1><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：</p><ul><li>类的实例成员</li><li>类的方法</li><li>函数参数</li><li>函数返回值</li></ul><h2 id="动机和示例"><a href="#动机和示例" class="headerlink" title="动机和示例"></a>动机和示例</h2><p>下面是对一个先进先出的数据结构——队列，在 <code>TypeScript</code> 和 <code>JavaScript</code> 中的简单实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue &#123;</span><br><span class="line">  <span class="keyword">private</span> data = [];</span><br><span class="line">  push = <span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  pop = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中存在一个问题，它允许你向队列中添加任何类型的数据，当然，当数据被弹出队列时，也可以是任意类型。在下面的示例中，看起来人们可以向队列中添加<code>string</code> 类型的数据，但是实际上，该用法假定的是只有 <code>number</code> 类型会被添加到队列里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue &#123;</span><br><span class="line">  <span class="keyword">private</span> data = [];</span><br><span class="line">  push = <span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  pop = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>); <span class="comment">// Oops，一个错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个使用者，走入了误区</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toPrecision(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toPrecision(<span class="number">1</span>)); <span class="comment">// RUNTIME ERROR</span></span><br></pre></td></tr></table></figure><p>一个解决的办法（事实上，这也是不支持泛型类型的唯一解决办法）是为这些约束创建特殊类，如快速创建数字类型的队列：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> QueueNumber &#123;</span><br><span class="line">  <span class="keyword">private</span> data = [];</span><br><span class="line">  push = <span class="function">(<span class="params">item: <span class="built_in">number</span></span>) =&gt;</span> <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  pop = (): <span class="function"><span class="params">number</span> =&gt;</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> QueueNumber();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>); <span class="comment">// Error: 不能推入一个 `string` 类型，只能是 `number` 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该错误得到修复，其他将不会出现问题</span></span><br></pre></td></tr></table></figure><p>当然，快速也意味着痛苦。例如当你想创建一个字符串的队列时，你将不得不再次修改相当大的代码。我们真正想要的一种方式是无论什么类型被推入队列，被推出的类型都与推入类型一样。当你使用泛型时，这会很容易：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个泛型类</span></span><br><span class="line"><span class="keyword">class</span> Queue&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> data: T[] = [];</span><br><span class="line">  push = <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  pop = (): T | <span class="function"><span class="params">undefined</span> =&gt;</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的使用</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>); <span class="comment">// Error：不能推入一个 `string`，只有 number 类型被允许</span></span><br></pre></td></tr></table></figure><p>另外一个我们见过的例子：一个 <code>reverse</code> 函数，现在在这个函数里提供了函数参数与函数返回值的约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> toreturn = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = items.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    toreturn.push(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toreturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sample = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> reversed = reverse(sample);</span><br><span class="line"></span><br><span class="line">reversed[<span class="number">0</span>] = <span class="string">'1'</span>; <span class="comment">// Error</span></span><br><span class="line">reversed = [<span class="string">'1'</span>, <span class="string">'2'</span>]; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">reversed[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">reversed = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>在此章节中，你已经了解在<em>类</em>和<em>函数</em>上使用泛型的例子。一个值得补充一点的是，你可以为创建的成员函数添加泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Utility &#123;</span><br><span class="line">  reverse&lt;T&gt;(items: T[]): T[] &#123;</span><br><span class="line">    <span class="keyword">const</span> toreturn = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = items.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      toreturn.push(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toreturn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TIP</p><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 <code>T</code>、<code>U</code>、<code>V</code> 表示。如果在你的参数里，不止拥有一个泛型，你应该使用一个更语义化名称，如 <code>TKey</code> 和 <code>TValue</code> （通常情况下，以 <code>T</code> 作为泛型的前缀，在其他语言如 C++ 里，也被称为模板）</p><h2 id="误用的泛型"><a href="#误用的泛型" class="headerlink" title="误用的泛型"></a>误用的泛型</h2><p>我见过开发者使用泛型仅仅是为了它的 hack。当你使用它时，你应该问问自己：你想用它来提供什么样的约束。如果你不能很好的回答它，你可能会误用泛型，如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><p>在这里，泛型完全没有必要使用，因为它仅用于单个参数的位置，使用如下方式可能更好：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h2 id="设计模式：方便通用"><a href="#设计模式：方便通用" class="headerlink" title="设计模式：方便通用"></a>设计模式：方便通用</h2><p>考虑如下函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>&lt;<span class="title">T</span>&gt;(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">T</span></span>;</span><br></pre></td></tr></table></figure><p>在这种情况下，泛型 <code>T</code> 只在一个地方被使用了，它并没有在成员之间提供约束 <code>T</code>。这相当于一个如下的类型断言：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> something = parse(<span class="string">'something'</span>) <span class="keyword">as</span> TypeOfSomething;</span><br></pre></td></tr></table></figure><p>仅使用一次的泛型并不比一个类型断言来的安全。它们都给你使用 API 提供了便利。</p><p>另一个明显的例子是，一个用于加载 json 返回值函数，它返回你任何传入类型的 <code>Promise</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = &lt;T&gt;(config: &#123; url: <span class="built_in">string</span>; headers?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; &#125;): <span class="built_in">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchConfig = &#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    Accept: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    ...(config.headers || &#123;&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fetch(config.url, fetchConfig).then&lt;T&gt;(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请注意，你仍然需要明显的注解任何你需要的类型，但是 <code>getJSON</code> 的签名 <code>config =&gt; Promise</code> 能够减少你一些关键的步骤（你不需要注解 <code>loadUsers</code> 的返回类型，因为它能够被推出来）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoadUserResponse = &#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    email: <span class="built_in">string</span>;</span><br><span class="line">  &#125;[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaderUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON&lt;LoadUserResponse&gt;(&#123; url: <span class="string">'https://example.com/users'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此类似：使用 <code>Promise</code> 做为一个函数的返回值比一些如：<code>Promise</code> 的备选方案要好很多。</p><h3 id="配合-axios-使用"><a href="#配合-axios-使用" class="headerlink" title="配合 axios 使用"></a>配合 axios 使用</h3><p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求接口数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResponseData&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 状态码</span></span><br><span class="line"><span class="comment">   * @type &#123; number &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  code: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据</span></span><br><span class="line"><span class="comment">   * @type &#123; T &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  result: T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 消息</span></span><br><span class="line"><span class="comment">   * @type &#123; string &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  message: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把 API 单独抽离成单个模块时：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span></span><br><span class="line"><span class="keyword">import</span> Ax <span class="keyword">from</span> <span class="string">'./axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ResponseData &#125; <span class="keyword">from</span> <span class="string">'./interface.ts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Ax.get&lt;ResponseData&lt;T&gt;&gt;(<span class="string">'/somepath'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.data)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们写入返回的数据类型 <code>User</code>，这可以让 TypeScript 顺利推断出我们想要的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// user 被推断出为</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//  code: number,</span></span><br><span class="line">  <span class="comment">//  result: &#123; name: string, age: number &#125;,</span></span><br><span class="line">  <span class="comment">//  message: string</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> getUser&lt;User&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TypeScript-Joiful"><a href="#TypeScript-Joiful" class="headerlink" title="TypeScript Joiful"></a>TypeScript Joiful</h1><p>传送门: <a href="https://github.com/joiful-ts/joiful" target="_blank" rel="noopener">joiful</a></p><p>大概就是个拿来validate你数据的东西，看看你输入输出空不空之类的</p><p>This lib allows you to apply Joi validation constraints on class properties, by using decorators.</p><p>This means you can combine your type schema and your validation schema in one go!</p><p>Calling <code>Validator.validateAsClass()</code> allows you to validate any object as if it were an instance of a given class.</p><h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><p>大概就是搞一个decorator然后说明下数据类型和限制</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> jf <span class="keyword">from</span> <span class="string">'joiful'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SignUp &#123;</span><br><span class="line">  <span class="meta">@jf</span>.string().required()</span><br><span class="line">  username: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@jf</span></span><br><span class="line">    .string()</span><br><span class="line">    .required()</span><br><span class="line">    .min(<span class="number">8</span>)</span><br><span class="line">  password: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@jf</span>.date()</span><br><span class="line">  dateOfBirth: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@jf</span>.boolean().required()</span><br><span class="line">  subscribedToNewsletter: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signUp = <span class="keyword">new</span> SignUp();</span><br><span class="line">signUp.username = <span class="string">'rick.sanchez'</span>;</span><br><span class="line">signUp.password = <span class="string">'wubbalubbadubdub'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; error &#125; = jf.validate(signUp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(error); <span class="comment">// Error will either be undefined or a standard joi validation error</span></span><br></pre></td></tr></table></figure><h2 id="Validate-plain-old-javascript-objects"><a href="#Validate-plain-old-javascript-objects" class="headerlink" title="Validate plain old javascript objects"></a>Validate plain old javascript objects</h2><p>假如之前的object并不是按class继承出来的，你也可以用这个方法来以class判定这个object合不合规矩</p><p>Don’t like creating instances of classes? Don’t worry, you don’t have to. You can validate a plain old javascript object as if it were an instance of a class.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signUp = &#123;</span><br><span class="line">  username: <span class="string">'rick.sanchez'</span>,</span><br><span class="line">  password: <span class="string">'wubbalubbadubdub'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = jf.validateAsClass(signUp, SignUp);</span><br></pre></td></tr></table></figure><h2 id="Custom-decorator-constraints"><a href="#Custom-decorator-constraints" class="headerlink" title="Custom decorator constraints"></a>Custom decorator constraints</h2><p>自定义decorator，让你在任何object上套用验证：</p><p><code>customDecorators.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> jf <span class="keyword">from</span> <span class="string">'joiful'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  jf</span><br><span class="line">    .string()</span><br><span class="line">    .min(<span class="number">8</span>)</span><br><span class="line">    .regex(<span class="regexp">/[a-z]/</span>)</span><br><span class="line">    .regex(<span class="regexp">/[A-Z]/</span>)</span><br><span class="line">    .regex(<span class="regexp">/[0-9]/</span>)</span><br><span class="line">    .required();</span><br></pre></td></tr></table></figure><p><code>changePassword.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; password &#125; <span class="keyword">from</span> <span class="string">'./customDecorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ChangePassword &#123;</span><br><span class="line">  <span class="meta">@password</span>()</span><br><span class="line">  newPassword: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Validating-array-properties"><a href="#Validating-array-properties" class="headerlink" title="Validating array properties"></a>Validating array properties</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SimpleTodoList &#123;</span><br><span class="line">  <span class="meta">@jf</span>.array().items(<span class="function"><span class="params">joi</span> =&gt;</span> joi.string())</span><br><span class="line">  todos?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To validate an array of objects that have their own joiful validation:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Actor &#123;</span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Movie &#123;</span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@array</span>(&#123; elementClass: Actor &#125;).required()</span><br><span class="line">  actors!: Actor[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Validating-object-properties"><a href="#Validating-object-properties" class="headerlink" title="Validating object properties"></a>Validating object properties</h2><p>To validate an object subproperty that has its own joiful validation:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Address &#123;</span><br><span class="line">  <span class="meta">@string</span>()</span><br><span class="line">  line1?: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@string</span>()</span><br><span class="line">  line2?: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  city!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  state!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  country!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Contact &#123;</span><br><span class="line">  <span class="meta">@string</span>().required()</span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@object</span>().optional()</span><br><span class="line">  address?: Address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> note </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机入门</title>
      <link href="/2020/03/31/%E7%9B%B8%E6%9C%BA%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/31/%E7%9B%B8%E6%9C%BA%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/40906537" target="_blank" rel="noopener">林夏</a></li><li><a href="https://www.zhihu.com/question/20982898/answer/29803305" target="_blank" rel="noopener">王波</a></li><li><a href="https://zhuanlan.zhihu.com/p/36878963" target="_blank" rel="noopener">woodlouse</a></li><li><a href="https://zhuanlan.zhihu.com/p/39049149" target="_blank" rel="noopener">东方IC</a></li><li><a href="https://zhuanlan.zhihu.com/p/39049149" target="_blank" rel="noopener">七工巧映像</a></li><li><a href="https://www.zhihu.com/question/30468001/answer/49335630" target="_blank" rel="noopener">Molejin</a></li><li><a href="https://www.zhihu.com/question/21427664/answer/40346193" target="_blank" rel="noopener">王波</a></li><li><a href="http://iphoto.blog.163.com/blog/static/174404124200832982358951/" target="_blank" rel="noopener">几个必要的摄影名词解释</a></li></ol><h1 id="相机种类"><a href="#相机种类" class="headerlink" title="相机种类"></a>相机种类</h1><h2 id="单反"><a href="#单反" class="headerlink" title="单反"></a>单反</h2><p>单反的英文是Single Lens Reflex （SLR），意思是<strong>“单镜头反光式取景”</strong>。数码单反即DSLR。</p><p>“单镜头”是说这个相机只有一个镜头，过去胶片时代曾存在一机两头的双反相机。</p><p>“反光式取景”是指机身里面有一个反光板和一个五棱镜。穿过镜头的光线经过这两个小镜子的反射到达取景器，摄影者便可以从取景器里看到镜头拍到的景象。这样的取景结构被称为<strong>光学取景</strong>，自胶片时代就在使用。这样的取景结构不需要任何电力，即使关了机也能从取景器里看到图像。</p><h2 id="无反-微单-微电"><a href="#无反-微单-微电" class="headerlink" title="无反/微单/微电"></a>无反/微单/微电</h2><p>“微单”并没有对应的英文词，因为在中国以外并没有类似“微单”的叫法。</p><p>在国内被称为“微单”的这类相机在英文中被称为Mirrorless，直译是“没有镜子”，全称则是 Mirrorless Interchangeable-lens Camera（MILC） ，意思是<strong>无反光镜的可换镜头相机</strong>。其实中文中对这类相机也有“无反”这个叫法，只是没有“微单”这么响亮。微单相机内部的确也没有任何镜子，它采用的取景方式是<strong>电子取景</strong>，类似于我们的手机。</p><h3 id="微单和单反区别"><a href="#微单和单反区别" class="headerlink" title="微单和单反区别"></a>微单和单反区别</h3><p>微单是无反光镜的、电子取景的、可换镜头的相机，<strong>与体积大小没有绝对关系。</strong>但一般来说单反还是比微单要大的。微单并不是微型单反。微单和单反都是可换镜头相机，所以<strong>不能换镜头的相机不能是微单或单反</strong></p><p>有关更详细的区别和选择的问题，传送门：<a href="https://zhuanlan.zhihu.com/p/40906537" target="_blank" rel="noopener">林夏</a></p><h2 id="卡片机"><a href="#卡片机" class="headerlink" title="卡片机"></a>卡片机</h2><p>卡片相机是指普通的数码相机，则非单反、非微单的小型数码相机，小巧的外形、相对较轻的机身以及超薄时尚的设计是衡量此类数码相机的主要标准。曾经卡片机几乎被手机斩尽杀绝，直到索尼RX100，佳能G7X等产品和手机拉开一定技术差距。但卡片机被手机消灭的大势仍在。</p><h1 id="相机解析"><a href="#相机解析" class="headerlink" title="相机解析"></a>相机解析</h1><h2 id="画幅"><a href="#画幅" class="headerlink" title="画幅"></a>画幅</h2><p>“画幅”通俗点来讲就是相机的感光元件面积的大小，就是下图装在相机里面的那个东西。全幅或半幅，指的是相机内成像传感器的尺寸大小。全画幅传感器的尺寸与传统的35mm胶片相同，实际上并没有半画幅的说法，半画幅指的是APS-C，它是一种图像传感器的规格。现今数码单反相机中，大都是采用了小于135规格的CCD或CMOS感光器件，除了奥林帕斯的4/3系统和尼康<strong>/</strong>佳能全画幅以外，现存几乎全部都是和APS-C型胶片一样的大小:长宽比为3:2，边长近似为24.9×16.6mm，为了便于形容，人们就把类似这种大小的感光器件称之为”APS-C规格”。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331202240.png"  alt=""></p><p><strong>目前，相机的区分总体上来讲是按照画幅来区分，大致分为：</strong><br>1、大画幅，用生命描写世界的感觉，骨灰级玩家。<br>2、中画幅，哈苏、飞思、富士，多用于商业摄影，对画质要求极高。<br>3、全画幅，我们通常说的135画幅就是它。<br>4、APS-C画幅，就是半画幅，多用于入门机型。<br>5、M43画幅，富士、奥林巴斯还有生产。<br>6、一英寸，常见于卡片机、摄像机。<br>再小就是我们手机的感光元件了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331202324.png"  alt=""></p><p>全画幅相机可以在高ISO下提供更好的画质表现。但并不是说半幅传感器相机的画质相比就有多差，在绝大多数情况下，半幅相机也能完成全画幅相要的工作，只是效果可能会稍差一些。就好比喝茶一样，有人用碗有人用茶杯，其实用碗喝茶同样可以很好的品茶，但是用茶杯就会更有情调，品起来味道更浓。</p><p>举个栗子：D5500这样的半幅相机具有2400万像素的图像传感器，与全画幅的D750相同。然而，由于D750上的单位像素面积更大，因此它们对光更敏感。相应的，同样弱光的表现，全画幅要更佳。</p><p>全画幅相机使用全画幅镜头，镜头是按1:1记录画面，比如讲50mm镜头，实际焦距就是50mm；而半画幅相机其使用的镜头要乘以一个系数，才是该镜头的实际焦距，仍用50mm 镜头为例，半画幅镜头就需要乘以1.6，也就是说实际镜头焦距是80mm。这样半画幅的照相机实际镜头的角度小于镜头标注的数值。</p><p>从摄影素质上说，全画幅与半画幅相比，优势是有，不过不是很大，对于不是非常专业的人来说，几乎可以忽略不计。但是，也要看到全画幅也是有固有的缺点的：</p><p>1.传感器尺寸较大的一个缺点，就是需要更大的相机体积，内部结构才能补偿传感器尺寸的增加。因此，除了微单，全幅机一般都比版半幅机要笨重。</p><p>2.传感器一一种非常昂贵的材料成本，绝大多数全幅相机可以轻松地超过半幅相机两倍以上的价格。可能一不小心就会在相机上花上个5万、10万或更多，也不足为奇！比如用得最多的牌子佳能和尼康，入门机都是半画幅或3/4系统，体积小容易方便携带，摄影效果完全可以满足摄影初学者的要求；但对于专业的摄影师来说，买一台高端全幅的才是标配，连同各种镜头和器材，所要花的钱何止是十万八万那么简单。</p><p>3.半幅相机能使用全幅镜头，但全幅相机不能使用半幅镜头。</p><p>传送门：<a href="https://zhuanlan.zhihu.com/p/39049149" target="_blank" rel="noopener">七工巧映像</a></p><h3 id="画幅之间究竟有什么区别呢？"><a href="#画幅之间究竟有什么区别呢？" class="headerlink" title="画幅之间究竟有什么区别呢？"></a><strong>画幅之间究竟有什么区别呢？</strong></h3><p>鉴于大家是新手或者消费级用户，我们重点拿全画幅跟APS-C画幅来聊一聊。这个时候我们回到刚开始的两个问题：镜头焦距。<strong>镜头也分为全幅镜头和半幅镜头，全幅镜头可以装在半幅机上，半幅镜头是不能装在全幅机上的</strong>。在半幅机上，镜头焦距都要乘以1.6的系数转换，我们称之为等效焦距。以55m为例，再对照下图来看一下。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331202500.png"  alt=""></p><p><strong>如果装到半幅机上，站在同样的位置，得到的画面就是经过剪裁的。</strong>而想要得到相同的画面，我们就要站的再靠后一点，因为等效焦距成了82.5mm。同时，<strong>等效光圈也是同样实实在在存在的</strong>，背景虚化相对没那么好了。而当我们把半幅镜头装到全幅机上，由于感光元件大小不同，我们得到的画面是这样的。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331202528.png"  alt=""></p><p><strong>所以全幅头可以装在半幅机上，而半幅镜头不可以装在全幅机上。</strong>我们建议大家的也是，去入手全幅镜头，即使买了半幅机，上全幅那也是早晚的事。<strong>但是、但是、但是，我们不是拉你下水啊，假如你考虑的非常清楚了。</strong>入手半幅也很好，<strong>讲真，半幅和全幅差距并没有那么的大</strong>。而相反的，半幅机和镜头在价格及重量上具有明显的优势。</p><p>详细对比我们就不做了，举个例子：现在手机基本都达到了2000w像素，而相机大都是2000w像素，很明显的手机图片放大之后几乎没有细节，噪点也非常严重。而同像素的相机，却拥有更多的细节、更好的抗噪。因为感光元件大很多，但是相机之间不会有这么明显的差距。入坑前，大家自己权衡性价比吧！</p><p>传送门：<a href="https://zhuanlan.zhihu.com/p/36878963" target="_blank" rel="noopener">woodlouse</a></p><h2 id="感光元件"><a href="#感光元件" class="headerlink" title="感光元件"></a>感光元件</h2><p>数码相机的核心成像部件有两种：一种是广泛使用的CCD（电荷耦合）元件；另一种是CMOS（互补金属氧化物半导体）器件。与传统相机相比，传统相机使用“胶卷”作为其记录信息的载体，而数码相机的“胶卷”就是其成像感光元件。</p><h2 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h2><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331211738.png"  alt=""></p><p>传送门：<a href="https://www.zhihu.com/question/21427664/answer/40346193" target="_blank" rel="noopener">王波</a></p><p>ISO – 感光度，是一个曝光率极高的词。货架上的胶卷有ISO100，200和400的几种，这就是感光速度不同的胶卷。ISO感光度是CCD/CMOS（或胶卷）对光线的敏感程度。如果用ISO100的胶卷，相机2秒可以正确曝光的话，同样光线条件下用ISO200的胶卷只需要1秒即可，用ISO400则只要0.5秒。  在数码时代，数码相机的主菜单里都有ISO选择，100，200，400或者800，这和胶卷上的一样。看机型不同，低的到ISO50，最高有到25600的，数字越大越敏感（感光度越高）。 </p><p>午餐和爱情都流行快餐，什么事都要快点搞，按道理我们应该喜欢高感光度。但世界上没有免费午餐，高ISO虽然速度快但图像颗粒粗，经不起精细放大出图。所以风光摄影要用相机的最低感光度才可得到精细的画面。高ISO一般在万不得已的时候才用。 </p><p>人在江湖身不由己，万不得已的时候很多，所以高ISO图片质量是数码相机最重要的指标之一。在弱光场合比如昏暗的室内，午夜的街头，ISO100时即使光圈开到最大，快门速度也需1/4秒甚至更慢才能正确曝光，这时不用三脚架是无法把相机端稳的，手一晃照片就糊；就算用三脚架，被摄者一转头照片同样会糊。闪光灯可以救急，但闪灯会破坏现场气氛，人会脸色不自然，而且相机内的小闪光灯有效距离不会超过四米，稍远的人物和景物就无法照亮了。更何况有些地方是不准使用闪光灯的，如博物馆剧院。我们没有办法只有提高数码相机感光度到ISO800甚至1600。  同样是1000万像素的小数码DC和数码单反DSLR，如果都设置在最低感光度来拍摄（例如ISO100或80），假设镜头的素质相同，它们所拍的图片分辨率和图片质量差距不是太大。但如果ISO提高到400来拍摄，图片质量的差别就明显了，DSLR拍出来的图像依然干净，和ISO100时所拍差别不大，而DC的图片质量则下降明显，噪点很大，颜色失真，细节丢失。如果继续提高到ISO800，小数码DC的图片质量就只能用惨不忍睹四个字来形容了，而数码单反的图片质量虽有下降但依然可以接受。如果进一步提高到ISO1600，大部分数码单反的图片质量也下降得厉害，但依然能满足10寸照片的放大需求，而此时小数码DC的图片质量之差，您需要一颗勇敢的心才敢看。  </p><p>在像素相等的情况下，CCD/CMOS面积越大，高ISO的成像质量越好。也就是说：在CCD/CMOS面积一定的情况下，里面增加更多的像素反而会造成图像质量的下降。 所以现在的数码相机不应该在1000万像素以上再简单增加几百万像素，而应该在提高CCD/CMOS质量上下功夫。降低高感光度（高ISO）噪音水平以及增大曝光宽容度才是当务之急。 800万像素已经足够旅游摄影之需，我们在选择数码相机时就不该只看像素高低，而应该注意相机CCD/CMOS的大小。目前而言，解像度已经足够，该是重点关心图像质量的时候了。</p><h2 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h2><p>在摄影术最初发明的那些年，拍张照片曝光时间一般都需要好几分钟，大部分照相机是不需要快门的，开始曝光的时候把镜头盖取下，然后看表，五分钟后盖上，照片完成。  后来，胶片的感光速度越来越快（ISO越来越高），曝光时间变为一分钟，几秒钟，1/10秒甚至几百分之一秒，这时候用手取镜头盖就不够快了。我们需要一个能准确控制曝光时间的东西，这个东西就是快门。 快门有机械快门，电子快门，以及电子机械联合快门等很多种类。 定义：快门就是相机里控制曝光时间的装置。  这里顺便介绍一下安全快门速度。在使用135相机拍摄的时候有一个 <strong>手持相机拍摄的安全速度原则：安全速度是焦距的倒数</strong>，如果使用35mm镜头，快门速度不得低于1/35秒，使用200mm镜头时速度不得低于1/200秒，否则图片就可能糊了。</p><h2 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h2><p>光圈是一个用来控制光线透过镜头，进入机身内感光面的光量的装置，它通常是在镜头内。表达光圈大小我们是用f值。对于已经制造好的镜头，我们不可能随意改变镜头的直径，但是我们可以通过在镜头内部加入多边形或者圆型，并且面积可变的孔状光栅来达到控制镜头通光量，这个装置就叫做光圈</p><h3 id="光圈大小"><a href="#光圈大小" class="headerlink" title="光圈大小"></a>光圈大小</h3><p>光圈英文名称为Aperture，光圈是一个用来控制光线透过镜头，进入机身内感光面的光量的装置，也是相机一个极其重要的指标参数，它通常是在镜头内。它的大小决定着通过镜头进入感光元件的光线的多少。表达光圈大小我们是用F值。</p><p><strong>光圈的 f值 = 镜头的焦距 / 镜头口径的直径</strong></p><p>从以上的公式可知，要达到相同的光圈f值，长焦距镜头的口径要比短焦距镜头的口径大。</p><p>完整的光圈值系列如下：</p><p>f1，f1.4，f2，f2.8，f4，f5.6，f8，f11，f16，f22，f32，f44，f64</p><p>这里值得一提的是光圈 f 值愈小，在同一单位时间内的进光量便愈多，而且上一级的进光量刚好是下一级的两倍，例如光圈从 f8 调整到 f5.6，进光量便多一倍，我们也说光圈开大了一级。对于消费型数码相机而言，光圈 f 值常常介于 f2.8 - f16。此外许多数码相机在调整光圈时，可以做 1/3 级的调整。F后面的数值越小，光圈越大：光圈的作用在于决定镜头的进光量，光圈越大，进光量越多；F后面的数值越大，光圈越小：简单的说就是，在快门不变的情况下，光圈越大，进光量越多，画面比较亮；光圈越小，画面比较暗。</p><p>详细解释：</p><p>所有相机都基于小孔成像原理：拿一个密封箱子，在任何一面钻个小圆孔，然后把有孔的这面对着窗外，窗外的景象比如一棵树什么的，就会在圆孔对面的箱内壁生成 此树的倒影。假如我们在内壁涂上感光材料（装上胶卷或CCD/CMOS），这个有孔的箱子就是一台完整的照相机了。这就是针孔相机。  </p><p>既然一台照相机可以不需要镜头，为什么现在的相机前面不是一个小圆孔而是几块玻璃呢？而且这几块玻璃（镜头）还卖得那么贵！这是因为小孔要成像的话，孔必须很小，这也是针孔相机名称的来历。如果孔开得和门一样大，这个孔就成不了像。所以我们没有小门成像一说。孔小进光量就小，所以玩针孔摄影非常锻炼人的耐心，一张照片曝光几分钟到几个小时都常见。而且，由于光的衍射干扰，针孔相机拍的图片都不够清晰，如雾里看花一般。  </p><p>没有人原意花几个小时去拍一张模模糊糊的照片，我们要想办法加大进光量。有什么办法能够把这个小孔开大而又能生成清晰的图像呢？人们马上就想到了凸镜的聚光功能。把玻璃凸镜装到大孔上，问题不就解决了？  确实如此。相机镜头就是这样诞生的。今天数码相机的各种镜头都是几块凹凸镜的排列组合，然后外面用塑料或铁皮一包。有了镜头，小孔成像的这个孔 – 也就是下文中的光圈 – 就不再是针孔了，它变成了洞。  进光量问题解决。</p><p>但有时候问题又来了：我们并不是任何时候都需要大洞。比如夏日沙滩上烈日当头，四处白花花一片，为了分清到底是人肉还是白沙，我们需要眯着眼睛仔细观察。镜头是照相机的眼睛，这时候相机也需要眯起眼睛。很显然，为了应付不同的光线强度，我们还需要给镜头装上能够调节这个洞的大小的装置，以便在强光时缩小为针孔，弱光时开成大洞。这个装置就是光圈。</p><p>光圈英文名称为Aperture。一组凹凸镜再加上光圈就诞生了完整的镜头。 定义：光圈就是镜头里调节进光孔大小的装置。 常见的光圈值如下： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16， F22， F32， F44， F64。每两挡相邻光圈值之间进光量相差一倍。例如光圈从F4调整到F2.8，进光量便多一倍；从F2.8到F2又多一倍。也许您已经看出来了，光圈值和光圈实际大小是相反的，进光量最大时光圈为F1，最小时为F64。 对135相机来说大多数镜头的最小光圈为F22。</p><h2 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h2><p>为了讲清曝光这个词，我们还是回到小孔成像。假设一个黑乎乎的密闭房间，一面墙壁上开了个小圆窗户，窗对面的内壁上安上感光材料（白沥青，大型胶卷或CCD/CMOS）。这就是一台大型房式照相机。在没有打开小窗之前，房间里是黑乎乎的。  我们打开小窗，光线从小孔而入，射到对面墙壁的胶卷上，产生光化反应（或光电反应，如果是CCD/CMOS），照片就诞生了。此过程就叫做曝光。要得正确曝光的图片，必须精确决定曝光量。所谓曝光量就是让多少光进入这个密闭房间里。如果进光量太大，照片就会白花花一片，晚上变成了白天。如果进光量太小，照片就会黑乎乎的，白人变成黑人。 幸好我们有了光圈和快门两样工具可以一起来控制曝光量。曝光就是光圈和快门的组合。 可以这样认为：光圈（值）大小其实就是那个小圆窗户开多大，快门（速度）就是窗户打开多久。假设窗户只打开1/4，时间为4秒钟可以正确曝光的话，很显然，窗户打开一半，时间2秒钟也能让底片正确曝光，因为1/4<em>4=1/2</em>2=1，进光量都是一样多。同样的，如果窗户全开，曝光时间就只需要1秒了。  假若一个镜头光圈全开为F4，用摄影行话来说，光圈F4快门速度1秒为正确曝光值，那F5.6和2秒以及F8和4秒也同样能得到准确曝光的图片。 重要结论：一张正确曝光的图片可以有N种不同的光圈和快门速度组合。 总结以上几个名词解释，有三个因素能影响一张图片是否正确曝光：光圈，快门速度，ISO。 其中光圈和速度联合决定进光量，ISO决定CCD/CMOS的感光速度。如果进光量不够，我们可以开大光圈或者降低快门速度，还是不够的话就提高ISO。 大光圈的缺点是解像度不如中等光圈，快门速度降低则图片可能会糊，提高ISO后图片质量也会下降 。没有完美的方案，如何取舍要灵活决定。 </p><p><strong>测光与测光模式</strong> 曝光和测光是一对双胞胎，如果不能准确测定光照强度，正确曝光就无从谈起。1965年以前绝大多数相机都没有机内测光装置，拍照时要另外携带笨重的测光表，或者靠经验来估计光照强度。现在所有的数码相机都内置测光表，它能测量光线的强度，自动给出能正确曝光的光圈和快门速度，大大降低了摄影的技术门槛。 相机是如何实现自动测光的？原来每个数码相机里都有一个光敏电阻（不同强度的光线照射时电阻值发生变化），相机内的电脑根据电阻值的变化确定光线强度，进而确定曝光值（光圈，快门）。 测光模式主要有点测光，中央重点测光，区域（平均）测光三种。点测光只测取景框内一个小点的光线强度（此小点大约为取景框面积的10%到1%，看不同机型）。区域（平均）测光则把取景框分为5到63块（看机型不同），分别对每块测光然后再加权平均得到光照强度。中央重点测光是简化的区域（平均）测光，只把取景框分为中央圆圈和四周两块，分别测光，然后加权平均（中央圆圈的权重为70%左右）。 根据什么情况来采用不同的测光方式？大多数情况下用区域测光即可。在光线明暗反差很大时应该采用点测光。用区域（平均）测光或中央重点也可以，你可根据自己的艺术创意进行曝光补偿。</p><p><strong>曝光补偿（exposure compensation）</strong></p><p>到底怎样才算是正确曝光？这个问题没有绝对准确的答案。总原则：照片要能真实反映拍摄时的环境亮度。如果一张正午户外的照片被拍得昏暗如夜，这张照片就曝光不足，反之则是曝光过度。曝光是否准确是根据日常生活经验判断的。</p><p>相机自动确定的曝光值90%以上是正确的，但也有不准的时候，典型的例子是雪景，本来应该雪白刺眼的场景拍出来却是一片灰色；再比如对着一堆煤球拍，本来是纯黑，拍出来却是灰煤。这种失误根源在于相机的反射式测光原理。</p><p>我们之所以能看见东西，不外乎两种情况：一是物体本身可以发光，比如太阳或灯泡；大多数情况是物体能反射外来光线。反射的光线越多，物体就越亮，反之则越 暗。假设两个极端，纯黑色物体不会反射光线，反射率为零，而纯白的物体反射率是100%。在这两个极端之间取中间值就是不黑也不白的灰色，称为柯达灰，也 称为18%中间灰。</p><p>以一张客厅照片为例，客厅墙壁又白又亮，而电视机的大屏幕又黑又暗，窗帘和家具等亮度居中。要以谁的亮度来确定曝光？相机自动测光就是取平均数，最后给出一个让图片达到中间灰的曝光值。</p><p>相机内部的自动测光电脑是个死脑筋，它认为全世界所有场景的平均亮度都是18%中间灰。好在大部分生活场景都是明暗交织的，平均起来差不多是灰色，所以大多数情况下自动曝光自动测光都相对准确。但在雪景这样的纯白场景（或者煤球等纯黑场景）时，相机依然会给出中间灰效果的曝光值，拍出来就会白雪成灰雪，煤球成灰球。此时我们就要对自动曝光值予以修正，对雪景增加曝光，煤球减少曝光，这样才能拍出亮度和色调正确的照片。修正（增减）曝光值就叫做曝光补偿。</p><p>曝光补偿的原则：白加黑减。如果构图中有大片白色物体或者有灯等特别明亮的物体，就要相应增加曝光量（增大光圈or/and减低快门速度）；如果取景框中有大片黑色的物体，则要减少曝光量。 一般来说，在光照比较平均的情况下相机的自动测光和曝光比较准确，但在明暗反差很大时自动曝光往往不准，需要手动暴光补偿。</p><p>之所以需要曝光补偿，是因为相机的小电脑虽然聪明，但还没有聪明到能判断物体到底是什么，如果有一天电脑能辨别出白雪，茶杯，或者煤球，那也就不用人脑来补偿了。不过就算  相机能认识物体，在进行艺术创作时还是需要曝光补偿，例如我今天心情不好，想故意把明亮的世界拍得灰暗些；又比如我想故意增加曝光量，把一个深色皮肤的妹妹拍得白白的。这些事情相机的电脑永远学不会，因为它不懂我的心，所以我们永远需要补偿。</p><p>在胶片时代，精确测光和曝光是极其重要的， 负片底片一旦曝光不足，色彩就非常难看；而反转片一旦过曝一档（1EV），其色彩和层次就消失大半，更何况只有在底片冲印后才知道曝光是否准确。在数码时代曝光的问题变得简单了，拍完之后可以立即回放，曝光不准可以马上改，而且如果图片以RAW格式存储的话，其抗过曝/欠曝能力是很强的，只要没有曝成完全没层次的一片纯白，过曝/欠曝一个EV之内的照片都能在后期电脑处理时调正，而且基本不漏痕迹。但过曝/欠曝太多还是不行，如果相差2EV以上，调正后的图片也会很难看。所以掌握曝光补偿白加黑减的原则依然重要。</p><h2 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h2><h3 id="一般用什么焦距？"><a href="#一般用什么焦距？" class="headerlink" title="一般用什么焦距？"></a>一般用什么焦距？</h3><p>传送门<a href="https://www.zhihu.com/question/30468001/answer/49335630" target="_blank" rel="noopener">Molejin</a></p><p>说一说各个焦距(焦距段)适合拍什么样的照片。这里的焦距(焦距段)是对全画幅而言的，在非全画幅相机上可以找到其除以1.6的焦距，拍出来的效果是差不多的。题主看18-135这支镜头的变焦环上是不是有18，24，35，50，85，135这几个数字和刻度，答主镜头不在身边记不太清了…不过这几个是定焦镜头中最常用的焦距，所以我们先说说这几个焦距的适用范围。 </p><p>18-35mm焦距段通常被认为是广角段，视角广，透视效果明显，主要用于拍摄风光照片。18，24，35的定焦镜头根据具体需要选择，而变焦镜头只需在此焦段内任意选择合适的视角大小(与焦距挂钩)即可。在非全幅机上，18mm*1.6=28.8mm，这个焦距依然在广角段内，尚可接受。 </p><p>50mm的定焦镜头被称为标准定焦镜头，因为它最接近人眼所看到的景象。这个焦距的镜头适用范围多样，个人认为最适宜用来抓怕，因为大概可以说是“所见即所得”。在非全幅机上，将变焦环对准35mm焦距刻度，所得效果大约和标准焦距是一样的。 </p><p>85-135mm被认为是拍摄人像的最佳焦距段，这与透视畸变有关，经过实验发现偏小的焦距会使人的鼻子看起来非常大，偏大的焦距会使整张脸看起来太平，而85-135这个焦段所得的人面部五官最悦目。在此焦距段内任意焦距都可以用来拍摄人像，可以根据具体需要决定，但一般使用的是85mm焦距，题主可曾了解佳能和尼康的顶级人像镜头都是85mm？此外135mm已属于中长焦，根据需要可以使用在非人像摄影上。在非全幅机上，选择50mm焦距将得到等效80mm焦距，这就是为什么题主被告知拍摄人像将焦距定在略大于50mm处了。 </p><p>此外，再介绍几个18-135镜头上没有的又比较常见的焦距。小于16mm的镜头(焦距)在《美国纽约摄影学院摄影教材》上被定义为鱼眼镜头，但通常被称作超广角镜头，顾名思义，超广角拥有比广角更广的视角，同样也是用于拍摄风光片为主。而鱼眼镜头，通常被用来特指厂家专门生产的一类焦距更小的镜头，最小可以小至8mm。这类鱼眼镜头(焦距)的视角甚至可以达到180°(全幅机上)，将其放在你眼睛平视的位置，它甚至能“看”到你的脚。它们在传感器上形成的影像成原型而不是长方形，具有严重的畸变，可见其属于一种特殊镜头，除非有特别的爱好否则很少用到。</p><p>200mm是一般长焦镜头的最长端。长焦镜头的效果是将远处的物体拉近，简单说就是放大拍摄。长焦镜头视角小，透视不明显，主要用于拍摄远景。一般认为除非你有特殊需要(如拍摄体育赛事或野生动物)，否则不推荐使用200mm以上的焦距(镜头)，价格昂贵且实用性不高。这里特别提示一下18-135镜头安装在非全幅机上，长焦端可达210+mm的等效焦距，非常好用。</p><p>最后再向题主推荐上文提到的《美国纽约摄影学院摄影教材》，其中系统化理论化地介绍了从设备到技术到技巧几乎全部的摄影知识，相当全面，几乎可以认为是摄影方面的标准教科书，是摄影学习中的必读书籍。</p><h3 id="对焦系统"><a href="#对焦系统" class="headerlink" title="对焦系统"></a>对焦系统</h3><p>对焦系统，单反相机主要采用的是相位差对焦，最直观的就是对焦点的多少。这里存在一个误区，并不是点多就一定比点少好。关键要看对焦点的覆盖面积和精度，例如十字和双十字对焦点的数量和布局等。</p><p>另一个关键参数则为对应光圈，例如我们经常会看到描述中央对焦点的一句话是“中央为对应f/2.8的双十字型自动对焦”，这句话可解释为：当使用f/2.8及其以上光圈时，相机中央点对焦点会启动双十字感应；当使用小于f/2.8的光圈时，中央点则只会使用单十字线性感应。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200331205022.png"  alt=""></p><p>除了焦距之外，最大光圈也是一个非常重要的参数，一般定焦镜头可以达到f/1.8、f/1.4的较大光圈。顶级变焦头一般为恒定f/2.8，常用中价位的变焦头则为浮动光圈，比如70-300mm f/3.5-5.6，这实际是说，在70mm端最大光圈为f/3.5，在300mm端最大光圈为f/5.6。大光圈会带来较大的进光量，景深更浅更虚化。</p><p><strong>详解光圈</strong>：</p><p>光线经过透镜就会聚成一点（焦点） ，镜头的焦距就是从镜片（或镜片组）的中心到焦点的距离，单位是毫米（mm）。对全幅135数码单反相机以及我们以前常用的135胶卷相机（使用超市里的盒装胶卷）来说，焦距50mm的镜头称为“标准镜头”，简称标头，拍出来的照片类似肉眼平视的感觉（视角为45°左右）。<br>严格的定义是：标准镜头就是焦距等于底片（或CCD/CMOS）对角线长度的镜头。单张135底片是24x36mm，根据勾股定理计算，其对角线长度为43mm，所以135画幅的标头应该是43mm。在实际应用中我们把焦距为40-60mm的都称为标头。早期的单反相机是与50mm镜头捆绑销售的，这也许是称其为“标准镜头”的原因吧。<br>广角镜头（焦距小于35mm）能够让照相机“看得更宽阔”，因为它视角大；长焦镜头（焦距大于70mm）能让照相机“看得更远”，但视角窄。长焦镜头也称远摄镜头或望远镜头。从焦距的定义就可以推断出，广角镜头都身材矮小，长焦镜头都高大威猛。以后我们只要一看到那些又粗又长的大家伙，不用说那都是长焦头。<br>焦距固定的镜头即定焦镜头。1960年以前，变焦基本靠走。1965年之后，焦距可以调节的变焦镜头开始大量上市。变焦镜头的优势是明显的，改变焦距不用再走路，只需转动镜头筒。但变焦需要一套复杂的光学系统（其内部结构大多超过十片镜片），这给变焦镜头带来了 两个问题: 1. 体积和重量大; 2. 成像往往都不如最好的定焦镜头成像清晰。</p><p><strong>光学变焦与数码变焦</strong></p><p>我们经常看到数码相机广告上写XX倍光学变焦。这里的变焦倍数＝最大焦距值/最小焦距值。一个28-280mm变焦镜头的光学变焦倍数就是280mm/28mm，即10倍。光学变焦英文名称为Optical Zoom，它依靠镜片的位移来实现焦距的改变。光学变焦倍数越大，里面的镜片就越多，镜头体积相应较大，画质相对较低，光圈相对较小。<br>光学变焦并不是越大越好。一般来说，只要愿意花大价钱认真设计精心制作，以目前的技术水平，光学变焦比在4倍以内的镜头其光学素质才有可能接近或者达到定焦头的平均水准，比如佳能Canon 70-200mmF2.8IS镜头（市价两千美元，重1.5公斤）。超过4倍变焦的镜头其光学素质基本不可能达到定焦头的水平。<br>1995年以来市场上陆续出现了10倍以上的大变焦镜头，光学变焦越大当然越方便，但成像也会相应下降。2007年底上市的Panasonic松下FZ18数码相机其光学变焦为28-504mm，达到了不可思议的18倍，但实测这款相机的镜头边缘解像度相当差，看来18倍已经接近光学变焦目前的技术极限了。<br>关于数码变焦我只有三个字：骗人的。数码变焦只是电子放大，软件稍作改动就可以从一倍到一万倍变焦任君自取。只有光学变焦才是真正的变焦，数码变焦是厂家用来欺骗外行消费者的。</p><p><strong>焦距与135相机镜头的分类</strong></p><p>焦距              镜头类型              备注<br>14-24mm          超广角               视角很大，形变夸张，多用于拍摄建筑与风光<br>24-35mm           广角                 多用于拍摄建筑与风光以及街头人文抓拍<br>35-70mm          中焦                 视角接近人眼，多用于人文纪实抓拍<br>70-135mm         中长焦               视角比人眼窄，很多人像摄影师喜欢用这个焦段拍半身和头像的特写<br>135-300mm        长焦                 适合拍摄远距离物体。例如体育摄影、风光特写等等。<br>大于300mm        超长焦/望远           适合拍摄超远距离物体比如野生动物</p><p>值得注意的是：一个镜头是不是标准镜头（标头）不是看它的焦距而是看它的视角，视角45度的就是标准镜头。对120相机来说80mm焦距镜头才是标头。在数码时代，对Nikon D5100等APS-C画幅的数码单反来说，35mm焦距的镜头就是标头。</p><h2 id="白平衡与RAW"><a href="#白平衡与RAW" class="headerlink" title="白平衡与RAW"></a>白平衡与RAW</h2><p>要了解白平衡white balance就必须先了解另一个概念：色温color temperature。所谓色温就是以开尔文温度表示光线的色彩，单位是K。当物体被加热到一定的温度时就会发出光线，此光线不仅含有亮度的成份，更含有颜色的成份。我们常说的炉火纯青，即炉火的温度非常高，颜色才会达到青色，所以，温度越高，蓝色的成份越多，图像就会偏蓝；相反，温度越低，红色的成份就越多，图像就会偏红。光线的色温举例参见下表：</p><p>光线的色温<br>光源                      色温（Ｋ）<br>蜡烛                       2000<br>钨丝灯                     2500-3200<br>荧光灯                     4500-6500<br>日光（平均）               5400<br>有云天气下的日光            6500-7000</p><p>物体在不同色温的光源照射下会呈现不同的色调，在日光灯下整体偏白，在普通钨丝白炽灯下整体偏黄。白平衡就是照相机对白色的还原准确性。大多数情况下数码相机能准确判断光源的类型，拍出的照片颜色准确，但也有时候相机的电脑对色温做出了错误的判断，拍出的照片颜色惨不忍睹，严重偏蓝或发黄。这时候我们就要手动设置白平衡。中档以上的小数码DC和所有的数码单反DSLR都能在菜单里选择色温。</p><p>但万一人脑也判断错误怎么办？要彻底解决白平衡和色温准确性的问题只有一个方案：选择RAW图片存储格式。</p><p>高档小数码DC和所有DSLR都有图片存储格式选择。相对于Word文字文档，图片文件都巨大无比，典型的一千万像素数码照片如果以不压缩的TIFF格式存储，一张可能超过25MB。如果相机存储卡是1G（约1024MB），一张卡只能拍40张。所以不推荐TIFF存储格式。我们需要把巨大的图片文件压缩以便一张卡能存储更多照片。现最常用的图片压缩存储格式为JPEG，同样是一千万像素的照片，以JPEG存储一张1G的卡往往能拍100多张。</p><p>但JPEG是一种有损压缩，拍两张一样的照片分别以TIFF和JPEG格式存储，你会发现JPEG图片丢失了某些细节。大部分相机都有图片质量选择，这实际上就是JPEG压缩比的选择，压缩得越厉害，文件越小，一张卡能存储更多照片，但细节丢失更多。</p><p>数码相机内部都有一个小电脑，CCD/CMOS经曝光产生电子图片信号，相机内的小电脑把这些电子信号进行加工处理，再传输给存储卡。这些加工处理包括白平衡配置，颜色饱和度的增减，图片锐度和对比度增减，降低图片噪点等等，最后压缩转换为JPEG格式进行存储。</p><p>RAW英文是原始的意思，这很好地说明了RAW图片的特点：它是原始的，CCD/CMOS经过曝光产生的图片电子信号直接传给存储卡，文件没有经过相机内部电路的任何图片参数和质量处理。所以RAW文件又被称为<strong>数码底片</strong>Digital Negatives。其实准确地说RAW文件也经过了压缩，但这是一种无损压缩，后期在电脑上可以准确还原，没有一点细节丢失。我们回家后在电脑上可以给RAW图片任意配置色温（彻底解决白平衡问题），调整图片的颜色，锐度，对比度，曝光补偿等等，可以这么说：RAW格式的图片几乎所有的参数都可以后期在电脑上调。桌面电脑比相机内的小电脑强大得多，我们后期手工精心处理RAW而转换成的JPEG图片肯定漂亮。</p><p>这个世界当然没有完美的事，RAW文件最大的问题和TIFF文件一样，太大了。虽然通常比TIFF稍小一点，但还是比JPEG大两倍以上。好在现在的存储卡都卖成了白菜价，16G的卡才人民币一百多，问题不大。RAW文件第二个问题就是后期处理比较费时间。如果出门旅行十来天拍了上千张RAW图片，后期处理会让人头变得巨大。还好现在很多相机都可以同时存储JPEG和RAW，如果JPEG图片看起来还可以就不用处理RAW文件了。但同时存储JPEG和RAW，文件不是更大？唉，没办法。所以我最后的建议就是：重要图片的拍摄一律存储JPEG+RAW，一般的图片存JPEG.</p><h2 id="对焦速度"><a href="#对焦速度" class="headerlink" title="对焦速度"></a>对焦速度</h2><h2 id="录像"><a href="#录像" class="headerlink" title="录像"></a>录像</h2><p>对于4K的支持度帧数，对于慢动作的支持度帧数，在动作画面中的快速对焦能力</p><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><p>像素，这个问题比较有争议。一款相机的最高像素等于它所拍摄最大尺寸图片分辨率的长×宽。比如索尼全幅无反A7，它拥有2430万有效像素，所以它能拍摄的最大尺寸照片分辨率为6000×4000。</p><p>当像素越高，可裁切的余量也就越大，当压缩到我们常看的照片尺寸时，画质在一定程度上就会更好。但是像素越高，对相机的图像处理器、高感、后期时电脑的配置等，都会有较高的要求。所以，不要过分贪恋高像素。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>电池续航</li><li>SD卡插槽</li><li>显示器方向调整，是否方便翻转显示器以支持vlog</li><li>麦克风声音质量</li><li>是否支持外接麦克风</li><li>重量，握感</li><li>镜头支持，配件支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> photonics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> photonics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学Node.JS笔记</title>
      <link href="/2020/03/30/%E8%87%AA%E5%AD%A6Node.JS%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/30/%E8%87%AA%E5%AD%A6Node.JS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p><p>来源：Udemy Course：The complete node.js developer course (3rd edition)</p><p>这门课有个pdf，我看到哪就会记到哪。这门课的内容也都比较基础，不建议有js基础的人看。pdf下载<a href="https://github.com/8128/LC-solution/raw/master/test/src/com/node.pdf" target="_blank" rel="noopener">传送门</a></p><h1 id="关于npm"><a href="#关于npm" class="headerlink" title="关于npm"></a>关于npm</h1><p>就是个package管理系统，类似于java中maven的东西，使用<code>npm init</code>会初始化一个项目，自动新建一个<code>package.json</code>文件和一个<code>package-lock.json</code>文件。注意，你永远不应该编辑后者，因为那是根据前者自动生成的文件。使用<code>npm install</code>的包都会被记录到<code>package.json</code>里。假如你用<code>npm install -g</code>安装则会装到你系统环境里，不会显示到<code>package.json</code> file</p><p>在安装了本地依赖后，依赖会出现在<code>node_modules</code>文件夹下。但凡是npm安装的module，你都可以直接用<code>require(&#39;module name&#39;)</code>的方式来导入。比如<code>validator.js</code>作为依赖导入后，他的module名为<code>validator</code>，因此只需要<code>requre(&#39;validator.js&#39;)</code>即可</p><h2 id="很有用的nodemon"><a href="#很有用的nodemon" class="headerlink" title="很有用的nodemon"></a>很有用的nodemon</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemon -g</span><br></pre></td></tr></table></figure><p>能自动读取你对文件的改变并在console输出。</p><h1 id="基础输入输出"><a href="#基础输入输出" class="headerlink" title="基础输入输出"></a>基础输入输出</h1><p><code>process.argv</code>可以获取到用户的所有输入。例如<code>node app.js Andrew</code>，利用它可以获取到长度为3的array，第一个为你的node路径，第二个为app.js路径，第三个为Andrew。</p><h2 id="利用Yargs"><a href="#利用Yargs" class="headerlink" title="利用Yargs"></a>利用Yargs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yargs</span><br></pre></td></tr></table></figure><p>建议直接用<code>yargs --help</code></p><h3 id="Simple-Example"><a href="#Simple-Example" class="headerlink" title="Simple Example"></a>Simple Example</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (argv.ships &gt; <span class="number">3</span> &amp;&amp; argv.distance &lt; <span class="number">53.5</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plunder more riffiwobbles!'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Retreat from the xupptumblers!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./plunder.js --ships=4 --distance=22</span></span><br><span class="line">Plunder more riffiwobbles!</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./plunder.js --ships 12 --distance 98.7</span></span><br><span class="line">Retreat from the xupptumblers!</span><br></pre></td></tr></table></figure><h3 id="Complex-Example"><a href="#Complex-Example" class="headerlink" title="Complex Example"></a>Complex Example</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'yargs'</span>) <span class="comment">// eslint-disable-line</span></span><br><span class="line">  .command(<span class="string">'serve [port]'</span>, <span class="string">'start the server'</span>, (yargs) =&gt; &#123;</span><br><span class="line">    yargs</span><br><span class="line">      .positional(<span class="string">'port'</span>, &#123;</span><br><span class="line">        describe: <span class="string">'port to bind on'</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">5000</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, (argv) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (argv.verbose) <span class="built_in">console</span>.info(<span class="string">`start server on :<span class="subst">$&#123;argv.port&#125;</span>`</span>)</span><br><span class="line">    serve(argv.port)</span><br><span class="line">  &#125;)</span><br><span class="line">  .option(<span class="string">'verbose'</span>, &#123;</span><br><span class="line">    alias: <span class="string">'v'</span>,</span><br><span class="line">    type: <span class="string">'boolean'</span>,</span><br><span class="line">    description: <span class="string">'Run with verbose logging'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .argv</span><br></pre></td></tr></table></figure><p>Run the example above with <code>--help</code> to see the help for the application.</p><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>变量遵循驼峰命名</p><p>$ dollar sign开头的函数一般表示getter setter</p><p>_ lowdash 开头一般表示对数据库的操作</p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>来源：<a href="https://www.runoob.com/nodejs/nodejs-callback.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-callback.html</a></p><p>Node.js 异步编程的直接体现就是回调。</p><p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p><p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p><p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p><p>回调函数一般作为函数的最后一个参数出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">name, age, callback</span>) </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">value, callback1, callback2</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞代码实例"><a href="#阻塞代码实例" class="headerlink" title="阻塞代码实例"></a>阻塞代码实例</h3><p>创建一个文件 input.txt ，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束!"</span>);</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node main.js</span></span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line"></span><br><span class="line">程序执行结束!</span><br></pre></td></tr></table></figure><h3 id="非阻塞代码实例"><a href="#非阻塞代码实例" class="headerlink" title="非阻塞代码实例"></a>非阻塞代码实例</h3><p>创建一个文件 input.txt ，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束!"</span>);</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node main.js</span></span><br><span class="line">程序执行结束!</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure><p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p><p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>传送门：<a href="https://caolan.github.io/async/v3/" target="_blank" rel="noopener">async doc</a></p><p>这是一个nodejs库</p><h4 id="waterfall-tasks-callbackopt"><a href="#waterfall-tasks-callbackopt" class="headerlink" title="waterfall(tasks, callbackopt)"></a>waterfall(tasks, callback<em>opt</em>)</h4><p>有两个输入，第一个输入是所有waterfall中经过的函数，第二个输入是callback函数。你可以把第一个输入中的函数写在waterfall外部</p><p>Runs the <code>tasks</code> array of functions in series, each passing their results to the next in the array. However, if any of the <code>tasks</code> pass an error to their own callback, the next function is not executed, and the main <code>callback</code> is immediately called with the error.</p><h5 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters:"></a>Parameters:</h5><table><thead><tr><th align="left">Name</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>tasks</code></td><td align="left">Array</td><td align="left">An array of <a href="https://caolan.github.io/async/v3/global.html" target="_blank" rel="noopener">async functions</a> to run. Each function should complete with any number of <code>result</code> values. The <code>result</code> values will be passed as arguments, in order, to the next task.</td></tr><tr><td align="left"><code>callback</code></td><td align="left">function <optional></td><td align="left">An optional callback to run once all the functions have completed. This will be passed the results of the last task’s callback. Invoked with (err, [results]).</td></tr></tbody></table><h5 id="Returns"><a href="#Returns" class="headerlink" title="Returns:"></a>Returns:</h5><p>undefined</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 now equals 'one' and arg2 now equals 'two'</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'three'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 now equals 'three'</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'done'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result now equals 'done'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, with named functions:</span></span><br><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">    myFirstFunction,</span><br><span class="line">    mySecondFunction,</span><br><span class="line">    myLastFunction,</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result now equals 'done'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFirstFunction</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySecondFunction</span>(<span class="params">arg1, arg2, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 now equals 'one' and arg2 now equals 'two'</span></span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'three'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLastFunction</span>(<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 now equals 'three'</span></span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'done'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrustmaster T150简评</title>
      <link href="/2020/03/30/Thrustmaster%20T150%E7%AE%80%E8%AF%84/"/>
      <url>/2020/03/30/Thrustmaster%20T150%E7%AE%80%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为什么会买一个方向盘呢？这就要从我不安的双脚讲起了。作为一个从小行为不端的人，我坐姿也不端，喜欢把脚踩在较高的地方，所以坐在桌前的时候总会不由自主地把脚放到桌子的横轴上。这坐久了我怕太胖把这铁栏给踩断了，于是寻思着要买一个foot hammock，就听见discord游戏群里有人在说他们正在用方向盘玩赛车游戏呢。我琢磨着假如有脚踏板，是不是就不用foot hammock了？脚应该会很自然地去踩油门吧！所以就去查了下方向盘价格，没想到T150正好打折，算了税也才141刀，二话不说直接下单了好吧。</p><p>B&amp;H上写着两天送到货，我想你也太能吹牛逼了，这疫情的情况下，你在纽约我在加州，还都在爆发中心，你能两天给我送到了？结果两天以后收到一快递，啪啪啪打脸。</p><p>拆开箱子，内容很简单，一个方向盘，一个脚踏板，一本说明书，没了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200330215453.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200330215445.jpeg"  alt=""></p><p>换挡器可以自己买，你也可以用方向盘后面的换挡拨片。方向盘整体廉价感很重，都是塑料，只有拨片是金属的。拨片手感不错。</p><p>踏板只有油门和刹车。假如你购买的是T150 pro，那么应该是有三个踏板。我买的时候T150税前129，T150 pro税前199，这特么多一个踏板70块钱，我可真是再见了您呐。踏板比较寒酸，是个塑料踏板。假如你没有买专门的赛车椅和方向盘支架套装，你的踏板可能会比较难放。你需要找个地方把它卡住，因为塑料制的它有点轻，和地面摩擦力是不够大的，尤其是你在用力踩踏刹车的时候（刹车比较硬）</p><p>货到的时候固件版本比较低，我先连接了PC，到官网上下载了驱动进行了升级。注意，在链接PC的时候你需要将PS3/PS4的开关调整到PS3那边，这样你才能在PC上正常使用这款方向盘。假如插错的话请拔掉USB，调整开关，再重新插入PS4。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200330221730.gif"  alt=""></p><p>用这款方向盘我测试了几个游戏。在PS4平台，我测试的游戏有极品飞车：热度，极品飞车：复仇。在PC平台，我测试的游戏有DiRT Rally 2.0，WRC 7，DiRT 4，Assetto Corsa，Project CARS 2</p><p>为什么要先提游戏呢？因为每个游戏中你玩方向盘的体验都是截然不同的，每个游戏都对他们的操作系统有所优化，所以你在方向盘上受到的力都是不同的。</p><p>首先说一下极品飞车吧。这是个娱乐向的游戏，跟仿真没有半毛钱关系，连驾驶员第一视角都没有，跟第一视角最相近的也只有保险杠视角……I mean, 谁会想玩保险杠视角？谁想当保险杠啊？</p><p>在极品飞车:复仇中，基本只有回正的回馈力。开过车的兄弟都知道，你转完之后方向盘会自己回正。复仇中提供的就是这个回正的力，而且给的特别大，回正了以后还会不由自主左右晃几下的那种。这种力度很不自然，回正速度没真车快，力道却比真车大。但是这也会让你开车变得很简单，反正就只有这一种方向的力嘛，你的方向很好控制</p><p>在极品飞车:热度中，EA稍稍改变了一下方向盘手感，但依然稀烂，我个人感觉它甚至不如复仇。而且PS4 pro上这19年的新游戏竟然没有4K！竟然！没有！4K！我坐在我70寸彩电前面看这大果粒看得眼睛都瞎了。</p><p>而在PC平台上的这些游戏，基本都是仿真向的。DiRT两款游戏我都非常推荐，新手上路可能非常难以把握，因为它们的轮胎漂移真的跟我们日常开车中的轮胎漂移完全不同。在DiRT Rally 2.0上我到现在还没开赢过AI（这玩意没有难度选择的我也是傻了）……这两款游戏的画面素质过硬，rally 2.0文件大小甚至达到100G+。下雨天开车你能听到车顶噼里啪啦雨滴落下来的声音，看到雨刷挂起，后视镜里面的尘埃在雨中稀稀落落得散去；雪天你则会被打滑搞得心态大崩，开几百米撞一次树……假如你在美国可以去<a href="https://www.cdkeys.com/" target="_blank" rel="noopener">CDKey</a>上购买，十多刀就能买到豪华版，非常非常划算。</p><p>WRC 7全称是World Rally Championship 7，这是2017年World Rally Championship的官方游戏，个人体验下来手感是不如DiRT的，力反馈之类的都比较弱，感觉就是弱化了的DiRT，开车像开玩具</p><p>然后就是Project CAR 2和Assetto Corsa，它们的关系就有点像DiRT和WRC的关系，Assetto Corsa就像个儿子版本的Project CAR 2，画质和手感都会差一截。这俩游戏都是跑赛道的，我对跑赛道没什么兴趣。它们俩也都是究极追求仿真的系列，好像赛车手在家训练的时候也会拿Project CAR来做模拟。我们T150这破方向盘，拟真？方程式拟真？呵呵，算了吧哥，不讲笑话了</p><p>总之我认为花个141刀买了个方向盘非常值，它有入门级的力反馈系统，较低的反应延迟，比较准确的方向判定。最主要是能让你在这疫情的wfh时期休闲娱乐，开开心心出门开车，这实在是难能可贵。假如你想体验赛车游戏，又是个休闲玩家，并不想拟真，那就买吧！</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200330225614.GIF"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> review </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grunt教程</title>
      <link href="/2020/03/29/Grunt%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/29/Grunt%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>部分来源：<a href="www.gruntjs.net/">Grunt中文网</a></p><h1 id="Grunt是什么"><a href="#Grunt是什么" class="headerlink" title="Grunt是什么"></a>Grunt是什么</h1><p>Grunt是一款构建工具，为了让程序自动化而生。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 <a href="https://www.gruntjs.net/sample-gruntfile" target="_blank" rel="noopener">Gruntfile</a> 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。</p><h1 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h1><p>这部分入门是我自己写的简单入门，官方的快速入门在下面。</p><p>假如你想要用grunt，首先你需要npm，然后在你的package下安装grunt，然后建立一个<code>Gruntfile.js</code>文件，在文件中写你的grunt设置。grunt会根据你的<code>Gruntfile.js</code>来运作，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'speak'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm speaking"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  grunt.registerTask(<span class="string">'yell'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm Yelling"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  grunt.registerTask(<span class="string">'cool'</span>, [<span class="string">'speak'</span>, <span class="string">'yell'</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时假如你在命令行中输入就可以调用其中regist过的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ grunt speak</span><br><span class="line"></span><br><span class="line">I<span class="string">'m speaking</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ grunt yell</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'</span>m Yelling</span><br><span class="line"></span><br><span class="line">$ grunt yell</span><br><span class="line"></span><br><span class="line">I<span class="string">'m speaking</span></span><br><span class="line"><span class="string">I'</span>m Yelling</span><br></pre></td></tr></table></figure><p>grunt还支持大量的plugin，你可以在<a href="https://gruntjs.com/plugins" target="_blank" rel="noopener">这里</a>查到，其中会有用法介绍。你在安装这些predefined task之后，它们可能需要project中的设置才能够运行。为此我们需要initConfig，长相可能如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span><br><span class="line">    uglify: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      build: &#123;</span><br><span class="line">        src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,</span><br><span class="line">        dest: <span class="string">'build/&lt;%= pkg.name %&gt;.min.js'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>根据不同的预设plugin，我们可能需要更改initConfig。举例，假使我们在使用concat的plugin，我们首先用<code>npm install grunt-contrib-concat --save-dev</code>安装concat插件，然后在<code>Gruntfile.js</code>中用<code>grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;)</code>导入这个模块。因为我们导入了这个模块，模块运行需要我们的project设置，所以我们到concat的官方GitHub上copy下官方config，略作修改，在之前写入initConfig如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    concat: &#123;</span><br><span class="line">      <span class="comment">//options: &#123;</span></span><br><span class="line">      <span class="comment">//  separator: ';',</span></span><br><span class="line">      <span class="comment">//&#125;,</span></span><br><span class="line">      dist: &#123; <span class="comment">//distribution可以被改成任何东西，你可以叫其他名字</span></span><br><span class="line">        src: [<span class="string">'src/intro.js'</span>, <span class="string">'src/project.js'</span>, <span class="string">'src/outro.js'</span>],</span><br><span class="line">        dest: <span class="string">'dist/built.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat); // 会自动寻找config中的concat部分</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>这时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grunt concat</span><br><span class="line">File dist/built.js created.</span><br></pre></td></tr></table></figure><p>假如我们有两个任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">      concat:&#123;</span><br><span class="line">        aa: &#123; <span class="comment">//distribution可以被改成任何东西，你可以叫其他名字</span></span><br><span class="line">          src: [<span class="string">'src/intro.js'</span>, <span class="string">'src/project.js'</span>, <span class="string">'src/outro.js'</span>],</span><br><span class="line">          dest: <span class="string">'dist/built.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        bb: &#123; </span><br><span class="line">          src: [<span class="string">'src/intro1.js'</span>, <span class="string">'src/project1.js'</span>, <span class="string">'src/outro1.js'</span>],</span><br><span class="line">          dest: <span class="string">'dist/built1.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat); // 会自动寻找config中的concat部分</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>那么运行<code>grunt concat</code>，会合并你所有的文件</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Grunt和 Grunt 插件是通过 <a href="https://www.npmjs.org/" target="_blank" rel="noopener">npm</a> 安装并管理的，npm是 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 的包管理器。</p><p>Grunt 0.4.x 必须配合 Node.js <code>&gt;= 0.8.0</code> 版本使用。</p><p>在安装 Grunt 前，请确保当前环境中所安装的 <a href="https://www.npmjs.org/" target="_blank" rel="noopener">npm</a> 已经是最新版本，执行 <code>npm update -g npm</code> 指令进行升级（在某些系统中可能需要 <code>sudo</code> 指令）。</p><p>如果你已经安装了 Grunt，现在需要参考一些文档手册，那就请看一看 <a href="https://gruntjs.net/sample-gruntfile" target="_blank" rel="noopener"><code>Gruntfile</code> 实例</a> 和如何 <a href="https://gruntjs.net/configuring-tasks" target="_blank" rel="noopener">配置任务</a>吧。</p><h2 id="安装CLI"><a href="#安装CLI" class="headerlink" title="安装CLI"></a>安装CLI</h2><p><strong>还在使用 Grunt 0.3 版本吗？请查看 <a href="https://www.gruntjs.net/upgrading-from-0.3-to-0.4#grunt-0.3-notes" target="_blank" rel="noopener">Grunt 0.3 注意事项</a></strong></p><p>在继续学习前，你需要先将Grunt命令行（CLI）安装到全局环境中。安装时可能需要使用sudo（针对OSX、*nix、BSD等系统中）权限或者作为管理员（对于Windows环境）来执行以下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure><p>上述命令执行完后，<code>grunt</code> 命令就被加入到你的系统路径中了，以后就可以在任何目录下执行此命令了。</p><p>注意，安装<code>grunt-cli</code>并不等于安装了 Grunt！Grunt CLI的任务很简单：调用与<code>Gruntfile</code>在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。</p><p>这样就能让多个版本的 Grunt 同时安装在同一台机器上。</p><h2 id="CLI-是如何工作的"><a href="#CLI-是如何工作的" class="headerlink" title="CLI 是如何工作的"></a>CLI 是如何工作的</h2><p>每次运行<code>grunt</code> 时，他就利用node提供的<code>require()</code>系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行<code>grunt</code> 。</p><p>如果找到一份本地安装的 Grunt，CLI就将其加载，并传递<code>Gruntfile</code>中的配置信息，然后执行你所指定的任务。为了更好的理解 Grunt CLI的执行原理，请<a href="https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt" target="_blank" rel="noopener">阅读源码</a>。</p><h2 id="拿一份现有的-Grunt-项目练手"><a href="#拿一份现有的-Grunt-项目练手" class="headerlink" title="拿一份现有的 Grunt 项目练手"></a>拿一份现有的 Grunt 项目练手</h2><p>假定Grunt CLI已经正确安装，并且已经有一份配置好<code>package.json</code> 和 <code>Gruntfile</code> 文件的项目了，接下来就很容易拿Grunt练手了：</p><ol><li>将命令行的当前目录转到项目的根目录下。</li><li>执行<code>npm install</code>命令安装项目依赖的库。</li><li>执行 <code>grunt</code> 命令。</li></ol><p>OK，就是这么简单。还可以通过<code>grunt --help</code> 命令列出所有已安装的Grunt任务（task），但是一般更建议去查看项目的文档以获取帮助信息。</p><h2 id="准备一份新的-Grunt-项目"><a href="#准备一份新的-Grunt-项目" class="headerlink" title="准备一份新的 Grunt 项目"></a>准备一份新的 Grunt 项目</h2><p>一般需要在你的项目中添加两份文件：<code>package.json</code> 和 <code>Gruntfile</code>。</p><p><strong>package.json</strong>: 此文件被<a href="https://www.npmjs.org/" target="_blank" rel="noopener">npm</a>用于存储项目的元数据，以便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于<a href="https://docs.npmjs.com/files/package.json#devdependencies" target="_blank" rel="noopener">devDependencies</a>配置段内。</p><p><strong>Gruntfile</strong>: 此文件被命名为 <code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code>，用来配置或定义任务（task）并加载Grunt插件的。 <strong>此文档中提到的 <code>Gruntfile</code> 其实说的是一个文件，文件名是 <code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code></strong>。</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p><code>package.json</code>应当放置于项目的根目录中，与<code>Gruntfile</code>在同一目录中，并且应该与项目的源代码一起被提交。在上述目录(<code>package.json</code>所在目录)中运行<code>npm install</code>将依据<code>package.json</code>文件中所列出的每个依赖来自动安装适当版本的依赖。</p><p>下面列出了几种为你的项目创建<code>package.json</code>文件的方式：</p><ul><li>大部分 <a href="https://www.gruntjs.net/project-scaffolding" target="_blank" rel="noopener">grunt-init</a> 模版都会自动创建特定于项目的<code>package.json</code>文件。</li><li><a href="https://docs.npmjs.com/cli/init" target="_blank" rel="noopener">npm init</a>命令会创建一个基本的<code>package.json</code>文件。</li><li>复制下面的案例，并根据需要做扩充，参考此<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">说明</a>.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"my-project-name"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"grunt"</span>: <span class="string">"~0.4.5"</span>,</span><br><span class="line">    <span class="string">"grunt-contrib-jshint"</span>: <span class="string">"~0.10.0"</span>,</span><br><span class="line">    <span class="string">"grunt-contrib-nodeunit"</span>: <span class="string">"~0.4.1"</span>,</span><br><span class="line">    <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.5.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装Grunt-和-grunt插件"><a href="#安装Grunt-和-grunt插件" class="headerlink" title="安装Grunt 和 grunt插件"></a>安装Grunt 和 grunt插件</h3><p>向已经存在的<code>package.json</code> 文件中添加Grunt和grunt插件的最简单方式是通过<code>npm install  --save-dev</code>命令。此命令不光安装了``，还会自动将其添加到<a href="https://docs.npmjs.com/files/package.json#devdependencies" target="_blank" rel="noopener">devDependencies</a> 配置段中，遵循<a href="https://www.npmjs.org/doc/misc/semver.html#Ranges" target="_blank" rel="noopener">tilde version range</a>格式。</p><p>例如，下面这条命令将安装Grunt最新版本到项目目录中，并将其添加到devDependencies内：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install grunt --save-dev</span><br></pre></td></tr></table></figure><p>同样，grunt插件和其它node模块都可以按相同的方式安装。下面展示的实例就是安装 JSHint 任务模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install grunt-contrib-jshint --save-dev</span><br></pre></td></tr></table></figure><p>在 <a href="https://gruntjs.net/plugins" target="_blank" rel="noopener">Grunt 插件</a> 页面可以看到当前可用的 Grunt 插件，他们可以直接在项目中安装并使用。</p><p>安装插件之后，请务必确保将更新之后的 <code>package.json</code> 文件提交到项目仓库中。</p><h2 id="Gruntfile"><a href="#Gruntfile" class="headerlink" title="Gruntfile"></a>Gruntfile</h2><p><code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code> 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和<code>package.json</code>文件在同一目录层级，并和项目源码一起加入源码管理器。</p><p>Gruntfile由以下几部分构成：</p><ul><li>“wrapper” 函数</li><li>项目与任务配置</li><li>加载grunt插件和任务</li><li>自定义任务</li></ul><h3 id="Gruntfile文件案例"><a href="#Gruntfile文件案例" class="headerlink" title="Gruntfile文件案例"></a>Gruntfile文件案例</h3><p>在下面列出的这个 <code>Gruntfile</code> 中，<code>package.json</code>文件中的项目元数据（metadata）被导入到 Grunt 配置中， <a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a> 插件中的<code>uglify</code> 任务（task）被配置为压缩（minify）源码文件并依据上述元数据动态生成一个文件头注释。当在命令行中执行 <code>grunt</code> 命令时，<code>uglify</code> 任务将被默认执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Project configuration.</span></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span><br><span class="line">    uglify: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      build: &#123;</span><br><span class="line">        src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,</span><br><span class="line">        dest: <span class="string">'build/&lt;%= pkg.name %&gt;.min.js'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载包含 "uglify" 任务的插件。</span></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认被执行的任务列表。</span></span><br><span class="line">  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'uglify'</span>]);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面已经向你展示了整个 <code>Gruntfile</code>，接下来将详细解释其中的每一部分。</p><h3 id="“wrapper”-函数"><a href="#“wrapper”-函数" class="headerlink" title="“wrapper” 函数"></a>“wrapper” 函数</h3><p>每一份 <code>Gruntfile</code> （和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do grunt-related things in here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="项目和任务配置"><a href="#项目和任务配置" class="headerlink" title="项目和任务配置"></a>项目和任务配置</h3><p>大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给<a href="https://www.gruntjs.net/grunt#grunt.initconfig" target="_blank" rel="noopener">grunt.initConfig</a> 方法。</p><p>在下面的案例中，<code>grunt.file.readJSON(&#39;package.json&#39;)</code> 将存储在<code>package.json</code>文件中的JSON元数据引入到grunt config中。 由于<code>&lt;% %&gt;</code>模板字符串可以引用任意的配置属性，因此可以通过这种方式来指定诸如文件路径和文件列表类型的配置数据，从而减少一些重复的工作。</p><p>你可以在这个配置对象中(传递给initConfig()方法的对象)存储任意的数据，只要它不与你任务配置所需的属性冲突，否则会被忽略。此外，由于这本身就是JavaScript，你不仅限于使用JSON；你可以在这里使用任意的有效的JS代码。如果有必要，你甚至可以以编程的方式生成配置。</p><p>与大多数task一样，<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a> 插件中的<code>uglify</code> 任务要求它的配置被指定在一个同名属性中。在这里有一个例子, 我们指定了一个<code>banner</code>选项(用于在文件顶部生成一个注释)，紧接着是一个单一的名为<code>build</code>的uglify目标，用于将一个js文件压缩为一个目标文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project configuration.</span></span><br><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    options: &#123;</span><br><span class="line">      banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    build: &#123;</span><br><span class="line">      src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,</span><br><span class="line">      dest: <span class="string">'build/&lt;%= pkg.name %&gt;.min.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="加载-Grunt-插件和任务"><a href="#加载-Grunt-插件和任务" class="headerlink" title="加载 Grunt 插件和任务"></a>加载 Grunt 插件和任务</h3><p>像 <a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank" rel="noopener">concatenation</a>、[minification]、<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a> 和 <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">linting</a>这些常用的任务（task）都已经以<a href="https://github.com/gruntjs" target="_blank" rel="noopener">grunt插件</a>的形式被开发出来了。只要在 <code>package.json</code> 文件中被列为dependency（依赖）的包，并通过<code>npm install</code>安装之后，都可以在<code>Gruntfile</code>中以简单命令的形式使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载能够提供"uglify"任务的插件。</span></span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>grunt --help</code> 命令将列出所有可用的任务。</p><h3 id="自定义任务"><a href="#自定义任务" class="headerlink" title="自定义任务"></a>自定义任务</h3><p>通过定义 <code>default</code> 任务，可以让Grunt默认执行一个或多个任务。在下面的这个案例中，执行 <code>grunt</code> 命令时如果不指定一个任务的话，将会执行<code>uglify</code>任务。这和执行<code>grunt uglify</code> 或者 <code>grunt default</code>的效果一样。<code>default</code>任务列表数组中可以指定任意数目的任务（可以带参数）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default task(s).</span></span><br><span class="line">grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'uglify'</span>]);</span><br></pre></td></tr></table></figure><p>如果Grunt插件中的任务（task）不能满足你的项目需求，你还可以在<code>Gruntfile</code>中自定义任务（task）。例如，在下面的 <code>Gruntfile</code> 中自定义了一个<code>default</code> 任务，并且他甚至不依赖任务配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A very basic default task.</span></span><br><span class="line">  grunt.registerTask(<span class="string">'default'</span>, <span class="string">'Log some stuff.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    grunt.log.write(<span class="string">'Logging some stuff...'</span>).ok();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>特定于项目的任务不必在 <code>Gruntfile</code> 中定义。他们可以定义在外部<code>.js</code> 文件中，并通过<a href="https://www.gruntjs.net/grunt/#grunt.loadtasks" target="_blank" rel="noopener">grunt.loadTasks</a> 方法加载。</p><h1 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h1><p>这个指南解释了如何使用 <code>Gruntfile</code> 来为你的项目配置task。如果你还不知道 <code>Gruntfile</code> 是什么，请先阅读 <a href="https://www.gruntjs.net/getting-started" target="_blank" rel="noopener">快速入门</a> 指南并看看这个<a href="https://www.gruntjs.net/sample-gruntfile" target="_blank" rel="noopener">Gruntfile 实例</a>。</p><h2 id="Grunt配置"><a href="#Grunt配置" class="headerlink" title="Grunt配置"></a>Grunt配置</h2><p>Grunt的task配置都是在 <code>Gruntfile</code> 中的<code>grunt.initConfig</code>方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。</p><p>此外，由于这本身就是JavaScript，因此你不仅限于使用JSON；你可以在这里使用任何有效的JavaScript。必要的情况下，你甚至可以以编程的方式生成配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    <span class="comment">// 这里是concat任务的配置信息。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    <span class="comment">// 这里是uglify任务的配置信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 任意数据。</span></span><br><span class="line">  my_property: <span class="string">'whatever'</span>,</span><br><span class="line">  my_src_files: [<span class="string">'foo/*.js'</span>, <span class="string">'bar/*.js'</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="任务配置和目标"><a href="#任务配置和目标" class="headerlink" title="任务配置和目标"></a>任务配置和目标</h2><p>当运行一个任务时，Grunt会自动查找配置对象中的同名属性。多任务（multi-task）可以通过任意命名的“目标（target）”来定义多个配置。在下面的案例中，<code>concat</code>任务有名为<code>foo</code>和<code>bar</code>两个目标，而<code>uglify</code>任务仅仅只有一个名为<code>bar</code>目标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      <span class="comment">// concat task "foo" target options and files go here.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      <span class="comment">// concat task "bar" target options and files go here.</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      <span class="comment">// uglify task "bar" target options and files go here.</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时指定任务（task）和目标（target），例如<code>grunt concat:foo</code>或者<code>grunt concat:bar</code>，将只会处理指定目标（target）的配置，而运行<code>grunt concat</code>将遍历<em>所有</em>目标（target）并依次处理。注意，如果一个任务使用<a href="https://www.gruntjs.net/grunt.task#grunt.task.renametask" target="_blank" rel="noopener">grunt.task.renameTask</a>重命名过，Grunt将在配置对象中查找以<em>新的</em>任务名命名的属性。</p><h2 id="options属性"><a href="#options属性" class="headerlink" title="options属性"></a>options属性</h2><p>在一个任务配置中，<code>options</code>属性可以用来指定覆盖内置属性的默认值。此外，每一个目标（target）中还可以拥有一个专门针对此目标（target）的<code>options</code>属性。目标（target）级的平options将会覆盖任务级的options。</p><p><code>options</code>对象是可选的，如果不需要，可以忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 这里是任务级的Options，覆盖默认值 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    foo: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// "foo" target options may go here, overriding task-level options.</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      <span class="comment">// No options specified; this target will use task-level options.</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>由于大多的任务都是执行文件操作，Grunt 有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义<strong>src-dest</strong>(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。</p><p>All file formats support <code>src</code> and <code>dest</code> but the <a href="https://www.gruntjs.net/configuring-tasks#compact-format" target="_blank" rel="noopener">Compact</a> and <a href="https://www.gruntjs.net/configuring-tasks#files-array-format" target="_blank" rel="noopener">Files Array</a> formats support a few additional properties:</p><ul><li><code>filter</code> 它通过接受任意一个有效的<a href="https://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats" target="_blank" rel="noopener">fs.Stats方法名</a>或者一个函数来匹配<code>src</code>文件路径并根据匹配结果返回<code>true</code>或者<code>false</code>。 <a href="https://www.gruntjs.net/configuring-tasks#custom-filter-function" target="_blank" rel="noopener">See examples</a></li><li><code>nonull</code> 如果被设置为 <code>true</code>，未匹配的模式也将执行。结合Grunt的<code>--verbore</code>标志, 这个选项可以帮助用来调试文件路径的问题。</li><li><code>dot</code> 它允许模式模式匹配句点开头的文件名，即使模式并不明确文件名开头部分是否有句点。</li><li><code>matchBase</code>如果设置这个属性，缺少斜线的模式(意味着模式中不能使用斜线进行文件路径的匹配)将不会匹配包含在斜线中的文件名。 例如，<code>a?b</code> 将匹配 <code>/xyz/123/acb</code> 但不匹配 <code>/xyz/acb/123</code>。</li><li><code>expand</code> 处理动态的<code>src-dest</code>文件映射，更多的信息请查看<a href="https://www.gruntjs.net/configuring-tasks#building-the-files-object-dynamically" target="_blank" rel="noopener">动态构建文件对象</a>。</li><li>其他的属性将作为匹配项传递给底层的库。 请查看<a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">node-glob</a> 和<a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">minimatch</a> 文档以获取更多信息。</li></ul><h3 id="Difference-Between-Grunt-and-Task-Options"><a href="#Difference-Between-Grunt-and-Task-Options" class="headerlink" title="Difference Between Grunt and Task Options"></a>Difference Between Grunt and Task Options</h3><p>Most tasks perform file operations, so Grunt provides a built-in infrastructure to retrieve the files a task should process. The advantage is that this logic doesn’t have to be implemented again by tasks authors. To allow a user to specify these files, Grunt provides options such as <code>nonull</code> and <code>filter</code>.</p><p>In addition to the files to work on, each task has its own specific needs. A task author may want to allow its user to configure some options to override the default behavior. These task-specific options shall not be confused with the Grunt options described before.</p><p>To further clarify this difference, let’s see an example that uses <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">grunt-contrib-jshint</a>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  jshint: &#123;</span><br><span class="line">    ignore_warning: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="string">'-W015'</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      src: <span class="string">'js/**'</span>,</span><br><span class="line">      filter: <span class="string">'isFile'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>This configuration employs the Grunt options <code>src</code> and <code>filter</code> to specify the files to process. It also uses the grunt-contrib-jshint task-specific option <code>-W015</code> to ignore a specific warning (the one having code <code>W015</code>).</p><h3 id="简洁格式"><a href="#简洁格式" class="headerlink" title="简洁格式"></a>简洁格式</h3><p>这种形式允许每个目标对应一个<strong>src-dest</strong>文件映射。通常情况下它用于只读任务，比如<a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">grunt-contrib-jshint</a>，它就只需要一个单一的<code>src</code>属性，而不需要关联的<code>dest</code>选项. 这种格式还支给每个<code>src-dest</code>文件映射指定额外的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  jshint: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      src: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  concat: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      src: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],</span><br><span class="line">      dest: <span class="string">'dest/b.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件对象格式"><a href="#文件对象格式" class="headerlink" title="文件对象格式"></a>文件对象格式</h3><p>这种形式支持每个目标对应多个<code>src-dest</code>形式的文件映射，属性名就是目标文件，源文件就是它的值(源文件列表则使用数组格式声明)。可以使用这种方式指定数个<code>src-dest</code>文件映射， 但是不能够给每个映射指定附加的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      files: &#123;</span><br><span class="line">        <span class="string">'dest/a.js'</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>],</span><br><span class="line">        <span class="string">'dest/a1.js'</span>: [<span class="string">'src/aa1.js'</span>, <span class="string">'src/aaa1.js'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      files: &#123;</span><br><span class="line">        <span class="string">'dest/b.js'</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],</span><br><span class="line">        <span class="string">'dest/b1.js'</span>: [<span class="string">'src/bb1.js'</span>, <span class="string">'src/bbb1.js'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件数组格式"><a href="#文件数组格式" class="headerlink" title="文件数组格式"></a>文件数组格式</h3><p>这种形式支持每个目标对应多个<code>src-dest</code>文件映射，同时也允许每个映射拥有额外属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      files: [</span><br><span class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/a.js'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/aa1.js'</span>, <span class="string">'src/aaa1.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/a1.js'</span>&#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      files: [</span><br><span class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/b/'</span>, <span class="attr">nonull</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/bb1.js'</span>, <span class="string">'src/bbb1.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/b1/'</span>, <span class="attr">filter</span>: <span class="string">'isFile'</span>&#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="较老的格式"><a href="#较老的格式" class="headerlink" title="较老的格式"></a>较老的格式</h3><p><strong>dest-as-target</strong>文件格式在多任务和目标出现之前是一个过渡形式，目标文件路径实际上就是目标名称。遗憾的是, 由于目标名称是文件路径，那么运行<code>grunt task:target</code>可能不合适。此外，你也不能指定一个目标级的<code>options</code>或者给每个<code>src-dest</code>文件映射指定额外属性。</p><p>此种格式已经不赞成使用，请尽量不要使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    <span class="string">'dest/a.js'</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>],</span><br><span class="line">    <span class="string">'dest/b.js'</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="自定义过滤函数"><a href="#自定义过滤函数" class="headerlink" title="自定义过滤函数"></a>自定义过滤函数</h3><p><code>filter</code>属性可以给你的目标文件提供一个更高级的详细帮助信息。只需要使用一个有效的<a href="https://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats" target="_blank" rel="noopener">fs.Stats 方法名</a>。下面的配置仅仅清理一个与模式匹配的真实的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  clean: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      src: [<span class="string">'tmp/**/*'</span>],</span><br><span class="line">      filter: <span class="string">'isFile'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者创建你自己的<code>filter</code>函数，根据文件是否匹配来返回<code>true</code>或者<code>false</code>。下面的例子将仅仅清理一个空目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  clean: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      src: [<span class="string">'tmp/**/*'</span>],</span><br><span class="line">      filter: <span class="function"><span class="keyword">function</span>(<span class="params">filepath</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (grunt.file.isDir(filepath) &amp;&amp; <span class="built_in">require</span>(<span class="string">'fs'</span>).readdirSync(filepath).length === <span class="number">0</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Another example—which utilizes the <a href="https://www.gruntjs.net/configuring-tasks#globbing-patterns" target="_blank" rel="noopener">globbing</a> and <a href="https://www.gruntjs.net/configuring-tasks#building-the-files-object-dynamically" target="_blank" rel="noopener">expand: true</a> features—allows you to avoid overwriting files which already exist in the destination:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  copy: &#123;</span><br><span class="line">    templates: &#123;</span><br><span class="line">      files: [&#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: [<span class="string">'templates/css/'</span>],     <span class="comment">// Parent folder of original CSS templates</span></span><br><span class="line">        src: <span class="string">'**/*.css'</span>,             <span class="comment">// Collects all `*.css` files within the parent folder (and its subfolders)</span></span><br><span class="line">        dest: <span class="string">'src/css/'</span>,            <span class="comment">// Stores the collected `*.css` files in your `src/css/` folder</span></span><br><span class="line">        filter: <span class="function"><span class="keyword">function</span> (<span class="params">dest</span>) </span>&#123;    <span class="comment">// `dest`, in this instance, is the filepath of each matched `src`</span></span><br><span class="line">          <span class="keyword">var</span> cwd = <span class="keyword">this</span>.cwd,        <span class="comment">// Configures variables (these are documented for your convenience only)</span></span><br><span class="line">              src = dest.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + cwd), <span class="string">''</span>);</span><br><span class="line">              dest = grunt.task.current.data.files[<span class="number">0</span>].dest;</span><br><span class="line">          <span class="keyword">return</span> (!grunt.file.exists(dest + src));    <span class="comment">// Copies `src` files ONLY if their destinations are unoccupied</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Keep in mind the above technique does not account for the <a href="https://www.gruntjs.net/configuring-tasks#building-the-files-object-dynamically" target="_blank" rel="noopener">rename property</a> when checking if the destination exists.</p><h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p>通常分别指定所有源文件路径是不切实际的，因此Grunt通过内置支持<a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">node-glob</a> 和 <a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">minimatch</a> 库来匹配文件名(又叫作<code>globbing</code>)。</p><p>然这并不是一个综合的匹配模式方面的教程，你只需要知道如何在文件路径匹配过程中使用它们即可：</p><ul><li><code>*</code> 匹配任意数量的字符，但不匹配 <code>/</code></li><li><code>?</code> 匹配单个字符，但不匹配 <code>/</code></li><li><code>**</code> 匹配任意数量的字符，包括 <code>/</code>，只要它是路径中唯一的一部分</li><li><code>{}</code> 允许使用一个逗号分割的“或”表达式列表</li><li><code>!</code> 在模式的开头用于排除一个匹配模式所匹配的任何文件</li></ul><p>每个人都需要知道的是：<code>foo/*.js</code>将匹配位于<code>foo/</code>目录下的所有的<code>.js</code>结尾的文件；而<code>foo/**/*js</code>将匹配<code>foo/</code>目录以<em>及其子目录</em>中所有以<code>.js</code>结尾的文件。</p><p>此外, 为了简化原本复杂的通配符模式，Grunt允许指定一个数组形式的文件路径或者一个通配符模式。所有模式按顺序处理，模式处理的过程中，带有<code>!</code>前缀的模式所匹配的文件将不包含在结果集中。 而且其结果集中的每一项也是唯一的。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定单个文件：</span></span><br><span class="line">&#123;<span class="attr">src</span>: <span class="string">'foo/this.js'</span>, <span class="attr">dest</span>: ...&#125;</span><br><span class="line"><span class="comment">// 指定一个文件数组：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/this.js'</span>, <span class="string">'foo/that.js'</span>, <span class="string">'foo/the-other.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"><span class="comment">// 使用一个匹配模式：</span></span><br><span class="line">&#123;<span class="attr">src</span>: <span class="string">'foo/th*.js'</span>, <span class="attr">dest</span>: ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个独立的node-glob模式：</span></span><br><span class="line">&#123;<span class="attr">src</span>: <span class="string">'foo/&#123;a,b&#125;*.js'</span>, <span class="attr">dest</span>: ...&#125;</span><br><span class="line"><span class="comment">// 也可以这样编写：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/a*.js'</span>, <span class="string">'foo/b*.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo目录中所有的.js文件，按字母顺序排序：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/*.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"><span class="comment">// 首先是bar.js，接着是剩下的.js文件，并按字母顺序排序：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/bar.js'</span>, <span class="string">'foo/*.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除bar.js之外的所有的.js文件，按字母顺序排序：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/*.js'</span>, <span class="string">'!foo/bar.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"><span class="comment">// 按字母顺序排序的所有.js文件，但是bar.js在最后。</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/*.js'</span>, <span class="string">'!foo/bar.js'</span>, <span class="string">'foo/bar.js'</span>], <span class="attr">dest</span>: ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板也可以用于文件路径或者匹配模式中：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'src/&lt;%= basename %&gt;.js'</span>], <span class="attr">dest</span>: <span class="string">'build/&lt;%= basename %&gt;.min.js'</span>&#125;</span><br><span class="line"><span class="comment">// 它们也可以引用在配置中定义的其他文件列表：</span></span><br><span class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/*.js'</span>, <span class="string">'&lt;%= jshint.all.src %&gt;'</span>], <span class="attr">dest</span>: ...&#125;</span><br></pre></td></tr></table></figure><p>更多关于通配符模式的语法，请查看<a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">node-glob</a> 和 <a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">minimatch</a> 的文档。</p><h3 id="动态构建文件对象"><a href="#动态构建文件对象" class="headerlink" title="动态构建文件对象"></a>动态构建文件对象</h3><p>当你希望处理大量的单个文件时，这里有一些附加的属性可以用来动态的构建一个文件列表。这些属性都可以用于 <a href="https://www.gruntjs.net/configuring-tasks#compact-format" target="_blank" rel="noopener">Compact</a> 和 <a href="https://www.gruntjs.net/configuring-tasks#files-array-format" target="_blank" rel="noopener">Files Array</a> 文件映射格式。</p><p><code>expand</code> 设置为<code>true</code>将启用下面的选项：</p><ul><li><code>cwd</code> 所有<code>src</code>指定的匹配都将相对于此处指定的路径（但不包括此路径） 。</li><li><code>src</code> 相对于<code>cwd</code>路径的匹配模式。</li><li><code>dest</code> 目标文件路径前缀。</li><li><code>ext</code> 对于生成的<code>dest</code>路径中所有实际存在文件，均使用这个属性值替换扩展名。</li><li><code>extDot</code> 用于指定标记扩展名的英文点号的所在位置。可以赋值 <code>&#39;first&#39;</code> （扩展名从文件名中的第一个英文点号开始） 或 <code>&#39;last&#39;</code> （扩展名从最后一个英文点号开始），默认值为 <code>&#39;first&#39;</code> <em>[添加于 0.4.3 版本]</em></li><li><code>flatten</code> 从生成的<code>dest</code>路径中移除所有的路径部分。</li><li><code>rename</code> Embeds a customized function, which returns a string containing the new destination and filename. This function is called for each matched <code>src</code> file (after extension renaming and flattening). <a href="https://www.gruntjs.net/configuring-tasks#the-rename-property" target="_blank" rel="noopener">More information</a></li></ul><p>在下面的例子中，<code>uglify</code> 任务中的<code>static_mappings</code>和<code>dynamic_mappings</code>两个目标具有相同的<code>src-dest</code>文件映射列表, 这是因为任务运行时Grunt会自动展开<code>dynamic_mappings</code>文件对象为4个单独的静态<code>src-dest</code>文件映射–假设这4个文件能够找到。</p><p>可以指定任意静态<code>src-dest</code>和动态的<code>src-dest</code>文件映射相互结合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    static_mappings: &#123;</span><br><span class="line">      <span class="comment">// Because these src-dest file mappings are manually specified, every</span></span><br><span class="line">      <span class="comment">// time a new file is added or removed, the Gruntfile has to be updated.</span></span><br><span class="line">      files: [</span><br><span class="line">        &#123;<span class="attr">src</span>: <span class="string">'lib/a.js'</span>, <span class="attr">dest</span>: <span class="string">'build/a.min.js'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">src</span>: <span class="string">'lib/b.js'</span>, <span class="attr">dest</span>: <span class="string">'build/b.min.js'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">src</span>: <span class="string">'lib/subdir/c.js'</span>, <span class="attr">dest</span>: <span class="string">'build/subdir/c.min.js'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">src</span>: <span class="string">'lib/subdir/d.js'</span>, <span class="attr">dest</span>: <span class="string">'build/subdir/d.min.js'</span>&#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    dynamic_mappings: &#123;</span><br><span class="line">      <span class="comment">// Grunt will search for "**/*.js" under "lib/" when the "uglify" task</span></span><br><span class="line">      <span class="comment">// runs and build the appropriate src-dest file mappings then, so you</span></span><br><span class="line">      <span class="comment">// don't need to update the Gruntfile when files are added or removed.</span></span><br><span class="line">      files: [</span><br><span class="line">        &#123;</span><br><span class="line">          expand: <span class="literal">true</span>,     <span class="comment">// Enable dynamic expansion.</span></span><br><span class="line">          cwd: <span class="string">'lib/'</span>,      <span class="comment">// Src matches are relative to this path.</span></span><br><span class="line">          src: [<span class="string">'**/*.js'</span>], <span class="comment">// Actual pattern(s) to match.</span></span><br><span class="line">          dest: <span class="string">'build/'</span>,   <span class="comment">// Destination path prefix.</span></span><br><span class="line">          ext: <span class="string">'.min.js'</span>,   <span class="comment">// Dest filepaths will have this extension.</span></span><br><span class="line">          extDot: <span class="string">'first'</span>   <span class="comment">// Extensions in filenames begin after the first dot</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="The-rename-Property"><a href="#The-rename-Property" class="headerlink" title="The rename Property"></a>The rename Property</h4><p>The <code>rename</code> property is unique, as the only valid value for it is a JavaScript function. Although the function returns a string, you cannot simply use a string as a value for <code>rename</code> (doing so results in an error: <code>Property &#39;rename&#39; of object # is not a function</code>). In the following example, the <code>copy</code> task will create a backup of README.md.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  copy: &#123;</span><br><span class="line">    backup: &#123;</span><br><span class="line">      files: [&#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        src: [<span class="string">'docs/README.md'</span>],    <span class="comment">// The README.md file has been specified for backup</span></span><br><span class="line">        rename: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       <span class="comment">// The value for rename must be a function</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">'docs/BACKUP.txt'</span>; <span class="comment">// The function must return a string with the complete destination</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>When the function is called, the <code>dest</code> and matched <code>src</code> path are passed in and can be used for returning the output string. In the following example, files are copied from the <code>dev</code> folder to the <code>dist</code> folder, and renamed to have the word “beta” removed .</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  copy: &#123;</span><br><span class="line">    production: &#123;</span><br><span class="line">      files: [&#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: <span class="string">'dev/'</span>,</span><br><span class="line">        src: [<span class="string">'*'</span>],</span><br><span class="line">        dest: <span class="string">'dist/'</span>,</span><br><span class="line">        rename: <span class="function"><span class="keyword">function</span> (<span class="params">dest, src</span>) </span>&#123;          <span class="comment">// The `dest` and `src` values can be passed into the function</span></span><br><span class="line">          <span class="keyword">return</span> dest + src.replace(<span class="string">'beta'</span>,<span class="string">''</span>); <span class="comment">// The `src` is being renamed; the `dest` remains the same</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>If multiple matched <code>src</code> paths are renamed to an identical destination (i.e. if two different files get renamed to the same file), each output will be added to an array of sources for it.</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>使用<code>&lt;% %&gt;</code>分隔符指定的模板会在任务从它们的配置中读取相应的数据时将自动扩展扫描。模板会被递归的展开，直到配置中不再存在遗留的模板相关的信息(与模板匹配的)。</p><p>整个配置对象决定了属性上下文(模板中的属性)。此外，在模板中使用<code>grunt</code>以及它的方法都是有效的，例如： <code>&lt;%= grunt.template.today(&#39;yyyy-mm-dd&#39;) %&gt;</code>。</p><ul><li><code>&lt;%= prop.subprop %&gt;</code> 将会自动展开配置信息中的<code>prop.subprop</code>的值，不管是什么类型。像这样的模板不仅可以用来引用字符串值，还可以引用数组或者其他对象类型的值。</li><li><code>&lt;% %&gt;</code> 执行任意内联的JavaScript代码。对于控制流或者循环来说是非常有用的。</li></ul><p>下面以<code>concat</code>任务配置为例，运行<code>grunt concat:sample</code>时将通过banner中的<code>/* abcde */</code>连同<code>foo/*.js</code>+<code>bar/*.js</code>+<code>bar/*.js</code>匹配的所有文件来生成一个名为<code>build/abcde.js</code>的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    sample: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        banner: <span class="string">'/* &lt;%= baz %&gt; */\n'</span>,   <span class="comment">// '/* abcde */\n'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      src: [<span class="string">'&lt;%= qux %&gt;'</span>, <span class="string">'baz/*.js'</span>],  <span class="comment">// [['foo/*.js', 'bar/*.js'], 'baz/*.js']</span></span><br><span class="line">      dest: <span class="string">'build/&lt;%= baz %&gt;.js'</span>,      <span class="comment">// 'build/abcde.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//用于任务配置模板的任意属性</span></span><br><span class="line">  foo: <span class="string">'c'</span>,</span><br><span class="line">  bar: <span class="string">'b&lt;%= foo %&gt;d'</span>, <span class="comment">// 'bcd'</span></span><br><span class="line">  baz: <span class="string">'a&lt;%= bar %&gt;e'</span>, <span class="comment">// 'abcde'</span></span><br><span class="line">  qux: [<span class="string">'foo/*.js'</span>, <span class="string">'bar/*.js'</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="导入外部数据"><a href="#导入外部数据" class="headerlink" title="导入外部数据"></a>导入外部数据</h2><p>在下面的Gruntfile中，项目的元数据是从<code>package.json</code>文件中导入到Grunt配置中的，并且<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify 插件</a>中的 <code>uglify</code> 任务被配置用于压缩一个源文件以及使用该元数据动态的生成一个banner注释。</p><p>Grunt有<code>grunt.file.readJSON</code>和<code>grunt.file.readYAML</code>两个方法分别用于引入JSON和YAML数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    options: &#123;</span><br><span class="line">      banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    dist: &#123;</span><br><span class="line">      src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,</span><br><span class="line">      dest: <span class="string">'dist/&lt;%= pkg.name %&gt;.min.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Gruntfile-实例"><a href="#Gruntfile-实例" class="headerlink" title="Gruntfile 实例"></a>Gruntfile 实例</h1><p>In this page we walk you through the creation of a <code>Gruntfile</code> that covers the usual needs of a simple project. If you already know how to set up a <code>Gruntfile</code> and you’re looking for a quick example, here’s one:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    jshint: &#123;</span><br><span class="line">      files: [<span class="string">'Gruntfile.js'</span>, <span class="string">'src/**/*.js'</span>, <span class="string">'test/**/*.js'</span>],</span><br><span class="line">      options: &#123;</span><br><span class="line">        globals: &#123;</span><br><span class="line">          jQuery: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      files: [<span class="string">'&lt;%= jshint.files %&gt;'</span>],</span><br><span class="line">      tasks: [<span class="string">'jshint'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'jshint'</span>]);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p>Every project has its own needs, but most of them have something in common. In this guide we introduce you to a few Grunt plugins to automate basic requirements. The final goal is to teach you how to configure these Grunt plugins so that you can use them in your projects.</p><p>For the sake of the example, let’s say that you’re creating a JavaScript library. The typical folder structure features the following folders: <code>src</code>, <code>dist</code>, and <code>test</code>. The <code>src</code> folder (sometimes called <code>app</code>) contains the source code of the library as you author it. The <code>dist</code> folder (sometimes called <code>build</code>) contains the distribution, a minified version of the source code. A minified file is one where all unnecessary characters, such as spaces, new lines, comments are removed, without affecting the functionality of the source code. Minified source code is especially useful for users of the project because it reduces the amount of data that needs to be transferred. Finally, the <code>test</code> folder contains the code to test the project. This set up will be used in the next sections when creating the <code>Gruntfile</code> configuration.</p><p>While developing the library and releasing new versions there are a few tasks that you need to perform on a regular basis. For example, you might want to ensure that the code you write adheres to best practices, or that the code you’ve written doesn’t result in unexpected behaviors. To do that, you can employ a tool called <a href="http://jshint.com/about/" target="_blank" rel="noopener">JSHint</a>. Grunt has an official plugin for it called <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">grunt-contrib-jshint</a> which we’ll adopt in this example. In particular, you might want to ensure that as you modify your code, you don’t break any rules or best practices. So, a good strategy is to check the code at every change you perform. To do that, we’ll cover a Grunt plugin called <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" rel="noopener">grunt-contrib-watch</a>. The latter runs predefined tasks, such as <code>grunt-contrib-jshint</code>, whenever files are added, changed, or deleted.</p><p>Checking that your source code follows best practices is not enough to guarantee that it’s stable and doesn’t contain bugs. To create a robust project, you need to test it. There are several libraries you can adopt such as <a href="https://qunitjs.com/" target="_blank" rel="noopener">QUnit</a> or <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>. In this guide, we describe how to configure QUnit, and specifically <a href="https://github.com/gruntjs/grunt-contrib-qunit" target="_blank" rel="noopener">grunt-contrib-qunit</a>, to test your code.</p><p>When it comes to distributing your work, you want to offer a version as small in size as possible. To create a minified version you need a Grunt plugin like <a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a>. Moreover, unless the project you’re developing is very small, chances are that you’ve split the code in multiple files. While this is a good practice for the developer, you want users to include only one file. So, before minifying the code, you should concatenate the source files to create a single one. To achieve this goal you need a Grunt plugin like <a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank" rel="noopener">grunt-contrib-concat</a>.</p><p>To sum up, in this guide we’ll use the following five Grunt plugins:</p><ul><li><a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a></li><li><a href="https://github.com/gruntjs/grunt-contrib-qunit" target="_blank" rel="noopener">grunt-contrib-qunit</a></li><li><a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank" rel="noopener">grunt-contrib-concat</a></li><li><a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">grunt-contrib-jshint</a></li><li><a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" rel="noopener">grunt-contrib-watch</a></li></ul><p>If you’re curious about what the final result looks like, the entire <code>Gruntfile</code> can be found at the bottom of this page.</p><h2 id="Setting-up-the-Gruntfile"><a href="#Setting-up-the-Gruntfile" class="headerlink" title="Setting up the Gruntfile"></a>Setting up the <code>Gruntfile</code></h2><p>The first part is the “wrapper” function, which encapsulates your Grunt configuration.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Within that function we can initialize our configuration object:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Next, we can store the project settings from the <code>package.json</code> file into the <code>pkg</code> property. This allows us to refer to the values of properties within our <code>package.json</code> file, as we’ll see shortly.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg: grunt.file.readJSON(<span class="string">'package.json'</span>)</span><br></pre></td></tr></table></figure><p>This leaves us with this so far:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we can define a configuration for each of the tasks we mentioned. The configuration object for a plugin lives as a property on the configuration object, that often shares the same name as its plugin. The configuration for <code>grunt-contrib-concat</code> goes in the configuration object under the <code>concat</code> key as shown below:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">concat: &#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// define a string to put between each file in the concatenated output</span></span><br><span class="line">    separator: <span class="string">';'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dist: &#123;</span><br><span class="line">    <span class="comment">// the files to concatenate</span></span><br><span class="line">    src: [<span class="string">'src/**/*.js'</span>],</span><br><span class="line">    <span class="comment">// the location of the resulting JS file</span></span><br><span class="line">    dest: <span class="string">'dist/&lt;%= pkg.name %&gt;.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note how in the snippet above we refer to the <code>name</code> property that’s in the JSON file. We access it by using <code>pkg.name</code> as earlier we defined the <code>pkg</code> property to be the result of loading the <code>package.json</code> file, which is then parsed to a JavaScript object. Grunt has a simple template engine to output the values of properties in the configuration object. Here we tell the <code>concat</code> task to concatenate all files that exist within <code>src/</code> and end in <code>.js</code>.</p><p>Now let’s configure the <code>grunt-contrib-uglify</code> plugin, which minifies the JavaScript code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uglify: &#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// the banner is inserted at the top of the output</span></span><br><span class="line">    banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dist: &#123;</span><br><span class="line">    files: &#123;</span><br><span class="line">      <span class="string">'dist/&lt;%= pkg.name %&gt;.min.js'</span>: [<span class="string">'&lt;%= concat.dist.dest %&gt;'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This snippet tells <code>grunt-contrib-uglify</code> to create a file within <code>dist/</code> that contains the result of minifying the JavaScript files. Here we use <code>&lt;%= concat.dist.dest %&gt;</code> so uglify will minify the file that the concat task produces.</p><p>Up to this point, we have configured the plugins to create the distribution version the library. It’s now time to use <code>grunt-contrib-qunit</code> to automate the testing of the code. To do that, we need to give to specify the location of the test runner files, which are the HTML files QUnit runs on. The resulting code is reported below:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qunit: &#123;</span><br><span class="line">  files: [<span class="string">'test/**/*.html'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>Once done, it’s time to set up the configuration to ensure that the code of the project adheres to best practices. JSHint is a tool that can detect issues or potential issues like a high cyclomatic complexity, the use of the equality operator instead of the strict equality operator, and the definition of unused variables and functions.</p><p>We advise you to analyze with <code>grunt-contrib-jshint</code> all the JavaScript files of your project, including <code>Gruntfile</code> and the test files. An example of configuration of <code>grunt-contrib-jshint</code> is the following:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jshint: &#123;</span><br><span class="line">  <span class="comment">// define the files to lint</span></span><br><span class="line">  files: [<span class="string">'Gruntfile.js'</span>, <span class="string">'src/**/*.js'</span>, <span class="string">'test/**/*.js'</span>],</span><br><span class="line">  <span class="comment">// configure JSHint (documented at http://www.jshint.com/docs/)</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// more options here if you want to override JSHint defaults</span></span><br><span class="line">    globals: &#123;</span><br><span class="line">      jQuery: <span class="literal">true</span>,</span><br><span class="line">      <span class="built_in">console</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="built_in">module</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This plugin takes an array of files and then an object of options. These are all <a href="http://www.jshint.com/docs/" target="_blank" rel="noopener">documented on the JSHint site</a>. If you’re happy with the plugin defaults, there’s no need to redefine them in the Gruntfile.</p><p>The last plugin left to configure is <code>grunt-contrib-watch</code>. We’ll use it to run the <code>jshint</code> and the <code>qunit</code> tasks as soon as a JavaScript file is added, deleted, or modified. When it detects any of the files specified have changed (here, we use the same files we told JSHint to check), it will run the tasks you specify, in the order they appear. This can be run on the command line with <code>grunt watch</code>.</p><p>Turning the previous description into a configuration for <code>grunt-contrib-watch</code> results in the snippet below:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  files: [<span class="string">'&lt;%= jshint.files %&gt;'</span>],</span><br><span class="line">  tasks: [<span class="string">'jshint'</span>, <span class="string">'qunit'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h1><p>任务是Grunt的面包和奶油。就像你常用的工具，如： <code>jshint</code> 或 <code>nodeunit</code>。每当运行Grunt时, 你可以为其指定一个或多个任务, 这些任务用于告诉Grunt你想要它做什么事情。</p><p>如果你没有指定一个任务，并且你已经定义一个名为 “default” 的任务，那么该任务将会默认被执行（不用诧异，总要做点儿什么啊！）。</p><h2 id="任务别名"><a href="#任务别名" class="headerlink" title="任务别名"></a>任务别名</h2><p>如果指定了一个任务列表，新任务将是这一个或多个指定任务的别名。当运行此 “任务别名” 时，在 <code>taskList</code> 中指定的每个任务都会按照其出现的顺序依次执行。<code>taskList</code>参数必须时一个任务数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(taskName, [description, ] taskList)</span><br></pre></td></tr></table></figure><p>下面的任务别名案例中定义了一个 ‘default’ 任务，如果运行Grunt时没有指定任何任务，它将自动执行’jshint’、’qunit’、’concat’ 和 ‘uglify’ 任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'jshint'</span>, <span class="string">'qunit'</span>, <span class="string">'concat'</span>, <span class="string">'uglify'</span>]);</span><br></pre></td></tr></table></figure><p>还可以给任务指定参数。在下面的案例中，别名 “dist” 将执行 “concat” 和 “uglify” 两个任务，并且它们都带有一个 “dist” 参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'dist'</span>, [<span class="string">'concat:dist'</span>, <span class="string">'uglify:dist'</span>]);</span><br></pre></td></tr></table></figure><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>当运行一个多任务时，Grunt会自动从项目的配置对象中查找同名属性。多任务可以有多个配置，并且可以使用任意命名的’targets’。</p><p>同时指定像<code>grunt concat:foo</code>或者<code>grunt concat:bar</code>这样的任务和目标，在运行时Grunt只会处理指定目标的配置；然而如果运行<code>grunt concat</code>，将会遍历所有的目标, 并按任务指定的顺序处理每个目标。注意，如果一个任务已经使用<a href="https://www.gruntjs.net/grunt.task#grunt.task.renametask" target="_blank" rel="noopener">grunt.task.renameTask</a>重命名过，Grunt将会自动在配置对象中查找新任务名称属性。</p><p>大部分的contrib任务(主要是指官方提供的任务)，包括<a href="https://github.com/gruntjs/grunt-contrib-jshint#jshint-task" target="_blank" rel="noopener">grunt-contrib-jshint插件的jshint任务</a>，以及<a href="https://github.com/gruntjs/grunt-contrib-concat#concat-task" target="_blank" rel="noopener">grunt-contrib-concat插件的concat任务</a>都是多任务形式的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerMultiTask(taskName, [description, ] taskFunction)</span><br></pre></td></tr></table></figure><p>对于指定的配置，这里有一个案例演示了如果通过<code>grunt log:foo</code>运行Grunt，它会输出<code>foo: 1,2,3</code>；如果通过<code>grunt log:bar</code>来运行Grunt， 它会输出<code>bar: hello world</code>。然而如果通过<code>grunt log</code>运行Grunt, 它会输出<code>foo: 1,2,3</code>，然后是<code>bar: hello world</code>，最后是<code>baz: false</code>(任务目标会按照指定的顺序进行处理)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  log: &#123;</span><br><span class="line">    foo: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    bar: <span class="string">'hello world'</span>,</span><br><span class="line">    baz: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.registerMultiTask(<span class="string">'log'</span>, <span class="string">'Log stuff.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  grunt.log.writeln(<span class="keyword">this</span>.target + <span class="string">': '</span> + <span class="keyword">this</span>.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="“基本”-任务"><a href="#“基本”-任务" class="headerlink" title="“基本” 任务"></a>“基本” 任务</h2><p>当一个基本任务执行时，Grunt并不会检查配置和环境 – 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(taskName, [description, ] taskFunction)</span><br></pre></td></tr></table></figure><p>下面的案例中，如果执行 <code>grunt foo:testing:123</code>，将输出日志 <code>foo, testing 123</code>。 如果执行这个任务时不传递参数，只是执行 <code>grunt foo</code>，那么将输出日志 <code>foo, no args</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'A sample task that logs stuff.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    grunt.log.writeln(<span class="keyword">this</span>.name + <span class="string">", no args"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    grunt.log.writeln(<span class="keyword">this</span>.name + <span class="string">", "</span> + arg1 + <span class="string">" "</span> + arg2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="自定义任务-1"><a href="#自定义任务-1" class="headerlink" title="自定义任务"></a>自定义任务</h2><p>你可以和任务一起疯狂。如果你的任务并没有遵循 “多任务” 结构，那就使用自定义任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'default'</span>, <span class="string">'My "default" task description.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  grunt.log.writeln(<span class="string">'Currently running the "default" task.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在一个任务内部，你可以执行其他的任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Enqueue "bar" and "baz" tasks, to run after "foo" finishes, in-order.</span></span><br><span class="line">  grunt.task.run(<span class="string">'bar'</span>, <span class="string">'baz'</span>);</span><br><span class="line">  <span class="comment">// Or:</span></span><br><span class="line">  grunt.task.run([<span class="string">'bar'</span>, <span class="string">'baz'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务也可以是异步的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'asyncfoo'</span>, <span class="string">'My "asyncfoo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Force task into async mode and grab a handle to the "done" function.</span></span><br><span class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</span><br><span class="line">  <span class="comment">// Run some sync stuff.</span></span><br><span class="line">  grunt.log.writeln(<span class="string">'Processing task...'</span>);</span><br><span class="line">  <span class="comment">// And some async stuff.</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    grunt.log.writeln(<span class="string">'All done!'</span>);</span><br><span class="line">    done();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务也可以访问它们自身名称和参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  grunt.log.writeln(<span class="keyword">this</span>.name, a, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="comment">// grunt foo</span></span><br><span class="line"><span class="comment">//   logs: "foo", undefined, undefined</span></span><br><span class="line"><span class="comment">// grunt foo:bar</span></span><br><span class="line"><span class="comment">//   logs: "foo", "bar", undefined</span></span><br><span class="line"><span class="comment">// grunt foo:bar:baz</span></span><br><span class="line"><span class="comment">//   logs: "foo", "bar", "baz"</span></span><br></pre></td></tr></table></figure><p>如果记录到任何错误，那么任务就会失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (failureOfSomeKind) &#123;</span><br><span class="line">    grunt.log.error(<span class="string">'This is an error message.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果这个任务出现错误则返回false</span></span><br><span class="line">  <span class="keyword">if</span> (ifErrors) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  grunt.log.writeln(<span class="string">'This is the success message'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当任务失败时，所有后续任务都将终止，除非指定 <code>--force</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fail synchronously.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.registerTask(<span class="string">'bar'</span>, <span class="string">'My "bar" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fail asynchronously.</span></span><br><span class="line">    done(<span class="literal">false</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务还可以依赖于其他任务的成功执行。注意 <code>grunt.task.requires</code> 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.registerTask(<span class="string">'bar'</span>, <span class="string">'My "bar" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果"foo"任务运行失败或者没有运行则任务失败。</span></span><br><span class="line">  grunt.task.requires(<span class="string">'foo'</span>);</span><br><span class="line">  <span class="comment">// 如果"foo"任务运行成功则执行这里的代码。</span></span><br><span class="line">  grunt.log.writeln(<span class="string">'Hello, world.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="comment">// grunt foo bar</span></span><br><span class="line"><span class="comment">//   没有输出，因为"foo"失败。</span></span><br><span class="line"><span class="comment">//   ***Note: This is an example of space-separated sequential commands,</span></span><br><span class="line"><span class="comment">//   (similar to executing two lines of code: `grunt foo` then `grunt bar`)</span></span><br><span class="line"><span class="comment">// grunt bar</span></span><br><span class="line"><span class="comment">//   没有输出，因为"foo"从未运行。</span></span><br></pre></td></tr></table></figure><p>如果任务需要的配置属性不存在，其也可能失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fail task if "meta.name" config prop is missing</span></span><br><span class="line">  <span class="comment">// Format 1: String</span></span><br><span class="line">  grunt.config.requires(<span class="string">'meta.name'</span>);</span><br><span class="line">  <span class="comment">// or Format 2: Array</span></span><br><span class="line">  grunt.config.requires([<span class="string">'meta'</span>, <span class="string">'name'</span>]);</span><br><span class="line">  <span class="comment">// Log... conditionally.</span></span><br><span class="line">  grunt.log.writeln(<span class="string">'This will only log if meta.name is defined in the config.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务还可以访问配置属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'foo'</span>, <span class="string">'My "foo" task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录属性值，如果属性未定义（undefined）则返回null。</span></span><br><span class="line">  grunt.log.writeln(<span class="string">'The meta.name property is: '</span> + grunt.config(<span class="string">'meta.name'</span>));</span><br><span class="line">  <span class="comment">// 同样的记录属性值，如果属性未定义（undefined）则返回null。</span></span><br><span class="line">  grunt.log.writeln(<span class="string">'The meta.name property is: '</span> + grunt.config([<span class="string">'meta'</span>, <span class="string">'name'</span>]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/gruntjs/" target="_blank" rel="noopener">contrib tasks</a> 中可以查看更多案例。</p><h2 id="CLI-参数-环境"><a href="#CLI-参数-环境" class="headerlink" title="CLI 参数 / 环境"></a>CLI 参数 / 环境</h2><p>通过 <code>process.env</code> 来访问<a href="https://en.wikipedia.org/wiki/Environment_variable" target="_blank" rel="noopener">环境变量</a>。</p><p>请参考 <a href="https://gruntjs.net/using-the-cli" target="_blank" rel="noopener">使用命令行工具</a>章节，查看完整的的命令行选项列表。</p><h2 id="为什么我的异步task没有完成？"><a href="#为什么我的异步task没有完成？" class="headerlink" title="为什么我的异步task没有完成？"></a>为什么我的异步task没有完成？</h2><p>Chances are this is happening because you have forgotten to call the <a href="https://gruntjs.net/api/inside-tasks#this.async" target="_blank" rel="noopener">this.async</a> method to tell Grunt that your task is asynchronous. For simplicity’s sake, Grunt uses a synchronous coding style, which can be switched to asynchronous by calling <code>this.async()</code> within the task body.</p><p>注意，传递 <code>false</code> 给 <code>done()</code> 函数就会告诉Grunt你的任务已经失败。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'asyncme'</span>, <span class="string">'My asynchronous task.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</span><br><span class="line">  doSomethingAsync(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h1><ol><li>通过 <code>npm install -g grunt-init</code> 命令安装 <a href="https://github.com/gruntjs/grunt-init" target="_blank" rel="noopener">grunt-init</a> 。</li><li>通过 <code>git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin</code> 命令安装grunt插件模版。</li><li>在一个空的目录中执行 <code>grunt-init gruntplugin</code> 。</li><li>执行 <code>npm install</code> 命令以准备开发环境。</li><li>为你的插件书写代码。</li><li>执行 <code>npm publish</code> 命令将你创建的 Grunt 插件提发布npm！</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="命名你的task"><a href="#命名你的task" class="headerlink" title="命名你的task"></a>命名你的task</h3><p>“grunt-contrib” 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>Grunt默认隐藏了error stack traces，但是可以通过 <code>--stack</code> 参数启用，方便你调试自己的task。如果你希望 Grunt 在出现错误时总是能记录下stack trace，可以在你的shell中创建一个命令别名（alias）。例如，在bash中，可以通过 <code>alias grunt=&#39;grunt --stack&#39;</code> 命令创建一个别名。</p><h3 id="存储任务文件"><a href="#存储任务文件" class="headerlink" title="存储任务文件"></a>存储任务文件</h3><p>只在项目根目录中的 .grunt/[npm-module-name] 目录中存储数据文件，并在适当的时候将其清除。对于临时文件这并不是一个好的解决方案, 建议使用后面列出的几个常用npm模块（例如 <a href="https://www.npmjs.org/package/temporary" target="_blank" rel="noopener">temporary</a>、<a href="https://www.npmjs.org/package/tmp" target="_blank" rel="noopener">tmp</a>）来调用操作系统级别的临时目录功能。</p><h3 id="避免改变当前工作目录：process-cwd"><a href="#避免改变当前工作目录：process-cwd" class="headerlink" title="避免改变当前工作目录：process.cwd()"></a>避免改变当前工作目录：<code>process.cwd()</code></h3><p>默认情况下，包含gruntfile文件的目录被设置为当前工作目录。用户可以在自己的gruntfile中通过执行<code>grunt.file.setBase()</code> 改变改变当前工作目录，但是插件不应该改变它。</p><p><code>path.resolve(&#39;foo&#39;)</code> 可以被用来获取’foo’ 相对于 <code>Gruntfile</code> 所在目录的绝对路径。</p><h3 id="Creating-your-task"><a href="#Creating-your-task" class="headerlink" title="Creating your task"></a>Creating your task</h3><p>You might also want to know how to <a href="https://gruntjs.net/creating-tasks" target="_blank" rel="noopener">create your own tasks</a> or take a look at the <a href="https://gruntjs.net/api" target="_blank" rel="noopener">API</a> reference.</p><h1 id="使用命令行工具"><a href="#使用命令行工具" class="headerlink" title="使用命令行工具"></a>使用命令行工具</h1><h2 id="安装命令行工具"><a href="#安装命令行工具" class="headerlink" title="安装命令行工具"></a>安装命令行工具</h2><p>执行 <code>sudo npm install -g grunt-cli</code> （Windows 用户应省略 “sudo”，并且可能需要提升权限以运行此命令）。</p><p><code>grunt</code>命令行接口提供了一系列选项。你可以在你的终端中使用<code>grunt -h</code>查看这个选项。</p><h3 id="–help-h"><a href="#–help-h" class="headerlink" title="–help, -h"></a>–help, -h</h3><p>显示帮助信息</p><h3 id="–base-b"><a href="#–base-b" class="headerlink" title="–base, -b"></a>–base, -b</h3><p>指定一个根路径。默认情况下，所有文件路径都是相对于 <code>Gruntfile</code> 的。</p><p>还可以调用 <code>grunt.file.setBase(...)</code></p><h3 id="–no-color"><a href="#–no-color" class="headerlink" title="–no-color"></a>–no-color</h3><p>禁用彩色输出。</p><h3 id="–gruntfile"><a href="#–gruntfile" class="headerlink" title="–gruntfile"></a>–gruntfile</h3><p>指定一个 <code>Gruntfile</code>。</p><p>默认情况下，grunt 会从当前目录或者父目录中寻找最近的 <code>Gruntfile.js</code> 或 <code>Gruntfile.[ext]</code> 文件。</p><h3 id="–debug-d"><a href="#–debug-d" class="headerlink" title="–debug, -d"></a>–debug, -d</h3><p>对支持调试的任务启用调试模式。</p><h3 id="–stack"><a href="#–stack" class="headerlink" title="–stack"></a>–stack</h3><p>因警告或者致命错误退出时打印堆栈跟踪信息。</p><h3 id="–force-f"><a href="#–force-f" class="headerlink" title="–force, -f"></a>–force, -f</h3><p>一种强制跳过警告信息的方式。</p><p>如果像从警告中得到提示，就不要使用这个选项，可以根据提示信息修正代码。</p><h3 id="–tasks"><a href="#–tasks" class="headerlink" title="–tasks"></a>–tasks</h3><p>指定一个包含可加载的任务和“额外”文件的目录。</p><p>还可以调用 <code>grunt.loadTasks(...)</code></p><h3 id="–npm"><a href="#–npm" class="headerlink" title="–npm"></a>–npm</h3><p>在通过 npm 安装的插件中检查可加载的任何任务以及“额外”文件。</p><p>还可以调用 <code>grunt.loadNpmTasks(...)</code></p><h3 id="–no-write"><a href="#–no-write" class="headerlink" title="–no-write"></a>–no-write</h3><p>禁用写文件操作（用于空运行）。</p><h3 id="–verbose-v"><a href="#–verbose-v" class="headerlink" title="–verbose, -v"></a>–verbose, -v</h3><p>冗长模式（Verbose mode）。会输出很多的信息。</p><h3 id="–version-V"><a href="#–version-V" class="headerlink" title="–version, -V"></a>–version, -V</h3><p>打印 grunt 版本。结合 –verbose 一起使用可以获取更多信息。</p><h3 id="–completion"><a href="#–completion" class="headerlink" title="–completion"></a>–completion</h3><p>输出 shell 的自动补全规则。更多信息参考 grunt-cli 相关的文档。</p><h3 id="–require"><a href="#–require" class="headerlink" title="–require"></a>–require</h3><p>如果你使用默认不支持 Grunt 的语言编写 Gruntfile，请首先指定一个要使用的语言解释器。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS关闭鼠标加速</title>
      <link href="/2020/03/29/MacOS%E5%85%B3%E9%97%AD%E9%BC%A0%E6%A0%87%E5%8A%A0%E9%80%9F/"/>
      <url>/2020/03/29/MacOS%E5%85%B3%E9%97%AD%E9%BC%A0%E6%A0%87%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个CS:GO玩家，我一直觉得在MacOS上无法精准控制自己的鼠标。这主要是因为Mac下鼠标默认开启了鼠标加速。假如你在Windows上玩过需要用鼠标精准控制的FPS游戏，你一定会调整鼠标至RAW Input关闭鼠标加速，这就是为什么你会感觉到鼠标在两个平台上表现有所差异。</p><p>为了解决这个问题，我们现在来把MacOS的鼠标加速也关了。网上有很多方法，用terminal之类的，我测试了一下，有的是每次开机都要输（当然你可以自己写个开机就跑的脚本），有的是已经过时了不能在新系统上用了。我来教大家个简单的</p><p>首先我们先到<a href="https://steelseries.com/engine" target="_blank" rel="noopener">赛睿鼠标的驱动下载页</a>，别慌，这跟你用不用赛睿鼠标没关系。我们来到这个页面的最下方，选择Miscellaneous，点开之后，其中有个工具叫做ExactMouse Tool，我们选择下载它。</p><p>你也可以直接用这个<a href="https://downloads.steelseriescdn.com/drivers/tools/steelseries-exactmouse-tool.dmg" target="_blank" rel="noopener">下载链接</a></p><p>下载完之后安装，打开软件，你的屏幕右上角应该会出现一个赛睿图标，这表示安装已完成。看看你的鼠标手感是不是回来了？</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%203.04.03%20PM.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> mac </tag>
            
            <tag> mouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗技MX Master 3简评</title>
      <link href="/2020/03/29/%E7%BD%97%E6%8A%80MX%20Master%203%E7%AE%80%E8%AF%84/"/>
      <url>/2020/03/29/%E7%BD%97%E6%8A%80MX%20Master%203%E7%AE%80%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>我的MX Master第一代在搬家的时候丢失了，我一度很难过。难过倒不是因为它有多好用，还是因为它不便宜。之后我买了个罗技M535，随便用用，觉得手感不行，便将它扔一边积灰了。</p><p>说起来还是因为平日里工作量变大，尽管我是触摸板达人，但是长时间用触摸板在双屏之间划来划去实在是太累了，只好又把积灰的M535捡起来用。可惜这小鼠标的精确度实在太差，用得我好多次想要砸鼠标。没办法，还是决定去买一只新鼠标。看来看去实在没什么可以买的了，最终还是选择了MX Master系列的第三代，就指望着它能有些改进。</p><p>作为罗技MX Master第一代的用户，我对这款鼠标并没有什么好感。或许正是因为它在网上好评如潮，我才会更对它失望，因为它跟我的心理预期实在是差太多了。随便列几个我不喜欢第一代mx master的理由：</p><ol><li>价格昂贵：原价99刀，我在打折期间60刀入手的，但是这个价格仍旧算是非常高昂，因为60刀的游戏鼠标操控性，定位和手感都远远强于MX Master</li><li>定位一般：作为一个CS:GO玩家，鼠标定位的精准与否，几乎是一上手便知。我之前常使用的鼠标是G703，一用MX Master立刻感觉到了手感和定位的降级。我明白它是商务鼠标，有其他侧重点，但是我仍然觉得这部分罗技缩水过多</li><li>机身笨重：假如你习惯抓握鼠标，那这款鼠标更是你的噩梦，它有足足145g。作为一款商务无线鼠标，它竟然完全不便携。可怕的是它不只是宽，它的背部也高高拱起，非常难以携带</li></ol><p>说完了它的缺点，我先暂时不提它的优点了，因为MX Master3几乎完美继承了它所有的优点。</p><p>现在买到了MX Master 3，真的让我庆幸，还好我当时把那旧的MX Master丢了，要不然现在我绝对不会去买这只新的。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/8739F928-F1CC-4175-8215-F3D0171BAAE9_1_105_c.jpeg"  alt=""></p><p>我买的是灰白色的版本。拆开包装之后一共三个物品，一个是鼠标本体，一个是信号接收的USB头，最后是一根usb-c的充电器。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/E8F71A26-CC1B-4F37-8993-2FD088766C34_1_105_c.jpeg"  alt=""></p><p>这里就要说到它的第一个优点：它是用type-c接口充电的。作为一个电子产品大户，我衷心希望所有的电子产品都统一接口，不要搞花里胡哨的玩意，不然插座上得插满不同种类的充电线。我上次买的打碟机还是mini-USB接口，让我瞬间以为回到初中。mini-USB接口的设备我都不知道埋了几年了，咋还能有厂商在用呢？</p><p>MX Master 3本身是支持蓝牙连接的，也就是说无需USB头就能连上你的电脑。用USB头的话延迟更低，反应更灵敏。其实个人单纯认为这个是没多大意义的，有低延迟需求的人估计都是打游戏的，没人会用你打游戏啊兄弟。不过有总比没有强。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/A01C1E91-35FD-460A-98C7-80B1E8D07137_1_105_c.jpeg"  alt=""></p><p>鼠标背面贴了个简单的说明书，就是告诉你MX Master 3支持同时匹配三台设备。没用过的兄弟可能不了解，这只鼠标长按可以进行匹配电脑，然后短按可以切换连接的电脑。一般来说我们蓝牙只能连一台设备，想连接第二台的话需要重新匹配，第一台和鼠标的连接就会断开，想要再连回去的时候需要重新匹配。而这只鼠标则不需要，只需要在2号位3号位匹配其他机器就行了，要用的时候可以在机器之间切换来切换去。这也是从第一代就有的优点。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/3A54E2AC-64EA-45FF-A6D6-75EB41D3D179_1_201_a.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/09683B04-976B-4EBC-992B-3BDAF1E147D2_1_102_o.jpeg"  alt=""></p><p>刚才也说过了，这只鼠标的体积很大，适合大手选手。这是它跟G703放在一起的时候的体积对比。</p><p>罗技商务键鼠系列用的软件都是Logi Options，你从设置界面上就能看到所有的自定义按键</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%2012.54.15%20AM.png"  alt=""></p><p>这里我要介绍一下罗技的自定义按键了，重头戏是最左边那块扁平的按键，它是个向下按压的按键。在我们的日常使用中，你的大拇指会放在这个按键上。我们暂时称这个按键为按键A。它支持手势操作，你可以设置的鼠标宏有，按下A后的鼠标宏，和按下A以后上/下/左/右移动鼠标后引发的鼠标宏。</p><p>这个按键在MX Master第一代中的体验并不是十分理想，其一是MX Master整体手感较重，其二是一代的A键比较重，大拇指按下去需要发点力，久而久之手就容易累。三代我整体使用下来觉得这个按键还行，主要还是因为你不再需要用力去按它了。用A键，你可以轻松的在Mac的多窗口之间滑动，操作多任务，打开launch pad。A键的手势操作可以说是鼠标中少有的。</p><p>第二个需要强调的键是图左俯视图中滚轮下方的按键。这个按键的默认设定是SmartShift切换。首先要说明下什么是SmartShift：从第一代开始，MX Master就有电磁滚轮，它的滚轮相当与众不同。我们日常见到的鼠标滚轮，一般分为两类，一类是滚动很流畅的滚轮，你一滚可以滚老远的，在看长篇大论的时候很方便；另一类是有强烈阻力的滚轮，你在滚动的时候会有类似被齿轮卡住的阻塞感，它能帮助你精准定位。MX Master的电磁滚轮可以让你两者都有（我全都要.jpg），而且提供了SmartShift。只要开启了这个功能，你就能在用力推滚轮的时候进入流畅模式，慢慢推滚轮的时候进入齿轮模式。这个滚轮下方的按键，默认控制着smartshift的开关。</p><p>第三代的金属滚轮相较前几代体验更好了，没有了第一代电磁滚轮的生硬，在阻塞模式的时候略微平滑了一些。它的滚动速度比普通鼠标能高出90%，而在精准度上能比第二代MX更精准87%。但是，我不知道是Mac平台的缘故还是罗技适配的缘故，我在Mac上慢速滑动滚轮的时候会有滚动速度不确定的情况。就是我以相同的慢速滑，有的时候快，有的时候慢，导致我无法准确定位。</p><p>其他键我就不多说了，基本都是单击键，设置返回前进，tab之间切换什么的，你可以自定义。罗技还帮你做了一些软件适配，在部分软件中（例如office，PS）有预设鼠标宏。</p><p>我有一个强烈推荐的自定义，就是将中间的滚轮绑定为look up，也就是mac自带的查字典。对着不会的词，一向下按鼠标中键，直接就帮你查了。相信我，绑定了查字典，看document你的效率会直线飞升。</p><p>Logi Option还有一个很人性化的设置就是你能在Logitech自己的界面更改滚轮滚动模式。你可以单独为它选择标准模式或自然模式。大家都知道苹果全系列的触控都是自然模式的触控，这实际上和微软系列的产品都是相反的。微软的触控模式被称为标准（双指向下滑动是让页面向下走，滚轮向下滚是让页面向下翻），而苹果的触控模式被称为自然。但我们假如习惯使用了智能手机，你就会习惯自然模式的触控板思维。可又由于你常年在微软系统下使用鼠标，你的滚轮思维还是标准思维。</p><p>苹果系统允许你切换自然或标准滚动，可是一切，你的触控板和鼠标滚轮会同时被改变。Logi Options就解决了这个问题，你能继续在触控板上使用自然触控，同时你能在鼠标上使用标准滚轮。（我全都要.jpg x 2）</p><p>大概介绍完了鼠标，我来做个使用后的使用体验</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>更轻</p><p>从数字上来看，MX Master 3并没有比一代轻多少（3代是141g，一代145g），但是整体握感却有明显提升。你会感觉这只鼠标变轻了。你可能会奇怪，才少了3g咋能变轻？或许这就是人体工学的魅力吧……（尽管滚轮变成金属的了）当然这都是我的猜测，毕竟我的第一代已经丢了……</p></li><li><p>金属滚轮体验很好</p><p>能随意在快速和慢速间切换的滚轮为阅读长文的你提供了方便</p></li><li><p>更精准，4000DPI下DarkField追踪技术传感器，高分辨率也无所畏惧</p></li><li><p>抓握感更好</p></li><li><p>续航时间长</p></li><li><p>能同时连接三台电脑，还有USB连接头</p></li><li><p>自定义扩展能力强</p></li><li><p>材质舒适</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>体积大，不适合小手</li><li>侧部的滚轮比较鸡肋，滚动速度过低</li><li>价格不菲，100刀+，目前折扣最低价也要90刀</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>买！</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> review </tag>
            
            <tag> mouse </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS下bash&amp;zsh切换与升级</title>
      <link href="/2020/03/26/MacOS%E4%B8%8Bbash&amp;zsh%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8D%87%E7%BA%A7/"/>
      <url>/2020/03/26/MacOS%E4%B8%8Bbash&amp;zsh%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>zsh和bash都是shell，linux默认是bash，现在macOS最新版的系统Catalina默认是zsh。很多小伙伴可能想在Mac中切换bash到zsh，或者zsh到bash</p><h2 id="切换系统默认shell"><a href="#切换系统默认shell" class="headerlink" title="切换系统默认shell"></a>切换系统默认shell</h2><ul><li>从bash切换到zsh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>输入密码成功切换，重启终端即可使用 zsh</p><ul><li>从zsh切换到bash</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /bin/bash</span><br></pre></td></tr></table></figure><p>重启终端即可。</p><p>还有一种方法是在左上角苹果-&gt;System Preference-&gt; Users &amp; Groups -&gt; 用密码解锁左下角高级设置 -&gt; 右键用户 -&gt; 在login shell选择bash</p><p>bash 的环境变量是<code>.bash_profile</code>文件。<br> zsh 的环境变量是<code>.zshrc</code>文件。</p><p>PS：如果从 bash 切换到 zsh，但想保留 bash 所设置的环境变量，可在 <code>.zshrc</code>文件末尾添加 <code>source ~/.bash_profile</code> 保存退出，并重启终端即可使用 bash 的环境变量</p><h3 id="关闭bash已过时提示"><a href="#关闭bash已过时提示" class="headerlink" title="关闭bash已过时提示"></a>关闭bash已过时提示</h3><p><strong>假如你还要继续后面的bash升级，你可以无视这一节，更新完bash提示自然会消失</strong></p><p>你在切换到bash之后，会不断收到terminal提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The default interactive shell is now zsh.</span><br><span class="line"></span><br><span class="line">To update your account to use zsh, please run `chsh -s /bin/zsh`.</span><br></pre></td></tr></table></figure><p>这就是苹果想让你去用默认的zsh。这倒也不奇怪，你放个旧版bash在这里，当然希望大家都去用新版zsh。假如你想关闭这条提示，你可以修改<code>.bash_profile</code>，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>然后向其中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> macOS Catalina</span></span><br><span class="line"></span><br><span class="line">export BASH_SILENCE_DEPRECATION_WARNING=1</span><br></pre></td></tr></table></figure><p>随后esc，输入wq，保存退出。重新打开就不会有警告了</p><h2 id="升级MacOS-bash"><a href="#升级MacOS-bash" class="headerlink" title="升级MacOS bash"></a>升级MacOS bash</h2><p>可能你是个复古派，或者你跟我一样懒得自己配环境（公司里的脚本都是按bash写的有没有！zsh改来改去很麻烦！）这时候你就需要转回bash</p><p>但是MacOS的bash版本不能更低了。MacOS上zsh是最新版，但bash却是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash --version</span><br><span class="line">GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin19)</span><br><span class="line">Copyright (C) 2007 Free Software Foundation, Inc.</span><br></pre></td></tr></table></figure><p>我滴个龟龟，这版本是刚从土里掘出来的吧？可能苹果公司很有匠人精神，还在打磨这款经典bash。但是我不是匠人，我要升级。我们直接通过homebrew安装最新版bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install bash</span><br></pre></td></tr></table></figure><p>这时候我们查看一下安装成功了没有，然后发现系统里有俩bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> -a bash</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/bash</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>这时候因为<code>/usr/local/bin/bash</code>是默认路径，假如你重启terminal你会发现你已经变成了新版bash。不过这还没完，unix系统会有安全权限等问题，我们需要把新安装的bash加入白名单，让它能成为login shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/shells</span><br></pre></td></tr></table></figure><p>之后再这个文件的底部加上<code>/usr/local/bin/bash</code>，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;csh</span><br><span class="line">&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>最后我们将新shell设置为默认login shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /usr/<span class="built_in">local</span>/bin/bash</span><br></pre></td></tr></table></figure><p>以上命令只会更改你一个人的默认shell，加入你想更改所有人的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chsh -s /usr/<span class="built_in">local</span>/bin/bash</span><br></pre></td></tr></table></figure><p>查看下自己现在的bash版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$BASH_VERSION</span></span><br><span class="line"></span><br><span class="line">5.0.16(1)-release</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> shell </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac多Java版本管理</title>
      <link href="/2020/03/26/Mac%E5%A4%9AJava%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/26/Mac%E5%A4%9AJava%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先你需要有homebrew，这种Mac必备的工具怎么装就不提了，官网上有，就一行terminal命令的事。</p><p>然后要安装多个版本的Java。这个时候你假如使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install java</span><br></pre></td></tr></table></figure><p>那么homebrew会自动给你安装最新版本的JDK。但是我们平常开发一般用的都是JDK8，旧版JDK的安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ brew tap adoptopenjdk/openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挑一个就行了啊，adoptopenjdk8就是JDK8，要用哪个装哪个，虽然都装了也没事</span></span><br><span class="line">$ brew cask install adoptopenjdk8</span><br><span class="line">$ brew cask install adoptopenjdk9</span><br><span class="line">$ brew cask install adoptopenjdk10</span><br><span class="line">$ brew cask install adoptopenjdk11</span><br></pre></td></tr></table></figure><p>之后为了管理多版本，我们安装jenv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install jenv</span><br></pre></td></tr></table></figure><p>安装之后将环境写到.bash_profile中（<strong>假如你系统版本为Catalina或以上，那么你应该把它写到.zshrc文件中，请把以下两行的.bash_profile都改成.zshrc）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.jenv/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><p>这个时候我们查看下已有的Java版本，会发现只有系统默认的Java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jenv versions</span><br><span class="line"></span><br><span class="line">* system (<span class="built_in">set</span> by /Users/tty/.jenv/version)</span><br></pre></td></tr></table></figure><p>接下来我们需要把我们安装的其他版本的java给加进去，这个时候就需要找到homebrew的java安装路径了。</p><p>一般来说你可以在 <code>/Library/Java/JavaVirtualMachines/</code>下找到你有的Java，比如我的JDK8是<code>/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/</code>，随后你要一直深入直到看到home文件夹，将它用以下命令放入jenv库里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jenv add /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/</span><br><span class="line"></span><br><span class="line">openjdk64-1.8.0.242 added</span><br><span class="line">1.8.0.242 added</span><br><span class="line">1.8 added</span><br></pre></td></tr></table></figure><p>It’s better to rehash to tell jenv to look for all know binaries and create necessary shims</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jenv <span class="built_in">rehash</span></span><br></pre></td></tr></table></figure><p>此时再次查看系统内Java版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jenv versions</span><br><span class="line">* system (<span class="built_in">set</span> by /Users/tty/.jenv/version)</span><br><span class="line">  1.8</span><br><span class="line">  1.8.0.242</span><br><span class="line">  openjdk64-1.8.0.242</span><br></pre></td></tr></table></figure><p>选一个版本然后运行<code>jenv global</code>命令，比如我用的1.8，就能把global变量给切到1.8版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jenv global 1.8</span><br><span class="line">$ java -version</span><br><span class="line">openjdk version <span class="string">"1.8.0_242"</span></span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_242-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.242-b08, mixed mode)</span><br></pre></td></tr></table></figure><p>输入<code>jenv -h</code>查看帮助，还有切换本地Java版本等功能</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> mac </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS测试教程</title>
      <link href="/2020/03/26/JS%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/26/JS%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源：<a href="https://javascript.ruanyifeng.com/tool/testing.html" target="_blank" rel="noopener">阮一峰</a></p><h2 id="为什么要写测试？"><a href="#为什么要写测试？" class="headerlink" title="为什么要写测试？"></a>为什么要写测试？</h2><p>Web应用程序越来越复杂，这意味着有更多的可能出错。测试是帮助我们提高代码质量、降低错误的最好方法和工具之一。</p><ul><li>测试可以确保得到预期结果。</li><li>加快开发速度。</li><li>方便维护。</li><li>提供用法的文档。</li></ul><p>通过测试提供软件的质量，在开始的时候，可能会降低开发速度。但是从长期看，尤其是那种代码需要长期维护、不断开发的情况，测试会大大加快开发速度，减轻维护难度。</p><h2 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试（unit testing）指的是以软件的单元（unit）为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或组件。它的基本特征就是，只要输入不变，必定返回同样的输出。</p><p>“单元测试”这个词，本身就暗示，软件应该以模块化结构存在。每个模块的运作，是独立于其他模块的。一个软件越容易写单元测试，往往暗示着它的模块化结构越好，各模块之间的耦合就越弱；越难写单元测试，或者每次单元测试，不得不模拟大量的外部条件，很可能暗示软件的模块化结构越差，模块之间存在较强的耦合。</p><p>单元测试的要求是，每个模块都必须有单元测试，而软件由模块组成。</p><p>单元测试通常采取断言（assertion）的形式，也就是测试某个功能的返回结果，是否与预期结果一致。如果与预期不一致，就表示测试失败。</p><p>单元测试是函数正常工作、不出错的最基本、最有效的方法之一。 每一个单元测试发出一个特定的输入到所要测试的函数，看看函数是否返回预期的输出，或者采取了预期的行动。单元测试证明了所测试的代码行为符合预期。</p><p>单元测试有助于代码的模块化，因此有助于长期的重用。因为有了测试，你就知道代码是可靠的，可以按照预期运行。从这个角度说，测试可以节省开发时间。单元测试的另一个好处是，有了测试，就等于就有了代码功能的文档，有助于其他开发者了解代码的意图。</p><p>单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。</p><p>一般来说，单元测试的步骤如下。</p><ul><li>准备所有的测试条件</li><li>调用（触发）所要测试的函数</li><li>验证运行结果是否正确</li><li>还原被修改的记录</li></ul><h3 id="其他测试类型"><a href="#其他测试类型" class="headerlink" title="其他测试类型"></a>其他测试类型</h3><p>（1）集成测试</p><p>集成测试（Integration test）指的是多个部分在一起测试，比如测试一个数据库连接模块，是否能够连接数据库。</p><p>（2）功能测试</p><p>功能测试（Functional test）指的是，自动测试整个应用程序的某个功能，比如使用Selenium工具自动打开浏览器运行程序。</p><p>（3）端对端测试</p><p>端对端测试（End-to-End testing）指的是全链路测试，即从开始端到终止端的测试，比如测试从用户界面、通过网络、经过应用程序处理、到达数据库，是否能够返回正确结果。端对端测试的目的是，确保整个系统能够正常运行，各个子系统之间依赖关系正常，数据能够在子系统之间、模块之间正确传递。</p><p>（4）冒烟测试</p><p>冒烟测试（smoke testing）指的是，正式的全面测试开始之前，对主要功能进行的预测试。它的主要目的是，确认主要功能能否满足需要，软件是否能运行。冒烟测试可以是手工测试，也可以是自动化测试。</p><p>这个名字最早来自对电子元件的测试，第一次对电子元件通电，看看它是否会冒烟。如果没有冒烟，说明通过了测试；如果电流达到某个临界点之后，才出现冒烟，这时可以评估是否能够接受这个临界点。</p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。</p><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD是“测试驱动的开发”（Test-Driven Development）的简称，指的是先写好测试，然后再根据测试完成开发。使用这种开发方式，会有很高的测试覆盖率。</p><p>TDD的开发步骤如下。</p><ul><li>先写一个测试。</li><li>写出最小数量的代码，使其能够通过测试。</li><li>优化代码。</li><li>重复前面三步。</li></ul><p>TDD开发的测试覆盖率通常在90%以上，这意味着维护代码和新增特性会非常容易。因为测试保证了你可以信任这些代码，修改它们不会破坏其他代码的运行。</p><p>TDD接口提供以下四个方法。</p><ul><li>suite()</li><li>test()</li><li>setup()</li><li>teardown()</li></ul><p>下面代码是测试计数器是否加1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">suite(<span class="string">'Counter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test(<span class="string">'tick increases count to 1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    counter.tick();</span><br><span class="line">    assert.equal(counter.count, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。</p><p>BDD认为，<strong>不应该针对代码的实现细节写测试，而是要针对行为写测试</strong>。BDD测试的是行为，即软件应该怎样运行。</p><p>BDD接口提供以下六个方法。</p><ul><li>describe()</li><li>it()</li><li>before()</li><li>after()</li><li>beforeEach()</li><li>afterEach()</li></ul><p>下面是测试计数器是否加1的BDD写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Counter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should increase count by 1 after calling tick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    <span class="keyword">var</span> expectedCount = counter.count + <span class="number">1</span>;</span><br><span class="line">    counter.tick();</span><br><span class="line">    assert.equal(counter.count, expectedCount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是一个BDD开发的示例。现在，需要开发一个<code>Foo</code>类，该类的实例有一个<code>sayHi</code>方法，会对类参数说“Hi”。这就是<code>Foo</code>类的规格，根据这个规格，我们可以写出测试用例文件<code>foo.spec.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Simple object'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="keyword">new</span> Foo(<span class="string">'John'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should say hi'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(foo.sayHi()).toEqual(<span class="string">'John says hi!'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有了测试用例以后，我们再写出实际的脚本文件<code>foo.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' says hi!'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了把测试用例与脚本文件分开，我们通常把测试用例放在<code>test</code>子目录之中。然后，我们就可以使用Mocha、Jasmine等测试框架，执行测试用例，看看脚本文件是否通过测试。</p><h3 id="BDD术语"><a href="#BDD术语" class="headerlink" title="BDD术语"></a>BDD术语</h3><p>（1）测试套件</p><p>测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。</p><p>测试套件由一个<code>describe</code>函数构成，它接受两个参数：第一个参数是字符串，表示测试套件的名字或标题，表示将要测试什么；第二个参数是函数，用来实现这个测试套件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"A suite"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（2）测试用例</p><p>测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。测试用例由<code>it</code>函数构成，它与<code>describe</code>函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"A suite"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"contains spec with an expectation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（3）断言</p><p>断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。</p><p>断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为<code>true</code>，测试用例才会通过。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"A suite"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"contains spec with an expectation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(<span class="literal">true</span>).toBe(<span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言是判断实际值与预期值是否相等的工具。</p><p>断言有assert、expect、should三种风格，或者称为三种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assert风格</span></span><br><span class="line">assert.equal(event.detail.item, <span class="string">'(item)‘);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// expect风格</span></span><br><span class="line"><span class="string">expect(event.detail.item).to.equal('</span>(item)<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// should风格</span></span><br><span class="line"><span class="string">event.detail.item.should.equal('</span>(item)<span class="string">');</span></span><br></pre></td></tr></table></figure><p>Chai.js是一个很流行的断言库，同时支持上面三种风格。</p><p>（1） assert风格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'chai'</span>).assert;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> beverages = &#123; <span class="attr">tea</span>: [ <span class="string">'chai'</span>, <span class="string">'matcha'</span>, <span class="string">'oolong'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">assert.typeOf(foo, <span class="string">'string'</span>, <span class="string">'foo is a string'</span>);</span><br><span class="line">assert.equal(foo, <span class="string">'bar'</span>, <span class="string">'foo equal `bar`'</span>);</span><br><span class="line">assert.lengthOf(foo, <span class="number">3</span>, <span class="string">'foo`s value has a length of 3'</span>);</span><br><span class="line">assert.lengthOf(beverages.tea, <span class="number">3</span>, <span class="string">'beverages has 3 types of tea'</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，assert方法的最后一个参数是错误提示信息，只有测试没有通过时，才会显示。</p><p>（2）expect风格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> beverages = &#123; <span class="attr">tea</span>: [ <span class="string">'chai'</span>, <span class="string">'matcha'</span>, <span class="string">'oolong'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">expect(foo).to.be.a(<span class="string">'string'</span>);</span><br><span class="line">expect(foo).to.equal(<span class="string">'bar'</span>);</span><br><span class="line">expect(foo).to.have.length(<span class="number">3</span>);</span><br><span class="line">expect(beverages).to.have.property(<span class="string">'tea'</span>).with.length(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>（3）should风格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'chai'</span>).should();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> beverages = &#123; <span class="attr">tea</span>: [ <span class="string">'chai'</span>, <span class="string">'matcha'</span>, <span class="string">'oolong'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">foo.should.be.a(<span class="string">'string'</span>);</span><br><span class="line">foo.should.equal(<span class="string">'bar'</span>);</span><br><span class="line">foo.should.have.length(<span class="number">3</span>);</span><br><span class="line">beverages.should.have.property(<span class="string">'tea'</span>).with.length(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Mocha-js"><a href="#Mocha-js" class="headerlink" title="Mocha.js"></a>Mocha.js</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Mocha（发音“摩卡”）是现在最流行的前端测试框架之一，此外常用的测试框架还有<a href="https://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>、<a href="https://github.com/substack/tape/" target="_blank" rel="noopener">Tape</a>、<a href="https://github.com/defunctzombie/zuul/" target="_blank" rel="noopener">zuul</a>等。所谓“测试框架”，就是运行测试的工具。</p><p>Mocha使用下面的命令安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装</span><br><span class="line">$ npm install -g mocha chai</span><br><span class="line"></span><br><span class="line"># 项目内安装</span><br><span class="line">$ npm i -D mocha chai</span><br></pre></td></tr></table></figure><p>上面代码中，除了安装Mocha以外，还安装了断言库<code>chai</code>，这是因为Mocha自身不带断言库，必须安装外部断言库。</p><p>测试套件文件一般放在<code>test</code>子目录下面，配置文件<code>mocha.opts</code>也放在这个目录里面。</p><h3 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h3><p>使用浏览器测试时，先用<code>mocha init</code>命令在指定目录生成初始化文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha init &lt;path&gt;</span><br></pre></td></tr></table></figure><p>运行上面命令，就会在该目录下生成一个<code>index.html</code>文件，以及配套的脚本和样式表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Unit.js tests <span class="keyword">in</span> the browser <span class="keyword">with</span> Mocha&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;meta http-equiv="Content-Type" content="text/</span>html; charset=UTF<span class="number">-8</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="</span>viewport<span class="string">" content="</span>width=device-width, initial-scale=<span class="number">1.0</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" href="</span>mocha.css<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Unit.js tests in the browser with Mocha&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>mocha<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>mocha.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">      mocha.setup('bdd');</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>tests.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">      mocha.run();</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>然后在该文件中，加入你要测试的文件（比如<code>app.js</code>）、测试脚本（<code>app.spec.js</code>）和断言库（<code>chai.js</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"app.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/chaijs.com/</span>chai.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>app.spec.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>各个文件的内容如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.spec.js</span></span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试add函数'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1加1应该等于2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="命令行测试"><a href="#命令行测试" class="headerlink" title="命令行测试"></a>命令行测试</h3><p>Mocha除了在浏览器运行，还可以在命令行运行。</p><p>还是使用上面的文件，作为例子，但是要改成CommonJS格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.spec.js</span></span><br><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试add函数'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1加1应该等于2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，在命令行下执行<code>mocha</code>，就会执行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br></pre></td></tr></table></figure><p>上面的命令等同于下面的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha <span class="built_in">test</span> --reporter spec --recursive --growl</span><br></pre></td></tr></table></figure><h3 id="mocha-opts"><a href="#mocha-opts" class="headerlink" title="mocha.opts"></a>mocha.opts</h3><p>所有Mocha的命令行参数，都可以写在<code>test</code>目录下的配置文件<code>mocha.opts</code>之中。</p><p>下面是一个典型的配置文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--reporter</span> <span class="string">spec</span></span><br><span class="line"><span class="attr">--recursive</span></span><br><span class="line"><span class="attr">--growl</span></span><br></pre></td></tr></table></figure><p>上面三个设置的含义如下。</p><ul><li>使用spec报告模板</li><li>包括子目录</li><li>打开桌面通知插件growl</li></ul><p>如果希望测试非存放于test子目录的测试用例，可以在<code>mocha.opts</code>写入以下内容。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-tests</span></span><br><span class="line"><span class="attr">--recursive</span></span><br></pre></td></tr></table></figure><p>上面代码指定运行<code>server-tests</code>目录及其子目录之中的测试脚本。</p><h3 id="生成规格文件"><a href="#生成规格文件" class="headerlink" title="生成规格文件"></a>生成规格文件</h3><p>Mocha支持从测试用例生成规格文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha <span class="built_in">test</span>/app.spec.js -R markdown &gt; spec.md</span><br></pre></td></tr></table></figure><p>上面命令生成单个<code>app.spec.js</code>规格。</p><p>生成HTML格式的报告，使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha <span class="built_in">test</span>/app.spec.js -R doc &gt; spec.html</span><br></pre></td></tr></table></figure><p>如果要生成整个<code>test</code>目录，对应的规格文件，使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha <span class="built_in">test</span> -R markdown &gt; spec.md --recursive</span><br></pre></td></tr></table></figure><p>只要提供测试脚本的路径，Mocha就可以运行这个测试脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -w src/index.test.js</span><br></pre></td></tr></table></figure><p>上面命令运行测试脚本<code>src/index.test.js</code>，参数<code>-w</code>表示watch，即当这个脚本一有变动，就会运行。</p><p>指定测试脚本时，可以使用通配符，同时指定多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporter spec spec/&#123;my,awesome&#125;.js</span><br><span class="line">$ mocha --ui tdd <span class="built_in">test</span>/unit/*.js etc</span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>--reporter</code>指定生成的报告格式（上面代码是spec格式），<code>-ui</code>指定采用哪一种测试模式（上面代码是tdd模式）。</p><p>除了使用shell通配符，还可以使用node通配符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers js:babel-core/register <span class="string">'test/**/*.@(js|jsx)'</span></span><br></pre></td></tr></table></figure><p>上面代码指定运行<code>test</code>目录下面任何子目录中，文件后缀名为<code>js</code>或<code>jsx</code>的测试脚本。注意，Node的通配符要放在单引号之中，因为否则星号（<code>*</code>）会先被shell解释。</p><p>如果要改用shell通配符，执行<code>test</code>目录下面任何子目录的测试脚本，要写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha <span class="built_in">test</span>/**.js</span><br></pre></td></tr></table></figure><p>如果测试脚本不止一个，最好将它们放在专门的目录当中。Mocha默认执行<code>test</code>目录的测试脚本，所以可以将所有测试脚本放在<code>test</code>子目录。<code>--recursive</code>参数可以指定运行子目录之中的测试脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --recursive</span><br></pre></td></tr></table></figure><p>上面命令会运行<code>test</code>子目录之中的所有测试脚本。</p><p><code>--grep</code>参数用于搜索测试用例的名称（即it方法的第一个参数），然后只执行匹配的测试用例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporter spec --grep <span class="string">"Fnord:"</span> server-test/*.js</span><br></pre></td></tr></table></figure><p>上面代码只测试名称中包含“Fnord：”的测试用例。</p><p><code>--invert</code>参数表示只运行不符合条件的测试脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --grep auth --invert</span><br></pre></td></tr></table></figure><p>如果测试脚本用到了ES6语法，还需要用<code>--compiler</code>参数指定babel进行转码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers js:babel/register --recursive</span><br></pre></td></tr></table></figure><p>上面命令会在运行测试脚本之前，先用Babel进行转码。<code>--compilers</code>参数的值是用冒号分隔的一个字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用<code>babel/register</code>模块，处理一下JS文件。</p><p><code>--require</code>参数指定测试脚本默认包含的文件。下面是一个<code>test_helper.js</code>文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/test_helper.js</span></span><br><span class="line"><span class="keyword">import</span> chai <span class="keyword">from</span> <span class="string">'chai'</span>;</span><br></pre></td></tr></table></figure><p>使用<code>--require</code>参数，将上面这个脚本包含进所有测试脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers js:babel/register --require ./<span class="built_in">test</span>/test_helper.js  --recursive</span><br></pre></td></tr></table></figure><h3 id="测试脚本的写法"><a href="#测试脚本的写法" class="headerlink" title="测试脚本的写法"></a>测试脚本的写法</h3><p>测试脚本中，describe方法和it方法都允许调用only方法，表示只运行某个测试套件或测试用例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe.only(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">describe(<span class="string">"using only"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it.only(<span class="string">"this is the only test to be run"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"this is not run"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只有带有<code>only</code>方法的测试套件或测试用例会运行。</p><p>describe方法和it方法还可以调用skip方法，表示跳过指定的测试套件或测试用例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">describe.skip(<span class="string">'Article'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">describe(<span class="string">"using only"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it.skip(<span class="string">"this is the only test to be run"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"this is not run"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，带有<code>skip</code>方法的测试套件或测试用例会被忽略。</p><p>如果测试用例包含异步操作，可以done方法显式指定测试用例的运行结束时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'logs a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'logs a'</span>);</span><br><span class="line">    done();</span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(f, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，正常情况下，函数f还没有执行，Mocha就已经结束运行了。为了保证Mocha等到测试用例跑完再结束运行，可以手动调用done方法</p><h2 id="Promise的测试"><a href="#Promise的测试" class="headerlink" title="Promise的测试"></a>Promise的测试</h2><p>对于异步的测试，测试用例之中，通常必须调用<code>done</code>方法，显式表明异步操作的结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should do something with promises'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = asyncTest();</span><br><span class="line"></span><br><span class="line">  result.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    expect(data).to.equal(<span class="string">'foobar'</span>);</span><br><span class="line">    done();</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    assert.fail(error);</span><br><span class="line">    done();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码之中，Promise对象的<code>then</code>方法之中，必须指定<code>reject</code>时的回调函数，并且使用<code>assert.fail</code>方法抛出错误，否则这个错误就不会被外界感知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  expect(data).to.equal(blah);</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码之中，如果Promise被<code>reject</code>，是不会被捕获的，因为Promise之中的错误，不会”泄漏“到外界。</p><p>Mocha内置了对Promise的支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should fail the test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'Promise被reject'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，Mocha能够捕获<code>reject</code>的Promise。</p><p>因此，使用Mocha时，Promise的测试可以简化成下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should do something with promises'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = asyncTest();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    expect(data).to.equal(<span class="string">'foobar'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h2><p>单元测试时，很多时候，测试的代码会请求HTTP服务器。这时，我们就需要模拟服务器的回应，不能在单元测试时去请求真实服务器数据，否则就不叫单元测试了，而是连同服务器一起测试了。</p><p>一些工具库可以模拟服务器回应。</p><ul><li><a href="https://github.com/pgte/nock" target="_blank" rel="noopener">nock</a></li><li><a href="http://sinonjs.org/docs/#server" target="_blank" rel="noopener">sinon</a></li><li><a href="https://github.com/algolia/faux-jax" target="_blank" rel="noopener">faux-jax</a></li><li><a href="https://github.com/moll/node-mitm" target="_blank" rel="noopener">MITM</a></li></ul><h2 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h2><p>测试的覆盖率需要安装istanbul模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D istanbul</span><br></pre></td></tr></table></figure><p>然后，在package.json设置运行覆盖率检查的命令。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test:cover": "istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js",</span><br><span class="line">  "check-coverage": "istanbul check-coverage --statements 100 --branches 100 --functions 100 --lines 100"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>test:cover</code>是生成覆盖率报告，<code>check-coverage</code>是设置覆盖率通过的门槛。</p><p>然后，将<code>coverage</code>目录写入<code>.gitignore</code>防止连这个目录一起提交。</p><p>如果希望在<code>git commit</code>提交之前，先运行一次测试，可以安装ghooks模块，配置<code>pre-commit</code>钩子。</p><p>安装ghooks。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D ghooks</span><br></pre></td></tr></table></figure><p>在package.json之中，配置<code>pre-commit</code>钩子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"config": &#123;</span><br><span class="line">  "ghooks": &#123;</span><br><span class="line">    "pre-commit": "npm run test:cover &amp;&amp; npm run check-coverage"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以把覆盖率检查，加入<code>.travis.yml</code>文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:cover</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">check-coverage</span></span><br></pre></td></tr></table></figure><p>如果测试脚本使用ES6，<code>scripts</code>字段还需要加入Babel转码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "mocha src/index.test.js -w --compilers js:babel/register",</span><br><span class="line">  "test:cover": "istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js --compilers js:babel/register"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖率报告可以上传到<a href="https://codecov.io/" target="_blank" rel="noopener">codecov.io</a>。先安装这个模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D codecov.io</span><br></pre></td></tr></table></figure><p>然后在package.json增加一个字段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "report-coverage": "cat ./coverage/lcov.info | codecov"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在CI的配置文件<code>.travis.yml</code>之中，增加运行这个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after_success:</span><br><span class="line">  - npm run report-coverage</span><br><span class="line">  - npm run semantic-release</span><br></pre></td></tr></table></figure><h2 id="WebDriver"><a href="#WebDriver" class="headerlink" title="WebDriver"></a>WebDriver</h2><p>WebDriver是一个浏览器的自动化框架。它在各种浏览器的基础上，提供一个统一接口，将接收到的指令转为浏览器的原生指令，驱动浏览器。</p><p>WebDriver由Selenium项目演变而来。Selenium是一个测试自动化框架，它的1.0版叫做Selenium RC，通过一个代理服务器，将测试脚本转为JavaScript脚本，注入不同的浏览器，再由浏览器执行这些脚本后返回结果。WebDriver就是Selenium 2.0，它对每个浏览器提供一个驱动，测试脚本通过驱动转换为浏览器原生命令，在浏览器中执行。</p><h3 id="定制测试环境"><a href="#定制测试环境" class="headerlink" title="定制测试环境"></a>定制测试环境</h3><p>DesiredCapabilities对象用于定制测试环境。</p><ul><li>定制DesiredCapabilities对象的各个属性</li><li>创建DesiredCapabilities实例</li><li>将DesiredCapabilities实例作为参数，新建一个WebDriver实例</li></ul><h3 id="操作浏览器的方法"><a href="#操作浏览器的方法" class="headerlink" title="操作浏览器的方法"></a>操作浏览器的方法</h3><p>WebDriver提供以下方法操作浏览器。</p><p>close()：退出或关闭当前浏览器窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.close();</span><br></pre></td></tr></table></figure><p>quit()：关闭所有浏览器窗口，中止当前浏览器driver和session。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.quit();</span><br></pre></td></tr></table></figure><p>getTitle()：返回当前网页的标题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.getTitle();</span><br></pre></td></tr></table></figure><p>getCurrentUrl()：返回当前网页的网址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.getCurrentUrl();</span><br></pre></td></tr></table></figure><p>getPageSource()：返回当前网页的源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断言是否含有指定文本</span></span><br><span class="line">assert(driver.getPageSource().contains(<span class="string">"Hello World"</span>),</span><br><span class="line">  <span class="string">"预期含有文本Hello World"</span>);</span><br></pre></td></tr></table></figure><p>click()：模拟鼠标点击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>))</span><br><span class="line">  .click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"webDriver"</span>);</span><br><span class="line">driver.findElement(By.id(<span class="string">"sblsbb"</span>))</span><br><span class="line">  .click();</span><br></pre></td></tr></table></figure><p>clear()：清空文本输入框。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>)).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"webDriver"</span>);</span><br><span class="line">driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .clear();</span><br><span class="line">driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"testing"</span>);</span><br></pre></td></tr></table></figure><p>sendKeys()：在文本输入框输入文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"your text"</span>);</span><br></pre></td></tr></table></figure><p>submit()：提交表单，或者用来模拟按下回车键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>))</span><br><span class="line">  .submit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"webdriver"</span>);</span><br><span class="line">element.submit();</span><br></pre></td></tr></table></figure><p>findElement()：返回选中的第一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.id(<span class="string">"lst-ib"</span>));</span><br></pre></td></tr></table></figure><p>findElements()：返回选中的所有元素（0个或多个）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">driver.findElement(By.id(<span class="string">"searchbox"</span>))</span><br><span class="line">  .sendKeys(<span class="string">"webdriver"</span>);</span><br><span class="line">driver.findElements(By.xpath(<span class="string">"//div[3]/ul/li"</span>))</span><br><span class="line">  .get(<span class="number">0</span>)</span><br><span class="line">  .click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line">driver.findElements(By.tagName(<span class="string">"select"</span>))</span><br><span class="line">  .get(<span class="number">0</span>)</span><br><span class="line">  .findElements(By.tagName(<span class="string">"option"</span>))</span><br><span class="line">  .get(<span class="number">3</span>)</span><br><span class="line">  .click()</span><br><span class="line">  .get(<span class="number">4</span>)</span><br><span class="line">  .click()</span><br><span class="line">  .get(<span class="number">5</span>)</span><br><span class="line">  .click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三：获取页面所有链接</span></span><br><span class="line"><span class="keyword">var</span> links = driver</span><br><span class="line">  .get(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">  .findElements(By.tagName(<span class="string">"a"</span>));</span><br><span class="line"><span class="keyword">var</span> linkSize = links.size();</span><br><span class="line"><span class="keyword">var</span> linksSrc = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(linkSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;linkSize;i++) &#123;</span><br><span class="line">  linksSrc[i] = links.get(i).getAttribute(<span class="string">"href"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;linkSize;i++)&#123;</span><br><span class="line">  driver.navigate().to(linksSrc[i]);</span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>size()</code>，查看到底选中了多少个元素。</p><h3 id="网页元素的定位"><a href="#网页元素的定位" class="headerlink" title="网页元素的定位"></a>网页元素的定位</h3><p>WebDriver提供8种定位器，用于定位网页元素。</p><ul><li>By.id：HTML元素的id属性</li><li>By.name：HTML元素的name属性</li><li>By.xpath：使用XPath语法选中HTML元素</li><li>By.cssSelector：使用CSS选择器语法</li><li>By.className：HTML元素的class属性</li><li>By.linkText：链接文本（只用于选中链接）</li><li>By.tagName：HTML元素的标签名</li><li>By.partialLinkText：部分链接文本（只用于选中链接）</li></ul><p>下面是一个使用id定位器，选中网页元素的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.findElement(By.id(<span class="string">"sblsbb"</span>)).click();</span><br></pre></td></tr></table></figure><h3 id="网页元素的方法"><a href="#网页元素的方法" class="headerlink" title="网页元素的方法"></a>网页元素的方法</h3><p>以下方法属于网页元素的方法，而不是webDriver实例的方法。需要注意的是，有些方法是某些元素特有的，比如只有文本框才能输入文字。如果在网页元素上调用不支持的方法，WebDriver不会报错，也不会给出给出任何提示，只会静静地忽略。</p><p>getAttribute()：返回网页元素指定属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.xpath(<span class="string">"//div[@id='lst-ib']"</span>))</span><br><span class="line">  .getAttribute(<span class="string">"class"</span>);</span><br></pre></td></tr></table></figure><p>getText()：返回网页元素的内部文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>)).getText();</span><br></pre></td></tr></table></figure><p>getTagName()：返回指定元素的标签名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.findElement(By.xpath(<span class="string">"//div[@class='sbib_b']"</span>))</span><br><span class="line">  .getTagName();</span><br></pre></td></tr></table></figure><p>isDisplayed()：返回一个布尔值，表示元素是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">assert(driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">  .isDisplayed(),</span><br><span class="line">  <span class="string">'搜索框应该可选择'</span>);</span><br></pre></td></tr></table></figure><p>isEnabled()：返回一个布尔值，表示文本框是否可编辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="keyword">var</span> Element = driver.findElement(By.name(<span class="string">"q"</span>));</span><br><span class="line"><span class="keyword">if</span> (Element.isEnabled()) &#123;</span><br><span class="line">  driver.findElement(By.name(<span class="string">"q"</span>))</span><br><span class="line">    .sendKeys(<span class="string">"Selenium Essentials"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isSelected()：返回一个布尔值，表示一个元素是否可选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.findElement(By.xpath(<span class="string">"//select[@name='jump']/option[1]"</span>))</span><br><span class="line">  .isSelected()</span><br></pre></td></tr></table></figure><p>getSize()：返回一个网页元素的宽度和高度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dimensions=driver.findElement(By.locatorType(<span class="string">"path"</span>))</span><br><span class="line">  .getSize(); </span><br><span class="line">dimensions.width;</span><br><span class="line">dimensions.height;</span><br></pre></td></tr></table></figure><p>getLocation()：返回网页元素左上角的x坐标和y坐标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = driver.findElement(By.locatorType(<span class="string">"path"</span>)).getLocation();</span><br><span class="line">point.x; <span class="comment">// 等同于 point.getX();</span></span><br><span class="line">point.y; <span class="comment">// 等同于 point.getY();</span></span><br></pre></td></tr></table></figure><p>getCssValue()：返回网页元素指定的CSS属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="keyword">var</span> element = driver.findElement(By.xpath(<span class="string">"//div[@id='hplogo']"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(element.getCssValue(<span class="string">"font-size"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(element.getCssValue(<span class="string">"font-weight"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(element.getCssValue(<span class="string">"color"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(element.getCssValue(<span class="string">"background-size"</span>));</span><br></pre></td></tr></table></figure><h3 id="页面跳转的方法"><a href="#页面跳转的方法" class="headerlink" title="页面跳转的方法"></a>页面跳转的方法</h3><p>以下方法用来跳转到某一个页面。</p><p>get()：要求浏览器跳到某个网址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"URL"</span>);</span><br></pre></td></tr></table></figure><p>navigate().back()：浏览器回退。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.navigate().back();</span><br></pre></td></tr></table></figure><p>navigate().forward()：浏览器前进。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.navigate().forward();</span><br></pre></td></tr></table></figure><p>navigate().to()：跳转到浏览器历史中的某个页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.navigate().to(<span class="string">"URL"</span>);</span><br></pre></td></tr></table></figure><p>navigate().refresh()：刷新当前页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">driver.navigate().refresh();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">driver.navigate()</span><br><span class="line">  .to(driver.getCurrentUrl());</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">driver.findElement(By.locatorType(<span class="string">"path"</span>))</span><br><span class="line">  .sendKeys(Keys.F5);</span><br></pre></td></tr></table></figure><h3 id="cookie的方法"><a href="#cookie的方法" class="headerlink" title="cookie的方法"></a>cookie的方法</h3><p>getCookies()：获取cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.manage().getCookies();</span><br></pre></td></tr></table></figure><p>getCookieNamed() ：返回指定名称的cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(driver.manage().getCookieNamed(<span class="string">"NID"</span>));</span><br></pre></td></tr></table></figure><p>addCookie()：将cookie加入当前页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.com"</span>);</span><br><span class="line">driver.manage().addCookie(cookie0);</span><br></pre></td></tr></table></figure><p>deleteCookie()：删除指定的cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.google.co.in"</span>);</span><br><span class="line">driver.manage().deleteCookieNamed(<span class="string">"NID"</span>);</span><br></pre></td></tr></table></figure><h3 id="浏览器窗口的方法"><a href="#浏览器窗口的方法" class="headerlink" title="浏览器窗口的方法"></a>浏览器窗口的方法</h3><p>maximize()：最大化浏览器窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> driver = <span class="keyword">new</span> FirefoxDriver();</span><br><span class="line">driver.manage().window().maximize();</span><br></pre></td></tr></table></figure><p>getSize()：返回浏览器窗口、图像、网页元素的宽和高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.manage().window().getSize();</span><br></pre></td></tr></table></figure><p>getPosition()：返回浏览器窗口左上角的x坐标和y坐标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Position X: "</span> + driver.manage().window().getPosition().x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Position Y: "</span> + driver.manage().window().getPosition().y);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Position X: "</span> + driver.manage().window().getPosition().getX());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Position Y: "</span> + driver.manage().window().getPosition().getY());</span><br></pre></td></tr></table></figure><p>setSize()：定制浏览器窗口的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dimension(<span class="number">320</span>, <span class="number">480</span>);</span><br><span class="line">driver.manage().window().setSize(d);</span><br><span class="line">driver.manage().window().setSize(<span class="keyword">new</span> Dimension(<span class="number">320</span>, <span class="number">480</span>));</span><br></pre></td></tr></table></figure><p>setPosition()：移动浏览器左上角到指定位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">driver.manage().window().setPosition(p);</span><br><span class="line">driver.manage().window().setPosition(<span class="keyword">new</span> Point(<span class="number">300</span>, <span class="number">150</span>));</span><br></pre></td></tr></table></figure><p>getWindowHandle()：返回当前浏览器窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentwindow = driver.getWindowHandle();</span><br><span class="line">driver.switchTo().window(parentwindow);</span><br></pre></td></tr></table></figure><p>getWindowHandles()：返回所有浏览器窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> childwindows =  driver.getWindowHandles();</span><br><span class="line">driver.switchTo().window(childwindow);</span><br></pre></td></tr></table></figure><p>switchTo.window()：在浏览器窗口之间切换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.SwitchTo().Window(childwindow);</span><br><span class="line">driver.close();</span><br><span class="line">driver.SwitchTo().Window(parentWindow);</span><br></pre></td></tr></table></figure><h3 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><p>以下方法处理浏览器的弹出窗口。</p><p>dismiss() ：关闭弹出窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alert = driver.switchTo().alert();</span><br><span class="line">alert.dismiss();</span><br></pre></td></tr></table></figure><p>accept()：接受弹出窗口，相当于按下接受OK按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alert = driver.switchTo().alert();</span><br><span class="line">alert.accept();</span><br></pre></td></tr></table></figure><p>getText()：返回弹出窗口的文本值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alert = driver.switchTo().alert();</span><br><span class="line">alert.getText();</span><br></pre></td></tr></table></figure><p>sendKeys()：向弹出窗口发送文本字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alert = driver.switchTo().alert();</span><br><span class="line">alert.sendKeys(<span class="string">"Text to be passed"</span>);</span><br></pre></td></tr></table></figure><p>authenticateUsing()：处理HTTP认证。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserAndPassword(<span class="string">"USERNAME"</span>, <span class="string">"PASSWORD"</span>);</span><br><span class="line">alert.authenticateUsing(user);</span><br></pre></td></tr></table></figure><h3 id="鼠标和键盘的方法"><a href="#鼠标和键盘的方法" class="headerlink" title="鼠标和键盘的方法"></a>鼠标和键盘的方法</h3><p>以下方法模拟鼠标和键盘的动作。</p><ul><li>click()：鼠标在当前位置点击。</li><li>clickAndHold()：按下鼠标不放</li><li>contextClick()：右击鼠标</li><li>doubleClick()：双击鼠标</li><li>dragAndDrop()：鼠标拖放到目标元素</li><li>dragAndDropBy()：鼠标拖放到目标坐标</li><li>keyDown()：按下某个键</li><li>keyUp()：从按下状态释放某个键</li><li>moveByOffset()：移动鼠标到另一个坐标位置</li><li>moveToElement()：移动鼠标到另一个网页元素</li><li>release()：释放拖拉的元素</li><li>sendKeys()：控制键盘输出</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>Jani Hartikainen, <a href="http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/" target="_blank" rel="noopener">http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6特性笔记</title>
      <link href="/2020/03/25/ES6%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/25/ES6%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>谷歌对特殊符号的不支持真是让我无语！很多查询都变得无比艰难！总结一下，我可不想再查一次了</p><p>提前说明这不是tutorial，我也没加tutorial标签。这里只有我想记一下的内容</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>你是不是见到过以下的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br></pre></td></tr></table></figure><p>却不知道这大括号是干什么用的？</p><p>这是ES6的解构赋值。</p><p><strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, rest;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [30, 40, 50]</span></span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stage 4（已完成）提案中的特性</span></span><br><span class="line">(&#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> [y, z] = x;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(z); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>JavaScript 中，解构赋值的作用类似于 Perl 和 Python 语言中的相似特性。</p><p>关于解构赋值，查看</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">MDN</a></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>来源：<a href="https://es6.ruanyifeng.com/#docs/function#rest参数" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure><p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，原始意图是返回一个对象<code>{ a: 1 }</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p><p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个例子是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p><p>箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p><p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p><p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p><p>所以，箭头函数转成 ES5 的代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p><p>请问下面的代码之中有几个<code>this</code>？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p><p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'args:'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p><p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.x).bind(&#123; <span class="attr">x</span>: <span class="string">'inner'</span> &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; <span class="attr">x</span>: <span class="string">'outer'</span> &#125;);</span><br><span class="line"><span class="comment">// ['outer']</span></span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p><p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p><p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p><p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'press'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'on'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p><p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p><h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面这个函数，可以使用箭头函数改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="function">(<span class="params">&#123;into: (array</span>) =&gt;</span> <span class="function">(<span class="params">&#123;after: (afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// λ演算的写法</span></span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> fix = <span class="function"><span class="params">f</span> =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</span><br><span class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)));</span><br></pre></td></tr></table></figure><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS异步讲解-Asynchronous JavaScript</title>
      <link href="/2020/03/25/JS%E5%BC%82%E6%AD%A5%E8%AE%B2%E8%A7%A3-Asynchronous%20JavaScript/"/>
      <url>/2020/03/25/JS%E5%BC%82%E6%AD%A5%E8%AE%B2%E8%A7%A3-Asynchronous%20JavaScript/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>头都被JavaScript的异步处理搞炸了，而且脑子不太好使，经常学一点忘一点。做个笔记记录一下几个学习JavaScript过程中的痛点</p><p>部分笔记来源：udemy-modern JavaScript from the beginning</p><p><a href="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html" target="_blank" rel="noopener">cnblog</a> &amp; <a href="https://juejin.im/post/5d89844ae51d4561ff6668f3" target="_blank" rel="noopener">dayTimeAffect</a> &amp; <a href="https://juejin.im/post/5bc76ff56fb9a05cee1e14a9" target="_blank" rel="noopener">Jiasm</a></p><h2 id="什么是异步-Asynchronous"><a href="#什么是异步-Asynchronous" class="headerlink" title="什么是异步 Asynchronous"></a>什么是异步 Asynchronous</h2><p>要说清楚异步，需要先把同步说明清楚。所谓同步就是一步步向下走</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">posts = loadPostsSync();</span><br><span class="line">doTheNextThing();</span><br></pre></td></tr></table></figure><p>如上所示，必须先把第一个函数执行完了，第二个函数才能执行。众所周知，JavaScript约等于没有多线程，那么node.js又是怎么实现高并发的呢？就是靠异步。现在的环境下一个工程往往会受制于读写时间，而不是真正的处理运算时间。假如我们遇到了读写瓶颈，我们就暂时先搁置手上的工作，优先去处理下一步的内容，随后等到读写完成，再次回来捡起过去仍在地上的工作，这就实现了异步。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loadPostsAsync(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//wait til posts are fetched</span></span><br><span class="line"><span class="comment">//do something with posts</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doTheNextThing();</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>首先要把callback说清楚，callback就我理解，就是在一个函数中call另外一个函数，避免在异步过程中出错。从简单的setTimeOut到匿名函数，都算callback。在JavaScript中，函数属于对象，是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以这样创建函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arg1"</span>, <span class="string">"arg2"</span>, <span class="string">"return arg1 * arg2;"</span>);</span><br><span class="line">fn(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h3 id="传递函数作为回调"><a href="#传递函数作为回调" class="headerlink" title="传递函数作为回调"></a>传递函数作为回调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg1, arg2, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * (arg1 - arg2) + arg2);</span><br><span class="line">    callback(num);　　<span class="comment">//传递结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">10</span>, <span class="number">20</span>, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Callback called! Num: "</span> + num);</span><br><span class="line">&#125;);　　　　<span class="comment">//结果为10和20之间的随机数</span></span><br></pre></td></tr></table></figure><p>这里看到我们把function拿来当参数直接传入函数中，这其实就是回调</p><p>传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。</p><p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在JavaScript中使用异步调用，甚至在这里强烈推荐使用！</p><p>下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">url, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpRequest;　　　　<span class="comment">//创建XHR</span></span><br><span class="line">    httpRequest = <span class="built_in">window</span>.XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() :　　　<span class="comment">//针对IE进行功能性检测</span></span><br><span class="line">　　　　<span class="built_in">window</span>.ActiveXObject ? <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>) : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(httpRequest.readystate === <span class="number">4</span> &amp;&amp; httpRequest.status === <span class="number">200</span>)&#123;　　<span class="comment">//状态判断</span></span><br><span class="line">          callback.call(httpRequest.responseXML);  </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    httpRequest.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    httpRequest.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="string">"text.xml"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;　　　　<span class="comment">//调用函数</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>); 　　<span class="comment">//此语句后输出</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"this will run before the above callback."</span>);　　<span class="comment">//此语句先输出</span></span><br></pre></td></tr></table></figure><p>我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。</p><p>最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。</p><p>上述例子不太易于理解，那看看下面的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;       </span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f(); <span class="comment">//return 20.</span></span><br><span class="line">f(); <span class="comment">//return 40.</span></span><br></pre></td></tr></table></figure><p>函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。<strong>函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。</strong>只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i: '</span>,i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的答案是五个五。那么为什么是五个五呢？</p><p>1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）</p><p>2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）</p><p>那么，为什么我们最先输出的是5呢？</p><p>非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。</p><p>这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志</a>，或者看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">并发模型与Event Loop</a></p><p>我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。</p><p>在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。</p><p>那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？</p><p>现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。</p><p>在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。</p><p><strong>注意，换作let的话那么输出结果就不一样了，let的结果会是0 1 2 3 4</strong></p><p>ES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。</p><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>被叫做promise是因为当他们在处理async的任务时他们可以promise去做一些async结束后的事。一个简单的案例。其中resolve表示接下去要做的事，而reject表示出现error等问题后如何handle</p><p>值得一提的是，你new一个promise后，这个promise会执行其中的所有内容直到出现回调函数（或到定义尾部）为止，随后进入pending状态</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>pending</code>: 初始状态, 非 <code>fulfilled</code> 或 <code>rejected</code>.</p><p><code>fulfilled</code>: 成功的操作.</p><p><code>rejected</code>: 失败的操作.</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h3><p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时<strong>第一个被reject的实例的</strong>返回值，会传递给p的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p><strong>使用其副作用而不是return</strong> 下面的代码有什么问题？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Gee, I hope someOtherPromise() has resolved!</span></span><br><span class="line">  <span class="comment">// Spoiler alert: it hasn't.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每一个promise对象都会提供一个then方法或者是catch方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在这里能做什么呢？有三种事可以做：</p><ol><li>返回另一个promise；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>返回一个同步值（或者undefined)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数什么都不返回等于返回了 undefined 目前为止，我们看到给 .then() 传递的都是函数，但是其实它可以接受非函数值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">later(<span class="number">1000</span>)</span><br><span class="line">  .then(later(<span class="number">2000</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data = later_1000</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>给 .then() 传递非函数值时，实际上会被解析成 .then(null)，从而导致上一个 promise 对象的结果被“穿透”。于是，上面的代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">later(<span class="number">1000</span>)</span><br><span class="line">  .then(<span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data = later_1000</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>为了避免不必要的麻烦，建议总是给 .then() 传递函数。</p><ol><li>抛出一个同步错误。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>cacth()和then(null, …)并不完全相同</strong></p><p>下面两个代码是不等价的，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了</p><p><strong>promise坠落现象</strong> 这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！</p><p>产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="promise数组依次执行"><a href="#promise数组依次执行" class="headerlink" title="promise数组依次执行"></a>promise数组依次执行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span> (<span class="params">api, ms, err = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`fetch-<span class="subst">$&#123;api&#125;</span>-<span class="subst">$&#123;ms&#125;</span> start`</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      err ? reject(<span class="string">`reject-<span class="subst">$&#123;api&#125;</span>-<span class="subst">$&#123;ms&#125;</span>`</span>) : resolve(<span class="string">`resolve-<span class="subst">$&#123;api&#125;</span>-<span class="subst">$&#123;ms&#125;</span>`</span>)</span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promises = [fetch(<span class="string">'API1'</span>, <span class="number">3000</span>), fetch(<span class="string">'API2'</span>, <span class="number">2000</span>), fetch(<span class="string">'API3'</span>, <span class="number">5000</span>)]</span><br><span class="line">  promises.reduce(<span class="function">(<span class="params">chain, promise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> promise</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve(<span class="string">'haha'</span>)).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadData()</span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promises = [fetch(<span class="string">'API1'</span>, <span class="number">3000</span>), fetch(<span class="string">'API2'</span>, <span class="number">2000</span>), fetch(<span class="string">'API3'</span>, <span class="number">5000</span>)]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise常见面试题"><a href="#promise常见面试题" class="headerlink" title="promise常见面试题"></a>promise常见面试题</h3><ol><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ol><p>  输出结果为：1，2，4，3。</p><p>  解题思路：then方法是异步执行的。</p><ol start="2"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>  输出结果：success</p><p>  解题思路：Promise状态一旦改变，无法在发生变更。</p><ol start="3"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure></li></ol><p>  输出结果：1</p><p>  解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。</p><ol start="4"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'Promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：Promise1    1    Promise2    setTimeout</p><p>解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列<strong>microtask queue</strong>中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有<strong>microtask queue</strong>顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36972010">www.zhihu.com/question/36…</a>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>结果是：3 4 6 8 7 5 2 1,优先级关系如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</span><br></pre></td></tr></table></figure><p>V8实现中，两个队列各包含不同的任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</span><br><span class="line">microtasks: process.nextTick, Promises, <span class="built_in">Object</span>.observe, MutationObserver</span><br></pre></td></tr></table></figure><p><strong>执行过程如下：\</strong>JavaScript引擎首先从macrotask queue中取出*<em>第一个任务*</em>，执行完毕后，将<strong>microtask queue</strong>中的<strong>所有任务</strong>取出，按顺序<strong>全部执行</strong>；然后再从macrotask queue中取<strong>下一个</strong>，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。</p><p><strong>解释：\</strong>代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，**放入到了另一个队列microtask queue**。等整个execution context stack执行完后，下一步该取的是*<em>microtask queue*</em>中的任务了。因此promise.then的回调比setTimeout先执行。 </p><ol start="5"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：1  2</p><p>解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。</p><ol start="6"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始'</span>);</span><br><span class="line">resolve(<span class="string">'success'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：</p><p>开始</p><p>success 5002</p><p>success 5002</p><p>解题思路：promise 的<strong>.then</strong>或者<strong>.catch</strong>可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用<strong>.then</strong> 或者<strong>.catch</strong>都会直接拿到该值。</p><ol start="7"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">6</span></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve1'</span>)</span><br><span class="line">    resolve(num)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject1'</span>)</span><br><span class="line">    reject(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve2'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,(rej)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject2'</span>)</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rej*<span class="number">2</span>&gt;<span class="number">10</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'resolve3'</span>)</span><br><span class="line">      resolve(rej*<span class="number">2</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'reject3'</span>)</span><br><span class="line">      reject(rej*<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&amp;emsp;&amp;emsp;<span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve4'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,(rej)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject4'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(rej)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>  输出结果：</p><p>    reject1    reject2    resolve3    resolve4    12</p><p>  解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。</p><ol start="8"><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function"><span class="params">resolve2</span> =&gt;</span> &#123;</span><br><span class="line">    resolve2(<span class="number">4</span>)</span><br><span class="line">  &#125;)).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p>输出1 2 4 3</p><ol start="9"><li>重头戏！！！！实现一个简单的Promise</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> status = <span class="string">'pending'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">successNotify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      status = <span class="string">'fulfilled'</span><span class="comment">//状态变为fulfilled</span></span><br><span class="line">      toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>)<span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">failNotify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      status = <span class="string">'rejected'</span><span class="comment">//状态变为rejected</span></span><br><span class="line">      toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>)<span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toDoThen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 保证回调是异步执行的</span></span><br><span class="line">          <span class="keyword">if</span>(status === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt; successArray.length;i ++)    &#123;</span><br><span class="line">                  successArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>)<span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt; failArray.length;i ++)    &#123;</span><br><span class="line">                  failArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>)<span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> successArray = []</span><br><span class="line">  <span class="keyword">var</span> failArray = []</span><br><span class="line">  fn.call(<span class="literal">undefined</span>, successNotify, failNotify)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      then: <span class="function"><span class="keyword">function</span>(<span class="params">successFn, failFn</span>)</span>&#123;</span><br><span class="line">          successArray.push(successFn)</span><br><span class="line">          failArray.push(failFn)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">undefined</span> <span class="comment">// 此处应该返回一个Promise</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><p>来源:<a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">边城</a></p><p>随着 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a> v7 的发布，越来越多的人开始研究据说是异步编程终级解决方案的 async/await。我第一次看到这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p><p>我之前在<a href="https://segmentfault.com/a/1190000003742890" target="_blank" rel="noopener">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href="https://msdn.microsoft.com/library/dd321424.aspx" target="_blank" rel="noopener">Task 或 Task</a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>。</p><p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p><h3 id="async-和-await-在干什么"><a href="#async-和-await-在干什么" class="headerlink" title="async 和 await 在干什么"></a>async 和 await 在干什么</h3><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p><p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p><p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p><h4 id="async-起什么作用"><a href="#async-起什么作用" class="headerlink" title="async 起什么作用"></a>async 起什么作用</h4><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p><p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello async"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\<span class="keyword">var</span>\test&gt; node --harmony_async_await .</span><br><span class="line"><span class="built_in">Promise</span> &#123; <span class="string">'hello async'</span> &#125;</span><br></pre></td></tr></table></figure><p>所以，async 函数返回的是一个 Promise 对象。从<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testAsync().then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);    <span class="comment">// 输出 hello async</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p>那么下一个关键点就在于 await 关键字了。</p><h4 id="await-到底在等啥"><a href="#await-到底在等啥" class="headerlink" title="await 到底在等啥"></a>await 到底在等啥</h4><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"something"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h4 id="await-等到了要等的，然后呢"><a href="#await-等到了要等的，然后呢" class="headerlink" title="await 等到了要等的，然后呢"></a>await 等到了要等的，然后呢</h4><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p><p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><blockquote><p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p></blockquote><h3 id="async-await-帮我们干了啥"><a href="#async-await-帮我们干了啥" class="headerlink" title="async/await 帮我们干了啥"></a>async/await 帮我们干了啥</h3><h4 id="作个简单的比较"><a href="#作个简单的比较" class="headerlink" title="作个简单的比较"></a>作个简单的比较</h4><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p><p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"long_time_value"</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">takeLongTime().then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"got"</span>, v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果改用 async/await 呢，会是这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"long_time_value"</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="keyword">await</span> takeLongTime();</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p><p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p><h4 id="async-await-的优势在于处理-then-链"><a href="#async-await-的优势在于处理-then-链" class="headerlink" title="async/await 的优势在于处理 then 链"></a>async/await 的优势在于处理 then 链</h4><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 &#x3D; 300;</span><br><span class="line">    const time2 &#x3D; await step1(time1);</span><br><span class="line">    const time3 &#x3D; await step2(time2);</span><br><span class="line">    const result &#x3D; await step3(time3);</span><br><span class="line">    console.log(&#96;result is $&#123;result&#125;&#96;);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h4 id="还有更酷的"><a href="#还有更酷的" class="headerlink" title="还有更酷的"></a>还有更酷的</h4><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这回先用 async/await 来写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 800 = 300 + 500</span></span><br><span class="line"><span class="comment">// step3 with 1800 = 300 + 500 + 1000</span></span><br><span class="line"><span class="comment">// result is 2000</span></span><br><span class="line"><span class="comment">// doIt: 2907.387ms</span></span><br></pre></td></tr></table></figure><p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> step2(time1, time2)</span><br><span class="line">                .then(<span class="function"><span class="params">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">times</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> [time1, time2, time3] = times;</span><br><span class="line">            <span class="keyword">return</span> step3(time1, time2, time3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p><h2 id="async-await-2"><a href="#async-await-2" class="headerlink" title="async await 2"></a>async await 2</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会<strong>先返回，等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定50毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>async 函数有多种使用形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h4 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h4><p><code>async</code>函数返回一个 Promise 对象。</p><p><strong><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><h4 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h4><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h4 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h4><p>正常情况下，<strong><code>await</code>命令后面是一个 Promise 对象。如果不是，会被转成一个立即<code>resolve</code>的 Promise 对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，它被转成 Promise 对象，并立即<code>resolve</code>。</p><p><strong><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</strong>也就是说假如async中有await函数被reject了，那么这段报错会出现在async的catch中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>只要一个<code>await</code>语句后面的 Promise 变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">    <span class="keyword">var</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">    <span class="keyword">var</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> superagent.get(<span class="string">'http://google.com/this-throws-an-error'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h3><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h3><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    p = p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="keyword">return</span> anim(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">  <span class="keyword">return</span> p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> anim(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p><p>最后是 async 函数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p><h3 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h3><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  textPromises.reduce(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.then(<span class="function"><span class="params">()</span> =&gt;</span> textPromise)</span><br><span class="line">      .then(<span class="function"><span class="params">text</span> =&gt;</span> <span class="built_in">console</span>.log(text));</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h3 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h3><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p><p>这里隐含着一个规定，<code>next</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>next</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p><p>目前，有一个<a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="noopener">提案</a>，为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p><h4 id="异步遍历的接口"><a href="#异步遍历的接口" class="headerlink" title="异步遍历的接口"></a>异步遍历的接口</h4><p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncIterator</span><br><span class="line">  .next()</span><br><span class="line">  .then(</span><br><span class="line">    (&#123; value, done &#125;) =&gt; <span class="comment">/* ... */</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p><p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p><p>下面是一个异步遍历器的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">const</span> asyncIterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line"></span><br><span class="line">asyncIterator</span><br><span class="line">.next()</span><br><span class="line">.then(<span class="function"><span class="params">iterResult1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterResult1); <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">  <span class="keyword">return</span> asyncIterator.next();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">iterResult2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterResult2); <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">  <span class="keyword">return</span> asyncIterator.next();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">iterResult3</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterResult3); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p><p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">  <span class="keyword">const</span> asyncIterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">  <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">  <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p><p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的Promise对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncGenObj = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">const</span> [&#123;<span class="attr">value</span>: v1&#125;, &#123;<span class="attr">value</span>: v2&#125;] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  asyncGenObj.next(), asyncGenObj.next()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v1, v2); <span class="comment">// a b</span></span><br></pre></td></tr></table></figure><p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> writer = openFile(<span class="string">'someFile.txt'</span>);</span><br><span class="line">writer.next(<span class="string">'hello'</span>);</span><br><span class="line">writer.next(<span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">await</span> writer.return();</span><br></pre></td></tr></table></figure><h4 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h4><p>前面介绍过，<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>])) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>createAsyncIterable()</code>返回一个异步遍历器，<code>for...of</code>循环自动调用这个遍历器的<code>next</code>方法，会得到一个Promise对象。<code>await</code>用来处理这个Promise对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p><p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> data <span class="keyword">of</span> req) body += data;</span><br><span class="line"><span class="keyword">const</span> parsed = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'got'</span>, parsed);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p><p>如果<code>next</code>方法返回的Promise对象被<code>reject</code>，那么就要用<code>try...catch</code>捕捉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> createRejectingIterable()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><h4 id="异步Generator函数"><a href="#异步Generator函数" class="headerlink" title="异步Generator函数"></a>异步Generator函数</h4><p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p><p>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">readLines</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">await</span> fileOpen(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!file.EOF) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">await</span> file.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回Promise对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法的停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是于同步Generator函数一致的。</p><p>可以像下面这样，使用上面代码定义的异步Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">prefixLines</span>(<span class="params">asyncIterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'&gt; '</span> + line;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield</code>命令依然是立刻返回的，但是返回的是一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Start'</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> doSomethingAsync(); <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Result: '</span>+ result; <span class="comment">// (B)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>next</code>方法以后，会在<code>B</code>处暂停执行，<code>yield</code>命令立刻返回一个Promise对象。这个Promise对象不同于<code>A</code>处<code>await</code>命令后面的那个 Promise 对象。主要有两点不同，一是<code>A</code>处的Promise对象<code>resolve</code>以后产生的值，会放入<code>result</code>变量；二是<code>B</code>处的Promise对象<code>resolve</code>以后产生的值，是表达式<code>&#39;Result： &#39; + result</code>的值；二是<code>A</code>处的 Promise 对象一定先于<code>B</code>处的 Promise 对象<code>resolve</code>。</p><p>如果异步 Generator 函数抛出错误，会被 Promise 对象<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncGenerator()</span><br><span class="line">.next()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure><p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，<code>async</code>函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">takeAsync</span>(<span class="params">asyncIterable, count=Infinity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> iterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">  <span class="keyword">while</span> (result.length &lt; count) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;value,done&#125; = <span class="keyword">await</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">    result.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步Generator函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。</p><p>下面是这个自动执行器的一个使用实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> takeAsync(gen());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。</p><p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">createAsyncIterable</span>(<span class="params">syncIterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> syncIterable) &#123;</span><br><span class="line">    <span class="keyword">yield</span> elem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p><h4 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span>* gen1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p><p>与同步Generator函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> gen2()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><h2 id="Promisify"><a href="#Promisify" class="headerlink" title="Promisify"></a>Promisify</h2><p><code>util.promisify</code>是在<code>node.js 8.x</code>版本中新增的一个工具，用于将老式的<code>Error first callback</code>转换为<code>Promise</code>对象，让老项目改造变得更为轻松。</p><p>在官方推出这个工具之前，民间已经有很多类似的工具了，比如<a href="https://www.npmjs.com/package/es6-promisify" target="_blank" rel="noopener">es6-promisify</a>、<a href="https://www.npmjs.com/package/thenify" target="_blank" rel="noopener">thenify</a>、<a href="http://bluebirdjs.com/docs/api/promise.promisify.html" target="_blank" rel="noopener">bluebird.promisify</a>。</p><p>以及很多其他优秀的工具，都是实现了这样的功能，帮助我们在处理老项目的时候，不必费神将各种代码使用<code>Promise</code>再重新实现一遍。</p><h3 id="工具实现的大致思路"><a href="#工具实现的大致思路" class="headerlink" title="工具实现的大致思路"></a>工具实现的大致思路</h3><p>首先要解释一下这种工具大致的实现思路，因为在<code>Node</code>中异步回调有一个约定：<code>Error first</code>，也就是说回调函数中的第一个参数一定要是<code>Error</code>对象，其余参数才是正确时的数据。</p><p>知道了这样的规律以后，工具就很好实现了，在匹配到第一个参数有值的情况下，触发<code>reject</code>，其余情况触发<code>resolve</code>，一个简单的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">util</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    func(...arg, (err, arg) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      <span class="keyword">else</span> resolve(arg)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用工具函数返回一个匿名函数，匿名函数接收原函数的参数。</li><li>匿名函数被调用后根据这些参数来调用真实的函数，同时拼接一个用来处理结果的<code>callback</code>。</li><li>检测到<code>err</code>有值，触发<code>reject</code>，其他情况触发<code>resolve</code></li></ol><p><strong>resolve 只能传入一个参数，所以<code>callback</code>中没有必要使用<code>...arg</code>获取所有的返回值</strong></p><h3 id="常规的使用方式"><a href="#常规的使用方式" class="headerlink" title="常规的使用方式"></a>常规的使用方式</h3><blockquote><p>拿一个官方文档中的示例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statAsync = promisify(fs.stat)</span><br><span class="line"></span><br><span class="line">statAsync(<span class="string">'.'</span>).then(<span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到了正确的数据</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="comment">// 出现了异常</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以及因为是<code>Promise</code>，我们可以使用<code>await</code>来进一步简化代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statAsync = promisify(fs.stat)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在 async 函数中</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stats = <span class="keyword">await</span> statAsync(<span class="string">'.'</span>)</span><br><span class="line">  <span class="comment">// 拿到正确结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 出现异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法与其他工具并没有太大的区别，我们可以很轻易的将回调转换为<code>Promise</code>，然后应用于新的项目中。</p><h3 id="自定义的-Promise-化"><a href="#自定义的-Promise-化" class="headerlink" title="自定义的 Promise 化"></a>自定义的 Promise 化</h3><p>有那么一些场景，是不能够直接使用<code>promisify</code>来进行转换的，有大概这么两种情况：</p><ol><li>没有遵循<code>Error first callback</code>约定的回调函数</li><li>返回多个参数的回调函数</li></ol><p>首先是第一个，如果没有遵循我们的约定，很可能导致<code>reject</code>的误判，得不到正确的反馈。<br>而第二项呢，则是因为<code>Promise.resolve</code>只能接收一个参数，多余的参数会被忽略。</p><p>所以为了实现正确的结果，我们可能需要手动实现对应的<code>Promise</code>函数，但是自己实现了以后并不能够确保使用方不会针对你的函数调用<code>promisify</code>。</p><p>所以，<code>util.promisify</code>还提供了一个<code>Symbol</code>类型的<code>key</code>，<code>util.promisify.custom</code>。</p><p><code>Symbol</code>类型的大家应该都有了解，是一个唯一的值，这里是<code>util.prosimify</code>用来指定自定义的<code>Promise</code>化的结果的，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="comment">// 比如我们有一个对象，提供了一个返回多个参数的回调版本的函数</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  getData (callback) &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'Niko'</span>, <span class="number">18</span>) <span class="comment">// 返回两个参数，姓名和年龄</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时使用promisify肯定是不行的</span></span><br><span class="line"><span class="comment">// 因为Promise.resolve只接收一个参数，所以我们只会得到 Niko</span></span><br><span class="line"></span><br><span class="line">promisify(obj.getData)().then(<span class="built_in">console</span>.log) <span class="comment">// Niko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们需要使用 promisify.custom 来自定义处理方式</span></span><br><span class="line"></span><br><span class="line">obj.getData[promisify.custom] = <span class="keyword">async</span> () =&gt; (&#123; <span class="attr">name</span>: <span class="string">'Niko'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然了，这是一个曲线救国的方式，无论如何 Promise 不会返回多个参数过来的</span></span><br><span class="line">promisify(obj.getData)().then(<span class="built_in">console</span>.log) <span class="comment">// &#123; name: 'Niko', age: 18 &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><em>关于<code>Promise</code>为什么不能<code>resolve</code>多个值，我有一个大胆的想法，一个没有经过考证，强行解释的理由：如果能<code>resolve</code>多个值，你让<code>async</code>函数怎么<code>return</code>（当个乐子看这句话就好，不要当真）</em><br><em>不过应该确实跟<code>return</code>有关，因为<code>Promise</code>是可以链式调用的，每个<code>Promise</code>中执行<code>then</code>以后都会将其返回值作为一个新的<code>Promise</code>对象<code>resolve</code>的值，在<code>JavaScript</code>中并没有办法<code>return</code>多个参数，所以即便第一个<code>Promise</code>可以返回多个参数，只要经过<code>return</code>的处理就会丢失</em></p><p>在使用上就是很简单的针对可能会被调用<code>promisify</code>的函数上添加<code>promisify.custom</code>对应的处理即可。<br>当后续代码调用<code>promisify</code>时就会进行判断：</p><ol><li><p>如果目标函数存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promisify.custom</span><br></pre></td></tr></table></figure><p>属性，则会判断其类型：</p><ol><li>如果不是一个可执行的函数，抛出异常</li><li>如果是可执行的函数，则直接返回其对应的函数</li></ol></li><li><p>如果目标函数不存在对应的属性，按照<code>Error first callback</code>的约定生成对应的处理函数然后返回</p></li></ol><p>添加了这个<code>custom</code>属性以后，就不用再担心使用方针对你的函数调用<code>promisify</code>了。<br>而且可以验证，赋值给<code>custom</code>的函数与<code>promisify</code>返回的函数地址是一处：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj.getData[promisify.custom] = <span class="keyword">async</span> () =&gt; (&#123; <span class="attr">name</span>: <span class="string">'Niko'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上边的赋值为 async 函数也可以改为普通函数，只要保证这个普通函数会返回 Promise 实例即可</span></span><br><span class="line"><span class="comment">// 这两种方式与上边的 async 都是完全相等的</span></span><br><span class="line"></span><br><span class="line">obj.getData[promisify.custom] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">name</span>: <span class="string">'Niko'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">obj.getData[promisify.custom] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve(&#123; <span class="attr">name</span>: <span class="string">'Niko'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getData[promisify.custom] === promisify(obj.getData)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="一些内置的-custom-处理"><a href="#一些内置的-custom-处理" class="headerlink" title="一些内置的 custom 处理"></a>一些内置的 custom 处理</h4><p>在一些内置包中，也能够找到<code>promisify.custom</code>的踪迹，比如说最常用的<code>child_process.exec</code>就内置了<code>promisify.custom</code>的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> exec[promisify.custom]) <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>因为就像前边示例中所提到的曲线救国的方案，官方的做法也是将函数签名中的参数名作为<code>key</code>，将其所有参数存放到一个<code>Object</code>对象中进行返回，比如<code>child_process.exec</code>的返回值抛开<code>error</code>以外会包含两个，<code>stdout</code>和<code>stderr</code>，一个是命令执行后的正确输出，一个是命令执行后的错误输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promisify(exec)(<span class="string">'ls'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// -&gt; &#123; stdout: 'XXX', stderr: '' &#125;</span></span><br></pre></td></tr></table></figure><p>或者我们故意输入一些错误的命令，当然了，这个只能在<code>catch</code>模块下才能够捕捉到，一般命令正常执行<code>stderr</code>都会是一个空字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promisify(exec)(<span class="string">'lss'</span>).then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">// -&gt; &#123; ..., stdout: '', stderr: 'lss: command not found' &#125;</span></span><br></pre></td></tr></table></figure><p>包括像<code>setTimeout</code>、<code>setImmediate</code>也都实现了对应的<code>promisify.custom</code>。<br>之前为了实现<code>sleep</code>的操作，还手动使用<code>Promise</code>封装了<code>setTimeout</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = promisify(setTimeout)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br></pre></td></tr></table></figure><h3 id="内置的-promisify-转换后函数"><a href="#内置的-promisify-转换后函数" class="headerlink" title="内置的 promisify 转换后函数"></a>内置的 promisify 转换后函数</h3><p>如果你的<code>Node</code>版本使用<code>10.x</code>以上的，还可以从很多内置的模块中找到类似<code>.promises</code>的子模块，这里边包含了该模块中常用的回调函数的<code>Promise</code>版本（都是<code>async</code>函数），无需再手动进行<code>promisify</code>转换了。</p><p>而且我本人觉得这是一个很好的指引方向，因为之前的工具实现，有的选择直接覆盖原有函数，有的则是在原有函数名后边增加<code>Async</code>进行区分，官方的这种在模块中单独引入一个子模块，在里边实现<code>Promise</code>版本的函数，其实这个在使用上是很方便的，就拿<code>fs</code>模块进行举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前引入一些 fs 相关的 API 是这样做的</span></span><br><span class="line"><span class="keyword">const</span> &#123; readFile, stat &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而现在可以很简单的改为</span></span><br><span class="line"><span class="keyword">const</span> &#123; readFile, stat &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">promises</span>: &#123; readFile, stat &#125; &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure><p>后边要做的就是将调用<code>promisify</code>相关的代码删掉即可，对于其他使用<code>API</code>的代码来讲，这个改动是无感知的。<br>所以如果你的<code>node</code>版本够高的话，可以在使用内置模块之前先去翻看文档，有没有对应的<code>promises</code>支持，如果有实现的话，就可以直接使用。</p><h3 id="promisify-的一些注意事项"><a href="#promisify-的一些注意事项" class="headerlink" title="promisify 的一些注意事项"></a>promisify 的一些注意事项</h3><ol><li>一定要符合<code>Error first callback</code>的约定</li><li>不能返回多个参数</li><li>注意进行转换的函数是否包含<code>this</code>的引用</li></ol><p>前两个问题，使用前边提到的<code>promisify.custom</code>都可以解决掉。<br>但是第三项可能会在某些情况下被我们所忽视，这并不是<code>promisify</code>独有的问题，就一个很简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Niko'</span>,</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getName() <span class="comment">// Niko</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = obj.getName</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>类似的，如果我们在进行<code>Promise</code>转换的时候，也是类似这样的操作，那么可能会导致生成后的函数<code>this</code>指向出现问题。<br>修复这样的问题有两种途径：</p><ol><li>使用箭头函数，也是推荐的做法</li><li>在调用<code>promisify</code>之前使用<code>bind</code>绑定对应的<code>this</code></li></ol><p>不过这样的问题也是建立在<code>promisify</code>转换后的函数被赋值给其他变量的情况下会发生。<br>如果是类似这样的代码，那么完全不必担心<code>this</code>指向的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Niko'</span>,</span><br><span class="line">  getName (callback) &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的操作是不需要担心 this 指向问题的</span></span><br><span class="line">obj.XXX = promisify(obj.getName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果赋值给了其他变量，那么这里就需要注意 this 的指向了</span></span><br><span class="line"><span class="keyword">const</span> func = promisify(obj.getName) <span class="comment">// 错误的 this</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>个人认为<code>Promise</code>作为当代<code>javaScript</code>异步编程中最核心的一部分，了解如何将老旧代码转换为<code>Promise</code>是一件很有意思的事儿。<br>而我去了解官方的这个工具，原因是在搜索<code>Redis</code>相关的<code>Promise</code>版本时看到了这个<a href="https://github.com/mjackson/then-redis" target="_blank" rel="noopener">readme</a>：</p><blockquote><p>This package is no longer maintained. node_redis now includes support for promises in core, so this is no longer needed.</p></blockquote><p>然后跳到了<code>node_redis</code>里边的实现方案，里边提到了<code>util.promisify</code>，遂抓过来研究了一下，感觉还挺有意思，总结了下分享给大家。</p><h2 id="Js异步执行顺序"><a href="#Js异步执行顺序" class="headerlink" title="Js异步执行顺序"></a>Js异步执行顺序</h2><p>今天在重温promise的时候，突然发现了一个有趣的题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">            <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line">                <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>));</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">7</span>));</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">8</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们先放上结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">9</span> <span class="number">5</span> <span class="number">0</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="简要讲述"><a href="#简要讲述" class="headerlink" title="简要讲述"></a>简要讲述</h3><p>首先我们知道JS分为了同步和异步，并且是顺序是先同步后异步，也就是同步代码执行完成后，哪怕异步代码到了它执行的时候，也会先让同步执行完。但是JS的执行顺序还可以分得更细，那就是异步的顺序。 我们知道很多异步任务，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout, setInterval, setImmediate, Promises.then, <span class="built_in">Promise</span>.catch</span><br></pre></td></tr></table></figure><p>甚至还有nodejs中的process.nextTick等，就像我们知道process.nextTick比promise先执行一样。那么这些异步事件是谁先执行谁后执行呢。 这涉及到了事件循环(event loop)。事件循环也就是事件出入栈。 上面说了这么多异步任务，我们先把它们分为两类： <strong>宏任务（macro-task）</strong>：setTimeout, setInterval, setImmediate <strong>微任务（micro-task）</strong>：Promises.then, Promise.catch</p><p>然后我们再明白一个概念：<strong>先执行微任务，再执行宏任务</strong>。这种执行是，<strong>先执行清空微任务队列，再执行宏任务，当当前宏任务执行完后，微任务队列中又有微任务，再次将微任务队列执行完，再执行下一个宏任务</strong>。</p><p>在异步任务执行过程中遇到宏任务与微任务，将其依次放入当前事件循环队列中。</p><h3 id="例题描述"><a href="#例题描述" class="headerlink" title="例题描述"></a>例题描述</h3><p>首先执行主线程，也就是script（script是宏任务），因为此时没有微任务</p><p>然后遇到<code>setTimeout(() =&gt; { console.log(0);});</code> 这是宏任务，将其放入宏任务队列中 记为 – 宏任务1</p><p>promise新建后会立即执行，输出<code>1</code></p><p>然后将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>继续放入宏任务队列中 记为 – 宏任务2</p><p>将<code>Promise.resolve().then(() =&gt; console.log(5));</code>放入微任务队列中 记为 – 微任务1</p><p>继续往下走，输出<code>9</code></p><p>此时当前宏任务执行完毕，开始执行微任务队列，目前微任务队列中只有微任务1，执行，输出<code>5</code></p><p>微任务队列此时清空，然后执行宏任务1，输出<code>0</code></p><p>微任务队列依然没有任务，继续执行宏任务2，遇见 <code>resolve();</code>，于是将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">7</span>));</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">8</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>放入微任务队列中，记为 – 微任务2，再将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>记为 – 微任务3</p><p>当前宏任务执行完毕，开始执行微任务，先执行微任务2，输出<code>6</code>；将<code>Promise.resolve().then(() =&gt; console.log(7));</code>记为 – 微任务4；<code>setTimeout(() =&gt; console.log(8));</code>记为 – 宏任务3</p><p>执行微任务3，输出<code>2</code>；将<code>setTimeout(() =&gt; console.log(3));</code>记为 – 宏任务4；将<code>Promise.resolve().then(() =&gt; console.log(4));</code>记为 – 微任务5；</p><p>此时队列中依然有微任务，执行微任务4，输出<code>7</code>；执行微任务5，输出<code>4</code>；微任务队列执行完毕</p><p>执行宏任务3，输出<code>8</code>；执行宏任务4，输出<code>3</code>；全部执行完毕</p><p>那么我们的结果为<code>1 9 5 0 6 2 7 4 8 3</code></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lodash笔记</title>
      <link href="/2020/03/25/Lodash%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/25/Lodash%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一部分来自官方文档，一部分内容来自：</p><p>作者：戈德斯文<br>链接：<a href="https://www.jianshu.com/p/d46abfa4ddc9" target="_blank" rel="noopener">https://www.jianshu.com/p/d46abfa4ddc9</a><br>来源：简书</p><h2 id="为什么使用lodash"><a href="#为什么使用lodash" class="headerlink" title="为什么使用lodash"></a>为什么使用lodash</h2><p>通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。</p><h2 id="常用lodash函数"><a href="#常用lodash函数" class="headerlink" title="常用lodash函数"></a>常用lodash函数</h2><h5 id="times-N次循环"><a href="#times-N次循环" class="headerlink" title="_.times N次循环"></a>_.times N次循环</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- javascript -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//js原生的循环方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodash -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//ladash的times方法</span></span></span><br><span class="line"><span class="actionscript">    _.times(<span class="number">5</span>,<span class="function"><span class="keyword">function</span><span class="params">(a)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>for</code>语句是执行循环的不二选择，但在上面代码的使用场景下，<code>_.times()</code>的解决方式更加简洁和易于理解。</p><h5 id="map-深层查找属性值"><a href="#map-深层查找属性值" class="headerlink" title="_.map 深层查找属性值"></a>_.map 深层查找属性值</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ownerArr = [&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"Colin"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog1"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog2"</span>&#125;]</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"John"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog3"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog4"</span>&#125;]</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> jsMap = ownerArr.map(<span class="function"><span class="keyword">function</span> <span class="params">(owner)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- jsMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(jsMap);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lodashMap = _.map(ownerArr, <span class="string">'pets[0].name'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodashMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lodashMap);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lodash中的<code>_.map</code>方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。</p><h5 id="cloneDeep-深克隆对象"><a href="#cloneDeep-深克隆对象" class="headerlink" title="_.cloneDeep 深克隆对象"></a>_.cloneDeep 深克隆对象</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"name"</span>: <span class="string">"戈德斯文"</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = _.cloneDeep(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objB);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA === objB);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:<code>JSON.parse(JSON.stringify(objectToClone))</code> 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。</p><h5 id="random-在指定范围内获取一个随机值"><a href="#random-在指定范围内获取一个随机值" class="headerlink" title="_.random 在指定范围内获取一个随机值"></a>_.random 在指定范围内获取一个随机值</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span><span class="params">(min, max)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(getRandomNumber(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.random(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lodash中的 <code>_.random</code> 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数<code>_.random(15,20,true)</code></p><h5 id="assign-扩展对象"><a href="#assign-扩展对象" class="headerlink" title="_.assign 扩展对象"></a>_.assign 扩展对象</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;    <span class="comment">//判断被扩展的对象有没有某个属性，</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>[i] = obj[i];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"戈德斯文"</span>, <span class="string">"car"</span>: <span class="string">"宝马"</span>&#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = &#123;<span class="string">"name"</span>: <span class="string">"柴硕"</span>, <span class="string">"loveEat"</span>: <span class="literal">true</span>&#125;;</span></span><br><span class="line"></span><br><span class="line">    objA.extend(objB);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA); </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.assign(objA, objB));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>_.assign</code> 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并</p><h5 id="sample-sampleSize-从列表中随机的选择列表项"><a href="#sample-sampleSize-从列表中随机的选择列表项" class="headerlink" title="_.sample _.sampleSize 从列表中随机的选择列表项"></a>_.sample _.sampleSize 从列表中随机的选择列表项</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">randomSmarter</span><span class="params">(smartTeam)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * smartTeam.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> smartTeam[index];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(randomSmarter(smartTeam));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Lodash</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sample(smartTeam));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sampleSize(smartTeam,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，你也可以指定随机返回元素的个数<code>_.sampleSize(smartTeam,n)</code>，n为需要返回的元素个数</p><h5 id="includes-判断对象中是否含有某元素"><a href="#includes-判断对象中是否含有某元素" class="headerlink" title="_.includes 判断对象中是否含有某元素"></a>_.includes 判断对象中是否含有某元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartPerson = &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">'name'</span>: <span class="string">'戈德斯文'</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'gender'</span>: <span class="string">'male'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartPerson, <span class="string">'戈德斯文'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>_.includes()</code>第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标</p><h5 id="forEach-遍历循环"><a href="#forEach-遍历循环" class="headerlink" title="_.forEach 遍历循环"></a>_.forEach 遍历循环</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _([<span class="number">1</span>, <span class="number">2</span>]).forEach(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    _.forEach([<span class="number">1</span>, <span class="number">3</span>] , <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(key,value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后<code>key</code>是元素的下标，当传入的是对象的时候，<code>key</code>是属性，<code>value</code>是值</p><h5 id="map-遍历循环执行某个方法"><a href="#map-遍历循环执行某个方法" class="headerlink" title="_.map 遍历循环执行某个方法"></a>_.map 遍历循环执行某个方法</h5><p><code>_.map()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(n)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> n * n;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map([<span class="number">4</span>, <span class="number">8</span>], square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(&#123; <span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">8</span> &#125;, square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64] (iteration order is not guaranteed)</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'barney'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'fred'</span> &#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// The `_.property` iteratee shorthand.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(users, <span class="string">'user'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; ['barney', 'fred']</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="isEmpty-检验值是否为空"><a href="#isEmpty-检验值是否为空" class="headerlink" title="_.isEmpty 检验值是否为空"></a>_.isEmpty 检验值是否为空</h5><p><code>_.isEmpty()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">null</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty(1);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty([1, 2, 3]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(&#123; <span class="string">'a'</span>: <span class="number">1</span> &#125;);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="find-、-filter-、-reject-查找属性"><a href="#find-、-filter-、-reject-查找属性" class="headerlink" title=".find()、.filter()、_.reject() 查找属性"></a><em>.find()、</em>.filter()、_.reject() 查找属性</h5><p><code>_.find()</code>、<code>_.filter()</code>、<code>_.reject()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'barney'</span>, <span class="string">'age'</span>: <span class="number">36</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'fred'</span>, <span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'active'</span>: <span class="literal">false</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'pebbles'</span>, <span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> o.age &lt; <span class="number">40</span>;</span></span><br><span class="line">    &#125;));</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="string">'active'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, <span class="string">'active'</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>_.find()</code>第一个返回真值的第一个元素。<br> <code>_.filter()</code>返回真值的所有元素的数组。<br> <code>_.reject()</code>是<code>_.filter</code>的反向方法，不返回真值的（集合）元素</p><h5 id="uniq-数组去重"><a href="#uniq-数组去重" class="headerlink" title="_.uniq 数组去重"></a>_.uniq 数组去重</h5><p><code>_.uniq(array)</code>创建一个去重后的array数组副本。</p><p>参数<br> <code>array (Array)</code>: 要检查的数组。</p><p>返回新的去重后的数组</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr1 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr2 = _.uniq(arr1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> newArr = [];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">            if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">                newArr.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> newArr;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr1);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr2);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(unique(arr1));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>_.uniqBy(array,[iteratee=_.identity])</code>这个方法类似 <code>_.uniq</code>，除了它接受一个 <code>iteratee</code>（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([<span class="number">2.1</span>, <span class="number">1.2</span>, <span class="number">2.3</span>], <span class="built_in">Math</span>.floor));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [2.1, 1.2]</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([&#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;], <span class="string">'x'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Math.floor</code>只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。</p><h5 id="template-模板插入"><a href="#template-模板插入" class="headerlink" title="_.template 模板插入"></a>_.template 模板插入</h5><p><code>_.template([string=&#39;&#39;], [options={}])</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data = [&#123;name: <span class="string">'戈德斯文'</span>&#125;, &#123;name: <span class="string">'柴硕'</span>&#125;, &#123;name: <span class="string">'杨海月'</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = _.template($(<span class="string">"#tpl"</span>).html());</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#container"</span>).html(t(data));</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    &lt;% _.each(obj,<span class="function"><span class="keyword">function</span><span class="params">(e,i)</span></span>&#123; %&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">e.name</span> %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="get-根据path找到object相关properties"><a href="#get-根据path找到object相关properties" class="headerlink" title="_.get 根据path找到object相关properties"></a>_.get 根据path找到object相关properties</h5><p><code>_.get(object, path, [defaultValue])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="string">'a'</span>: [&#123; <span class="string">'b'</span>: &#123; <span class="string">'c'</span>: <span class="number">3</span> &#125; &#125;] &#125;;</span><br><span class="line"> </span><br><span class="line">_.get(object, <span class="string">'a[0].b.c'</span>);</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"> </span><br><span class="line">_.get(object, [<span class="string">'a'</span>, <span class="string">'0'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"> </span><br><span class="line">_.get(object, <span class="string">'a.b.c'</span>, <span class="string">'default'</span>);</span><br><span class="line"><span class="comment">// =&gt; 'default'</span></span><br></pre></td></tr></table></figure><h5 id="concat-将一些array连在一起"><a href="#concat-将一些array连在一起" class="headerlink" title="_.concat 将一些array连在一起"></a>_.concat 将一些array连在一起</h5><p><code>_.concat(array, [values])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> other = _.concat(array, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(other);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3, [4]]</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">// =&gt; [1]</span></span><br></pre></td></tr></table></figure><h5 id="compact-移除falsey-values"><a href="#compact-移除falsey-values" class="headerlink" title="_.compact 移除falsey values"></a>_.compact 移除falsey values</h5><p><code>_.compact(array)</code></p><p>Creates an array with all falsey values removed. The values <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, and <code>NaN</code> are falsey.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="prototype-value"><a href="#prototype-value" class="headerlink" title="_.prototype.value"></a>_.prototype.value</h5><p><code>_.prototype.value()</code></p><p>Executes the chain sequence to resolve the unwrapped value.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).value();</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="prototype-filter-查找符合条件的"><a href="#prototype-filter-查找符合条件的" class="headerlink" title="_prototype.filter 查找符合条件的"></a>_prototype.filter 查找符合条件的</h5><p><code>_.filter(collection, [predicate=_.identity])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="string">'user'</span>: <span class="string">'barney'</span>, <span class="string">'age'</span>: <span class="number">36</span>, <span class="string">'active'</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'user'</span>: <span class="string">'fred'</span>,   <span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'active'</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line">_.filter(users, <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123; <span class="keyword">return</span> !o.active; &#125;);</span><br><span class="line"><span class="comment">// =&gt; objects for ['fred']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The `_.matches` iteratee shorthand.</span></span><br><span class="line">_.filter(users, &#123; <span class="string">'age'</span>: <span class="number">36</span>, <span class="string">'active'</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// =&gt; objects for ['barney']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The `_.matchesProperty` iteratee shorthand.</span></span><br><span class="line">_.filter(users, [<span class="string">'active'</span>, <span class="literal">false</span>]);</span><br><span class="line"><span class="comment">// =&gt; objects for ['fred']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The `_.property` iteratee shorthand.</span></span><br><span class="line">_.filter(users, <span class="string">'active'</span>);</span><br><span class="line"><span class="comment">// =&gt; objects for ['barney']</span></span><br></pre></td></tr></table></figure><h5 id="omit-object-paths-删除部分key-value"><a href="#omit-object-paths-删除部分key-value" class="headerlink" title="_.omit(object, [paths]) 删除部分key-value"></a>_.omit(object, [paths]) 删除部分key-value</h5><p><code>_.omit(object, [paths])</code>，和pick刚好相反，但是速度比pick要更慢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="number">3</span> &#125;;</span><br><span class="line"> </span><br><span class="line">_.omit(object, [<span class="string">'a'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123; 'b': '2' &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB快速入门</title>
      <link href="/2020/03/23/MongoDB%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/23/MongoDB%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mongo与MySQL"><a href="#Mongo与MySQL" class="headerlink" title="Mongo与MySQL"></a>Mongo与MySQL</h1><p>Mysql数据库有什么缺陷?</p><ul><li>关系型数据库表结构复杂,扩展性差;</li><li>需要较高的学习成本,复杂的表结构会产生更高的维护成本</li></ul><p>关系型数据库的”连接查询”会影响查询效率?</p><ul><li>会使查询效率变低</li></ul><p>连接查询效率低,为什么还要分表?</p><ul><li>分表可以减少数据冗余</li></ul><p>数据库可以不使用复杂的表结构么?</p><ul><li>可以,但要多消耗一些存储空间,mongodb(非关系型数据库)就为此而生</li></ul><p>Mongo优势</p><ul><li><p>mongo默认开启了新手模式,登录无需键入用户名和密码,只需要在终端输入<code>mongo</code>即可进入交互环境</p></li><li><p>mongo没有”表”的概念,也不用设计表(mongo使用”集合”存储 多个”键值对”,取代表的功能)</p></li><li><p>mongo有数据库的概念,但可以不经创建,直接使用(类似vim编辑器创建新文件,如果新文件中未添加数据,则新文件不会保存到硬盘;与vim不同的是,如果用户添加了数据,vim需要手动确认,保存文件,mongo会自动保存数据到相应的数据库)</p></li><li><p>mongo没有mysql中”记录”的概念,mongo使用”文档”存储任意数量的”键值对”信息(“记录”中的信息受表中各字段的约束,”文档”可以存放任意数量的键值对)</p></li><li><p>mongo无需手动设置”主键”,系统会自动为每一个”文档”自动添加”_id”键值对,保证数据的唯一性.</p></li></ul><h3 id="MongoDB-概念解析"><a href="#MongoDB-概念解析" class="headerlink" title="MongoDB 概念解析"></a>MongoDB 概念解析</h3><table><thead><tr><th align="center">SQL术语/概念</th><th align="center">MongoDB术语/概念</th><th align="center">解释/说明</th></tr></thead><tbody><tr><td align="center">database</td><td align="center">database</td><td align="center">数据库</td></tr><tr><td align="center">table</td><td align="center">collection</td><td align="center">数据库表/集合</td></tr><tr><td align="center">row</td><td align="center">document</td><td align="center">数据记录行/文档</td></tr><tr><td align="center">column</td><td align="center">field</td><td align="center">数据字段/域</td></tr><tr><td align="center">index</td><td align="center">index</td><td align="center">索引</td></tr><tr><td align="center">table joins</td><td align="center"></td><td align="center">表连接,MongoDB不支持</td></tr><tr><td align="center">primary key</td><td align="center">primary key</td><td align="center">主键,MongoDb自动将_id字段设置为主键</td></tr></tbody></table><h1 id="MongoDB基本用法"><a href="#MongoDB基本用法" class="headerlink" title="MongoDB基本用法"></a>MongoDB基本用法</h1><h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><h3 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1.服务端"></a>1.服务端</h3><ul><li><p>(1)开启服务</p><p><code>sudo service mongod start</code></p></li><li><p>(2)重启服务</p><p><code>sudo service mongod restart</code></p></li><li><p>(3)关闭服务</p><p><code>sudo service mongod stop</code></p></li></ul><h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2.客户端"></a>2.客户端</h3><ul><li><p>(1)登录数据库</p><p><code>mongo</code></p></li><li><p>(2)退出数据库</p><p><code>exit</code></p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-查看数据库"><a href="#1-查看数据库" class="headerlink" title="1.查看数据库"></a>1.查看数据库</h3><p><code>show dbs</code></p><h3 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2.使用数据库"></a>2.使用数据库</h3><ul><li><p>格式</p><p>use 数据库名</p></li><li><p>示例</p><p><code>use students</code></p></li></ul><h3 id="3-查看当前数据库"><a href="#3-查看当前数据库" class="headerlink" title="3.查看当前数据库"></a>3.查看当前数据库</h3><p><code>db</code></p><h3 id="4-删除当前数据库"><a href="#4-删除当前数据库" class="headerlink" title="4.删除当前数据库"></a>4.删除当前数据库</h3><p><code>db.dropDatabase()</code></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1.创建集合"></a>1.创建集合</h3><p>格式</p><ul><li>db.createCollection(“集合名称”)</li><li>db.createCollection(name, options) </li></ul><p>说明</p><ul><li>name: 要创建的集合名称</li><li>options: 可选参数, 指定有关内存大小及索引的选项</li></ul><p>示例(创建名为<code>stu</code>的集合)</p><ul><li><code>db.createCollection(&quot;stu&quot;)</code></li></ul><h3 id="2-查看当前数据库的集合"><a href="#2-查看当前数据库的集合" class="headerlink" title="2.查看当前数据库的集合"></a>2.查看当前数据库的集合</h3><p><code>show collections</code><br><code>show tables</code></p><h3 id="3-删除集合"><a href="#3-删除集合" class="headerlink" title="3.删除集合"></a>3.删除集合</h3><ul><li>格式<br><code>db.集合名.drop()</code></li><li>示例(移除名为<code>stu</code>的文档)<br><code>db.stu.drop()</code></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="1-插入文档"><a href="#1-插入文档" class="headerlink" title="1.插入文档"></a>1.插入文档</h3><ul><li><p>格式<br>db.集合名.insert({})</p></li><li><p>示例</p><p><code>db.stu.insert({name:&quot;李明&quot;,age:18,gender: true,birthday:&quot;1995-12-08&quot;,height:186.6})</code></p></li></ul><h3 id="2-删除文档"><a href="#2-删除文档" class="headerlink" title="2.删除文档"></a>2.删除文档</h3><p>remove() 方法的基本语法格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p>我们移除 name 为 ‘守护之心’ 的文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.gift.remove(&#123;&#39;name&#39;:&#39;守护之心&#39;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure><p>如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</span><br></pre></td></tr></table></figure><h3 id="3-修改文档"><a href="#3-修改文档" class="headerlink" title="3.修改文档"></a>3.修改文档</h3><p>update() 方法用于更新已存在的文档。语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。</li></ul><p>我们在集合 gift 中插入如下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.gift.insert(&#123;</span><br><span class="line">&quot;id&quot; : &quot;1&quot;,</span><br><span class="line">&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class="line">&quot;price&quot; : &quot;10&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着我们通过 update() 方法来更新礼物价格(price),并查看，更新成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.gift.update(&#123;&#39;id&#39;:&#39;1&#39;&#125;,&#123;$set:&#123;&#39;price&#39;:&#39;888&#39;&#125;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line">&gt; db.gift.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5d1a9e46b35668bf92c989e3&quot;),</span><br><span class="line">&quot;id&quot; : &quot;1&quot;,</span><br><span class="line">&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class="line">&quot;price&quot; : &quot;888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-查询文档"><a href="#4-查询文档" class="headerlink" title="4.查询文档"></a>4.查询文档</h3><p>MongoDB 查询数据的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection).pretty()</span><br></pre></td></tr></table></figure><p>以下实例我们查询了集合 col 中的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.gift.find().pretty();</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5d1951a6659f4eaa30bac84f&quot;),</span><br><span class="line">&quot;id&quot; : &quot;1&quot;,</span><br><span class="line">&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class="line">&quot;price&quot; : &quot;10&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符用于比较两个表达式并从mongoDB集合中获取数据。</p><p>MongoDB中条件操作符有：</p><ul><li>(&gt;) 大于 - $gt</li><li>(&lt;) 小于 - $lt</li><li>(&gt;=) 大于等于 - $gte</li><li>(&lt;= ) 小于等于 - $lte</li></ul><h2 id="type操作符"><a href="#type操作符" class="headerlink" title="$type操作符"></a>$type操作符</h2><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p><p>MongoDB 中可以使用的类型如下表所示：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>数字</strong></th><th align="left"><strong>备注</strong></th></tr></thead><tbody><tr><td align="left">Double</td><td align="left">1</td><td align="left"></td></tr><tr><td align="left">String</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">Object</td><td align="left">3</td><td align="left"></td></tr><tr><td align="left">Array</td><td align="left">4</td><td align="left"></td></tr><tr><td align="left">Binary data</td><td align="left">5</td><td align="left"></td></tr><tr><td align="left">Undefined</td><td align="left">6</td><td align="left">已废弃。</td></tr><tr><td align="left">Object id</td><td align="left">7</td><td align="left"></td></tr><tr><td align="left">Boolean</td><td align="left">8</td><td align="left"></td></tr><tr><td align="left">Date</td><td align="left">9</td><td align="left"></td></tr><tr><td align="left">Null</td><td align="left">10</td><td align="left"></td></tr><tr><td align="left">Regular Expression</td><td align="left">11</td><td align="left"></td></tr><tr><td align="left">JavaScript</td><td align="left">13</td><td align="left"></td></tr><tr><td align="left">Symbol</td><td align="left">14</td><td align="left"></td></tr><tr><td align="left">JavaScript (with scope)</td><td align="left">15</td><td align="left"></td></tr><tr><td align="left">32-bit integer</td><td align="left">16</td><td align="left"></td></tr><tr><td align="left">Timestamp</td><td align="left">17</td><td align="left"></td></tr><tr><td align="left">64-bit integer</td><td align="left">18</td><td align="left"></td></tr><tr><td align="left">Min key</td><td align="left">255</td><td align="left">Query with <code>-1</code>.</td></tr><tr><td align="left">Max key</td><td align="left">127</td><td align="left"></td></tr></tbody></table><p><strong>我们使用的数据库名称为”runoob” 我们的集合名称为”col”，以下为我们插入的数据。</strong></p><p>简单的集合”col”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.insert(&#123;</span><br><span class="line">    title: &#39;PHP 教程&#39;, </span><br><span class="line">    description: &#39;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。&#39;,</span><br><span class="line">    by: &#39;菜鸟教程&#39;,</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class="line">    tags: [&#39;php&#39;],</span><br><span class="line">    likes: 200</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.insert(&#123;title: &#39;Java 教程&#39;, </span><br><span class="line">    description: &#39;Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。&#39;,</span><br><span class="line">    by: &#39;菜鸟教程&#39;,</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class="line">    tags: [&#39;java&#39;],</span><br><span class="line">    likes: 150</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, </span><br><span class="line">    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,</span><br><span class="line">    by: &#39;菜鸟教程&#39;,</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class="line">    tags: [&#39;mongodb&#39;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用find()命令查看数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find()</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066542ade2f21f36b0313a"</span>), <span class="attr">"title"</span> : <span class="string">"PHP 教程"</span>, <span class="attr">"description"</span> : <span class="string">"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"php"</span> ], <span class="attr">"likes"</span> : <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066549ade2f21f36b0313b"</span>), <span class="attr">"title"</span> : <span class="string">"Java 教程"</span>, <span class="attr">"description"</span> : <span class="string">"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"java"</span> ], <span class="attr">"likes"</span> : <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"5606654fade2f21f36b0313c"</span>), <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>, <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"mongodb"</span> ], <span class="attr">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="MongoDB-操作符-type-实例"><a href="#MongoDB-操作符-type-实例" class="headerlink" title="MongoDB 操作符 - $type 实例"></a>MongoDB 操作符 - $type 实例</h3><p>如果想获取 “col” 集合中 title 为 String 的数据，你可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class="line">或</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066542ade2f21f36b0313a"</span>), <span class="attr">"title"</span> : <span class="string">"PHP 教程"</span>, <span class="attr">"description"</span> : <span class="string">"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"php"</span> ], <span class="attr">"likes"</span> : <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066549ade2f21f36b0313b"</span>), <span class="attr">"title"</span> : <span class="string">"Java 教程"</span>, <span class="attr">"description"</span> : <span class="string">"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"java"</span> ], <span class="attr">"likes"</span> : <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"5606654fade2f21f36b0313c"</span>), <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>, <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"mongodb"</span> ], <span class="attr">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="MongoDB-常用方法"><a href="#MongoDB-常用方法" class="headerlink" title="MongoDB 常用方法"></a>MongoDB 常用方法</h2><h3 id="MongoDB-Limit-方法"><a href="#MongoDB-Limit-方法" class="headerlink" title="MongoDB Limit() 方法"></a>MongoDB Limit() 方法</h3><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>limit()方法基本语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>集合 col 中的数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066542ade2f21f36b0313a"</span>), <span class="attr">"title"</span> : <span class="string">"PHP 教程"</span>, <span class="attr">"description"</span> : <span class="string">"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"php"</span> ], <span class="attr">"likes"</span> : <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"56066549ade2f21f36b0313b"</span>), <span class="attr">"title"</span> : <span class="string">"Java 教程"</span>, <span class="attr">"description"</span> : <span class="string">"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"java"</span> ], <span class="attr">"likes"</span> : <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"5606654fade2f21f36b0313c"</span>), <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>, <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>, <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="attr">"tags"</span> : [ <span class="string">"mongodb"</span> ], <span class="attr">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><p>以下实例为显示查询文档中的两条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)</span><br><span class="line">&#123; &quot;title&quot; : &quot;PHP 教程&quot; &#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。</p><hr><h3 id="MongoDB-Skip-方法"><a href="#MongoDB-Skip-方法" class="headerlink" title="MongoDB Skip() 方法"></a>MongoDB Skip() 方法</h3><p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>skip() 方法脚本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>以下实例只会显示第二条文档数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)</span><br><span class="line">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>注:</strong>skip()方法默认参数为 0 。</p><h3 id="MongoDB-sort-方法"><a href="#MongoDB-sort-方法" class="headerlink" title="MongoDB sort() 方法"></a>MongoDB sort() 方法</h3><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>sort()方法基本语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure><h1 id="MongoDB-索引"><a href="#MongoDB-索引" class="headerlink" title="MongoDB 索引"></a>MongoDB 索引</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p><h2 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h2><p>MongoDB使用 createIndex() 方法来创建索引。</p><blockquote><p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p></blockquote><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>createIndex()方法基本语法格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.collection.createIndex(keys, options)</span><br></pre></td></tr></table></figure><p>语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.createIndex(&#123;&quot;title&quot;:1&#125;)</span><br></pre></td></tr></table></figure><p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br></pre></td></tr></table></figure><p>createIndex() 接收可选参数，可选参数列表如下：</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">background</td><td align="left">Boolean</td><td align="left">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td></tr><tr><td align="left">unique</td><td align="left">Boolean</td><td align="left">建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td></tr><tr><td align="left">name</td><td align="left">string</td><td align="left">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td></tr><tr><td align="left">dropDups</td><td align="left">Boolean</td><td align="left"><strong>3.0+版本已废弃。</strong>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">sparse</td><td align="left">Boolean</td><td align="left">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">expireAfterSeconds</td><td align="left">integer</td><td align="left">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td></tr><tr><td align="left">v</td><td align="left">index version</td><td align="left">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td align="left">weights</td><td align="left">document</td><td align="left">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td></tr><tr><td align="left">default_language</td><td align="left">string</td><td align="left">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td></tr><tr><td align="left">language_override</td><td align="left">string</td><td align="left">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td></tr></tbody></table><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>在后台创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)</span><br></pre></td></tr></table></figure><p>通过在创建索引时加 background:true 的选项，让创建工作在后台执行</p><h1 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h1><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h2><p>MongoDB中聚合的方法使用aggregate()。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>aggregate() 方法的基本语法格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>集合中的数据如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: 'MongoDB Overview', </span><br><span class="line">   description: 'MongoDB is no sql database',</span><br><span class="line">   by_user: 'runoob.com',</span><br><span class="line">   url: 'http://www.runoob.com',</span><br><span class="line">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902d)</span><br><span class="line">   title: 'NoSQL Overview', </span><br><span class="line">   description: 'No sql database is very fast',</span><br><span class="line">   by_user: 'runoob.com',</span><br><span class="line">   url: 'http://www.runoob.com',</span><br><span class="line">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">   likes: 10</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902e)</span><br><span class="line">   title: 'Neo4j Overview', </span><br><span class="line">   description: 'Neo4j is no sql database',</span><br><span class="line">   by_user: 'Neo4j',</span><br><span class="line">   url: 'http://www.neo4j.com',</span><br><span class="line">   tags: ['neo4j', 'database', 'NoSQL'],</span><br><span class="line">   likes: 750</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">   &quot;result&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;runoob.com&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 1</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>以上实例类似sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select by_user, count(*) from mycol group by by_user</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。</p><p>下表展示了一些聚合的表达式:</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">$sum</td><td align="left">计算总和。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td></tr><tr><td align="left">$avg</td><td align="left">计算平均值</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td></tr><tr><td align="left">$min</td><td align="left">获取集合中所有文档对应值得最小值。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td></tr><tr><td align="left">$max</td><td align="left">获取集合中所有文档对应值得最大值。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td></tr><tr><td align="left">$push</td><td align="left">在结果文档中插入值到一个数组中。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td></tr><tr><td align="left">$addToSet</td><td align="left">在结果文档中插入值到一个数组中，但不创建副本。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td></tr><tr><td align="left">$first</td><td align="left">根据资源文档的排序获取第一个文档数据。</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td></tr><tr><td align="left">$last</td><td align="left">根据资源文档的排序获取最后一个文档数据</td><td align="left">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td></tr></tbody></table><h2 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h2><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p><p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个操作：</p><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3 id="管道操作符实例"><a href="#管道操作符实例" class="headerlink" title="管道操作符实例"></a>管道操作符实例</h3><p>1、$project实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $project : &#123;</span><br><span class="line">        title : 1 ,</span><br><span class="line">        author : 1 ,</span><br><span class="line">    &#125;&#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $project : &#123;</span><br><span class="line">        _id : 0 ,</span><br><span class="line">        title : 1 ,</span><br><span class="line">        author : 1</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>2.$match实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.articles.aggregate( [</span><br><span class="line">                        &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;,</span><br><span class="line">                        &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;</span><br><span class="line">                       ] );</span><br></pre></td></tr></table></figure><p>$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。</p><p>3.$skip实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $skip : 5 &#125;);</span><br></pre></td></tr></table></figure><p>经过$skip管道操作符处理后，前五个文档被”过滤”掉。</p><h1 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h1><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p><p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p><h2 id="为什么使用分片"><a href="#为什么使用分片" class="headerlink" title="为什么使用分片"></a>为什么使用分片</h2><ul><li>复制所有的写入操作到主节点</li><li>延迟的敏感数据会在主节点查询</li><li>单个副本集限制在12个节点</li><li>当请求量巨大时会出现内存不足。</li><li>本地磁盘不足</li><li>垂直扩展价格昂贵</li></ul><h2 id="MongoDB分片"><a href="#MongoDB分片" class="headerlink" title="MongoDB分片"></a>MongoDB分片</h2><p>下图展示了在MongoDB中使用分片集群结构分布：</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200323133206.png"  alt=""></p><p>上图中主要有如下所述三个主要组件：</p><ul><li><p>Shard:</p><p>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</p></li><li><p>Config Server:</p><p>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</p></li><li><p>Query Routers:</p><p>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p></li></ul><h2 id="分片实例"><a href="#分片实例" class="headerlink" title="分片实例"></a>分片实例</h2><p>分片结构端口分布如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shard Server 1：27020</span><br><span class="line">Shard Server 2：27021</span><br><span class="line">Shard Server 3：27022</span><br><span class="line">Shard Server 4：27023</span><br><span class="line">Config Server ：27100</span><br><span class="line">Route Process：40000</span><br></pre></td></tr></table></figure><p>步骤一：启动Shard Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0</span><br><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s1</span><br><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s2</span><br><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3</span><br><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log</span><br><span class="line">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27020 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s0.log --logappend --fork</span><br><span class="line">....</span><br><span class="line">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27023 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s3.log --logappend --fork</span><br></pre></td></tr></table></figure><p>步骤二： 启动Config Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config</span><br><span class="line">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27100 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;config.log --logappend --fork</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。</p><p>步骤三： 启动Route Process</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongos --port 40000 --configdb localhost:27100 --fork --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;route.log --chunkSize 500</span><br></pre></td></tr></table></figure><p>mongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p><p>步骤四： 配置Sharding</p><p>接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@100 shard]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongo admin --port 40000</span><br><span class="line">MongoDB shell version: 2.0.7</span><br><span class="line">connecting to: 127.0.0.1:40000&#x2F;admin</span><br><span class="line">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27020&quot; &#125;)</span><br><span class="line">&#123; &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">......</span><br><span class="line">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27029&quot; &#125;)</span><br><span class="line">&#123; &quot;shardAdded&quot; : &quot;shard0009&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">mongos&gt; db.runCommand(&#123; enablesharding:&quot;test&quot; &#125;) #设置分片存储的数据库</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">mongos&gt; db.runCommand(&#123; shardcollection: &quot;test.log&quot;, key: &#123; id:1,time:1&#125;&#125;)</span><br><span class="line">&#123; &quot;collectionsharded&quot; : &quot;test.log&quot;, &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure><p>步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000</p><h1 id="Node-js-连接-MongoDB"><a href="#Node-js-连接-MongoDB" class="headerlink" title="Node.js 连接 MongoDB"></a>Node.js 连接 MongoDB</h1><p>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。</p><p>本章节我们将为大家介绍如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。</p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mongodb</span><br></pre></td></tr></table></figure><p>接下来我们来实现增删改查功能。</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。</p><p>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/runoob"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据库已创建!"</span>);</span><br><span class="line">  db.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>我们可以使用 createCollection() 方法来创建集合：</p><h4 id="创建集合-1"><a href="#创建集合-1" class="headerlink" title="创建集合"></a>创建集合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'mongodb://localhost:27017/runoob'</span>;</span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已创建'</span>);</span><br><span class="line">    <span class="keyword">var</span> dbase = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbase.createCollection(<span class="string">'site'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"创建集合!"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数据库操作-CURD"><a href="#数据库操作-CURD" class="headerlink" title="数据库操作( CURD )"></a>数据库操作( CURD )</h2><p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 <strong>insertOne()</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj = &#123; <span class="attr">name</span>: <span class="string">"菜鸟教程"</span>, <span class="attr">url</span>: <span class="string">"www.runoob"</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertOne(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档插入成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">文档插入成功</span><br></pre></td></tr></table></figure><h4 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h4><p>var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“;  MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {    if (err) throw err;    var dbo = db.db(“runoob”);    var myobj = { name: “菜鸟教程”, url: “<a href="http://www.runoob&quot;" target="_blank" rel="noopener">www.runoob&quot;</a> };    dbo.collection(“site”).insertOne(myobj, function(err, res) {        if (err) throw err;        console.log(“文档插入成功”);        db.close();    }); });</p><p>执行以下命令输出就结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">文档插入成功</span><br></pre></td></tr></table></figure><p>从输出结果来看，数据已插入成功。</p><p>我们也可以打开 MongoDB 的客户端查看数据，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">runoob  0.000GB          # 自动创建了 runoob 数据库</span><br><span class="line">&gt; show tables</span><br><span class="line">site                     # 自动创建了 site 集合（数据表）</span><br><span class="line">&gt; db.site.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;), &quot;name&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;www.runoob&quot; &#125;</span><br></pre></td></tr></table></figure><p>如果要插入多条数据可以使用 <strong>insertMany()</strong>：</p><h2 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj =  [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'菜鸟工具'</span>, <span class="attr">url</span>: <span class="string">'https://c.runoob.com'</span>, <span class="attr">type</span>: <span class="string">'cn'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Google'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Facebook'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;</span><br><span class="line">       ];</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertMany(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"插入的文档数量为: "</span> + res.insertedCount);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>res.insertedCount 为插入的条数。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>). find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123; <span class="comment">// 返回集合中所有数据</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以下实例检索 name 为 “菜鸟教程” 的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">     <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find(whereStr).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; _id: 5a794e36763eb821b24db854,</span><br><span class="line">    name: '菜鸟教程',</span><br><span class="line">    url: 'www.runoob' &#125; ]</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 <a href="https://www.runoob.com：">https://www.runoob.com：</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">更新一条数据</span><br><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateOne(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档更新成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行成功后，进入 mongo 管理工具查看数据已修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.site.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;菜鸟教程&quot;,</span><br><span class="line">    &quot;url&quot; : &quot;https:&#x2F;&#x2F;www.runoob.com&quot;     &#x2F;&#x2F; 已修改为 https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要更新所有符合条的文档数据可以使用 <strong>updateMany()</strong>：</p><h4 id="更新多条数据"><a href="#更新多条数据" class="headerlink" title="更新多条数据"></a>更新多条数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"type"</span>:<span class="string">'en'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateMany(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">         <span class="built_in">console</span>.log(res.result.nModified + <span class="string">" 条文档被更新"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>result.nModified 为更新的条数。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>以下实例将 name 为 “菜鸟教程” 的数据删除 :</p><h4 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteOne(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档删除成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行成功后，进入 mongo 管理工具查看数据已删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.site.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果要删除多条语句可以使用 <strong>deleteMany()</strong> 方法</p><p>以下实例将 type 为 en 的所有数据删除 :</p><h4 id="删除多条数据"><a href="#删除多条数据" class="headerlink" title="删除多条数据"></a>删除多条数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123; <span class="attr">type</span>: <span class="string">"en"</span> &#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteMany(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(obj.result.n + <span class="string">" 条文档被删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>obj.result.n 删除的条数。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; type: 1 &#125;  &#x2F;&#x2F; 按 type 字段升序</span><br><span class="line">&#123; type: -1 &#125; &#x2F;&#x2F; 按 type 字段降序</span><br></pre></td></tr></table></figure><p>按 type 升序排列:</p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> mysort = &#123; <span class="attr">type</span>: <span class="number">1</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().sort(mysort).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="查询分页"><a href="#查询分页" class="headerlink" title="查询分页"></a>查询分页</h3><p>如果要设置指定的返回条数可以使用 <strong>limit()</strong> 方法，该方法只接受一个参数，指定了返回的条数。</p><h4 id="limit-：读取两条数据"><a href="#limit-：读取两条数据" class="headerlink" title="limit()：读取两条数据"></a>limit()：读取两条数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果要指定跳过的条数，可以使用 <strong>skip()</strong> 方法。</p><h4 id="skip-跳过前面两条数据，读取两条数据"><a href="#skip-跳过前面两条数据，读取两条数据" class="headerlink" title="skip(): 跳过前面两条数据，读取两条数据"></a>skip(): 跳过前面两条数据，读取两条数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().skip(<span class="number">2</span>).limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p>mongoDB 不是一个关系型数据库，但我们可以使用 <strong>$lookup</strong> 来实现左连接。</p><p>例如我们有两个集合数据分别为：</p><p>集合1：orders</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; _id: 1, product_id: 154, status: 1 &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>集合2：products</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; _id: 154, name: &#39;笔记本电脑&#39; &#125;,</span><br><span class="line">  &#123; _id: 155, name: &#39;耳机&#39; &#125;,</span><br><span class="line">  &#123; _id: 156, name: &#39;台式电脑&#39; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="lookup-实现左连接"><a href="#lookup-实现左连接" class="headerlink" title="$lookup 实现左连接"></a>$lookup 实现左连接</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://127.0.0.1:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">  dbo.collection(<span class="string">'orders'</span>).aggregate([</span><br><span class="line">    &#123; <span class="attr">$lookup</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">'products'</span>,            <span class="comment">// 右集合</span></span><br><span class="line">         localField: <span class="string">'product_id'</span>,    <span class="comment">// 左集合 join 字段</span></span><br><span class="line">         foreignField: <span class="string">'_id'</span>,         <span class="comment">// 右集合 join 字段</span></span><br><span class="line">         <span class="keyword">as</span>: <span class="string">'orderdetails'</span>           <span class="comment">// 新生成字段（类型array）</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ]).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p>我们可以使用 <strong>drop()</strong> 方法来删除集合：</p><h4 id="drop"><a href="#drop" class="headerlink" title="drop()"></a>drop()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"mongodb://localhost:27017/"</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="comment">// 删除 test 集合</span></span><br><span class="line">    dbo.collection(<span class="string">"test"</span>).drop(<span class="function"><span class="keyword">function</span>(<span class="params">err, delOK</span>) </span>&#123;  <span class="comment">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">if</span> (delOK) <span class="built_in">console</span>.log(<span class="string">"集合已删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><p>作者：Jay_huaxiao<br>链接：<a href="https://juejin.im/post/5d1883a05188255eea62e096" target="_blank" rel="noopener">https://juejin.im/post/5d1883a05188255eea62e096</a><br>来源：掘金</p></li><li><p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/a95c6b21c382" target="_blank" rel="noopener">https://www.jianshu.com/p/a95c6b21c382</a><br>来源：简书</p></li><li><p>来源：菜鸟教程</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础简明教程</title>
      <link href="/2020/03/22/Git%E5%9F%BA%E7%A1%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/22/Git%E5%9F%BA%E7%A1%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>部分来源：<a href="https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/" target="_blank" rel="noopener">颜海镜</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>版本控制工具是什么</p><p>软件，用来保存软件开发过程中各个版本</p></li><li><p>为什么要用版本控制工具</p><ol><li>有利于打造自己的核心竞争力，积累经验保存项目</li><li>能够提供以往版本记录，方便恢复数据</li><li>分清责任不背锅</li><li>科学合理的规划工作</li><li>进行项目精度和进度的把控</li></ol></li><li><p>SVN 和 git 成为了主流</p><ol><li><p>SVN的优缺点</p><p>优点：</p><ol><li>管理方便，逻辑明确，符合一般人思维逻辑</li><li>集中式管理，保证代码一致性</li></ol><p>缺点：</p><ol><li>给服务器压力较大</li><li>如果不能连接到服务器则基本不能工作</li><li>不太适合人数较多的开源开发</li></ol></li><li><p>Git的优缺点</p><p>优点：</p><ol><li>适合多人分布式的开发</li><li>适合灵活快速的开发</li><li>给服务器压力小，强调个体</li><li>可进行离线工作</li><li>非常容易解决冲突</li></ol><p>缺点：</p><ol><li>学习周期比较长</li><li>不太符合常规的思维</li><li>代码的保密性比较差，每人都有一份代码和历史改动</li></ol></li><li><p>如何选择？</p><p>看应用场景，进行综合比较：</p><ul><li>对权限要求比较高，则进行集中式管理，使用SVN</li><li>对代码写作要求比较高，则使用Git</li></ul></li></ol></li></ol><h2 id="Git常用概念"><a href="#Git常用概念" class="headerlink" title="Git常用概念"></a>Git常用概念</h2><h3 id="仓库（书店）"><a href="#仓库（书店）" class="headerlink" title="仓库（书店）"></a>仓库（书店）</h3><p>所有版本的代码都在仓库里</p><h3 id="分支（书架）"><a href="#分支（书架）" class="headerlink" title="分支（书架）"></a>分支（书架）</h3><p>不同功能代码存放的地方（可能是测试代码）</p><h3 id="提交（书）"><a href="#提交（书）" class="headerlink" title="提交（书）"></a>提交（书）</h3><p>每一个版本的代码</p><h3 id="三区"><a href="#三区" class="headerlink" title="三区"></a>三区</h3><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200323001246.png"  alt=""></p><ol><li><p>工作区</p><p>工作的目录</p></li><li><p>暂存区</p><p>项目目录和仓库之间的暂时存储区域 桥梁</p></li><li><p>仓库区</p><p>存放着所有的版本</p></li><li><p>远程仓库</p><p>github上的仓库</p></li></ol><h2 id="Git的基础操作"><a href="#Git的基础操作" class="headerlink" title="Git的基础操作"></a>Git的基础操作</h2><ol><li><p>新建一个文件夹作为repo目录</p></li><li><p>在目录中使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化Git目录</p></li><li><p>创建一个文件，如：helloworld.html</p></li><li><p>查看文件状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>这时候应该会查看到有一个文件被修改，并且被标记为untracked file</p></li><li><p>加入文件</p><p>第一种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add hellworld.html</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>之后状态应该已经不同，会发现文件已经被放入暂存区</p><p>第二种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>表示暂存所有文件</p></li><li><p>将暂存区文件提交到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'你的注释'</span></span><br></pre></td></tr></table></figure></li><li><p>假如你在期间再次更改了文件，则需要重复步骤5和6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>可以查看版本</p></li><li><p>假如想回退到之前的版本，则copy之前的版本id，id可在git log中查到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tty@MacBook-Pro % git <span class="built_in">log</span></span><br><span class="line">commit 926f60662797c96ccc3eeb4d99ec09d6d5db3547 (HEAD -&gt; master, origin/master)</span><br><span class="line">Date:   Sun Mar 22 16:25:10 2020 -0700</span><br><span class="line"></span><br><span class="line">    Update 2020-02-03-Bloomberg面试见闻.md</span><br><span class="line">    </span><br><span class="line">commit c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br><span class="line">Date:   Sun Mar 22 16:15:48 2020 -0700</span><br><span class="line"></span><br><span class="line">    update paginate</span><br></pre></td></tr></table></figure><p>此时如果想回到上一次记录，则使用上此的commit id， 如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br></pre></td></tr></table></figure><p>假如你不想指定具体的某一次记录，而是想单纯的回到上一次的记录，则有更方便的选择</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure></li><li><p>你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>假设有一被修改多次的<code>readme.txt</code>文件，我们看一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">   HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">   Git is a distributed version control system.</span><br><span class="line">   Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">   commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">   Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">   Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line">   </span><br><span class="line">       add distributed</span><br><span class="line">   </span><br><span class="line">   commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">   Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">   Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line">   </span><br><span class="line">       wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">   HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">   Git is a distributed version control system.</span><br><span class="line">   Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">   │HEAD│</span><br><span class="line">   └────┘</span><br><span class="line">      │</span><br><span class="line">      └──&gt; ○ append GPL</span><br><span class="line">           │</span><br><span class="line">           ○ add distributed</span><br><span class="line">           │</span><br><span class="line">           ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">   │HEAD│</span><br><span class="line">   └────┘</span><br><span class="line">      │</span><br><span class="line">      │    ○ append GPL</span><br><span class="line">      │    │</span><br><span class="line">      └──&gt; ○ add distributed</span><br><span class="line">           │</span><br><span class="line">           ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">   e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">   1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">   e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">   eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p></li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>当你在开发测试内容，或是新功能时，可能你就需要一个分支，以避免影响master branch的稳定性</p><p>分支的概念在各个版本控制系统中早已存在，分支对于团队协作开发来说作用是非常大的，如：</p><ul><li><p>当一个项目还是1.0版时，开发团队可能要同时进行1.1版和2.0版的开发，此时，代码就会出现较大分歧，这时就需要用到分支了，不同的任务组在各自不同的分支上开发，互相之间不会影响。</p></li><li><p>需要向项目中添加一个新功能，一般的团队都不会直接在主分支上修改而是新建一个branch，在上面更改代码，这样做的好处一是保证主线代码的完整性和可用性，也就是说，主线上都是稳定的代码，可以直接拿来发布。二是避免出现其他问题。</p></li><li><p>发布是所有的功能模块的集成，分支可能是零散功能的半成品。</p></li><li><p>万一出现冲突很严重，或者出现各种情况而造成当前的分支出了问题，冲突解决起来很麻烦，如果有一个分支始终保留着最新的稳定版本,最多就是吧当前分支删掉,从那个稳定分支重新分一支出来,这样处理起来更方便。</p></li><li><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的风险，又或者丢失向领导汇报工作进度的风险。有了分支后，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p></li></ul><h3 id="分支特性"><a href="#分支特性" class="headerlink" title="分支特性"></a>分支特性</h3><ul><li><p>Git的技术可以说是非常强大，说一切开发都依赖于分支一点都不过分。一般项目的master分支都是稳定的代码，可以直接发布或者被项目之外的人使用。</p></li><li><p>新特性和BUG修改都在不同的分支上进行开发和测试，这样规范了整个软件的开发流程。</p></li></ul><p>分支之间的互不影响这种特性可以增加团队合作的效率。</p><ul><li><p>Git分支的另外一个重要特性就是可以合并不同软件仓库（fork）的分支。如：开发团队有一个主软件仓库，开发者可以fork这个仓库，相当于克隆了一个私有的软件仓库，然后开发者就可以在自己的软件仓库中建立分支并开发测试，测试完毕之后，可以向主软件仓库提交merge request，这样新开发的特性就会被合并到主软件仓库的某个分支中。这种特性极大地推动了开源项目，多年前参加开源项目都是神话，自从Git出现后，每个人都可能成为开源项目的贡献者，就是基于这种特性。</p></li><li><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，让人无法忍受，结果分支功能成了摆设，基本都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p></li></ul><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在版本回退里中已经知道每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。<br>如果没有创建过任何分支的情况下，Git中只有一个分支，叫主分支（即master分支）。</p><p>当我们创建新的分支，例如test时，Git新建了一个指针叫test，指向master相同的提交，再把HEAD指向test，就表示当前分支在test上。</p><p>注：Git创建一个分支很快，因为除了增加一个test指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>假如我们在test上的工作完成了，就可以把test合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向test的当前提交，就完成了合并。</p><p>注：Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，也可以删除test分支。删除test分支就是把test指针给删掉，删掉后，就剩下了一条master分支了。</p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p><strong>创建并切换分支 （git checkout -b test ）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Switched to a new branch ‘<span class="built_in">test</span>’</span><br></pre></td></tr></table></figure><p>注：git checkout命令加上-b参数表示创建并切换，相当于执行了以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="built_in">test</span></span><br><span class="line">$ git checkout <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Switched to branch ‘<span class="built_in">test</span>’</span><br></pre></td></tr></table></figure><p><strong>查看当前分支</strong> （ git branch ）<br>然后，用git branch命令查看当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line">*<span class="built_in">test</span></span><br><span class="line">master</span><br></pre></td></tr></table></figure><p>git branch命令会列出所有分支，当前分支前面会标一个*号。此时，我们就可以在test分支上进行开发并正常提交。</p><p><strong>分支的切换 （git checkout master ）</strong></p><p>如果在test分支上完成了开发，我们可以切换回master分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">Switched to branch ‘master’</span><br></pre></td></tr></table></figure><p>注：当切换回master分支后，其实内容是不会有任何改变的，因为你所做的修改和提交工作全部在test分支上完成，而master分支的提交点是没有任何改变的。</p><p><strong>分支合并 （git merge test）</strong></p><p>我们试着把test分支下的工作成果合并到master主分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge <span class="built_in">test</span></span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line">……. | 1 +</span><br><span class="line">…. file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>git merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支test合并过来。合并后，可以发现master主分支的内容和test分支的最新提交是完全一样的。</p><p>注：上面的Fast-forward信息是Git告诉我们，这次合并是“快进模式”，也就是直接把master指向test的当前提交，所以合并速度非常快，当然也不是每次合并都能Fast-forward，后续会总结其他方式的合并。</p><p><strong>删除分支 （git branch -d test）</strong></p><p>合并完成后，若不再需要test分支，也可以放心的删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Deleted branch <span class="built_in">test</span> (was fec145a).</span><br></pre></td></tr></table></figure><p>删除后，再次运行 git branch 命令，可以看到只剩下master分支了。</p><p>建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。</p><h3 id="图解4种git合并分支方法"><a href="#图解4种git合并分支方法" class="headerlink" title="图解4种git合并分支方法"></a>图解4种git合并分支方法</h3><p>彼此分开的世界也能随时交叉合并，世界就这样开开合合，偶会需要解决合并冲突</p><p>git中的分支非常的轻量，其实就是一个文件，里面记录了分支所指向的commit id，下图中有两个分支分别是master和test，他们都指向了A2这个提交，HEAD是一个特殊的指针，他永远指向你当前所在的位置；有时候你可能不在某一个分支上，不要惊慌，你随时有权利去你想去的分支，git赋予了你新建，切换分支的能力</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200323005510.png"  alt=""></p><p>然后有时候世界并不总如上图那般美好，面对分叉的两个分支，git新手总是一脸茫然，本文我将讲述git中合并分支的方法</p><p>在git中合并分支有三种方法，分别是merge，rebase，cherry-pick，而其中merge又有三种区别，下面将一一介绍</p><h4 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h4><p>如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/498.gif"  alt=""></p><h4 id="no-ff"><a href="#no-ff" class="headerlink" title="no-ff"></a>no-ff</h4><p>如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上<code>--no-ff</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge –no-ff test</span><br></pre></td></tr></table></figure><p>这种合并方法会在master分支上新建一个提交节点，从而完成合并</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/499.gif"  alt=""></p><h4 id="squash"><a href="#squash" class="headerlink" title="squash"></a>squash</h4><p>svn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点</p><p>squash和no-ff非常类似，区别只有一点不会保留对合入分支的引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge –squash <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/500.gif"  alt=""></p><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><p>当要合并两个分叉的分支时，merge的方式是将待合入分支和当前分支不同的部分，在当前分支新建节点，如下图所示</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200323005658.png"  alt=""></p><p>rebase与merge不同，rebase会将合入分支上超前的节点在待合入分支上重新提交一遍，如下图，B1 B2会变为B1’ B2’，看起来会变成线性历史</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200323005638.png"  alt=""></p><h4 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h4><p>这命令简直就是神器，给你自由，你想把那个节点merge过来就把那个节点merge过来，其合入的不是分支而是提交节点</p><h2 id="项目托管与协作"><a href="#项目托管与协作" class="headerlink" title="项目托管与协作"></a>项目托管与协作</h2><p>托管：把项目或者代码放到服务器上以便其他人员能够使用</p><p>协作：针对项目，不同的人进行操作</p><p>从github或gitlab上克隆的库无需git init命令，已经初始化完成</p><p>首次提交，在本地commit之后，再做远程提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/id/repo.git <span class="comment">#这里的id和repo是你github的id和repo</span></span><br><span class="line">git push -u origin master <span class="comment">#这里会有github验证</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门JavaScript笔记</title>
      <link href="/2020/03/22/%E5%85%A5%E9%97%A8JavaScript%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/22/%E5%85%A5%E9%97%A8JavaScript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p><p>本笔记基于udemy课程JavaScript basics for beginners，你可以在YouTube上看到相关试听视频</p><p>部分基于udemy课程Modern JavaScript From The Beginning</p><p>部分笔记来源：<a href="https://wangdoc.com/javascript/index.html" target="_blank" rel="noopener">JavaScript</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank" rel="noopener">MDN</a></p><p>关于ES6：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6</a></p><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ol><li>安装live server 插件 in vscode</li><li>在项目新建一个hello world的html，右键你的html然后用live server打开</li><li>假如你html有改动，在html中的内容会自动刷新到live server</li></ol><p>推荐：bracket pair colorizer、JavaScript (ES6) code snippets</p><p>基础：</p><ul><li><p>js脚本可以添加到head或添加到body，建议添加到body的末尾</p></li><li><p>chrome中alt+command+i打开console</p></li></ul><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>在ES6之前，js常常用var来定义变量，但在ES6之后var不再被推荐，建议使用let来定义变量</p><p>在JavaScript中假如你没有define一个变量则其值为undefined</p><p>在JavaScript中一般用单引号来括起string</p><p>Variable不能是保留字（reserved keyword），最好有意义，并且不以数字开头，不能有空格和短杠-（hyphen），命名方式同样遵循camel notation（驼峰命名法），variable都是case-sensitive的</p><p>可以同时initialize多个变量，用逗号隔开</p><h3 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h3><p>假如你使用的是const而不是var，那么你的变量不能被修改</p><h2 id="Primitive-types"><a href="#Primitive-types" class="headerlink" title="Primitive types"></a>Primitive types</h2><p>JavaScript共有两种value可以assign给variable，一种是primitives(aka. value types)，一种是reference type，</p><h3 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h3><ul><li>String</li><li>Number（在JavaScript中没有float，double这种类型，只有统一的number）</li><li>Boolean</li><li>undefined（是一种type，同时是一个value）</li><li>null</li></ul><p>假如当前我们有一个变量，我们没有它的值，但是知晓这个variable将来是什么type，这时候我们就将它设为null，而不是设为undefined</p><h3 id="Dynamic-typing"><a href="#Dynamic-typing" class="headerlink" title="Dynamic typing"></a>Dynamic typing</h3><p>编程语言有两种，一种是static，一种是dynamic。在static language里，变量设置了type之后就不能再更改。但是在JavaScript中，变量能被修改为其他数据类型。</p><h2 id="Reference-types"><a href="#Reference-types" class="headerlink" title="Reference types"></a>Reference types</h2><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Mosh'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name = <span class="string">'Mosh'</span>, <span class="comment">//value pair, key is called properties</span></span><br><span class="line">  age = <span class="number">30</span></span><br><span class="line">&#125;; <span class="comment">// this is an object literal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Two way to access the properties</span></span><br><span class="line"><span class="comment">// 1. Dot notation</span></span><br><span class="line">person.name = <span class="string">'John'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Bracket notation</span></span><br><span class="line">person[<span class="string">'name'</span>] = <span class="string">'Mary'</span>;</span><br></pre></td></tr></table></figure><p>Dot notation is more concise and shorter, and it should be your default notation</p><p>But sometimes the variable you wanna use might be dynamic, like</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selection = <span class="string">'name'</span>;</span><br><span class="line">person[selection] = <span class="string">'Mary'</span></span><br></pre></td></tr></table></figure><p>In this case the second notation would be better</p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  selectedColors = [<span class="string">'red'</span>,<span class="string">'blue'</span>]; <span class="comment">// these square brackets are called array literal</span></span><br><span class="line">selectedColors[<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">// we can store different types of data into the array</span></span><br></pre></td></tr></table></figure><p>Type of the array is object</p><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">parameter</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello '</span>) + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(Your argument);</span><br></pre></td></tr></table></figure><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>I will ignore the basic common stuff</p><h3 id="Arithmetic-Operators"><a href="#Arithmetic-Operators" class="headerlink" title="Arithmetic Operators"></a>Arithmetic Operators</h3><ul><li>Addition + (increment ++)</li><li>Subtraction - (decrement –)</li><li>Multiplication *</li><li>Division /</li><li>Remainder of division %</li><li>exponentiation **</li></ul><h3 id="Assignment-Operators"><a href="#Assignment-Operators" class="headerlink" title="Assignment Operators"></a>Assignment Operators</h3><ul><li>+=</li><li>-=</li><li>=</li></ul><h3 id="Comparasion-Operators"><a href="#Comparasion-Operators" class="headerlink" title="Comparasion Operators"></a>Comparasion Operators</h3><ul><li>&gt;=</li><li>&lt;=</li><li>==</li><li>===(strict equality operator, have the same type and the same value)</li><li>!==</li><li>==(loose equality operator)</li></ul><p>=== 判断规则:</p><ol><li>如果类型不同，就[不相等]</li><li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）</li><li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。</li><li>如果两个值都是true，或者都是false，那么[相等]。</li><li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。</li><li>如果两个值都是null，或者都是undefined，那么[相等]。</li></ol><p>== 判断规则：</p><ol><li>如果两个值类型相同，进行 === 比较。</li><li>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：</li><li>如果一个是null、一个是undefined，那么[相等]。</li><li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。</li><li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。</li><li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）</li><li>任何其他组合，都[不相等]。</li></ol><h3 id="Ternary-Operators"><a href="#Ternary-Operators" class="headerlink" title="Ternary Operators"></a>Ternary Operators</h3><p>: ? 三元运算符</p><h3 id="Logic-Operators"><a href="#Logic-Operators" class="headerlink" title="Logic Operators"></a>Logic Operators</h3><ul><li><p>: ?</p></li><li><p>&amp;&amp;</p></li><li><p><code>||</code></p></li></ul><p>the result of a logic operators is not always a boolean value. Eg, false || ‘Mosh’ === ‘Mosh’</p><h4 id="Falsy"><a href="#Falsy" class="headerlink" title="Falsy"></a>Falsy</h4><ol><li>undefined</li><li>null</li><li>0</li><li>false</li><li>‘’</li><li>NaN</li></ol><p>Anything else is truthy</p><p>it will return the first truthy value in the<code>||</code>, eg, false <code>||</code> 1 <code>||</code> 2, it returns 1</p><h3 id="Bitwise-Operators"><a href="#Bitwise-Operators" class="headerlink" title="Bitwise Operators"></a>Bitwise Operators</h3><ul><li><code>|</code> bitwise or</li><li><code>&amp;</code> bitwise and</li></ul><h2 id="Control-flow"><a href="#Control-flow" class="headerlink" title="Control flow"></a>Control flow</h2><p>I will ignore the parts which is the same as Java (if…else…, while, do…while, switch)</p><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">'Mosh'</span>;</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person)</span><br><span class="line"><span class="built_in">console</span>.log(key, person[key]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="comment">//get you the index with 'in'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> colors)</span><br><span class="line">  <span class="built_in">console</span>.log(index, colors[index]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get you the data inside of the array with 'of'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> colors)</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in 和 of的区别就在于，in是在iterate key，而of在iterate value</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an example of object</span></span><br><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  radius: <span class="number">1</span>,</span><br><span class="line">  loaction: &#123;</span><br><span class="line">  x: <span class="number">1</span>;</span><br><span class="line">  y: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">  isVisible: <span class="literal">true</span>,</span><br><span class="line">  draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.draw();</span><br></pre></td></tr></table></figure><h3 id="Factory-Function"><a href="#Factory-Function" class="headerlink" title="Factory Function"></a>Factory Function</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    radius,</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using this way to create object, the object.constructor will shows you Object()</p><h3 id="Constructor-Function"><a href="#Constructor-Function" class="headerlink" title="Constructor Function"></a>Constructor Function</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This one looks like a class, but the factory function looks like a function</p><p>构造函数一般首字母大写</p><h3 id="Dynamic-Nature"><a href="#Dynamic-Nature" class="headerlink" title="Dynamic Nature"></a>Dynamic Nature</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  radius: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.color = <span class="string">'yello'</span>; <span class="comment">// add properties</span></span><br><span class="line">circle.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> circle.color; <span class="comment">// remove properties</span></span><br><span class="line"><span class="keyword">delete</span> circle.draw;</span><br></pre></td></tr></table></figure><h3 id="Cloning-an-object"><a href="#Cloning-an-object" class="headerlink" title="Cloning an object"></a>Cloning an object</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> another = <span class="built_in">Object</span>.assign(newObj, oldObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> another = &#123;...target&#125;; <span class="comment">// three dots means all the properties inside of the old object</span></span><br></pre></td></tr></table></figure><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><p>All the process is automatic and you cannot clean the memory mannualy.</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>There is primitive string and object String, primitive string can also use functions, and they will be wrapped as String object</p><p>Escape character(转义字符)</p><p>在JavaScript中，引号间的换行会被记录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">const</span> another =</span><br><span class="line">‘This is my $&#123;message&#125;</span><br><span class="line"><span class="string">'first'</span> message<span class="string">';</span></span><br></pre></td></tr></table></figure><p>输出会是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is my hello</span><br><span class="line">&#39;first&#39; message</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h4><h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大毛'</span>, <span class="string">'白色'</span>);</span><br><span class="line"></span><br><span class="line">cat1.name <span class="comment">// '大毛'</span></span><br><span class="line">cat1.color <span class="comment">// '白色'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p><p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.meow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵喵'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大毛'</span>, <span class="string">'白色'</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">'二毛'</span>, <span class="string">'黑色'</span>);</span><br><span class="line"></span><br><span class="line">cat1.meow === cat2.meow</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p><p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p><h5 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h5><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p><p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.prototype <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p><p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = <span class="string">'white'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">'二毛'</span>);</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'white'</span></span><br><span class="line">cat2.color <span class="comment">// 'white'</span></span><br></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p><p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// "yellow"</span></span><br><span class="line">cat2.color <span class="comment">// "yellow"</span></span><br></pre></td></tr></table></figure><p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p><p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'black'</span></span><br><span class="line">cat2.color <span class="comment">// 'yellow'</span></span><br><span class="line">Animal.prototype.color <span class="comment">// 'yellow';</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p><p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is walking'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p><p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p><p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p><p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p><p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyArray = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">MyArray.prototype.constructor = MyArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> MyArray();</span><br><span class="line">mine.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mine.length <span class="comment">// 3</span></span><br><span class="line">mine <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p><p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p><h5 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">'constructor'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p><p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.constructor === F <span class="comment">// true</span></span><br><span class="line">f.constructor === <span class="built_in">RegExp</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p><p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constr</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Constr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.constructor();</span><br><span class="line">y <span class="keyword">instanceof</span> Constr <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constr.prototype.createCopy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p><p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// false</span></span><br><span class="line">Person.prototype.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p><p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  method1: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: C,</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">C.prototype.method1 = <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p><p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line">f.constructor.name <span class="comment">// "Foo"</span></span><br></pre></td></tr></table></figure><h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> Vehicle</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p><p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p><p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p><p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p><p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p><p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p><p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="keyword">this</span>._foo = foo;</span><br><span class="line">    <span class="keyword">this</span>._bar = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p><h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p><p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p><p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p><p>举例来说，下面是一个<code>Shape</code>构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Shape;</span><br><span class="line">  <span class="keyword">this</span>.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure><p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hello = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.world = <span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="keyword">this</span>);</span><br><span class="line">  M2.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// 'hello'</span></span><br><span class="line">s.world <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p><p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p><p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p><h5 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h5><p>模块是实现特定功能的一组属性和方法的封装。</p><p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">　_count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure><p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h5 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">     buffer.push(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.join(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._buffer = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: StringBuilder,</span><br><span class="line">  add: function (str) &#123;</span><br><span class="line">    <span class="keyword">this</span>._buffer.push(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._buffer.join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p><h5 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(module1._count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p><h5 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure><p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure><p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p><h5 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h5><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p><p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure><p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p><p>立即执行函数还可以起到命名空间的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dieCarouselDie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//attach to the global scope</span></span><br><span class="line">  <span class="built_in">window</span>.finalCarousel = &#123;</span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)( jQuery, <span class="built_in">window</span>, <span class="built_in">document</span> );</span><br></pre></td></tr></table></figure><p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="adding-element"><a href="#adding-element" class="headerlink" title="adding element"></a>adding element</h3><p>及时你使用了const来作为array，你虽然不能reassign this array to something else，但是你可以增加删除其中的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//add at the end</span></span><br><span class="line">numbers.push(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//add at the beginning</span></span><br><span class="line">numbers.unshift(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//middle</span></span><br><span class="line"><span class="comment">//第一个：位置，第二：删除的元素数量，第三以及之后：添加的内容</span></span><br><span class="line">numbers.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><h3 id="Find-element"><a href="#Find-element" class="headerlink" title="Find element"></a>Find element</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it is easy to find a primitive type</span></span><br><span class="line">numbers.includes(<span class="number">1</span>);</span><br><span class="line">numbers.indexOf(<span class="number">1</span>);</span><br><span class="line">numbers.lastIndexOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// to find an object</span></span><br><span class="line"><span class="keyword">const</span> course = courses.find(<span class="function"><span class="keyword">function</span>(<span class="params">course</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> course.name === <span class="string">'xyz'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Arrow-functions"><a href="#Arrow-functions" class="headerlink" title="Arrow functions"></a>Arrow functions</h3><p>looks like java lambda</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> course = courses.find(<span class="function"><span class="params">course</span> =&gt;</span> course.name === <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><h3 id="Removing-Element"><a href="#Removing-Element" class="headerlink" title="Removing Element"></a>Removing Element</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//end</span></span><br><span class="line">numbers.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//beginning</span></span><br><span class="line">numbers.shift();</span><br><span class="line"></span><br><span class="line"><span class="comment">//middle</span></span><br><span class="line">numbers.splice(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//first is offset, second is the number of elements you want to delete</span></span><br></pre></td></tr></table></figure><h3 id="Empty-an-array"><a href="#Empty-an-array" class="headerlink" title="Empty an array"></a>Empty an array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution 1</span></span><br><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> num1 = num;</span><br><span class="line"></span><br><span class="line">num = []; <span class="comment">//in this solution, num is reassigned but num1 is still pointing to the num, so the info of num will not be garbage collected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution 2</span></span><br><span class="line">numbers.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution 3</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, numbers.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution 4</span></span><br><span class="line"><span class="keyword">while</span> (numbers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  numbers.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Combing-Arrays"><a href="#Combing-Arrays" class="headerlink" title="Combing Arrays"></a>Combing Arrays</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> second = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combined = first.concat(second);</span><br><span class="line"><span class="keyword">const</span> sllice = combined.slice(<span class="number">2</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="Iterate-Array"><a href="#Iterate-Array" class="headerlink" title="Iterate Array"></a>Iterate Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line">nums.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(number);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// after es6</span></span><br><span class="line">nums.forEach(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number));</span><br><span class="line">nums.forEach(<span class="function">(<span class="params">number, index</span>) =&gt;</span> <span class="built_in">console</span>.log(index, number)); <span class="comment">// the second value is index, the first is the value</span></span><br></pre></td></tr></table></figure><h3 id="Join-array"><a href="#Join-array" class="headerlink" title="Join array"></a>Join array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> joined = numbers.join(<span class="string">'-'</span>);<span class="comment">//default is comma</span></span><br><span class="line"><span class="comment">// result is 1-2-3</span></span><br></pre></td></tr></table></figure><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">numbers.sort();</span><br><span class="line">numbers.reverse();</span><br></pre></td></tr></table></figure><h3 id="Every-and-some"><a href="#Every-and-some" class="headerlink" title="Every and some"></a>Every and some</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> k = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">// all passed then return true, else return false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">// at leaset one match then return true, else return false</span></span><br></pre></td></tr></table></figure><h3 id="Filter-an-array"><a href="#Filter-an-array" class="headerlink" title="Filter an array"></a>Filter an array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filtered = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filtered = numbers.filter(<span class="function"><span class="params">value</span> =&gt;</span> value &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = filtered.map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123;<span class="attr">value</span> : n&#125;));</span><br></pre></td></tr></table></figure><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">sum</span> = <span class="title">numbers</span>.<span class="title">reduce</span>(<span class="params">(accumulator, currentValue</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">calcRectArea(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// run it before the declaration is okay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a function declaration</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcRectArea</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRectArea(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// run it before the expression then there will be error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a function expression, and is an anonymous(there is also named) function expression</span></span><br><span class="line"><span class="keyword">const</span> getRectArea = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hoisting: JavaScript engine will automatically move the function declaration to the top of the file</p><p>Arguments: all the input elemments will be shown as argument in the function with there index. For a funtion who needs 2 elements, if you input 5 elements, that doesn’t matter, the function will only use the first two number</p><p>Default Value: same like python, define it in the parameters</p><h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="Getter and Setter"></a>Getter and Setter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"John"</span>,</span><br><span class="line">  lastName : <span class="string">"Doe"</span>,</span><br><span class="line">  language : <span class="string">"en"</span>,</span><br><span class="line">  <span class="keyword">get</span> lang() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.language;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> lang(lang) &#123;</span><br><span class="line">    <span class="keyword">this</span>.language = lang;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set an object property using a setter:</span></span><br><span class="line">person.lang = <span class="string">"en"</span>;</span><br><span class="line"><span class="comment">// Display data from the object using a getter:</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = person.lang;</span><br></pre></td></tr></table></figure><h3 id="Try-and-catch"><a href="#Try-and-catch" class="headerlink" title="Try and catch"></a>Try and catch</h3><h4 id="The-throw-Statement"><a href="#The-throw-Statement" class="headerlink" title="The throw Statement"></a>The throw Statement</h4><p>The <code>throw</code> statement allows you to create a custom error.</p><p>Technically you can <strong>throw an exception (throw an error)</strong>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">"Too big"</span>;    <span class="comment">// throw a text</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">500</span>;          <span class="comment">// throw a number</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'value is invalid'</span>);</span><br></pre></td></tr></table></figure><p>If you use <code>throw</code> together with <code>try</code> and <code>catch</code>, you can control program flow and generate custom error messages.</p><h4 id="Try-catch-finally"><a href="#Try-catch-finally" class="headerlink" title="Try catch finally"></a>Try catch finally</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message, x;</span><br><span class="line">  message = <span class="built_in">document</span>.getElementById(<span class="string">"p01"</span>);</span><br><span class="line">  message.innerHTML = <span class="string">""</span>;</span><br><span class="line">  x = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">""</span>) <span class="keyword">throw</span> <span class="string">"empty"</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">"not a number"</span>;</span><br><span class="line">    x = <span class="built_in">Number</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">5</span>) <span class="keyword">throw</span> <span class="string">"too low"</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>) <span class="keyword">throw</span> <span class="string">"too high"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    message.innerHTML = <span class="string">"Input is "</span> + e;</span><br><span class="line">    alert(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Let-and-Var"><a href="#Let-and-Var" class="headerlink" title="Let and Var"></a>Let and Var</h2><h3 id="ES6可以用let定义块级作用域变量"><a href="#ES6可以用let定义块级作用域变量" class="headerlink" title="ES6可以用let定义块级作用域变量"></a>ES6可以用let定义块级作用域变量</h3><p>在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以<code>{}</code>限定不了var声明变量的访问范围。<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>ES6新增的<code>let</code>，可以声明块级作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">9</span>;     <span class="comment">// i变量只在 花括号内有效！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h3 id="let-配合for循环的独特应用"><a href="#let-配合for循环的独特应用" class="headerlink" title="let 配合for循环的独特应用"></a>let 配合for循环的独特应用</h3><p><code>let</code>非常适合用于 <code>for</code>循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;  </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 同步注册回调函数到 异步的 宏任务队列。</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);        <span class="comment">// 执行此代码时，同步代码for循环已经执行完成</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">10</span>   共<span class="number">10</span>个</span><br><span class="line"><span class="comment">// 这里面的知识点： JS的事件循环机制，setTimeout的机制等</span></span><br></pre></td></tr></table></figure><p>如果把 <code>var</code>改成 <code>let</code>声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);    <span class="comment">//  i 是循环体内局部作用域，不受外界影响。</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="let没有变量提升与暂时性死区"><a href="#let没有变量提升与暂时性死区" class="headerlink" title="let没有变量提升与暂时性死区"></a>let没有变量提升与暂时性死区</h3><p>用<code>let</code>声明的变量，不存在变量提升。而且要求必须 等<code>let</code>声明语句执行完之后，变量才能使用，不然会报<code>Uncaught ReferenceError</code>错误。<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aicoder);    <span class="comment">// 错误：Uncaught ReferenceError ...</span></span><br><span class="line"><span class="keyword">let</span> aicoder = <span class="string">'aicoder.com'</span>;</span><br><span class="line"><span class="comment">// 这里就可以安全使用aicoder</span></span><br></pre></td></tr></table></figure><blockquote><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><h3 id="let变量不能重复声明"><a href="#let变量不能重复声明" class="headerlink" title="let变量不能重复声明"></a>let变量不能重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。否则报错：<code>Uncaught SyntaxError: Identifier &#39;XXX&#39; has already been declared</code></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'sss'</span>;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">err.message <span class="comment">// "出错了"</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p><p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p><ul><li><strong>message</strong>：错误提示信息</li><li><strong>name</strong>：错误名称（非标准属性）</li><li><strong>stack</strong>：错误的堆栈（非标准属性）</li></ul><p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.name + <span class="string">': '</span> + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stack</code>属性用来查看错误发生时的堆栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwit();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack); <span class="comment">// print stack trace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catchit()</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class="line"><span class="comment">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class="line"><span class="comment">//    at repl:1:5</span></span><br></pre></td></tr></table></figure><p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p><h3 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h3><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p><h4 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h4><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>a;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure><p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p><h4 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h4><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个不存在的变量</span></span><br><span class="line">unknownVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure><p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure><p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误。</p><h4 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h4><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组长度不得为负数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure><h4 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h4><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: number is not a func</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p><h4 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h4><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">'%2'</span>)</span><br><span class="line"><span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure><h4 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h4><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'出错了，变量超出有效范围！'</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'出错了，变量类型无效！'</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// "出错了！"</span></span><br><span class="line">err2.message <span class="comment">// "出错了，变量超出有效范围！"</span></span><br><span class="line">err3.message <span class="comment">// "出错了，变量类型无效！"</span></span><br></pre></td></tr></table></figure><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure><h3 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h3><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x 必须为正数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p><p><code>throw</code>也可以抛出自定义错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserError(<span class="string">'出错了！'</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p><p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Error！'</span>;</span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Error!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p><h3 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p><p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p><p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"出错了"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p><p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught 100</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p><p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">EvalError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p><h3 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h3><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleansUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了……'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此行不会执行'</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成清理工作'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleansUp()</span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Uncaught Error: 出错了……</span></span><br><span class="line"><span class="comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:10:1</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idle</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'FINALLY'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idle(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p><p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countUp()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">count</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p><p>下面是<code>finally</code>代码块用法的典型场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openFile();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writeFile(Data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p><p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'bug'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p><p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'出错了！'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉到内部错误'</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caught outer "bogus"'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure><p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p><p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consle.log(<span class="string">'Hello world!'</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finally'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Will I run?'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finally</span></span><br><span class="line"><span class="comment">// consle is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p><h2 id="Console对象与控制台"><a href="#Console对象与控制台" class="headerlink" title="Console对象与控制台"></a>Console对象与控制台</h2><h3 id="console-对象"><a href="#console-对象" class="headerlink" title="console 对象"></a>console 对象</h3><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p><p><code>console</code>的常见用途有两个。</p><ul><li>调试程序，显示网页代码运行时的错误信息。</li><li>提供了一个命令行接口，用来与网页代码互动。</li></ul><p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p><ol><li>按 F12 或者<code>Control + Shift + i</code>（PC）/ <code>Command + Option + i</code>（Mac）。</li><li>浏览器菜单选择“工具/开发者工具”。</li><li>在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li></ol><p>打开开发者工具以后，顶端有多个面板。</p><ul><li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li><li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li><li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li><li><strong>Sources</strong>：查看网页加载的脚本源码。</li><li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li><li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li><li><strong>Console</strong>：用来运行 JavaScript 命令。</li></ul><p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。</p><p><code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p><h3 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h3><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p><h4 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h4><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure><p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">' %s + %s = %s'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">//  1 + 1 = 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p><p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p><ul><li><code>%s</code> 字符串</li><li><code>%d</code> 整数</li><li><code>%i</code> 整数</li><li><code>%f</code> 浮点数</li><li><code>%o</code> 对象的链接</li><li><code>%c</code> CSS 格式字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">11</span> * <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%d %s balloons'</span>, number, color);</span><br><span class="line"><span class="comment">// 99 red balloons</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。</p><p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">'%cThis text is styled!'</span>,</span><br><span class="line">  <span class="string">'color: red; background: yellow; font-size: 24px;'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面代码运行后，输出的内容将显示为黄底红字。</p><p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">' %s + %s '</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'= 2'</span>)</span><br><span class="line"><span class="comment">// 1 + 1  = 2</span></span><br></pre></td></tr></table></figure><p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;foo: "bar"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>)</span><br><span class="line"><span class="comment">// function Date() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。</p><p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。</p><p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p><p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'log'</span>, <span class="string">'info'</span>, <span class="string">'warn'</span>, <span class="string">'error'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>[method] = <span class="built_in">console</span>[method].bind(</span><br><span class="line">    <span class="built_in">console</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"出错了！"</span>);</span><br><span class="line"><span class="comment">// 2014-05-18T09:00.000Z 出错了！</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p><h4 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h4><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.error(<span class="string">'Error: %s (%i)'</span>, <span class="string">'Server is not responding'</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// Error: Server is not responding (500)</span></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'Warning! Too few nodes (%d)'</span>, <span class="built_in">document</span>.childNodes.length)</span><br><span class="line"><span class="comment">// Warning! Too few nodes (1)</span></span><br></pre></td></tr></table></figure><p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p><h4 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h4><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"JavaScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".js"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"TypeScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".ts"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"CoffeeScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".coffee"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure><p>上面代码的<code>language</code>变量，转为表格显示如下。</p><table><thead><tr><th align="left">(index)</th><th align="left">name</th><th align="left">fileExtension</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">“JavaScript”</td><td align="left">“.js”</td></tr><tr><td align="left">1</td><td align="left">“TypeScript”</td><td align="left">“.ts”</td></tr><tr><td align="left">2</td><td align="left">“CoffeeScript”</td><td align="left">“.coffee”</td></tr></tbody></table><p>下面是显示表格内容的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = &#123;</span><br><span class="line">  csharp: &#123; <span class="attr">name</span>: <span class="string">"C#"</span>, <span class="attr">paradigm</span>: <span class="string">"object-oriented"</span> &#125;,</span><br><span class="line">  fsharp: &#123; <span class="attr">name</span>: <span class="string">"F#"</span>, <span class="attr">paradigm</span>: <span class="string">"functional"</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure><p>上面代码的<code>language</code>，转为表格显示如下。</p><table><thead><tr><th align="left">(index)</th><th align="left">name</th><th align="left">paradigm</th></tr></thead><tbody><tr><td align="left">csharp</td><td align="left">“C#”</td><td align="left">“object-oriented”</td></tr><tr><td align="left">fsharp</td><td align="left">“F#”</td><td align="left">“functional”</td></tr></tbody></table><h4 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h4><p><code>count</code>方法用于计数，输出它被调用了多少次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi '</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">'bob'</span>)</span><br><span class="line"><span class="comment">//  : 1</span></span><br><span class="line"><span class="comment">// "hi bob"</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">'alice'</span>)</span><br><span class="line"><span class="comment">//  : 2</span></span><br><span class="line"><span class="comment">// "hi alice"</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">'bob'</span>)</span><br><span class="line"><span class="comment">//  : 3</span></span><br><span class="line"><span class="comment">// "hi bob"</span></span><br></pre></td></tr></table></figure><p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p><p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hi "</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">'bob'</span>)</span><br><span class="line"><span class="comment">// bob: 1</span></span><br><span class="line"><span class="comment">// "hi bob"</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">'alice'</span>)</span><br><span class="line"><span class="comment">// alice: 1</span></span><br><span class="line"><span class="comment">// "hi alice"</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">'bob'</span>)</span><br><span class="line"><span class="comment">// bob: 2</span></span><br><span class="line"><span class="comment">// "hi bob"</span></span><br></pre></td></tr></table></figure><p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p><h4 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h4><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">f1</span>: <span class="string">'foo'</span>, <span class="attr">f2</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;f1: "foo", f2: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(&#123;<span class="attr">f1</span>: <span class="string">'foo'</span>, <span class="attr">f2</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">//   f1: "foo"</span></span><br><span class="line"><span class="comment">//   f2: "bar"</span></span><br><span class="line"><span class="comment">//   __proto__: Object</span></span><br></pre></td></tr></table></figure><p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p><p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><p>Node 环境之中，还可以指定以代码高亮的形式输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(obj, &#123;<span class="attr">colors</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dirxml(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dirxml([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.dir([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h4 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h4><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="literal">false</span>, <span class="string">'判断条件不成立'</span>)</span><br><span class="line"><span class="comment">// Assertion failed: 判断条件不成立</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'判断条件不成立'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子，判断子节点的个数是否大于等于500。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(list.childNodes.length &lt; <span class="number">500</span>, <span class="string">'节点个数大于等于500'</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p><h4 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h4><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'Array initialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'Array initialize'</span>);</span><br><span class="line"><span class="comment">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure><p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p><h4 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h4><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">'一级分组'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'一级分组的内容'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">'二级分组'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'二级分组的内容'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 二级分组结束</span></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 一级分组结束</span></span><br></pre></td></tr></table></figure><p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p><p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.groupCollapsed(<span class="string">'Fetching Data'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Request Sent'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'Error: Server not responding (500)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure><p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p><h4 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h4><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace()</span><br><span class="line"><span class="comment">// console.trace()</span></span><br><span class="line"><span class="comment">//   (anonymous function)</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateOn</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateAndWrap</span></span><br><span class="line"><span class="comment">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure><p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p><h3 id="控制台命令行-API"><a href="#控制台命令行-API" class="headerlink" title="控制台命令行 API"></a>控制台命令行 API</h3><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p><p>（1）<code>$_</code></p><p><code>$_</code>属性返回上一个表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">$_</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>（2）<code>$0</code> - <code>$4</code></p><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p><p>（3）<code>$(selector)</code></p><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p><p>（4）<code>$$(selector)</code></p><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p><p>（5）<code>$x(path)</code></p><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x(<span class="string">"//p[a]"</span>)</span><br></pre></td></tr></table></figure><p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p><p>（6）<code>inspect(object)</code></p><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p><p>（7）<code>getEventListeners(object)</code></p><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><p>（8）<code>keys(object)</code>，<code>values(object)</code></p><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p><p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="string">'p1'</span>: <span class="string">'a'</span>, <span class="string">'p2'</span>: <span class="string">'b'</span>&#125;;</span><br><span class="line"></span><br><span class="line">keys(o)</span><br><span class="line"><span class="comment">// ["p1", "p2"]</span></span><br><span class="line">values(o)</span><br><span class="line"><span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure><p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p><p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents(<span class="built_in">window</span>, <span class="string">"resize"</span>);</span><br><span class="line">monitorEvents(<span class="built_in">window</span>, [<span class="string">"resize"</span>, <span class="string">"scroll"</span>])</span><br></pre></td></tr></table></figure><p>上面代码分别表示单个事件和多个事件的监听方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($<span class="number">0</span>, <span class="string">'mouse'</span>);</span><br><span class="line">unmonitorEvents($<span class="number">0</span>, <span class="string">'mousemove'</span>);</span><br></pre></td></tr></table></figure><p>上面代码表示如何停止监听。</p><p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p><ul><li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li><li>key：”keydown”, “keyup”, “keypress”, “textInput”</li><li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li><li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($(<span class="string">"#msg"</span>), <span class="string">"key"</span>);</span><br></pre></td></tr></table></figure><p>上面代码表示监听所有<code>key</code>大类的事件。</p><p>（10）其他方法</p><p>命令行 API 还提供以下方法。</p><ul><li><code>clear()</code>：清除控制台的历史。</li><li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li><li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li><li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li></ul><h3 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h3><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p><h2 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p><p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h3 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><h3 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p><p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p><p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href="https://api.jquery.com/on/" target="_blank" rel="noopener">写法</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></table></figure><p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f1.trigger(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href="https://en.wikipedia.org/wiki/Decoupling" target="_blank" rel="noopener">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern" target="_blank" rel="noopener">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noopener">观察者模式</a>”（observer pattern）。</p><p>这个模式有多种<a href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx" target="_blank" rel="noopener">实现</a>，下面采用的是 Ben Alman 的 <a href="https://gist.github.com/661855" target="_blank" rel="noopener">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p><p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></table></figure><p>然后，<code>f1</code>进行如下改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.publish(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p><p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></table></figure><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h3 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p><p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>(<span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">async</span>(<span class="number">4</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">async</span>(<span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">async</span>(<span class="number">6</span>, final);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数为 1 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 2 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 3 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 4 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 5 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 6 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 完成:  12</span></span><br></pre></td></tr></table></figure><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">series</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item) &#123;</span><br><span class="line">    <span class="keyword">async</span>( item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      <span class="keyword">return</span> series(items.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">series(items.shift());</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p><p>注意，上面的写法需要六秒，才能完成整个脚本。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    results.push(result);</span><br><span class="line">    <span class="keyword">if</span>(results.length === items.length) &#123;</span><br><span class="line">      final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p><p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p><h4 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> running = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.shift();</span><br><span class="line">    <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      running--;</span><br><span class="line">      <span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        launcher();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(running == <span class="number">0</span>) &#123;</span><br><span class="line">        final(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launcher();</span><br></pre></td></tr></table></figure><p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p><p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员标配？Herman Miller Sayl</title>
      <link href="/2020/03/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%87%E9%85%8D%EF%BC%9FHerman-Miller-Sayl/"/>
      <url>/2020/03/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%87%E9%85%8D%EF%BC%9FHerman-Miller-Sayl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为疫情原因，公司决定work from home，给所有员工400刀的预算去买自己在家办公所需。我寻思着自己的东西都买的差的不多了，显示器是个游戏显示器不太好意思拿去报销，桌子是转租房自带的不是自己买的，家里只有一台一百刀的打印机能报销。正好Amazon上买的Amazon basic椅子并不好用，决定买张Herman Miller的椅子，试试感觉。</p><p>Herman Miller的大家应该都听说过，一张$1500+的Herman Miller Embody号称程序员之梦。我个人觉得自己没这么高需求，而且工作第一桶金还没拿到呢，买这么贵的不合适，就买了一张亚马逊上最便宜的Herman Miller Sayl。这张椅子据说是很多顶级公司的会议室标配。顶级公司没去过，椅子可以先买张爽爽。</p><p>个人买的是$510的版本，主要是当时我没细看它们有什么区别，直接买了张最便宜的。按论坛上说的，“Herman Miller的椅子，买就行了，不会差的”。于是我就真没看，直接买了，现在想想稍微有点后悔，还是应该稍微加点钱上高级点的版本的。</p><p>Herman Miller的椅子运送都是整只装好了运送的。箱子大而沉。我琢磨着大概510刀有一半是组装费用，这么一算倒还是挺值的！</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/5B5F402D-89F2-441F-9918-490853DBA67E_1_105_c.jpeg"  alt=""></p><p>拆开箱子以后椅子可以直接拉出来。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/86182C54-1523-4CA6-8AC9-2DFE4A8889D3_1_105_c.jpeg"  alt=""></p><p>从箱子里拿出来后的Herman Miller Sayl</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/E9E8D6E2-A252-41AA-BFAF-D82F546DFCE9_1_105_c.jpeg"  alt=""></p><p>这个版本是Stationary Seat Depth and Arms，也就是说坐垫和手把都是不可调整的，而且后背也没有可调整的支撑位置。在其他版本之中，后背的支撑处有一个可以上下滑动调整支撑腰部位置的模块。</p><p>在这个版本的Sayl上，仍具备的功能有：</p><ul><li><p>上下高度调整</p></li><li><p>后仰弹力调整：</p><p>椅子的靠背可以向后仰，但是后仰的角度并不能固定住，需要你施加力量。右侧有一旋钮，可以改变力量强度。你可以调整成很轻松随意一靠就能后仰，或者根本仰不动</p></li><li><p>后仰角度调整：</p><p>你可以调整最大后仰的角度，有三种，一种是前倾，一种是后仰15度左右，另一种是后仰45度左右</p></li></ul><h3 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h3><p>首先坐垫并不柔软。这是一块类硬海绵材质的坐垫，你坐下去可能它形变都不到一厘米，这方面的体验实际上不太好，整得有点像坐火车硬座。</p><p>这个靠背就有点意思了，它确实能给你的腰足够的支撑。我也算是误打误撞，没有买可调整的腰部模块，但是无需调整，这张的椅子刚好支撑到了我的腰部。又因为这低配椅子没有可调节的坐垫模块，坐垫比较狭窄，我必须靠内坐才能舒服。这就导致我必须在这张椅子上坐正坐直。好在腰部支撑力足够，坐久了并不会累——除了屁股。这坐垫可太硬了。</p><p>之前看到有个评测说这张椅子能矫正你的坐姿，让你在不知不觉之间坐正坐直。看来此言不虚。</p>]]></content>
      
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南疆游记</title>
      <link href="/2020/03/21/%E5%8D%97%E7%96%86%E6%B8%B8%E8%AE%B0/"/>
      <url>/2020/03/21/%E5%8D%97%E7%96%86%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>照片都是手机直出的，没有任何调色等修改</strong></p><p>在19年的南疆之旅之前，我已去过新疆，不过前往的都是北疆景点，未曾踏足天山以南的土地。上次游玩之后，同行的人发来邀请，问是否明年想改换航线，前往南疆旅行一次。</p><p>在北疆旅游的时候，但凡见到当地的汉人，他们都会说：北边都是汉化的地儿，兵团驻扎，你们要想感受感受风土人情，那还是得去南疆看看。想起夏尔西里的景色和烤羊的诱惑，假如南疆比这北疆还能更好玩，那便绝对值得一去。我们想也没想就答应了。</p><p>所谓南疆北疆，是按天山划分的。这天山几乎横切了整个新疆，按我爸的话说，“抬头看到高山，得嘞，那就是天山”。我们虽然计划去南疆，但因为有朋友在北疆等我们，于是还是降落在了乌鲁木齐。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/ED5408C8-72EC-4110-953E-6FF33F88229C_1_105_c.jpeg"  alt=""></p><p>乌鲁木齐这座城市汉化很严重，管理也很严格。在我18年来的时候，全国各地都在用4G了，而且都整上好几年了，到了乌鲁木齐一打开手机，诶嘿，还是3G网（周边城市有4G，就乌鲁木齐没有），速度慢得跟没有一样，妻管严的兄弟来这里玩估计随随便便就漏掉好多老婆的微信，回家的时候只能当光棍了。当时据说是只有申请才能用上4G（我们同行的人中有当地人能上），我们这些外来物种那就只能乖乖3G了。</p><p>严格管理当然不只是网络管理，有一位部队里的兄弟在吃饭的时候直接吹牛，说在新疆11点后你四人大声打牌都要给你逮起来，新疆现在就是全国最安全的地方。</p><p>18年的环境，他说这句话，我举双手赞成。我们当时就是在乌鲁木齐坐个车，一路上但凡到了十字路口就会有一个关卡，有的关卡甚至会有水泥铸的碉堡（和谐一点，叫保安亭好了）。大伙可都拿的是真枪实弹，哪有人能在这环境下整活？你到了十字路口，警察叔叔就过来了，让你把窗户摇下来——他一瞥，哟，是个汉人，走走走吧，没你事了，该干嘛干嘛去。但假如你是个维族人，兄弟，请你出示一下你的身份证！</p><p>也亏得我们是汉人，这维族人简直就是寸步难行。其实我们汉人也一样，没了身份证你哪都跑不了，到处都有可能要检查身份证，加油站这种门口摆着巨大战时路障的更不用说了，你还得过安检。只是你被查到的概率远远低于维族人而已。你被查一次，他们大概已经被查20次了。</p><p>在这样的环境下，大巴扎在18年的时候，关门关得特别早。大巴扎在维语中就是大集市的意思。出事以前，大巴扎半夜三更都特别热闹，当然今非昔比了。</p><p>我19年再去的时候，环境改善了不少。不仅有4G了，大巴扎竟然开到晚上了。于是我们就进去恰了一顿夜宵。虽然游客不少，但是其中维族人比例属实不低。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/6BDA8F68-B75E-4DD3-847E-95088A5BBF21_1_105_c.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/282348A7-709B-415E-9735-18820A7EAE54_1_105_c.jpeg"  alt=""></p><p>你问我在大巴扎中印象最深的是什么？害，我会告诉你我吃夜宵的时候，<del>在我前面的维族志愿者小姐姐好看到爆表我完全忘不掉吗？</del> 不，是啤酒！人头大的啤酒你喝过吗！<del>很难喝</del></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/D329EC50-6258-4D2A-8A1F-790E0F54CA0E_1_105_c.jpeg"  alt=""></p><p>隔天我们就直接飞向了阿克苏。阿克苏这名字是不是很耳熟？是不是脑子里蹦出来一个红苹果？</p><p>因为坐飞机到阿克苏已经花了一早上，我们在阿克苏我们就去了一个景点：刀郎部落。且不说这个景点疯狂蹭刀郎（没错就是2002年第一场雪的刀郎）热度，这个景点本身做工低劣极其弟弟……他们企图把这个村包装成一个人文景观，但是实际上只有自然景观还算凑合，坐马车跑跑路还算惬意。那几个部落里跳舞的小兄弟看起来无精打采的，小姐姐也莫得只剩大姐姐了，建议别去浪费钱了</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/4DCEDA5E-01F8-47C4-A07C-F64D6651A90E_1_105_c.jpeg"  alt=""></p><p>次日终于来到了本次旅途重头戏之一——沙漠公路。话说我自上次北疆之旅就对沙漠公路念念不忘，没办法，听起来实在是太酷了。但是上次时间有些不足，多半时间都花在独库公路上了。这次终于能见识到什么叫做沙漠公路了。</p><p>说起来我也未曾去大沙漠中好好玩一圈，此前去过的也顶多就是陕甘宁那片区的小沙漠，它们跟塔克拉玛干比起来自然是不值一提。</p><p>我们行过的路段是阿克苏到和田的部分。去之前司机小哥对沙漠公路是一顿胡夸海吹，跟我说到了沙漠之中，你就能感受到大漠孤烟直，长河落日圆的气氛！公路在沙漠中笔直穿过看不到边际，两边是一望无际的旷野……</p><p>因为他这几句话，我刚上路的时候是满怀期待的。但是为了保护这条沙漠公路，公路两旁都有防护带，或是摆成方格状的干草，或是生存力顽强的草皮。其中有一个片区还种植了各式植物，据司机小哥说，这里是在做对照试验，看哪种方法防砂效果最佳。</p><p>防砂固然要紧，但这沙漠公路看起来就没有那么酷了。本来我以为两侧是一望无尽的沙漠丘陵，你给我上面种些花里胡哨的植物，我总觉得破坏了其中的艺术气息。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/DC5C4B3D-A795-4672-8D13-62191E7E19A4_1_105_c.jpeg"  alt=""></p><p>为了看看沙漠的真面目，我们找了几个地方停了车。翻过丘陵之后，却发现之后的沙漠也没想象中的那么广阔壮观。靠北，多半是之前看到的沙漠宣传照都被调了色！PS害人呐！真正的沙漠就这？</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/2C124614-02BC-4703-B640-F48C0FA77690_1_105_c.jpeg"  alt=""></p><p>不过沙漠最终还是没让我们失望，行车不久后，我们便看到小哥口中的“大漠孤烟直”了。一开始我还不确定那是什么，以为前面失火了，寻思着大沙漠里难不成有人的车自燃了，谁知道靠近了一看，竟然是道通天高的龙卷风。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-5124d97939f8.gif"  alt=""></p><p>我不知道你们有没有见过龙卷风，反正我是从来没见过。我只是小时候在百科全书上见过，之后就是各种灾难片。没想到在这大沙漠中竟然能看到龙卷风的真身。令人咋舌的是沙漠中远远不止这一阵龙卷风，随着我们深入，龙卷风变得随处可见！</p><p>不过之前看新闻的时候我记得美国曾发生过一次龙卷风把人卷到空中的事件。这里的龙卷风威力并没有那么大。我不太清楚它们是如何形成的，但是有些小龙卷风在踏上这条公路之后便快速消失了。车从这些龙卷风中穿过并不会遭到太大的阻碍。不过有一次我企图开车窗拍张风哥近照，风哥突然加快了步伐，冲过来就喂了我一嘴沙。想到这我都觉得嘴里有点异样。</p><p>在我们快到和田之前，司机一个拐弯拐进了沙漠里，原来有座热瓦克古佛寺藏在这沙漠之中。在这小道中我们一路颠簸，到了一个只有游客中心的地方。这游客中心可算是空无一人，门口与写着全国重点文物保护单位，却只有个大爷坐在门口阴凉处打瞌睡。我们上去前往交流，却发现这看管景点的大爷并不会汉语。司机小哥用几句蹩脚的维语问大爷入口是不是在这，大爷好像点了点头。我们也不管，就这么进去了。看来新疆的文物保护着实还是需要加大力度。</p><p>这座古佛寺据说建于南北朝时期，还是被一个英国探险家发现的。谈到这就难受，过去大家对文物都不怎么当回事，不知道被别人拐了多少家产走。说起来作为一个历史麻瓜，我当时一瞬间脑子卡壳，这怎么在伊斯兰的地盘会有佛寺？原来新疆以前一度是佛国地区，要不是被伊斯兰国攻打，可能他们现在跟我们一样信教主要信佛教呢！不得不说，对付宗教还得靠宗教。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/D780C6BF-A6BC-409E-9C50-4CD2DBDA824E_1_105_c.jpeg"  alt=""></p><p>下午到了和田之后我们一行人稍作休息，晚上跑到和田夜市恰了一顿饭。不得不说，现在回来看和田夜市的照片，真的，卫生环境不知道比武汉海鲜市场高到哪里去了（武汉海鲜市场的视频在YouTube上满天飞，很多老外说什么中国人还不如病毒，能吃得下这肮脏海鲜市场里东西的家伙根本不能算人。当然了，说出这种话的人根本不能算人，但是我们总得反省下吧，尼玛的2020年了菜市场还这样呢？）亏得你们还是生活条件不错的内地人！这里有几样菜比较有意思，牛羊肉就不必说了（新疆的羊肉串!=其他地方的羊肉串，新疆羊肉独一档，内蒙古羊肉在新疆羊肉面前就是乐色），酸奶（是什么奶我忘了）冰淇淋和烤蛋都挺好吃。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-8e0a5126f1fc.gif"  alt=""></p><!--split--><p>第二天一早起来，我们就去参观了一个植物园一样的地方。那里种植了树龄有足足1300年的核桃树，占地上百平米的无花果王，还有些葫芦，葡萄，西瓜之类的水果。估计是休息时间实在太长，有一位葫芦先生屁股都坐扁了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/0BF6261B-93FE-477F-9C22-20F137C19894_1_105_c.jpeg"  alt=""></p><p>这位是无花果王，怎么说呢，你看到的围起来的地方都是这株无花果的领地……</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/CA8A3D8B-E44A-4686-87D6-CA0405A5327F_1_105_c.jpeg"  alt=""></p><p>这天的中饭非常有意思，我们跑到了墨玉县去吃当地的特色菜。一个叫西瓜烧肉，一个叫肚烧肉。所谓西瓜烧肉，就是用西瓜当锅，然后将乳鸽和羊肉放在其中炖汤，炖出来的汤带有西瓜汁的味道，怪好喝的，不过西瓜炖得都发黑了，属实不太好看。肚烧肉也是一个意思，用猪肚还不知道是牛肚烤羊肉。不过我总觉得那羊肉没烤透，便没怎么吃。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/232B41AE-DE56-4DDD-83BE-6C46146710A2_1_201_a.jpeg"  alt=""></p><p>吃完饭之后我们直接开车前往喀什。喀什据说是以前东突分子们的首都，假如搞什么独立，好像喀什会成为他们东突首府，具体是个什么情况我不清楚，反正独立我是不赞成的。</p><p>在这去喀什的路上还有一段小插曲，就是我们想要上高速的时候，被警察拦住了。警察告诉我们说这段路不能走了，路那边好像有什么领导要过来，只能换小路走。我纳闷呢，咋能有人这么威风直接拦高速自己走。</p><p>不过当时那段高速也没彻底修好，路上还有不少施工的人和车，要是有什么交通厅的领导来视察之类的，也是可以理解。警察说你们往边上绕吧，绕也能去喀什的。于是我们两辆车就从侧边的一条小路走去。</p><p>结果走着走着发现这路在GPS上没了，大概是地图信息有段时间没更新了，或者是这路本来就没在地图上过。但我们隐隐约约看到不远处有一个上高速的入口，不由得欣喜若狂，一脚油门就继续在这砂石小径上继续走了，一同跟来的商务车便也踩着油门往前冲。我们是山地SUV，这都是小case，噌噌噌就过去了，跑回到了高速路上。</p><p>其实我是不赞成回到这高速的，因为两边不是有交警拦着么，虽然我们这条小路上没人拦，但总觉得开上来好像不是很合法。交警叫我们绕道，应该是绕道走普通道路，不是绕道上高速啊。果不其然，开到一半就出事了，不久后我们看到一辆逆向的军车朝我们打着双闪冲过来了。我们立刻将车靠边停了，也没做什么后续动作。军车也没有理会我们，呼啸着从我们身旁开过去了。</p><p>“这军车是开道的，后面应该有什么车队。”司机小哥说。</p><p>不一时果真有车队到来。这是由几辆军车护航的大巴车队，我们依稀能见到这些大巴车上有隔开司机的铁栅栏。一共四十多量大巴，一路开过，根本没有人来打理我们一下，估计以为我们是来修高速的工人。随着最后一辆护卫车驶过，我们发动了引擎。</p><p>“是监狱的车吧，要不就是……”</p><p>我们也没有多想，继续往前开，突然想起我们后面那辆车来。这我们上了高速也有一阵了，虽然这高速还在修路况有些问题，但这商务车也不至于那么慢吧？十分应景的是电话这时候就响了，原来是后面的人来求助来了。</p><p>“我们的商务车卡沙子里了！你们找根绳子来帮我们拉出来。”</p><p>我们真的满头问号，我们这都开出来40分钟了快到叶城了，你们咋才告诉我们你们陷沙子里了啊？而且我们车上也没绳子啊。我们一边告诉他们我们会尽力去找，另一方面叫他们去找墨玉县的人帮帮忙。于是我们开车就去找路边的修路老伯。司机小哥掏了包烟带上钱就过去了，问维族老伯有绳子没有。</p><p>老伯不会汉语，但总算听明白了我们的意思。他摆了摆手表示不要烟和钱，而且跟我们说没有绳子，但是会带我们去找绳子，说完就开了十分钟车带我们去他的小屋拿了根绳子。我们不停地谢谢，然后便往回走了。</p><p>谁知开到一半，另外一头又打电话告诉我们不必来了。说是遇到了几个开车的维族小伙子，看到需要帮忙，直接热心肠帮忙给他们把车给揪出来了。</p><p>大家都不由得感叹维族人的热心善良，这要是汉族人指不定要收你多少钱。最后我们把绳子还给老伯，老伯还是什么都不肯收。</p><p>说道这里就不得不再提一句维族人的善良真诚了，真的，一路遇到的维族人无一不是热心善良的，小孩子也是天真可爱，看到你过来会睁大眼睛不停地摆手打招呼，跟内地印象中的新疆人完全不相符。按队里小哥的话说，外面都是善良的人，可能是因为但凡你有一点不善良的动机，你已经被拉去再教育了。从这点来看，我觉得大部分的维族人都太可怜了。假如说Trump说Chinese virus是歧视，那我们因为一次暴恐事件把所有维族人都严加管理，这又算是什么呢？（我没说Trump说Chinese virus是正确的行为）</p><p>喀什玩的地方很多，有古城，艾提尕尔清真寺，大巴扎等等。你到了喀什会有种来到了中东的错觉，这里的很多建筑就跟中东战争电影里的一模一样。喀什古城就是其中一种跟中东风哥相仿的建筑区，这个建筑群建在一个大概两三层楼高的一个高台上，据说只有过去的权贵（天龙人）才能住在这里。你想象下我们中原的城墙，他们就住在那个高度上。那当真应该是意气奋发，抬头向窗外一看，嗨你们这些屁民，只能住在地面上。当然现在住的已经都是些朴实无华的人，你走过路过路边摊或者民宿的时候，还会有不少维族小姐姐来打招呼，<del>哎哟小哥进来玩呀，完全免费哦💕</del>。可别信了她们的邪，进去参观是免费的，可你跟她们互动来扭捏去过会说不定一会就挂不下面子疯狂消费了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/B8B5E8B5-C134-49A8-B3D8-759E5A930B20_1_105_c.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/6FCB8EA6-767C-4286-BA48-02F5368186E6_1_105_c.jpeg"  alt=""></p><p>同样，这里的维族人也很友好。我们跟维族阿姨说买馕的钱不用找了的时候，感觉她把一年的快乐都笑出来了。路边还有带着孩子让他给我们打招呼的可爱小姐姐，善良的人们呐祝你们一生幸福。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/21F3F998-E734-4E8B-9D39-2D2C63BADD67_1_105_c.jpeg"  alt=""></p><p>接着我们去了那个亚洲最大的清真寺艾提尕尔清真寺和大巴扎。这儿的大巴扎不得不说还是比乌鲁木齐的有趣多了，东西多而广，衣食住行应有尽有。我们买了一堆坚果葡萄干之类的产品直接寄回家了，然后在市场里面闲逛。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/7F926F8D-6CED-478E-B45A-4ECA78AD3CE2_1_105_c.jpeg"  alt=""></p><p>期间一个老伯先是问我们要不要买帽子（戴起来像皇军的那种），我们谢绝了之后，他突然压低声音问我们要不要狼牙。这倒是引起了我们的兴趣，我们跟着他走进屋里看了看，但也不能确定是不是真的狼牙，便还是走了出来。狼是保护动物，你猎杀不得，但是假如它攻击你的话，那你就可以反击。老A说了个故事，说他在西藏海拔五千多米的地方驾车时遇到过狼群，怎么甩也甩不掉，头狼深蓝色的眼睛就透过车窗死死地盯着自己。他当时差点就想去撞死那狼，但最后还是作罢。“狼真的有灵性，带着狼牙可以辟邪。这400块钱的狼牙，假如是真的肯定值，但是我看起来不像是真的。”他这么说。</p><p>中午我们吃了一顿饭，天啊现在想起来我还馋得不行，那架烤羊肉！那大盘鸡！那羊肉抓饭！那蜂蜜藏红花！简直就是极致美味。什么烤全羊都是弟中弟，当你吃过那架子上金黄色肥而不腻的架烤羊肉，你就不知道其他羊肉还算不算羊肉了！</p><p>羊肉手抓饭也是当之无愧的新疆必吃美味，在新疆这辽阔的地方当你开了八小时的车累得快死了，你想到下一顿是羊肉手抓饭，你就能继续开下去，说不定你还能再开八小时。</p><p>饭桌上老C说阿尔泰的羊肉就是最好的羊肉，我们吃的就是阿尔泰羊肉。阿尔泰羊肉最好，其次才是伊犁的羊肉。别的地方小羊养到15kg才开涮，伊犁他们12kg就开始了。RIP小羊，我是爱（吃）你们的。</p><!--split--><p>吃完饭后我们也没歇着，直接向阿图什天门开去。据说这座天门被发现还是因为有飞行员在此地飞行，看到山中间竟有一个大洞，这才发现的。这个景点较新，并没有很多人去过，我们决定过去探探险。</p><p>一路上都是一望无际的戈壁滩，在行车的过程中尤为壮观。可用手机一拍，好像又不是那么一回事了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/42708B60-13F2-466F-9E85-A656CE9CFAF6_1_105_c.jpeg"  alt=""></p><p>来到天门我们几人买了门票，就徒步向里走去。这个景点在丰水期间好像会关门，而我们徒步进入的地方也似是一条河道。刚踏入这个景区我们便被壮观的风化山石镇住了。随行的小D还时不时的看看岩壁，按他的话说，搞不好这些岩壁上有化石。“以前这些地方都是沉在水里的，这里有化石丝毫不奇怪，我以前就捡到过化石。”他这么说。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/3D89B5ED-62C5-45D4-A685-36A65594A525_1_105_c.jpeg"  alt=""></p><p>山间大风严重，有一座山直接被经年累月的风凿除了一个巨洞，宛如被一记重拳打中。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/3D115670-CBA0-4D0C-B2C9-1C5787DB8D66_1_105_c.jpeg"  alt=""></p><p>走到后段，队内的中老年选手已经不太行了，少说走了有几公里路了。不过眼前出现了天门的光点，让大家都有了希望。所有人都顺着溪石向上攀登，不一时有了台阶，离山顶还有几百级。然而在到山顶之前，你都不会知道结局有多波澜壮阔！</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/8B758FEB-ED8D-4A45-BC67-9D80658F6A41_1_105_c.jpeg"  alt=""></p><p>这是一扇高达百米的门！我们在山下只能看见门的上半部分，殊不知其后还有深不见底的裂谷。远方的那座高山在烈日下被染成金色，队里一阵“我操”声。</p><p>“消耗了我一年的运动量，真没算白来！”老A瞪大了眼，半天才“我操”出来。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/E3F7C8EE-EE71-40C3-A411-2E0932B007CB_1_105_c.jpeg"  alt=""></p><p>这时候再看看我们之前上来的路……GG，上山容易下山难，怕是又要忙活好久一阵了……</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/C15F7849-E970-477E-B4C0-184B784F14F4_1_105_c.jpeg"  alt=""></p><p>下山之后的戈壁滩（这是我的微信profile图，假如你有看到过），新疆这地方，随手一拍都是美景啊</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/AB51348C-E5D9-4EA5-BDF4-4A56F1F1AB7F_1_105_c.jpeg"  alt=""></p><p>倒数第二日我们走G314国道前往了塔县。塔县的全名是塔什库尔干塔吉克自治县，在帕米尔高原之上。喀什库尔干意思就是石头城，里面还有石头城遗迹，同时这里还有中国唯一的白人种族，塔吉克族。据老D所说，塔吉克族虽然是白人，但是异常爱国，他们很多人从小的梦想就是成为军人守护边疆。</p><p>前往塔县之路是一条边境之路。你想去塔县，你得有边防证才能走这条边境之路。在这里就能看出中国基建狂魔之名号不是浪得虚名，有几个路段，在巨山之中，几十米高的桥就这么突兀地架过去了。这条路还尤为惊险，左右都能看到不少的山体滑坡，想来泥石流在这也不是什么怪事，毕竟山顶都是积雪。还有些路段被积水淹没了。</p><p>在新疆的荒野中开车，突然遇到堵车，那是很正常的事情。之前我们在独库公路上就因为前方路面坍塌而不得不绕道，这次我们也好几次遇到了施工队，等待他们解决问题。好笑的是有时候路边会有巴扎，然后堵车的时候有的维族人就跑巴扎里去了，出来的时候抱着一只羊。羊还超级乖，可可爱爱地坐他怀里一动不动，我们都笑晕了。</p><p>我们在这危险路段开了一段时间，海拔也是越开越高，车上大家逐渐困顿，一个个睡去。一段时间后终于拨开云雾，来到一片巨大的湖泊前。此湖名为白沙湖，如你所见，湖边的山全是由白沙构成的。湖呈现不真实的碧蓝色。我不知道怎么形容它，我只能说在这海拔3300+米的地方看到它，unreal。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/9FFFC562-FF06-4E01-B63B-C6BF05980592_1_105_c.jpeg"  alt=""></p><p>首先声明下这图里俩人一车不是我们的人和车……然后我也不知道为什么这张的湖水颜色不一样。不过说实话两张照片中湖水的颜色都跟真实颜色有一定差距，真实的颜色更接近淡淡的青色。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/7CD71221-68BC-4F4C-8F73-522D0F5D0E8D_1_105_c.jpeg"  alt=""></p><p>在这里我们喝了几碗羊汤就上路了。假如你爱干净的话可能你不会很喜欢这里，因为这里只有旱厕。但是羊汤很便宜，十块钱一碗，在这3300+的海拔上，属实不能算贵了。</p><p>慕士塔格峰在就在白沙湖的边上，海拔有7500+，极其壮观。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/840FCE17-6E74-45B8-B504-EA4FE6AE0385_1_105_c.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/3B0484FD-E6AB-4D2C-9067-01728C23CEA9_1_105_c.jpeg"  alt=""></p><p>之后还有个葱岭圣湖。然而大家都刚刚看过白沙湖，直接贤者模式了，这葱岭圣湖便没怎么看直接路过了</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/C611EDD8-116D-488D-90F7-9A522D1362DC_1_105_c.jpeg"  alt=""></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/7A0389B7-3B0B-487F-AFFB-0362D2A1E762_1_105_c.jpeg"  alt=""></p><p>到了塔县后我们休息了一晚，吃了吃高原牦牛火锅，去了趟高原湿地公园（我们那天大雾，拍照片拍不清楚。但是远方的山都被雾所阻隔了，我当时以为湿地大到离谱，第二天才发现四野是有山的）</p><p>第二日我们就去了红其拉甫口岸，这是我们此行去的最后一个地方。这是跟巴基斯坦交接的口岸，海拔有5000米之高，人没缺氧，车缺氧了，燃油有些烧不动，动力变弱了。上面还得过个哨所，得有通行证才能过。边防兵脾气也不好，可能直接上来骂娘，得小心点，毕竟人身上带着枪呢。上去之后还特别冷，老C老D裹着棉被冲出去拍照，给爷逗笑了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/040807D0-7DC7-4806-811D-3DCED01F7815_1_201_a.jpeg"  alt=""></p><p>去了口岸之后，我们回到塔县吃了一顿冷水鱼。塔县并不是个吃冷水鱼的好地方，老板也做得不怎么样，导致这顿冷水鱼吃着感觉还不如吃鲫鱼。晚上我们便回了喀什，飞回了家。</p><p>下次若还有机会，我倒是很想走走新藏公路，见识见识昆仑的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> travel </tag>
            
            <tag> blog </tag>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown教程</title>
      <link href="/2020/03/20/Markdown%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/20/Markdown%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Tip: 强烈建议使用typora作为您的markdown工具</p><blockquote><p>提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 <a href="https://daringfireball.net/" target="_blank" rel="noopener"> JOHN GRUBER</a> 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看…</p></blockquote><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown支持6种级别的标题，对应html标签 <strong>h1 ~ h6</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上标记效果如下：</p><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><p>除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 标记语言的表现形式，使用下划线进行文本大小的控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;</span><br><span class="line">这是二级标题</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200320181200.png"  alt=""></p><p>这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。</p><h3 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h3><p>需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。</p><p>而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这段文字将被高亮显示...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下：</p><blockquote><p>这段文字将被高亮显示…</p></blockquote><h3 id="插入链接或图片"><a href="#插入链接或图片" class="headerlink" title="插入链接或图片"></a>插入链接或图片</h3><p>Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[点击跳转至百度](http:&#x2F;&#x2F;www.baidu.com)</span><br><span class="line">![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;8128&#x2F;PicGo&#x2F;master&#x2F;20200320181301.png)</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下：</p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">点击跳转至百度</a></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png"  alt=""></p><p>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表两种形式：</p><ul><li>无序列表使用*或+或-标识</li><li>有序列表使用数字加.标识，例如：1.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 黄瓜</span><br><span class="line">* 玉米</span><br><span class="line">* 茄子</span><br><span class="line"></span><br><span class="line">+ 黄瓜</span><br><span class="line">+ 玉米</span><br><span class="line">+ 茄子</span><br><span class="line"></span><br><span class="line">- 黄瓜</span><br><span class="line">- 玉米</span><br><span class="line">- 茄子</span><br><span class="line"></span><br><span class="line">1. 黄瓜</span><br><span class="line">2. 玉米</span><br><span class="line">3. 茄子</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下：</p><ul><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li></ul><ol><li>黄瓜</li><li>玉米</li><li>茄子</li></ol><p>注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。</p><h3 id="使用列表的一些注意事项"><a href="#使用列表的一些注意事项" class="headerlink" title="使用列表的一些注意事项"></a>使用列表的一些注意事项</h3><p>如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*    段落一</span><br><span class="line"></span><br><span class="line">     小段一</span><br><span class="line">*    段落二</span><br><span class="line"></span><br><span class="line">     小段二</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下：</p><ul><li><p>段落一</p><p>小段一</p></li><li><p>段落二</p><p>小段二</p></li></ul><p>另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 段落一</span><br><span class="line">    &gt; 区块标记一</span><br><span class="line">* 段落二</span><br><span class="line">    &gt; 区块标记二</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>段落一</p><blockquote><p>区块标记一</p></blockquote></li><li><p>段落二</p><blockquote><p>区块标记二</p></blockquote></li></ul><p>注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><hr><p>产生分隔线的语法要求比较松，符号之间添加空格也可以。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*这里是斜体*</span><br><span class="line">_这里是斜体_</span><br><span class="line"></span><br><span class="line">**这里是加粗**</span><br><span class="line">__这里是加粗__</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><em>这里是斜体</em> <em>这里是斜体</em></p><p><strong>这里是加粗</strong> <strong>这里是加粗</strong></p><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。</p><p>方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹</p><p>这是一段<code>var x = 3</code>行内代码</p><p>如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun (x: Int, y: Int): Int &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。</p><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><p>表格是Markdown语法中比较复杂的一个，其语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|条目一|条目二</span><br><span class="line">:---:|:---:|:---:</span><br><span class="line">项目|项目一|项目二</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下：</p><table><thead><tr><th align="center">表头</th><th align="center">条目一</th><th align="center">条目二</th></tr></thead><tbody><tr><td align="center">项目</td><td align="center">项目一</td><td align="center">项目二</td></tr></tbody></table><p>注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h3 id="特殊符号处理"><a href="#特殊符号处理" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h3><p>Markdown使用反斜杠\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\ =&gt; \ 。</p><p>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p><h3 id="如何给文字上色"><a href="#如何给文字上色" class="headerlink" title="如何给文字上色"></a>如何给文字上色</h3><p>使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：</p><ol><li>先用Markdown编辑完成</li><li>导出为html，在需要上色的部分手动添加标签<font color='#ff0000'></font>保存即可。</li></ol><h3 id="Markdown软件推荐"><a href="#Markdown软件推荐" class="headerlink" title="Markdown软件推荐"></a>Markdown软件推荐</h3><p>强烈建议你使用typora</p><p>如果你是一个Mac用户，也可以使用开源的 <a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a>：</p><p><img src="/" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/4/18/162d75d95959514c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  alt="Macdown"></p><h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>Markdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。</p><p>不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！</p><p>作者：欧阳锋<br>链接：<a href="https://juejin.im/post/5ad6e09e518825557b4d451c" target="_blank" rel="noopener">https://juejin.im/post/5ad6e09e518825557b4d451c</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash Shell编程入门</title>
      <link href="/2020/03/19/Bash-Shell%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/19/Bash-Shell%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>作者：echoworlding</strong></p><p><strong>链接：<a href="https://www.jianshu.com/p/e1c8e5bfa45e" target="_blank" rel="noopener">https://www.jianshu.com/p/e1c8e5bfa45e</a></strong></p><p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p><h2 id="Shell是什么？"><a href="#Shell是什么？" class="headerlink" title="Shell是什么？"></a>Shell是什么？</h2><p>shell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。</p><h3 id="Shell语言的流派"><a href="#Shell语言的流派" class="headerlink" title="Shell语言的流派"></a>Shell语言的流派</h3><p>目前，shell主要有两大流派：</p><ul><li>sh:<ul><li>burne shell (sh)</li><li>burne again shell (bash)</li></ul></li><li>csh:<ul><li>c shell (csh)</li><li>tc shell (tcsh)</li><li>korn shell (ksh)</li></ul></li></ul><p>目前，大部分Linux系统预设的shell都是bash。</p><blockquote><p>Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slot@slot-ubt:~$ cat /etc/shells </span><br><span class="line"><span class="comment"># /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">slot@slot-ubt:~$</span><br></pre></td></tr></table></figure><blockquote><p>Mac OS提供的shell环境：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line"><span class="comment"># List of acceptable shells for chpass(1).</span></span><br><span class="line"><span class="comment"># Ftpd will not allow users to connect who are not using</span></span><br><span class="line"><span class="comment"># one of these shells.</span></span><br><span class="line">&gt;</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh  <span class="comment"># zsh系本文作者自己安装</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>在Catalina之后mac就不是使用bash的了，而是使用zsh的</p></blockquote><h3 id="一个极简的bash-demo-hello-world-sh"><a href="#一个极简的bash-demo-hello-world-sh" class="headerlink" title="一个极简的bash demo: hello_world.sh"></a>一个极简的bash demo: hello_world.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here is comment </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><p><strong>执行</strong>  </p><p>方法1: 直接使用bash解释器来解释执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash hello_world.sh</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh hello_world.sh</span><br></pre></td></tr></table></figure><p>方法2: 先将文件属性改为可执行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x hello_world.sh</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 hello_world.sh</span><br></pre></td></tr></table></figure><p>再直接执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_world.sh</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。</p><p>#开头的是注释行(#!除外)，shell中只有单行注释。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World!"</span> 即用<span class="built_in">echo</span>命令输出字符串<span class="string">"Hello World!"</span>到终端显示器。</span><br></pre></td></tr></table></figure><blockquote><p><strong>补充知识: 文件的属性</strong><br> 通过<code>ls -l</code>命令可以查看文件的属性，例如查看新建文件test.sh的属性：</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot@slot-<span class="symbol">ubt:</span>~$ touch test.sh</span><br><span class="line">slot@slot-<span class="symbol">ubt:</span>~$ ls -l test.sh </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> slot slot <span class="number">0</span> <span class="number">12</span>月 <span class="number">21</span> <span class="number">15</span><span class="symbol">:</span><span class="number">40</span> test.sh</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，一般新建文件的默认属性是<code>-rw-rw-r--</code>，即644，不具有可执行属性<code>x</code>，可使用<code>chmod</code>命令来改变文件属性（修改默认属性则使用<code>umask</code>命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot@slot-<span class="symbol">ubt:</span>~$ chmod <span class="number">777</span> test.sh </span><br><span class="line">slot@slot-<span class="symbol">ubt:</span>~$ ls -l test.sh </span><br><span class="line">-rwxrwxrwx <span class="number">1</span> slot slot <span class="number">0</span> <span class="number">12</span>月 <span class="number">21</span> <span class="number">15</span><span class="symbol">:</span><span class="number">40</span> test.sh</span><br></pre></td></tr></table></figure><h2 id="Bash中的变量"><a href="#Bash中的变量" class="headerlink" title="Bash中的变量"></a>Bash中的变量</h2><h3 id="变量的定义与赋值"><a href="#变量的定义与赋值" class="headerlink" title="变量的定义与赋值"></a>变量的定义与赋值</h3><p>不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_bash_var=<span class="string">"this is my bash var"</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ul><li><strong><code>＝</code>两边不能有空格！</strong>否则就是语法错误了。</li><li>Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。</li></ul><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>使用已定义的变量时，只要在变量名前面加<code>$</code>符号即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$my_bash_var</span></span><br></pre></td></tr></table></figure><p>或者使用<code>${var_name}</code>的形式，<code>{}</code>是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_bash_var&#125;</span></span><br></pre></td></tr></table></figure><p>注意<code>&#39;&#39;</code>和<code>&quot;&quot;</code>的区别：</p><ul><li><code>&#39;&#39;</code> ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；</li><li><code>&quot;&quot;</code>：双引号里可以引用变量，可以出现转义字符。</li></ul><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'a is : $a'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is : <span class="variable">$a</span>"</span></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span> : $a</span><br><span class="line">a <span class="keyword">is</span> : hello</span><br></pre></td></tr></table></figure><h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong><code>readonly</code></strong> 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_var=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">readonly</span> a_var</span><br><span class="line">a_var=<span class="string">"world"</span>  <span class="comment"># Output: bash: read-only variable: a_var</span></span><br></pre></td></tr></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 <strong><code>unset</code></strong> 命令可以删除变量，但是不能删除只读变量。<br> 变量被删除后不能再次使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_var=<span class="string">"haha"</span></span><br><span class="line"><span class="built_in">unset</span> my_var</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_var&#125;</span> <span class="comment"># 变量my_var已被删除，没有任何输出</span></span><br></pre></td></tr></table></figure><h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分<strong>类型</strong>。</p><p>本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是<strong>变量中的值是否只有数字</strong>，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。</p><p>另外，注意Bash中的数字默认的是十进制，八进制需要以<code>0</code>开头，十六进制以<code>0x</code>开头。</p><p>纯数字变量是“数字变量”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=1234</span><br><span class="line"><span class="built_in">let</span> <span class="string">"a+=1"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span>  <span class="comment"># Output: 1235</span></span><br></pre></td></tr></table></figure><p>数字＋字符串：字符串变量，字符串变量不能进行数学运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="variable">$&#123;a/12/BB&#125;</span> <span class="comment"># 将12替换为BB</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;b&#125;</span>    <span class="comment"># Output: BB35</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"b+=1"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;b&#125;</span>    <span class="comment"># Output:1</span></span><br></pre></td></tr></table></figure><p>将变量中的非数字字符替换为数字，得到数字变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c=BB34</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;c&#125;</span>     <span class="comment"># Output: BB34</span></span><br><span class="line"></span><br><span class="line">d=<span class="variable">$&#123;c/BB/12&#125;</span>  <span class="comment"># 将BB替换为12</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;d&#125;</span>     <span class="comment"># Output: 1234</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"d+=1"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;d&#125;</span>     <span class="comment"># Output: 1235</span></span><br></pre></td></tr></table></figure><p>空变量+数字：数字变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量e定义为空值</span></span><br><span class="line">e=<span class="string">""</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;e&#125;</span>  <span class="comment"># Output: 没有任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"e+=1"</span> <span class="comment"># 空值 + 1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;e&#125;</span>  <span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure><p>未定义的变量+数字：数字变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量f未定义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"f = <span class="variable">$f</span>"</span>   <span class="comment"># Output: f =</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"f+=1"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"f = <span class="variable">$&#123;f&#125;</span>"</span> <span class="comment"># Output: f = 1</span></span><br></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul><li>局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用<code>local</code>声明；</li><li>全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；</li><li>环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。<br> 如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。</li></ul><blockquote><p>更多关于环境变量的知识可以参考以下文章：</p><ul><li><a href="https://www.jianshu.com/p/ac2bc0ad3d74" target="_blank" rel="noopener">Linux环境变量总结</a></li><li><a href="https://www.jianshu.com/p/f7d4a821d292" target="_blank" rel="noopener">linux入门之环境变量与文件查找</a></li></ul></blockquote><h2 id="Bash中的运算符"><a href="#Bash中的运算符" class="headerlink" title="Bash中的运算符"></a>Bash中的运算符</h2><p>Bash支持的运算符有：</p><ul><li>数学运算符</li><li>关系运算符</li><li>布尔运算符</li><li>逻辑运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><table><thead><tr><th>数学运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>==</td><td>相等测试，相等则返回true</td></tr><tr><td>!=</td><td>不相等测试，不相等则返回true</td></tr></tbody></table><p><strong>注意：</strong>  乘号<code>*</code>前边必须加反斜杠 \ 才能实现乘法运算</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>(equal)    检测两个数是否相等，相等则返回 true</td></tr><tr><td>-ne</td><td>(not equal）检测两个数是否相等，不相等则返回 true</td></tr><tr><td>-gt</td><td>(greater than）检测左边的数是否大于右边的，如果是，则返回 true</td></tr><tr><td>-lt</td><td>(lower than) 检测左边的数是否小于右边的，如果是，则返回 true</td></tr><tr><td>-ge</td><td>(greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true</td></tr><tr><td>-le</td><td>(lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true</td></tr></tbody></table><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><table><thead><tr><th>布尔运算符</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>与运算，两个表达式都为 true 才返回 true</td></tr><tr><td>-o</td><td>或运算，有一个表达式为 true 则返回 true</td></tr><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>II</td><td>逻辑或</td></tr></tbody></table><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table><thead><tr><th>字符串运算符</th><th>说明</th><th>举例  (a=”abc” b=”def”)</th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true</td><td>[ $a = $b ] 返回 false</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true</td><td>[ $a != $b ] 返回 true</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true</td><td>[ -z $a ] 返回 false</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true</td><td>[ -n $a ] 返回 true</td></tr><tr><td>str_name</td><td>检测字符串是否为空，不为空返回 true</td><td>[ $a ] 返回 true</td></tr></tbody></table><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性</p><table><thead><tr><th>文件测试运算符</th><th>说明</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td></tr><tr><td>-p fill</td><td>检测文件是否是命名管道，如果是，则返回 true</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td></tr></tbody></table><h2 id="Bash的控制流"><a href="#Bash的控制流" class="headerlink" title="Bash的控制流"></a>Bash的控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><ul><li>if</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if-else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if-elif-else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br> 勿忘最后的<code>fi</code>（<code>if</code>的反向拼写）!</p><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$&#123;var&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"<span class="variable">$condition1</span>"</span> )</span><br><span class="line">        command1</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    <span class="string">"<span class="variable">$condition2</span>"</span> )</span><br><span class="line">        command2</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    * )  <span class="comment"># 这里相当于C中case语句的default </span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>对变量使用<code>&quot;&quot;</code>并不是强制的，因为不会发生单词分离;</li><li>每句测试行,都以右小括号<code>)</code>结尾;</li><li>每个条件块都以两个分号<code>;;</code>结尾（作用类似C中的break）;</li><li>case 块的结束以 <code>esac</code>(case 的反向拼写)结尾.</li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br> 在循环的每次执行中，var将顺序的存取 list （i.e. item1 … itemN）中列出的变量。</p><p>C风格的for循环:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( EXP1; EXP2; EXP3 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong>  <code>(())</code>中对变量的引用可以不加<code>$</code></p><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>C风格的while循环:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (( condition ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong>  <code>(())</code>中对变量的引用同样可以不加<code>$</code></p><h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition-is-true ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br> util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。</p><h2 id="Bash支持的编程模型"><a href="#Bash支持的编程模型" class="headerlink" title="Bash支持的编程模型"></a>Bash支持的编程模型</h2><p>Bash只支持<strong>过程式</strong>的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。</p><h2 id="Bash的传参机制"><a href="#Bash的传参机制" class="headerlink" title="Bash的传参机制"></a>Bash的传参机制</h2><p>shell通过<strong>位置参数</strong>（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,$0, $1, $2, $3…  其中：</p><ul><li>$0 是该脚本文件的名字</li><li>$1 是第一个参数, $2 是第 2 个参数…</li></ul><p><strong>注意：</strong></p><ul><li>$9 以后就需要大括号了,如 ${10}, ${11}, ${12}…</li></ul><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数。</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><p><code>$*</code> 与 <code>$@</code> 区别:</p><ul><li>相同点：都表示引用所有的位置参数;</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><h2 id="Bash函数"><a href="#Bash函数" class="headerlink" title="Bash函数"></a>Bash函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment"># 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>关键字function是可选的;</li><li>函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;</li><li>在一个函数内嵌套另一个函数也是可以的，但是不常用.</li></ul><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>函数以<strong>位置</strong>来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, …</p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。</p><h4 id="无参函数的调用"><a href="#无参函数的调用" class="headerlink" title="无参函数的调用"></a>无参函数的调用</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"This is func1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling func1</span></span><br><span class="line">func1</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="type">World!</span></span><br><span class="line"><span class="type">This</span> <span class="keyword">is</span> func1</span><br></pre></td></tr></table></figure><h4 id="有参函数的调用"><a href="#有参函数的调用" class="headerlink" title="有参函数的调用"></a>有参函数的调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func2()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is func2"</span></span><br><span class="line">    </span><br><span class="line">    a=<span class="variable">$1</span></span><br><span class="line">    b=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a is : <span class="variable">$a</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"b is : <span class="variable">$b</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling func2,and pass two parameters</span></span><br><span class="line">func2 <span class="string">"aaa"</span> <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> func2</span><br><span class="line">a <span class="keyword">is</span> : aaa</span><br><span class="line">b <span class="keyword">is</span> : bbb</span><br></pre></td></tr></table></figure><h3 id="函数中参数的作用域"><a href="#函数中参数的作用域" class="headerlink" title="函数中参数的作用域"></a>函数中参数的作用域</h3><p>在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。</p><p>如果变量用<code>local</code> 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部”范围”。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 <span class="comment">#!/bin/bash</span></span><br><span class="line"> 2</span><br><span class="line"> 3 func()</span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5     global_var=<span class="string">"I am global_var difined in function func."</span></span><br><span class="line"> 6     <span class="built_in">echo</span> <span class="variable">$global_var</span></span><br><span class="line"> 7</span><br><span class="line"> 8     <span class="built_in">local</span> loc_var=<span class="string">"I am local_var defined in function func"</span></span><br><span class="line"> 9     <span class="built_in">echo</span> <span class="variable">$loc_var</span></span><br><span class="line">10 &#125;</span><br><span class="line">11</span><br><span class="line">12 func</span><br><span class="line">13 <span class="built_in">echo</span></span><br><span class="line">14 <span class="built_in">echo</span> <span class="variable">$global_var</span></span><br><span class="line">15 <span class="built_in">echo</span> <span class="variable">$loc_var</span></span><br><span class="line">16</span><br><span class="line">17 <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am global_var difined in function <span class="function"><span class="keyword">func</span>.</span></span><br><span class="line">I am local_var defined in function <span class="function"><span class="keyword">func</span></span></span><br><span class="line"></span><br><span class="line">I am global_var difined in function <span class="function"><span class="keyword">func</span>.</span></span><br></pre></td></tr></table></figure><h2 id="Bash数组"><a href="#Bash数组" class="headerlink" title="Bash数组"></a>Bash数组</h2><p>Bash 只支持一维数组，用圆括号<code>()</code>来表示，数组元素之间用”空格”符号来分割（不同于C、C++、Java等语言中用逗号分割）。</p><h3 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h3><p>初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从<code>0</code>开始。</p><h3 id="初始化方式1：直接初始化"><a href="#初始化方式1：直接初始化" class="headerlink" title="初始化方式1：直接初始化"></a>初始化方式1：直接初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_name&#x3D;(value1 value2 ... valueN)</span><br></pre></td></tr></table></figure><h3 id="初始化方式2-用下标初始化"><a href="#初始化方式2-用下标初始化" class="headerlink" title="初始化方式2: 用下标初始化"></a>初始化方式2: 用下标初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_name[0]=value1</span><br><span class="line">arr_name[1]=value2</span><br><span class="line">arr_name[223]=value3 <span class="comment"># 不连续初始化</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>数组成员不必一定要连续，空缺元素是允许的;</li><li>数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;</li></ul><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>访问数组元素的一般格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;arr_name[index]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>使用<code>*</code> 或<code>@</code> 可以获取数组中的所有元素<br> 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_arr=(A B C <span class="string">"ddd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组格式1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my_arr: <span class="variable">$&#123;my_arr[*]&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 遍历数组格式2</span></span><br><span class="line"><span class="string">echo "</span>my_arr: <span class="variable">$&#123;my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_arr: A B C ddd</span><br><span class="line">my_arr: A B C ddd</span><br></pre></td></tr></table></figure><h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><p>获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了<code>#</code>符号，格式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="comment">#arr_name[*]&#125;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="comment">#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数组my_arr的长度（元素个数）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my_arr length: <span class="variable">$&#123;#my_arr[*]&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 获取数组my_arr的长度,</span></span><br><span class="line"><span class="string">echo "</span>my_arr length: <span class="variable">$&#123;#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_arr length: 4</span><br><span class="line">my_arr length: 4</span><br></pre></td></tr></table></figure><h2 id="Bash字符串操作"><a href="#Bash字符串操作" class="headerlink" title="Bash字符串操作"></a>Bash字符串操作</h2><p>在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。<br> 定义字符串实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1=hello</span><br><span class="line">str2=<span class="string">'hello'</span></span><br><span class="line">str3=<span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p>格式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="comment">#string_name&#125;</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_str=<span class="string">"hello world"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my_str length: <span class="variable">$&#123;#my_str&#125;</span></span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_str length: 11</span><br></pre></td></tr></table></figure><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。<br> 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">"hello"</span></span><br><span class="line">str2=<span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">str3=<span class="variable">$&#123;str1&#125;</span><span class="string">" "</span><span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h3><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>${string:position}</td><td>在string中, 从位置position开始提取子串</td></tr><tr><td>${string:position:length}</td><td>在string中, 从位置position开始提取长度为length的子串</td></tr></tbody></table><p>实例1：从位置1开始提取子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">sub_str=<span class="variable">$&#123;str:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sub_str: <span class="variable">$&#123;sub_str&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_str: ello world</span><br></pre></td></tr></table></figure><p>实例2：从位置1开始提取长度为3的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">sub_str=<span class="variable">$&#123;str:1:3&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sub_str: <span class="variable">$&#123;sub_str&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_str: ell</span><br></pre></td></tr></table></figure><h3 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h3><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>${string#substring}</td><td>从string的开头, 删除最短匹配substring的子串</td></tr><tr><td>${string##substring}</td><td>从string的开头, 删除最长匹配substring的子串</td></tr><tr><td>${string%substring}</td><td>从string的结尾, 删除最短匹配substring的子串</td></tr><tr><td>${string%%substring}</td><td>从string的结尾, 删除最长匹配substring的子串</td></tr></tbody></table><p>记忆：</p><ul><li><code>#</code>表示从头匹配，<code>%</code>表示从尾匹配</li><li>一个符号（<code>#</code>或者<code>%</code>）表示最短匹配，两个符号（<code>##</code>或者<code>%%</code>）表示最长匹配</li></ul><p><strong>注意：</strong>substring可以是正则表达式。</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"abcabcdefabcabc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从str的开头,删除最短匹配的以a开头c结尾的子串</span></span><br><span class="line"><span class="comment"># 将删除最左端的abc</span></span><br><span class="line"><span class="comment"># 输出：abcdefabcabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;str#a*c&#125;</span>"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从str的开头,删除最长匹配以a开头b结尾的子串</span></span><br><span class="line"><span class="comment"># 将删除abcabcdefabcab</span></span><br><span class="line"><span class="comment"># 输出：c</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;str##a*b&#125;</span>"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从str的结尾,删除最短匹配以a开头c结尾的子串</span></span><br><span class="line"><span class="comment"># 将删除最右端的abc</span></span><br><span class="line"><span class="comment"># 输出：abcabcdefabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;str%a*c&#125;</span>"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从str的结尾,删除最长匹配以a开头c结尾的子串</span></span><br><span class="line"><span class="comment"># 将删除整个字符串</span></span><br><span class="line"><span class="comment"># 输出：空</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;str%%a*b&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>${string/substring/replacement}</td><td>使用$replacement 来代替<strong>第一个</strong>匹配的$substring</td></tr><tr><td>${string//substring/replacement}</td><td>使用$replacement 代替<strong>所有</strong>匹配的$substring</td></tr><tr><td>${string/#substring/replacement}</td><td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr><tr><td>${string/%substring/replacement}</td><td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr></tbody></table><p>实例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"abcdefabc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用hello替换第一个abc</span></span><br><span class="line">echo $&#123;str/<span class="string">"abc"</span>/<span class="string">"hello"</span>&#125;    <span class="comment"># 输出：hellodefabc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用hello替换第一个abc</span></span><br><span class="line">echo $&#123;str/<span class="regexp">/"abc"/</span><span class="string">"hello"</span>&#125;   <span class="comment"># 输出：hellodefhello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀匹配替换</span></span><br><span class="line">echo $&#123;str/<span class="comment">#"abc"/"world"&#125;   # 输出：worlddefabc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后缀匹配替换</span></span><br><span class="line">echo $&#123;str/％<span class="string">"abc"</span>/<span class="string">"world"</span>&#125;   <span class="comment"># 输出：abcdefworld</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://link.jianshu.com?t=http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">Advanced Bash-Scripting Guide</a><br> 这本书内容翔实，实例丰富，既可做精钻细研的教材，又可作为手册时时查阅，真是居家旅行必备良品;-)</p><p>另外，感兴趣的同学也可翻阅《Linux Shell Scripting Cookbook》(中文译名《Linux Shell脚本攻略》)，里面介绍了很多Shell编程的奇技淫巧，甚是有用有趣。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtualenv简明教程</title>
      <link href="/2020/03/19/Virtualenv%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/19/Virtualenv%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><strong>作者：Andrew_liu</strong></p><p><strong>链接：<a href="https://www.jianshu.com/p/08c657bd34f1" target="_blank" rel="noopener">https://www.jianshu.com/p/08c657bd34f1</a></strong></p><p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p><p><code>virtualenv</code>创建一个拥有自己安装目录的环境, 这个环境不与其他虚拟环境共享库, 能够方便的管理python版本和管理python库</p><h2 id="1-安装Virtualenv"><a href="#1-安装Virtualenv" class="headerlink" title="1. 安装Virtualenv"></a>1. 安装Virtualenv</h2><p>使用<code>pip</code>安装Virtualenv, 使用过python的都应该知道<code>pip</code>包管理神器吧, 即使不知道, 网站也有大把的教程, 不过推荐查看<a href="https://link.jianshu.com?t=https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="noopener">官方安装指南</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv</span><br><span class="line">//或者由于权限问题使用sudo临时提升权限</span><br><span class="line">$ sudo pip install virtualenv</span><br></pre></td></tr></table></figure><h2 id="2-virtualenv基本使用"><a href="#2-virtualenv基本使用" class="headerlink" title="2. virtualenv基本使用"></a>2. virtualenv基本使用</h2><p>现在开始使用virtualenv管理python环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  Test git:(master)$ virtualenv ENV  <span class="comment">#创建一个名为ENV的目录, 并且安装了ENV/bin/python, 创建了lib,include,bin目录,安装了pip</span></span><br><span class="line">New python executable <span class="keyword">in</span> </span><br><span class="line">Installing setuptools, pip...done.</span><br><span class="line">  </span><br><span class="line">➜  Test git:(master)$ <span class="built_in">cd</span> ENV</span><br><span class="line">➜  ENV git:(master)$ ll</span><br><span class="line">drwxr-xr-x  14 andrew_liu  staff  476 12  8 08:49 bin</span><br><span class="line">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 include</span><br><span class="line">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 lib</span><br></pre></td></tr></table></figure><ul><li><code>lib</code>,所有安装的python库都会放在这个目录中的<code>lib/pythonx.x/site-packages/</code>下</li><li><code>bin</code>,<code>bin/python</code>是在当前环境是使用的python解释器</li></ul><blockquote><p>如果在命令行中运行<code>virtualenv --system-site-packages ENV</code>, 会继承<code>/usr/lib/python2.7/site-packages</code>下的所有库, 最新版本virtualenv把把访问全局<code>site-packages</code>作为默认行为<br> default behavior.</p></blockquote><h3 id="2-1-激活virtualenv"><a href="#2-1-激活virtualenv" class="headerlink" title="2.1. 激活virtualenv"></a>2.1. 激活virtualenv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ENV目录下使用如下命令</span></span><br><span class="line">➜  ENV git:(master)$ <span class="built_in">source</span> ./bin/activate  <span class="comment">#激活当前virtualenv</span></span><br><span class="line">(ENV)➜  ENV git:(master)$ <span class="comment">#注意终端发生了变化</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#使用<span class="selector-tag">pip</span>查看当前库</span><br><span class="line">(ENV)➜  ENV git:(master)$ pip list</span><br><span class="line"><span class="selector-tag">pip</span> (1<span class="selector-class">.5</span><span class="selector-class">.6</span>)</span><br><span class="line"><span class="selector-tag">setuptools</span> (3<span class="selector-class">.6</span>)</span><br><span class="line"><span class="selector-tag">wsgiref</span> (0<span class="selector-class">.1</span><span class="selector-class">.2</span>) #发现在只有这三个</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">freeze</span>  #显示所有依赖</span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">freeze</span> &gt; <span class="selector-tag">requirement</span><span class="selector-class">.txt</span>  #生成<span class="selector-tag">requirement</span><span class="selector-class">.txt</span>文件</span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">-r</span> <span class="selector-tag">requirement</span><span class="selector-class">.txt</span>  #根据<span class="selector-tag">requirement</span><span class="selector-class">.txt</span>生成相同的环境</span><br></pre></td></tr></table></figure><h3 id="2-2-关闭virtualenv"><a href="#2-2-关闭virtualenv" class="headerlink" title="2.2. 关闭virtualenv"></a>2.2. 关闭virtualenv</h3><p>使用下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure><h3 id="2-3-指定python版本"><a href="#2-3-指定python版本" class="headerlink" title="2.3. 指定python版本"></a>2.3. 指定python版本</h3><p>可以使用<code>-p PYTHON_EXE</code>选项在创建虚拟环境的时候指定python版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建python2.7虚拟环境</span></span><br><span class="line">➜  Test git:(master) $ virtualenv -p /usr/bin/python2.7 ENV2.7</span><br><span class="line">Running virtualenv with interpreter /usr/bin/python2.7</span><br><span class="line">New python executable <span class="keyword">in</span> ENV2.7/bin/python</span><br><span class="line">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建python3.4虚拟环境</span></span><br><span class="line">➜  Test git:(master) $ virtualenv -p /usr/<span class="built_in">local</span>/bin/python3.4 ENV3.4</span><br><span class="line">Running virtualenv with interpreter /usr/<span class="built_in">local</span>/bin/python3.4</span><br><span class="line">Using base prefix <span class="string">'/Library/Frameworks/Python.framework/Versions/3.4'</span></span><br><span class="line">New python executable <span class="keyword">in</span> ENV3.4/bin/python3.4</span><br><span class="line">Also creating executable <span class="keyword">in</span> ENV3.4/bin/python</span><br><span class="line">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure><blockquote><p>到此已经可以解决python版本冲突问题和python库不同版本的问题</p></blockquote><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><h3 id="3-1-生成可打包环境"><a href="#3-1-生成可打包环境" class="headerlink" title="3.1. 生成可打包环境"></a>3.1. 生成可打包环境</h3><p>某些特殊需求下,可能没有网络, 我们期望直接打包一个ENV, 可以解压后直接使用, 这时候可以使用<code>virtualenv -relocatable</code>指令将ENV修改为可更改位置的ENV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对当前已经创建的虚拟环境更改为可迁移</span></span><br><span class="line">➜  ENV3.4 git:(master) ✗ virtualenv --relocatable ./</span><br><span class="line">Making script ./bin/easy_install relative</span><br><span class="line">Making script ./bin/easy_install-3.4 relative</span><br><span class="line">Making script ./bin/pip relative</span><br><span class="line">Making script ./bin/pip3 relative</span><br><span class="line">Making script ./bin/pip3.4 relative</span><br></pre></td></tr></table></figure><h3 id="3-2-获得帮助"><a href="#3-2-获得帮助" class="headerlink" title="3.2. 获得帮助"></a>3.2. 获得帮助</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv -h</span><br></pre></td></tr></table></figure><p>当前的ENV都被修改为相对路径, 可以打包当前目录, 上传到其他位置使用</p><blockquote><p>这并不能使虚拟环境跨平台使用</p></blockquote><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><p><a href="https://link.jianshu.com?t=http://virtualenv.readthedocs.org/en/latest/virtualenv.html" target="_blank" rel="noopener">virtualenv官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make教程</title>
      <link href="/2020/03/18/Make%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/18/Make%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Make，Makefile是什么"><a href="#Make，Makefile是什么" class="headerlink" title="Make，Makefile是什么"></a>Make，Makefile是什么</h2><p>在开发一个系统时，一般是将一个系统分成几个模块，这样做提高了系统的可维护性，但由于各个模块间不可避免存在关联，所以当一个模块改动后，其他模块也许会有所更新。</p><p>对小系统来说，手工编译连接是没问题，但是如果是一个大系统，存在很多个模块，那么手工编译的方法就不适用了。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件，与手工编译和连接相比，make命令的优点在于他只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文件则置之不理，并且make命令不会漏掉一个需要更新的文件。</p><p>文件和文件间或模块或模块间有可能存在倚赖关系，make命令也是依据这种依赖关系来进行维护的，所以我们有必要了解什么是依赖关系；make命令当然不会自己知道这些依赖关系，而需要程序员将这些依赖关系写入一个叫makefile的文件中。Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。</p><p>即make和makefile的关系是：make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p><p>Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>对于很大的项目来说，自己手写Makefile非常麻烦，而标准的GNU软件（如Apacle）都是运行一个configure脚本文件来产生Makefile；GNU软件automake和autoconf就是自动生成configure的工具。开发人员只需要先定义好宏，automake处理后会产生供autoconf使用的Makefine.in，再用autoconf就可以产生configure。<br>————————————————<br>版权声明：本文为CSDN博主「Jane_小妍」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yg_2012/article/details/38925161" target="_blank" rel="noopener">https://blog.csdn.net/yg_2012/article/details/38925161</a></p><h2 id="如何写Makefile"><a href="#如何写Makefile" class="headerlink" title="如何写Makefile"></a>如何写Makefile</h2><p>以下内容来自于<strong><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">阮一峰的网络日志</a></strong></p><p>构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make  clean</span><br></pre></td></tr></table></figure><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">手册</a>。</p><p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><p>上面代码执行Makefile文件的第一个目标。</p><h3 id="前置条件（prerequisites）"><a href="#前置条件（prerequisites）" class="headerlink" title="前置条件（prerequisites）"></a>前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"this is the source"</span> &gt; source.txt</span><br></pre></td></tr></table></figure><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure><p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure><h3 id="命令（commands）"><a href="#命令（commands）" class="headerlink" title="命令（commands）"></a>命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">all:</span><br><span class="line">&gt; <span class="built_in">echo</span> Hello, world</span><br></pre></td></tr></table></figure><p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p><p>需要注意的是，<strong>每行命令在一个单独的shell中执行。这些Shell之间没有继承关系</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    <span class="built_in">export</span> foo=bar</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"foo=[$<span class="variable">$foo</span>]"</span></span><br></pre></td></tr></table></figure><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar; <span class="built_in">echo</span> <span class="string">"foo=[$<span class="variable">$foo</span>]"</span></span><br></pre></td></tr></table></figure><p>另一个解决办法是在换行符前加反斜杠转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"foo=[$<span class="variable">$foo</span>]"</span></span><br></pre></td></tr></table></figure><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"foo=[$<span class="variable">$foo</span>]"</span></span><br></pre></td></tr></table></figure><h2 id="Makefile文件的语法"><a href="#Makefile文件的语法" class="headerlink" title="Makefile文件的语法"></a>Makefile文件的语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>井号（#）在Makefile中表示注释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line">result.txt: source.txt</span><br><span class="line">    <span class="comment"># 这是注释</span></span><br><span class="line">    cp source.txt result.txt <span class="comment"># 这也是注释</span></span><br></pre></td></tr></table></figure><h3 id="回声（echoing）"><a href="#回声（echoing）" class="headerlink" title="回声（echoing）"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>执行上面的规则，会得到下面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>在命令的前面加上@，就可以关闭回声。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>现在再执行<code>make test</code>，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br><span class="line">    @<span class="built_in">echo</span> TODO</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">        rm -f *.o</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure><p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p><h3 id="变量和赋值符"><a href="#变量和赋值符" class="headerlink" title="变量和赋值符"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $(txt)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p><p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $<span class="variable">$HOME</span></span><br></pre></td></tr></table></figure><p>有时，变量的值可能指向另一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看<a href="http://stackoverflow.com/questions/448910/makefile-variable-assignment" target="_blank" rel="noopener">StackOverflow</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h3 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html" target="_blank" rel="noopener">手册</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure><h3 id="自动变量（Automatic-Variables）"><a href="#自动变量（Automatic-Variables）" class="headerlink" title="自动变量（Automatic Variables）"></a>自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><p><strong>（1）$@</strong></p><p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 $@ 就指代foo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt:</span><br><span class="line">    touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    touch a.txt</span><br><span class="line">b.txt:</span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure><p><strong>（2）$&lt;</strong></p><p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp $&lt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp b.txt a.txt</span><br></pre></td></tr></table></figure><p><strong>（3）$?</strong></p><p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p><p><strong>（4）$^</strong></p><p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p><p><strong>（5）$*</strong></p><p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p><p><strong>（6）$(@D) 和 $(@F)</strong></p><p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p><p>**（7）$(</p><p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html" target="_blank" rel="noopener">手册</a>。下面是自动变量的一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest/%.txt: src/%.txt</span><br><span class="line">    @[ -d dest ] || mkdir dest</span><br><span class="line">    cp $&lt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p><h3 id="判断和循环"><a href="#判断和循环" class="headerlink" title="判断和循环"></a>判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> $<span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> one two three; <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面代码的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Makefile 还可以使用函数，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure><p>Makefile提供了许多<a href="http://www.gnu.org/software/make/manual/html_node/Functions.html" target="_blank" rel="noopener">内置函数</a>，可供调用。下面是几个常用的内置函数。</p><p><strong>（1）shell 函数</strong></p><p>shell 函数用来执行 shell 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(shell <span class="built_in">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure><p><strong>（2）wildcard 函数</strong></p><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure><p><strong>（3）subst 函数</strong></p><p>subst 函数用来文本替换，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure><p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class="line"><span class="comment"># bar is now `a,b,c'.</span></span><br></pre></td></tr></table></figure><p><strong>（4）patsubst函数</strong></p><p>patsubst 函数用于模式匹配的替换，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure><p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure><p><strong>（5）替换后缀名</strong></p><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><h2 id="Makefile-的实例"><a href="#Makefile-的实例" class="headerlink" title="Makefile 的实例"></a>Makefile 的实例</h2><p><strong>（1）执行多个目标</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p><p><strong>（2）编译C语言项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">     rm edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">.PHONY: edit clean</span><br></pre></td></tr></table></figure><h2 id="使用make构建网站"><a href="#使用make构建网站" class="headerlink" title="使用make构建网站"></a>使用make构建网站</h2><p>本文来源<strong><a href="http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html" target="_blank" rel="noopener">阮一峰的网络日志</a></strong></p><h3 id="Make的优点"><a href="#Make的优点" class="headerlink" title="Make的优点"></a>Make的优点</h3><p>首先解释一下，为什么要用Make。</p><p>目前，网站项目（尤其是Node.js项目）有三种构建方案。</p><blockquote><ul><li>方案一：基于Node.js的专用构建工具（<a href="http://gruntjs.com/" target="_blank" rel="noopener">Grunt</a>、<a href="http://gulpjs.com/" target="_blank" rel="noopener">Gulp</a>、<a href="http://brunch.io/" target="_blank" rel="noopener">Brunch</a>、<a href="https://github.com/broccolijs/broccoli" target="_blank" rel="noopener">Broccoli</a>、<a href="http://mimosa.io/" target="_blank" rel="noopener">Mimosa</a>）</li><li>方案二：npm run命令（<a href="http://substack.net/task_automation_with_npm_run" target="_blank" rel="noopener">教程1</a>、<a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" target="_blank" rel="noopener">2</a>、<a href="http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/" target="_blank" rel="noopener">3</a>）</li><li>方案三：make命令</li></ul></blockquote><p>我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。</p><p><strong>（1）插件问题</strong></p><p>Grunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。</p><p><strong>（2）兼容性问题</strong></p><p>插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，<a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank" rel="noopener">grunt-contrib-jshint插件</a>现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。</p><p><strong>（3）语法问题</strong></p><p>Grunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。</p><p><strong>（4）功能问题</strong></p><p>make已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。</p><p>基于以上理由，我看好make。</p><h3 id="常见的构建任务"><a href="#常见的构建任务" class="headerlink" title="常见的构建任务"></a>常见的构建任务</h3><p>下面是一些常见的网站构建任务。</p><blockquote><ul><li>检查语法</li><li>编译模板</li><li>转码</li><li>合并</li><li>压缩</li><li>测试</li><li>删除</li></ul></blockquote><p>这些任务用到 <a href="http://jshint.com/" target="_blank" rel="noopener">JSHint</a>、<a href="http://handlebarsjs.com/" target="_blank" rel="noopener">handlebars</a>、<a href="http://coffeescript.org/" target="_blank" rel="noopener">CoffeeScript</a>、<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">uglifyjs</a>、<a href="http://mochajs.org/" target="_blank" rel="noopener">mocha</a> 等工具。对应的package.json文件如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"coffee-script"</span>: <span class="string">"~1.9.1"</span>,</span><br><span class="line">    <span class="string">"handlebars"</span>: <span class="string">"~3.0.0"</span>,</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"^2.6.3"</span>,</span><br><span class="line">    <span class="string">"mocha"</span>: <span class="string">"~2.2.1"</span>,</span><br><span class="line">    <span class="string">"uglify-js"</span>: <span class="string">"~2.4.17"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看，Make 命令怎么完成这些构建任务。</p><h3 id="Makefile的通用配置"><a href="#Makefile的通用配置" class="headerlink" title="Makefile的通用配置"></a>Makefile的通用配置</h3><p>开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件（参见<a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">《Make 命令教程》</a>）。</p><p>首先，写入两行通用配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH  := node_modules/.bin:$(PATH)</span><br><span class="line">SHELL := /bin/bash</span><br></pre></td></tr></table></figure><p>上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。</p><p>PATH变量重新赋值为，优先在 node<em>modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node</em>modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。</p><p>SHELL变量指定构建环境使用BASH。</p><h3 id="检查语法错误"><a href="#检查语法错误" class="headerlink" title="检查语法错误"></a>检查语法错误</h3><p>第一个任务是，检查源码有没有语法错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js_files = $(shell find ./lib -name <span class="string">'*.js'</span>)</span><br><span class="line"></span><br><span class="line">lint: $(js_files)</span><br><span class="line">    jshint $?</span><br></pre></td></tr></table></figure><p>上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make lint</span><br></pre></td></tr></table></figure><h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build/templates.js: templates/*.handlebars</span><br><span class="line">    mkdir -p $(dir <span class="variable">$@</span>)</span><br><span class="line">    handlebars templates/*.handlebars &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">template: build/templates.js</span><br></pre></td></tr></table></figure><p>上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make template</span><br></pre></td></tr></table></figure><h3 id="Coffee脚本转码"><a href="#Coffee脚本转码" class="headerlink" title="Coffee脚本转码"></a>Coffee脚本转码</h3><p>第三个任务是，将CofferScript脚本转为JavaScript脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source_files := $(wildcard lib/*.coffee)</span><br><span class="line">build_files  := $(source_files:lib/%.coffee=build/%.js)</span><br><span class="line"></span><br><span class="line">build/%.js: lib/%.coffee</span><br><span class="line">    coffee -co $(dir <span class="variable">$@</span>) $&lt;</span><br><span class="line"></span><br><span class="line">coffee: $(build_files)</span><br></pre></td></tr></table></figure><p>上面代码中，首先获取所有的Coffee脚本文件，存放在变量source<em>files，函数wildcard用来扩展通配符。然后，将变量source</em>files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make coffee</span><br></pre></td></tr></table></figure><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p>使用cat命令，合并多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS_FILES := $(wildcard build/*.js)</span><br><span class="line">OUTPUT := build/bundle.js</span><br><span class="line"></span><br><span class="line">concat: $(JS_FILES)</span><br><span class="line">    cat $^ &gt; $(OUTPUT)</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make concat</span><br></pre></td></tr></table></figure><h3 id="压缩JavaScript脚本"><a href="#压缩JavaScript脚本" class="headerlink" title="压缩JavaScript脚本"></a>压缩JavaScript脚本</h3><p>将所有JavaScript脚本，压缩为build目录下的app.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app_bundle := build/app.js</span><br><span class="line"></span><br><span class="line">$(app_bundle): $(build_files) $(template_js)</span><br><span class="line">    uglifyjs -cmo <span class="variable">$@</span> $^</span><br><span class="line"></span><br><span class="line">min: $(app_bundle)</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make min</span><br></pre></td></tr></table></figure><p>还有另一种写法，可以另行指定压缩工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UGLIFY ?= uglify</span><br><span class="line"></span><br><span class="line">$(app_bundle): $(build_files) $(template_js)</span><br><span class="line">    $(UGLIFY) -cmo <span class="variable">$@</span> $^</span><br></pre></td></tr></table></figure><p>上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。</p><p>调用时这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make UGLIFY=node_modules/.bin/jsmin min</span><br></pre></td></tr></table></figure><p>上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。</p><h3 id="删除临时文件"><a href="#删除临时文件" class="headerlink" title="删除临时文件"></a>删除临时文件</h3><p>构建结束前，删除所有临时文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -rf build</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>假定测试工具是mocha，所有测试用例放在test目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>: $(app_bundle) $(test_js)</span><br><span class="line">    mocha</span><br></pre></td></tr></table></figure><p>当脚本和测试用例都存在，上面代码就会执行mocha。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="多任务执行"><a href="#多任务执行" class="headerlink" title="多任务执行"></a>多任务执行</h3><p>构建过程需要一次性执行多个任务，可以指定一个多任务目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build: template concat min clean</span><br></pre></td></tr></table></figure><p>上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make build</span><br></pre></td></tr></table></figure><p>如果这行规则在Makefile的最前面，执行时可以省略目标名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><p>通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -j build</span><br></pre></td></tr></table></figure><h3 id="声明伪文件"><a href="#声明伪文件" class="headerlink" title="声明伪文件"></a>声明伪文件</h3><p>最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: lint template coffee concat min <span class="built_in">test</span> clean build</span><br></pre></td></tr></table></figure><h3 id="Makefile文件示例"><a href="#Makefile文件示例" class="headerlink" title="Makefile文件示例"></a>Makefile文件示例</h3><p>下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。</p><p>实例一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PROJECT = <span class="string">"My Fancy Node.js project"</span></span><br><span class="line"></span><br><span class="line">all: install <span class="built_in">test</span> server</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>: ;@<span class="built_in">echo</span> <span class="string">"Testing <span class="variable">$&#123;PROJECT&#125;</span>....."</span>; \</span><br><span class="line">    <span class="built_in">export</span> NODE_PATH=.; \</span><br><span class="line">    ./node_modules/mocha/bin/mocha;</span><br><span class="line"></span><br><span class="line">install: ;@<span class="built_in">echo</span> <span class="string">"Installing <span class="variable">$&#123;PROJECT&#125;</span>....."</span>; \</span><br><span class="line">    npm install</span><br><span class="line"></span><br><span class="line">update: ;@<span class="built_in">echo</span> <span class="string">"Updating <span class="variable">$&#123;PROJECT&#125;</span>....."</span>; \</span><br><span class="line">    git pull --rebase; \</span><br><span class="line">    npm install</span><br><span class="line"></span><br><span class="line">clean : ;</span><br><span class="line">    rm -rf node_modules</span><br><span class="line"></span><br><span class="line">.PHONY: <span class="built_in">test</span> server install clean update</span><br></pre></td></tr></table></figure><p>实例二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: build-js build-css</span><br><span class="line"></span><br><span class="line">build-js:</span><br><span class="line">  browserify -t brfs src/app.js &gt; site/app.js</span><br><span class="line"></span><br><span class="line">build-css:</span><br><span class="line">  stylus src/style.styl &gt; site/style.css</span><br><span class="line"></span><br><span class="line">.PHONY build-js build-css</span><br></pre></td></tr></table></figure><p>参考链接</p><ul><li>Jess Telford, <a href="https://github.com/jesstelford/cloverfield-build-make" target="_blank" rel="noopener">Example using Makefile for cloverfield</a></li><li>Oskar Schöldström, <a href="http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/" target="_blank" rel="noopener">How to use Makefiles in your web projects</a></li><li>James Coglan, <a href="https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/" target="_blank" rel="noopener">Building JavaScript projects with Make</a></li><li>Rob Ashton, <a href="http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html" target="_blank" rel="noopener">The joy of make</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式教程</title>
      <link href="/2020/03/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文来源<a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></strong> 原作者：deerchao</p><p>相关链接：</p><ul><li><a href="https://deerchao.cn/tutorials/regex/common.htm" target="_blank" rel="noopener">常用正则表达式</a></li><li><a href="https://deerchao.cn/tools/wegester/" target="_blank" rel="noopener">JavaScript 在线正则测试器</a></li><li><a href="https://deerchao.cn/tools/regester/" target="_blank" rel="noopener">.Net 正则表达式测试工具</a></li><li><a href="https://deerchao.cn/tutorials/regex/diffs.html" target="_blank" rel="noopener">正则表达式引擎特性对比</a></li></ul><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p><h2 id="如何使用本教程"><a href="#如何使用本教程" class="headerlink" title="如何使用本教程"></a>如何使用本教程</h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p><p>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？</p><p><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">清除格式</a> 文本格式约定：<strong>专业术语</strong> 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) <em>对其进行匹配的源字符串</em> 对正则表达式或其中一部分的说明</p><p><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">隐藏边注</a> 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。</p><p>本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看<a href="https://deerchao.cn/tutorials/regex/diffs.html" target="_blank" rel="noopener">正则表达式引擎特性对比</a>。</p><p>最重要的是——请给我<em>30分钟</em>，如果你没有使用正则表达式的经验，请不要试图在30<em>秒</em>内入门——除非你是超人 :)</p><h2 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><p>很可能你使用过Windows/Dos下用于文件查找的<strong>通配符(wildcard)</strong>，也就是<em>和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索</em>.doc。在这里，<em>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或*0376-7654321</em>)。</p><p><strong>字符</strong>是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。<strong>字符串</strong>是0个或更多个字符的序列。<strong>文本</strong>也就是文字，字符串。说某个字符串<strong>匹配</strong>某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。</p><p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p><p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<em>hi</em>,<em>HI</em>,<em>Hi</em>,<em>hI</em>这四种情况中的任意一种。</p><p>不幸的是，很多单词里包含<em>hi<em>这两个连续的字符，比如</em>him</em>,<em>history</em>,<em>high</em>等等。用hi来查找的话，这里边的<em>hi</em>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。</p><p>\b是正则表达式规定的一个特殊代码（好吧，某些人叫它<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p><p>如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。</p><p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。</p><p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.<em>连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.</em>\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p><p>换行符就是’\n’,ASCII编码为10(十六进制0x0A)的字符。</p><p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p><p>0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p><p>这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p><p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。</p><h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p><p>不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 <a href="https://deerchao.cn/tools/regester/" target="_blank" rel="noopener">Regester</a>。请参考该页面的说明来安装和运行该软件。</p><p>你也可以试试这个在线测试工具：<a href="https://deerchao.cn/tools/wegester/" target="_blank" rel="noopener">Wegester, JavaScript正则表达式测试器。</a></p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p><p>对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</p><p>下面来看看更多的例子：</p><p>\ba\w<em>\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w</em>)，最后是单词结束处(\b)。</p><p>\d+匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p><p>\b\w{6}\b 匹配刚好6个字符的单词。</p><p>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。</p><p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p><p>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p><p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p><p>正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.</p><p>例如：deerchao.cn匹配deerchao.cn，C:\Windows匹配C:\Windows。</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>你已经看过了前面的<em>,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如</em>,{5,12}等)：</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><p>下面是一些使用重复的例子：</p><p>Windows\d+匹配Windows后面跟1个或更多数字</p><p>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p><p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><p>我们也可以轻松地指定一个字符<strong>范围</strong>，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p><p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p><p>这个表达式可以匹配几种格式的电话号码，像<em>(010)88886666</em>，或<em>022-22334455</em>，或<em>02912345678</em>等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p><p>“(”和“)”也是元字符，后面的<a href="https://deerchao.cn/tutorials/regex/regex.htm#grouping" target="_blank" rel="noopener">分组节</a>里会提到，所以在这里需要使用<a href="https://deerchao.cn/tutorials/regex/regex.htm#escape" target="_blank" rel="noopener">转义</a>。</p><h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配<em>010)12345678*或</em>(022-87654321<em>这样的“不正确”的格式。要解决这个问题，我们需要用到*</em>分枝条件<strong>。正则表达式里的</strong>分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p><p>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p><p>(0\d{2})[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p><p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p><p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p><p>不幸的是，它也将匹配<em>256.300.888.999</em>这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p><p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p><p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>：</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><p>例子：\S+匹配不包含空白符的字符串。</p><p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p><h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>呃……其实,组号分配还不像我刚说得那么简单：</p><ul><li>分组0对应整个正则表达式</li><li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li><li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li></ul><p><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p><p>你也可以自己指定子表达式的<strong>组名</strong>。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组<strong>捕获</strong>的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。</p><p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>(?<name>exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td><td></td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td></td></tr><tr><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。最好还是拿例子来说明吧：</p><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p><p>(?=exp)也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<em>I’m singing while you’re dancing.</em>时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫<strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<em>reading a book</em>时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对<em>1234567890</em>进行查找时结果是234567890。</p><p>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p><p>\b\w<em>q[^u]\w</em>\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w<em>\b将会匹配下一个单词，于是\b\w</em>q[^u]\w<em>\b就能匹配整个</em>Iraq fighting<em>。*</em>负向零宽断言<strong>能解决这样的问题，因为它只匹配一个位置，并不</strong>消费*<em>任何字符。现在，我们可以这样来解决这个问题：\b\w</em>q(?!u)\w*\b。</p><p><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p><p>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言</strong>来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。</p><p>一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).<em>(?=&lt;/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的<strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是.</em>(任意的字符串),最后是一个<strong>后缀</strong>(?=&lt;/\1&gt;)。注意后缀里的/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25<a href="?#250-255">0-5</a>|[01]?\d\d?(?#0-199)。</p><p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;&#x3D;    # 断言要匹配的文本的前缀</span><br><span class="line">&lt;(\w+)&gt; # 查找尖括号括起来的内容</span><br><span class="line">        # (即HTML&#x2F;XML标签)</span><br><span class="line">)       # 前缀结束</span><br><span class="line">.*      # 匹配任意文本</span><br><span class="line">(?&#x3D;     # 断言要匹配的文本的后缀</span><br><span class="line">&lt;\&#x2F;\1&gt;  # 查找尖括号括起来的内容</span><br><span class="line">        # 查找尖括号括起来的内容</span><br><span class="line">)       # 后缀结束</span><br></pre></td></tr></table></figure><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索</em>aabab<em>的话，它会匹配整个字符串aabab。这被称为*</em>贪婪**匹配。</p><p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p>a.<em>?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于</em>aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p><p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>IgnoreCase(忽略大小写)</td><td>匹配时不区分大小写。</td></tr><tr><td>Multiline(多行模式)</td><td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td></tr><tr><td>Singleline(单行模式)</td><td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td></tr><tr><td>IgnorePatternWhitespace(忽略空白)</td><td>忽略表达式中的非转义空白并启用由#标记的注释。</td></tr><tr><td>ExplicitCapture(显式捕获)</td><td>仅捕获已被显式命名的组。</td></tr></tbody></table><p>在C#中，你可以使用<a href="http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx" target="_blank" rel="noopener">Regex(String, RegexOptions)构造函数</a>来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\ba\w{6}\b”, RegexOptions.IgnoreCase);</p><p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.</p><p>目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。</p><h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如<em>( 5 / ( 3 + 2 ) ) )</em>，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p><p>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p><p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<em>xx   aa&gt; yy</em>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p><p>这里需要用到以下的语法构造：</p><ul><li>(?’group’) 把捕获的内容命名为group,并压入<strong>堆栈(Stack)</strong></li><li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li><li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;                   #最外层的左括号</span><br><span class="line">  [^&lt;&gt;]*            #它后面非括号的内容</span><br><span class="line">  (</span><br><span class="line">      (</span><br><span class="line">        (?&#39;Open&#39;&lt;)  #左括号，压入&quot;Open&quot;</span><br><span class="line">        [^&lt;&gt;]*      #左括号后面的内容</span><br><span class="line">      )+</span><br><span class="line">      (</span><br><span class="line">        (?&#39;-Open&#39;&gt;) #右括号，弹出一个&quot;Open&quot;</span><br><span class="line">        [^&lt;&gt;]*      #右括号后面的内容</span><br><span class="line">      )+</span><br><span class="line">  )*</span><br><span class="line">  (?(Open)(?!))     #最外层的右括号前检查</span><br><span class="line">                    #若还有未弹出的&quot;Open&quot;</span><br><span class="line">                    #则匹配失败</span><br><span class="line"></span><br><span class="line">&gt;                #最外层的右括号</span><br></pre></td></tr></table></figure><p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：&lt;div[^&gt;]<em>&gt;[^&lt;&gt;]</em>(((?’Open’&lt;div[^&gt;]<em>&gt;)[^&lt;&gt;]</em>)+((?’-Open’</div>)[^&lt;&gt;]<em>)+)</em>(?(Open)(?!))</div>.</p><p>如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p><h2 id="还有些什么东西没提到"><a href="#还有些什么东西没提到" class="headerlink" title="还有些什么东西没提到"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href="http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx" target="_blank" rel="noopener">关于正则表达式语言元素的MSDN在线文档</a>。</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>报警字符(打印它的效果是电脑嘀一声)</td></tr><tr><td>\b</td><td>通常是单词分界位置，但如果在字符类里使用代表退格</td></tr><tr><td>\t</td><td>制表符，Tab</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\v</td><td>竖向制表符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\e</td><td>Escape</td></tr><tr><td>\0nn</td><td>ASCII代码中八进制代码为nn的字符</td></tr><tr><td>\xnn</td><td>ASCII代码中十六进制代码为nn的字符</td></tr><tr><td>\unnnn</td><td>Unicode代码中十六进制代码为nnnn的字符</td></tr><tr><td>\cN</td><td>ASCII控制字符。比如\cC代表Ctrl+C</td></tr><tr><td>\A</td><td>字符串开头(类似^，但不受处理多行选项的影响)</td></tr><tr><td>\Z</td><td>字符串结尾或行尾(不受处理多行选项的影响)</td></tr><tr><td>\z</td><td>字符串结尾(类似$，但不受处理多行选项的影响)</td></tr><tr><td>\G</td><td>当前搜索的开头</td></tr><tr><td>\p{name}</td><td>Unicode中命名为name的字符类，例如\p{IsGreek}</td></tr><tr><td>(?&gt;exp)</td><td>贪婪子表达式</td></tr><tr><td>(?<x>-<y>exp)</td><td>平衡组</td></tr><tr><td>(?im-nsx:exp)</td><td>在子表达式exp中改变处理选项</td></tr><tr><td>(?im-nsx)</td><td>为表达式后面的部分改变处理选项</td></tr><tr><td>(?(exp)yes|no)</td><td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td></tr><tr><td>(?(exp)yes)</td><td>同上，只是使用空表达式作为no</td></tr><tr><td>(?(name)yes|no)</td><td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td></tr><tr><td>(?(name)yes)</td><td>同上，只是使用空表达式作为no</td></tr></tbody></table><h2 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h2><p>好吧，我承认，我骗了你，读到这里你肯定花了不止30分钟。相信我，这是我的错，而不是因为你太笨。我之所以说”30分钟”，是为了让你有信心，有耐心继续下去。既然你看到了这里，那证明我的阴谋成功了。被忽悠的感觉很爽吧？</p><p>要投诉我，或者觉得我其实可以忽悠得更高明，或者有关于正则表达式的问题, 可以发邮件到 deerchao#qq#com。如果本文给了你帮助，你可以使用支付宝或微信支付向我打赏。点击本页右上方的“打赏”即可看到支付二维码，可能你得先<a href="https://deerchao.cn/tutorials/regex/regex.htm#top" target="_blank" rel="noopener">回到页面最顶端</a>。</p><h2 id="网上的资源及本文参考文献"><a href="#网上的资源及本文参考文献" class="headerlink" title="网上的资源及本文参考文献"></a>网上的资源及本文参考文献</h2><ul><li><a href="https://u.jd.com/0yfKdc" target="_blank" rel="noopener">精通正则表达式(第3版)</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions" target="_blank" rel="noopener">微软的正则表达式教程</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex" target="_blank" rel="noopener">Regex类(微软文档)</a></li><li><a href="http://www.regular-expressions.info/" target="_blank" rel="noopener">专业的正则表达式教学网站(英文)</a></li><li><a href="http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx" target="_blank" rel="noopener">关于.Net下的平衡组的详细讨论（英文）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为低分辨率屏幕开启HiDPI</title>
      <link href="/2020/03/17/%E4%B8%BA%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%B1%8F%E5%B9%95%E5%BC%80%E5%90%AFHiDPI/"/>
      <url>/2020/03/17/%E4%B8%BA%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%B1%8F%E5%B9%95%E5%BC%80%E5%90%AFHiDPI/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我一直不推荐Mac用户购买21:9的显示器，理由有很多。光是不买21:9的理由就不少，因为就个人的使用体验来说，21:9的生产力是远远不及双屏的生产力的，双屏的分屏控制不知道比21:9要高到哪里去了。</p><p>再者，Mac对4K以下的分辨率十分不友好，在2K，1080p中，字体发虚模糊都是很正常的事情。一切换成Windows，你就立马觉得字体变得清晰了很多，足以看出Mac对于低分屏有多不用心了。</p><p>但是因为AW3420DW近期在打折，我看也没啥4K屏有好价，便干脆再次入手了一个，希望它在AW3418DW之上有所改观。一插上电我就后悔了，熟悉的发虚字体又回来了。</p><p>这个时候唯一的解决办法就是HiDPI了。这个功能MacOS并不在低分屏上开启，所以我们要手动开启。其一共有三个步骤</p><h2 id="1-关闭SIP（System-Integrity-Protection）"><a href="#1-关闭SIP（System-Integrity-Protection）" class="headerlink" title="1. 关闭SIP（System Integrity Protection）"></a>1. 关闭SIP（System Integrity Protection）</h2><ol><li>Click the <strong>Apple symbol</strong> in the Menu bar.</li><li>Click <strong>Restart</strong></li><li>Hold down <strong>Command-R</strong> to reboot into Recovery Mode.</li><li>Click <strong>Utilities</strong>.</li><li>Select <strong>Terminal</strong>.</li><li>Type <strong><code>csrutil disable</code></strong>.</li><li>Press <strong>Return</strong> or <strong>Enter</strong> on your keyboard.</li><li>Click the <strong>Apple symbol</strong> in the Menu bar.</li><li>Click <strong>Restart</strong></li></ol><h2 id="2-使用一键脚本"><a href="#2-使用一键脚本" class="headerlink" title="2. 使用一键脚本"></a>2. 使用一键脚本</h2><p><a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="noopener">One Key HiDPI</a></p><p>阅读其readme，中英双语，相信身为高材生的你不难搞定</p><p>其中，我们21:9的用户由于并不常见，可以选择手动输入分辨率，输入2560x1072 5120x2144就好</p><p>接下来重启，应该就能看到效果，选择一个合适的缩放即可</p><p>假如你觉得视觉效果还是不行，那是这个显示器分辨率不够高。你已经到显示效果极限了。假如你并不满意，建议还是上双4K屏幕，省心省力，而且清晰</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Hire Benefit 全解</title>
      <link href="/2020/03/17/New-Hire-Benefit-%E5%85%A8%E8%A7%A3/"/>
      <url>/2020/03/17/New-Hire-Benefit-%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文纯属转载</strong></p><p>第一天remote onboarding，benefit的人上来对保险一顿讲解，讲得我头晕眼花。回来仔细查查，才好了解自己到底要买哪个。虽然现在新冠疫情严重，我早已决定把保险拉满（冲</p><h2 id="Medical-Insurance"><a href="#Medical-Insurance" class="headerlink" title="Medical Insurance"></a>Medical Insurance</h2><p>First of all there are some terms that you need to know, because these are the main differences of all the insurances.</p><p><strong>此处部分原文来源<a href="https://tigerless.com/how-to-choose-us-health-insurance/" target="_blank" rel="noopener">虎虎保险</a></strong></p><ul><li><p><strong>1 保险费(Premium)</strong></p><p><strong>不要贪图便宜选保险费(Premium)低的</strong></p><p>保险费 （Premium）。保险费是指你购买健保时，定期要支付给保险公司的费用，一般是每月支付。保险费与受保人年龄、健康状况等相关。一般受保人年龄越高，保险费越贵。一定要先了解公司的保险费（Premium）是多少， 一般每个保险公司都会给出不同(价位的保险选择来迎合不同的受保人需要。但保险费（Premium）不是越低越好？保险费越低意味着赔偿支付也越低，并且限制条件会比较多。</p></li><li><p><strong>2 Out-Of-Pocket</strong></p><p>指自己看病后实际上需要交的钱</p></li><li><p><strong>2 最高限额（Maximum Payment）</strong></p><p><strong>保险公司的 Maximum Payment 额高很重要</strong></p><p>最高保险支付额(Maximum Payment) 是保险公司愿意为你买单的上限。不要天真的以为，看什么病，花多少钱，买了医疗保险，保险公司就都会为你买单。事实上，一般的美国医疗保险都会有一个支付额度的上限。如果你选的保险支付额越低，那么你自己生了大病，要掏腰包的钱就越多。 美国随便做个手术，几万美金小意思~</p></li><li><p><strong>3 自付额(Deductible)</strong></p><p><strong>自付额低很重要</strong></p><p>一般保险公司要求个人支付500美元到5000美元不等的自付款。也就是你一年要先自付一笔钱之后，保险公司才会开始付。总之就是当然是自付额越少越好。有些保险甚至没有自付额，但是每月的Premium就会变高，也就是每月固定支付的钱增加。</p></li><li><p><strong>4 挂号费(Copay)</strong></p><p><strong>挂号费高低因人而异</strong></p><p>定额手续费（copay）是指受保人每次看普通门诊或购买处方药时需当场支付的一笔固定费用。例如，每次看医生门诊个人需支付20美元，购买处方药时需支付15美元。具体的定额手续费金额，看保险合同。一般来说copay从20-50美元都有，也有0的。如果你是医院的“常客”，建议你选择copay低一点的美国医保，但是这样的医疗保险保险费可能相对较高。如果你身体很好，又年轻，不怎么进医院，可以选择保险费相对低的，copay高一点也就无所谓了。</p></li><li><p><strong>5 特殊限制(Special Limits)</strong></p><p><strong>那么医保公司到底可以付多少？需要仔细阅读保险的条款，特别是你有一些疾病，需要长期治疗的。</strong></p><p>对于一些特殊医疗服务，包括住院、手术、麻醉、心理治疗等，不少保险公司规定有一定的支付限额。有些规定一年只报一次Image, 一次体检，需要更多则要自己掏钱。</p></li><li><p><strong>6 排除支付条款(Exclusion)</strong></p><p><strong>每一份保险都会有一个Exclusion list，购买之前一定要仔细阅读哪些医疗项目不在保险支付范围之内。</strong></p><p>在美国看牙，是出了名的贵，牙科/眼科一般都是单门的医保项目。</p></li></ul><ul><li><p><strong>HMO(Health Maintenance Organization)</strong></p><p>Cost less, but you have less choice of doctors, when you choose HMO, you have to name a specific doctor who manages all of your cares, often called primary care doctor. You must go to see this specific doctor before you see any other doctors when you are sick or need care. You will have to make a pre-defined payment, known as copay every time you see your primary doctor and any specialists she or he may send you to for care.</p></li><li><p><strong>PPO(Preferred Provider Organization)</strong></p><p>Give you more freedom to choose from a larger pool of doctors, generally cost you more paychecks. You still need to see the doctors “in network” to get the most coverage from the plan. You still need to pay the copay each time you visit the specialist</p></li></ul><ul><li><p><strong>HDHP(High Deductible Health Plan) or CDHP</strong></p><p>Cost the least but have a higher deductible. A health Saving account- or HSA- can be attached to a HDHP to help cover the expenses</p></li></ul><h2 id="Flexible-Spending-Account-FSA"><a href="#Flexible-Spending-Account-FSA" class="headerlink" title="Flexible Spending Account (FSA)"></a>Flexible Spending Account (FSA)</h2><p><strong>本文来源：<a href="https://usdweekly.com/what-is-fsa/" target="_blank" rel="noopener">美元先生</a></strong></p><h3 id="FSA是什么？"><a href="#FSA是什么？" class="headerlink" title="FSA是什么？"></a>FSA是什么？</h3><p>FSA的全称叫Flexible Saving Account，它的主要作用是国税局考虑到贫苦大众们面对生活的摩擦，在生病时总得给点安慰。于是，国税局在1978年开始，正式开始将FSA作为一个福利推出。</p><p>FSA是一个用于给你自己报销医疗花销的储蓄帐户</p><p>最简单的理解是，FSA就是一个银行帐户，在你的工资被扣税前，你可以选择存一部分到这个帐户中。</p><p>存入的这个部分，国税局不会对你征税。</p><p>举个例子，你一年收入是10万美元，而今年你决定把2000美元整放到FSA中，那么你的征税收入计算是98,000而非10万。</p><h3 id="FSA报销怎么理解？"><a href="#FSA报销怎么理解？" class="headerlink" title="FSA报销怎么理解？"></a>FSA报销怎么理解？</h3><p>FSA的报销是指，你自己报销向自己报销花销。这个概念一开始很难理解，哪有人自己找自己报销的？我们用一个例子来说明</p><p>还是继续上面的假设，你今年在FSA里放了2000美元，注意这2000美元IRS没跟你要过一分钱税，而是直接从你工资税前部分存入的。</p><p>然后你很不幸地摔了，看病花了1000美元，这1000美元是你用你自己Chase卡付的。<em>注意，这里的1000美元花的是你税后的钱</em>（不管你用的是Chase信用卡还是借记卡都是你税后的钱）</p><p>现在，你决定去跟自己的FSA报销。你FSA的余额还有2000美元，而你需要报销1000美元出来。你提交了医疗凭证（收据、医生处方），被批准后，FSA往你的银行存入1000美元。这整个过程结果是，你用1000美元税钱的钱看好了病，也即你向自己的FSA成功报销了一次。</p><h3 id="怎么用FSA省钱？"><a href="#怎么用FSA省钱？" class="headerlink" title="怎么用FSA省钱？"></a>怎么用FSA省钱？</h3><p>FSA省钱的策略比HSA简单太多了。</p><p>最基本的理解就是，存入FSA的钱不需要交税，而用这个帐户付钱的时候，只要是付<strong><em>医疗相关</em></strong>的费用（需要证明）就可以被允许（或俗称的，可报销）。</p><p>假设你今年在FSA里存入了2000美元，这2000美元拿去打针吃药是完全没有问题的。最棒的是，FSA还可以报销一些你不太想得到的开销</p><h3 id="FSA可以报销哪些开销"><a href="#FSA可以报销哪些开销" class="headerlink" title="FSA可以报销哪些开销"></a>FSA可以报销哪些开销</h3><p>再次夸一次IRS，或者说瞪一眼美国国税局——由于这个资本主义国家发展的年代已经非常久远，税收的体制已经非常健全，你能想到的漏洞它基本已经帮你想好且堵住了。</p><p>比如说，一个自然的想法就是，FSA里的钱如果可以拿去支付任何开销的话，那不就等于现金了吗？</p><p>非常遗憾的是，IRS不仅对花销的种类有限制，甚至逐条列出来了你可以报销的具体东西，比如</p><ul><li>处方药</li><li>血糖测剂</li><li>计生用品（我的天，这个词我打出来的时候都觉得中文真是博大精深）</li><li>验孕棒（怎么样，IRS心思细不细）</li><li>胰岛素</li><li>绷带</li><li>拐杖（怎么样，再一次，就问你细不细）</li><li>针灸</li><li>理疗</li><li>心理医生费用</li><li>戒烟项目费用</li><li>牙医</li><li><strong>Child care</strong></li></ul><p>写到这里我真的是不禁联想，国内规定的特点是爱用”相关物品“，比如说”医疗相关用品“，这就留下了很多解释的空间。而IRS则相反，把FSA可以报销的东西一件件列出来，如果感兴趣可以看<a href="https://www.irs.gov/pub/irs-pdf/p969.pdf#page=16" target="_blank" rel="noopener">IRS的这个解释</a></p><p>注意上面列表里最后一项，Child care被FSA认为是可以报销的项目。因此，如果你有小朋友需要child care，那么FSA可以用税前的钱来搞定。这也是为什么FSA可能对宝妈们特别有用。</p><h3 id="为什么不选FSA"><a href="#为什么不选FSA" class="headerlink" title="为什么不选FSA?"></a>为什么不选FSA?</h3><p>大转折来了</p><p>尽管有免税的好处，而且报销的范围比HSA广，FSA仍然不是一个非常好的金融工具。原因如下</p><p><strong>原因一：FSA的保持期只有一年</strong></p><p>如果你在一个税务年之前（通常是报税终止之前）FSA里的钱没有用完，那你的FSA帐户非常大的概率会被清空（不被清楚的情况太特殊不讨论）</p><p><strong>原因二：FSA的钱不可以用于投资</strong></p><p>接上条，既然FSA的钱每年会清空，那也就没什么复利增加的意义了。同时，FSA帐户不提供投资的途径，因此断了复利增长这条路。可惜的是，复利增长几乎所有金融工具能帮我们<a href="https://usdweekly.com/what-is-financial-independence/" target="_blank" rel="noopener">实现财富独立</a>的基础</p><p><strong>原因三：FSA只跟着雇主走，换工作清空</strong></p><p>因此，如果你有的是FSA帐户，请确保在换工作前一定把里面的钱花完。可以考虑多看一次牙医，存一些药之类</p><p>正是因为上面三个原因，FSA几乎不应该成为任何人的首选，除非你真的认为用税前的钱来支付Child care之类开销非常重要（HSA不能用于支付Child care）。但是理性来说，如果对比<a href="https://usdweekly.com/hsa-save-investment-tax-saving-guide/" target="_blank" rel="noopener">HSA在30年内可以帮你多挣50万美元</a>的能力，FSA这点可怜的好处几乎不值一提</p><h3 id="FSA这么没用，为什么它还卑微地存在呢？"><a href="#FSA这么没用，为什么它还卑微地存在呢？" class="headerlink" title="FSA这么没用，为什么它还卑微地存在呢？"></a>FSA这么没用，为什么它还卑微地存在呢？</h3><p>原因很简单，iPhone是不是一代比一代好？</p><p>FSA/HSA这样的项目也类似，在收集前面的反馈的时候，后续项目会有一些相关的调整。</p><p>考虑FSA和HSA推出的时间</p><p>FSA是1978年咱改革开放那年出品，而HSA是2003年布什总统在位时出品的二代产品</p><p>这样看起来，咱就把HSA当作iPhone X，把FSA当作iPhone 4吧 🤔</p><p>从另一个角度，FSA也并不是一无事处。注意不是每个公司都有给员工提供HSA的福利，有的公司只有FSA，那也只能矮子里面挑高个了</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>FSA是个有趣的项目，有一些特点。</p><p>比如它的报销范围比较广，可以报销牙医、Child care等项目。</p><p>但它也有些致命的缺点，每年会被清空，且它是跟着雇主走的帐户，一换工作也要清空，因此它并不能有效地帮助我们实现财富独立。</p><p>相比而言，如果你的公司提供HSA，那么你可以用HSA在30年内用复利增长多挣50万美元。具体步骤请读这篇文章：<a href="https://usdweekly.com/hsa-save-investment-tax-saving-guide/" target="_blank" rel="noopener">如何用HSA投资且多挣50万美元</a></p><p>本文参考：</p><ul><li><a href="https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/" target="_blank" rel="noopener">https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/</a></li><li><a href="https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/" target="_blank" rel="noopener">https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/</a></li><li><a href="https://en.wikipedia.org/wiki/Flexible_spending_account#History" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Flexible_spending_account#History</a></li><li><a href="https://dpath.com/2019-fsa-contribution-limits/" target="_blank" rel="noopener">https://dpath.com/2019-fsa-contribution-limits/</a></li><li><a href="https://www.investopedia.com/insurance/hsa-vs-fsa/" target="_blank" rel="noopener">https://www.investopedia.com/insurance/hsa-vs-fsa/</a></li><li><a href="https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/" target="_blank" rel="noopener">https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/</a></li></ul><h2 id="Dependent-Care-FSA"><a href="#Dependent-Care-FSA" class="headerlink" title="Dependent Care FSA"></a>Dependent Care FSA</h2><h3 id="1、如何使用-Dependent-Care-FSA报账"><a href="#1、如何使用-Dependent-Care-FSA报账" class="headerlink" title="1、如何使用 Dependent Care FSA报账"></a><strong>1、如何使用 Dependent Care FSA报账</strong></h3><p>首先要说明的一点是，<strong>FSA并不是国家统一管理的，也不是所有公司雇主都提供，提供FSA的雇主各自有自己的管理公司</strong>，你需要在规定的管理公司的网站上注册账号，这样就可以随时检查余额、提交申请了。另外，FSA是在大家每年的福利开放登记（benefit open enrollment）期间登记注册，而且一般每年都要重新登记，不会像医疗保险那样自动保留你上一年的选择。</p><p>FSA登记注册好之后，你选择的缴纳金额按pay schedule进入账户，钱到账之后，你就可以在网上提交你的Daycare费用支付收据。这里要提醒大家注意的是，DCFSA和MFSA不一样，MFSA是你自1月1日起一整年的全部花费都可以获得补偿，而DFSA只有已到帐的余额才能用，而且补偿的必须是已经发生的服务。</p><p>举个很简单的例子，如果你是在3月底交的4月份的学费，无法在3月底得到补偿，而是要等到4月结束后。因此，你的Daycare支付费用收据上最好除了社会保险号之外，还要有提供服务的日期（service period from xxx to xxxx）</p><h3 id="2、DCFSA的好处和最高限额"><a href="#2、DCFSA的好处和最高限额" class="headerlink" title="2、DCFSA的好处和最高限额"></a><strong>2、DCFSA的好处和最高限额</strong></h3><p>FSA 享有很好的免税待遇，FSA的补偿金完全是税前的，不用交SSN、Medicare、Federal and State tax，但是这个免税优惠是有条件的，那就是你的花销得是花在符合资格的个体身上，而且不超过IRS规定的补偿限制。<strong>Dependent Care FSA目前的最高限额是每个家庭5000美元</strong>，夫妻双方任何一人使用都可以，也就是两个人加起来不能超过5000美元的最高限额。</p><p>另外需要注意的是，这里所能享受到的免税额度和夫妻双方的收入是有关系的：如果夫妻双方的收入都多于5000美元，则5000美元都可以免税；如果有一方的收入少于5000美元，比如只有2000美元的话，那么无论你的贡献金额为多少，能免税的都只有那2000美元；如果有一方没有收入，那么你的FSA的贡献金额不管是多少都不能满足免税条件（夫妻中有一方或双方是全职学生或残障人士的情况除外）。</p><h3 id="3、享受DCFSA的免税补偿需要满足的条件"><a href="#3、享受DCFSA的免税补偿需要满足的条件" class="headerlink" title="3、享受DCFSA的免税补偿需要满足的条件"></a><strong>3、享受DCFSA的免税补偿需要满足的条件</strong></h3><p>那么什么才算是有资格的个体呢？除了开头讲到的无生活自理能力的被抚养者之外，对于大多数的妈妈们来说，符合这个资格的就是年龄不超过13岁的孩子（孩子满13岁的这一年要按实际接受的服务来计算价钱）。也就是说，<strong>DCFSA只有在夫妻为双职工或正在找工作（或夫妻一方为全日制学生），且孩子在13岁之下才能获得补偿。</strong>如果夫妻中有一方为全职妈妈或全职爸爸，收入为0，就无法享受这项免税优惠。</p><p>P.S.判定自身或配偶属于全职学生的要求为：必须满足至少五个月的在学校全职上学的条件，这里所指的学校不包括在职培训课程、函授学校或只通过互联网授课的学校。</p><p><strong>与照顾孩子相关的这些费用可以享受DCFSA的免税补偿：</strong></p><p>①Fees for licensed day care（持有牌照经营的Daycare费用。）</p><p>②Amounts paid for services (including babysitters or nursery school) – provided in or outside of your home – for the care of a qualified dependent necessary to allow you and your spouse to work, look for work, or attend school full-time.（付给照顾孩子的保姆或nursery school所产生的费用。）</p><p>③Summer day camp for children under age 13 qualifies if attendance allows you and your spouse to work, look for work, or for your spouse to attend school full-time.（13岁以下孩子参加夏令营所产生的费用。）</p><p>④Before and after school care programs for dependents under age 13.（在上学前、上学后提供照看13岁以下孩子服务所产生的费用。）</p><p>⑤Payment to a relative (age 19 or older who is not your dependent) who cares for your qualified dependent.（请19岁以上的亲戚来照看孩子所产生的费用，这个亲戚不能是你的被抚养者。）</p><p>⑥Payment to a housekeeper whose duties also include dependent day care.（请同样承担照看孩子工作的家庭管家所产生的费用。）</p><p>请参考<a href="http://www.irs.com所给出的官方说明：">www.irs.com所给出的官方说明：</a><br><a href="https://www.irs.gov/pub/irs-pdf/i2441.pdf" target="_blank" rel="noopener">https://www.irs.gov/pub/irs-pdf/i2441.pdf</a><br><a href="https://www.irs.gov/pub/irs-pdf/p503.pdf" target="_blank" rel="noopener">https://www.irs.gov/pub/irs-pdf/p503.pdf</a></p><h2 id="HSA"><a href="#HSA" class="headerlink" title="HSA"></a>HSA</h2><p><strong>本文来源：<a href="https://usdweekly.com/hsa-save-investment-tax-saving-guide/" target="_blank" rel="noopener">美元先生</a></strong></p><h3 id="到底什么是HSA帐户"><a href="#到底什么是HSA帐户" class="headerlink" title="到底什么是HSA帐户?"></a>到底什么是HSA帐户?</h3><p>要了解怎么样用HSA省税挣钱，需要先大致对美国税法有一个基本了解：在美国，IRS可能是比FBI更难惹的一个部门</p><p>一来后者关乎犯罪，我等良民不太容易惹得到，而前者则跟每个在美国生活、投资的人息息相关。而美国税制最神奇的一个地方是，你不光需要遵守税法，且你需要对自己不懂税法负责——不情的情况下报税错误？不好意思，也要罚款坐牢</p><p>HSA的全称是Health Savings Account，以下我将会简称其为HSA。顾名思义，这个帐户应该是跟医保储蓄之类的事情相关的。但这个帐户跟你大摇大摆走进一家银行，跟柜员开户的银行帐户完全是两个概念。</p><p>首先，HSA不是一个具体的“银行帐户”概念。相反，它是一种减轻减轻特定人群税务负担的行政手段。</p><p>你可以把HSA理解为，政府为了帮助有医疗需求的人（也即几乎所有在美国生活的人）减轻税务负担而单独开设的减税计划。</p><p>用白话说，就是政府看到有些居民生活困难，而如果碰到医疗开销的话更将会雪上加霜。那么政府决定，由IRS出面，给这些人士一个特殊的“帐户”，这些帐户的唯一作用是，如果往这个帐户里存钱，那么政府将认为这些钱会最终用于你或家人的医疗开销，<strong>而这部分存入的钱是不收税的</strong>。</p><p>举个例子，张二狗同学年收入十万美元，他把7000块存入HSA帐户内。那么他被征税的部分就是93,000美元，存入的7000美元部分免税。</p><h3 id="HSA的限制"><a href="#HSA的限制" class="headerlink" title="HSA的限制"></a>HSA的限制</h3><p>上面的例子听起来很刺激对不对?</p><p>假设你是一位程序写得飞起的Google工程师，每年收25万美元整，那么你可以把25万美元全部存到HSA帐户里喜滋滋把税免了？</p><p>当然不行，IRS这么容易让你钻空子就不是IRS了:)</p><p>通常来说，使用HSA有这么几个限制</p><ol><li>HSA有每年的存入限额</li><li>你，你的公司和IRS三方需要介入整个过程</li><li>多数HSA需要你用的医保是High-deductible的</li></ol><p>我们一条一条来分析</p><p>限制1，HSA有每年的存入限额</p><p>虽然有限额，但是这个限额从历史上来看，是每年严格递增的，也就是说随着时间增加每年你能通过HSA避的税会逐年增加。同时注意HSA的限制对于个人和家庭来说是不一样的，而如果你超过55岁，还可以享受一个“落后生”优惠：每年可以比其它人多存一部分。</p><p>具体年每年IRS允许往HSA帐户里存入的限额如下表（摘自<a href="https://en.wikipedia.org/wiki/Health_savings_account" target="_blank" rel="noopener">wikipedia</a>)</p><p><strong>HSA存入限额（按年）</strong></p><table><thead><tr><th align="left">年份</th><th align="left">单身HSA限额</th><th align="left">家庭HSA限额</th><th align="left">55岁以上可补交</th></tr></thead><tbody><tr><td align="left">2010<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-26" target="_blank" rel="noopener">[26]</a></td><td align="left">$3,050</td><td align="left">$6,150</td><td align="left">$1,000</td></tr><tr><td align="left">2011<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-27" target="_blank" rel="noopener">[27]</a></td><td align="left">$3,050</td><td align="left">$6,150</td><td align="left">$1,000</td></tr><tr><td align="left">2012<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-28" target="_blank" rel="noopener">[28]</a></td><td align="left">$3,100</td><td align="left">$6,250</td><td align="left">$1,000</td></tr><tr><td align="left">2013<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-29" target="_blank" rel="noopener">[29]</a></td><td align="left">$3,250</td><td align="left">$6,450</td><td align="left">$1,000</td></tr><tr><td align="left">2014<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-30" target="_blank" rel="noopener">[30]</a></td><td align="left">$3,300</td><td align="left">$6,550</td><td align="left">$1,000</td></tr><tr><td align="left">2015<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-31" target="_blank" rel="noopener">[31]</a></td><td align="left">$3,350</td><td align="left">$6,650</td><td align="left">$1,000</td></tr><tr><td align="left">2016<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-32" target="_blank" rel="noopener">[32]</a></td><td align="left">$3,350</td><td align="left">$6,750</td><td align="left">$1,000</td></tr><tr><td align="left">2017<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-33" target="_blank" rel="noopener">[33]</a></td><td align="left">$3,400</td><td align="left">$6,750</td><td align="left">$1,000</td></tr><tr><td align="left">2018<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-34" target="_blank" rel="noopener">[34]</a></td><td align="left">$3,450</td><td align="left">$6,900</td><td align="left">$1,000</td></tr><tr><td align="left">2019<a href="https://en.wikipedia.org/wiki/Health_savings_account#cite_note-35" target="_blank" rel="noopener">[35]</a></td><td align="left">$3,500</td><td align="left">$7,000</td><td align="left">$1,000</td></tr></tbody></table><p>限制2，你，你的公司和IRS三方需要介入整个过程</p><p>如上文所说，你不能走进一家银行要求”开一个HSA“帐户。到目前为止，你如果需要往HSA帐户里存钱的话，只能通过你的雇主。对于你是自己在创业的同学，你有可能可以搞一个self-employed HSA（相对少见这里不展开讨论了）。而对于IRS在这里的作用则更多是监督你把省的税和投资收益用来买药，而不会把HSA的税务优惠用来买兰博基尼 🙂</p><p>限制3，多数HSA需要你用的医保是High-deductible</p><p>这一条要求搞糊涂了不少人。其实简单点讲，high-deductible plan就是每次去医院的时候需要自己掏腰包的部分稍多一点。但是只要你不是天天去医院，对99%的50岁以下年轻人来说，high-deductible完全够用。同时，比起多出来那一点co-pay和多掏的腰包，HSA能给你带来的收益大得多得多（下文会有具体的计算）</p><h3 id="如何理解HSA"><a href="#如何理解HSA" class="headerlink" title="如何理解HSA"></a>如何理解HSA</h3><p>很多人在理解HSA的时候，包括我自己最初在试图搞清楚它的时候，都被各种概念搞晕。其实要理解HSA，只要脑中简单地有一个概念即可：HSA是一个杯子（容器）</p><p>而你往HSA里放钱的时候，是在把这个杯子换为更大号的杯子。比如说，前三年你往HSA里存入了2万美元，那么你的HSA就是一个容积为2升的杯子。</p><p>而这个杯子的用途就多了，你可以把杯子当作装饰，放在桌上不管它（对应HSA里的钱当作现金）；也可以把杯子里装满茶（对应HSA帐号里的钱用来购买国债）；也可以把杯子里装满咖啡（对应HSA帐号里的钱用来购买mutual fund或者<a href="https://usdweekly.com/how-to-invest-etf/" target="_blank" rel="noopener">购买ETF基金</a>）</p><p>总之，这个杯子里装茶还是咖啡，甚至是一半茶一半咖啡，都是可以的。</p><h3 id="如何用HSA帐户进行投资"><a href="#如何用HSA帐户进行投资" class="headerlink" title="如何用HSA帐户进行投资"></a>如何用HSA帐户进行投资</h3><p>这一节的副标题应该叫：如何用HSA多挣50万美元😍</p><p>到这里为止，你应该大致了解了政府设立HSA的动机是什么，以及HSA的一些限制。那么这一章我就详细讲解一下如何用HSA来帮你多挣50万。</p><p>首先我们做一些简单的假设：</p><ol><li>你每年将会在HSA里放满允许存入的金额。比如2019年你将会放满7000美金</li><li>你还会工作30年直到你退休</li><li>在退休前你不会碰HSA里的钱（千万不要拿出来）</li></ol><p><strong>对于绝大多数HSA帐户，如果你存入超过1000美金，这个帐户就可以用于购买股票、债券或者指数基金。</strong></p><p>而绝大多数HSA提供商（比如我的是HSAbank）都会允许你购买股票、基金或者共同基金</p><p>HSABank的功能界面 – 提供了investments的选项</p><p>那么如何用HSA帐户多挣美元的问题，就转化成了，年定投7000美金30年复利增长可以收益多少的问题。同样，我们用标普500的历史数据来做这个基本分析。我们的基本参数如下：</p><p>年存入: $7000 (2019年家庭限额）</p><p>年限: 30年</p><p>预计年收益：10% (标普500 80年平均）</p><p>复利频率：1年</p><p>用于计算复利的参数</p><p>那么到2048年，我们的总余额将达到126万美元，其中本金仅为21万左右</p><p>当然你可能会说，考虑通货膨胀的话，到2048年这些钱可能就是30年前的万元户手里的一万美元了。其实不然，即使调整了通胀的收益，收益也会是非常可观的数字。本金同样为21万，收益则为50万美元。</p><h3 id="HSA如何帮你省税"><a href="#HSA如何帮你省税" class="headerlink" title="HSA如何帮你省税"></a>HSA如何帮你省税</h3><p>如同乔帮主常说的，just one more thing…</p><p>HSA的超强吸引力，不光在于它可以让你免税开始存钱，更可怕的是，它的收益也可以做到部分免税（医疗报销），而这是401(K)，Traditional IRA, Roth IRA等任何储蓄计划都做不到的。</p><p>具体来说</p><ol><li>你的工资、收入在存入HSA时，是不收税的</li><li>你存入HSA的钱，在收益增值的过程中，是不收税的</li><li>如果你生病了，需要在中途把一部分钱拿出来（不建议，下文讨论如何看病省钱两不误的操作），你可以把钱拿出来且不用交任何税</li><li>如果你到了65岁，你可以把所有的钱一次性拿出来，仅按收入税交税</li></ol><p>举个具体例子，张二狗同学25岁从弟伦比亚大学毕业，到湾区成为了一位光荣的年薪20万美元的初级软件工程师。</p><p>读完这篇文章后张二狗同学决定每年把7000美元拿出来放到HSA中，首先20万美元中的7000美元被划分开，IRS决定对这7000美元免税。即，张二狗同学可能被扣税的收入减少为19万3千美元。</p><p>张二狗同学把HSA中所有的美元全部购买了指数基金。</p><p>到45岁时，张二狗同学的颈椎病发作，但他手里还有一些多余的现金，因此他只把看病时的收据拍照留下了，而在HSA帐户里的基金继续增值。</p><p>到55岁时，张二狗同学决定跟翠花辞职退休，环游世界。30年过去，这时他的HSA帐户中已经有了126万美元，而这30年他仅仅往帐户里存入过21万美元。他需要一些钱来支付环游世界的费用。于是他找出来之前看病时的收据，于55岁这年从HSA帐户里拿出6万美金用于环游世界。</p><p>终于到了65岁，张二狗同学决定把HSA里的钱全拿出来。而此时HSA帐户中已经有了300万美元！这就是复利的力量。这时候二狗同学的身体已经不太好了，累积了50万美元的医疗开销。而张二狗同学在把这300万美元拿出来的过程中，50万美元的部分不必交税，仅余下的250万需要交收入税。</p><p>这就是HSA最大的威力：收入免税+复利增长+部分收益免税</p><h3 id="有关HSA的常见问题"><a href="#有关HSA的常见问题" class="headerlink" title="有关HSA的常见问题"></a>有关HSA的常见问题</h3><p>这里解答一些关于HSA的常见问题</p><h3 id="回国了HSA怎么办"><a href="#回国了HSA怎么办" class="headerlink" title="回国了HSA怎么办?"></a>回国了HSA怎么办?</h3><p>如果你已经决定了在65岁前回国，那么你有两个选择</p><p>选择1，提前把钱退出来（不推荐）</p><p>虽然你可以提前把HSA里的钱拿出来，但是如果不是手头真的紧的话，并不建议。原因是你在把钱放入HSA时，没有交税。那么如果你要提前拿出来，不但你要把拿出来的部分的税补交上，且要加上<a href="https://hsastore.com/" target="_blank" rel="noopener">20%的惩罚</a>。</p><p>举个例子，张二狗同学拿到了假格基金的投资，毅然决然决定2020年启程回国担任CEO走上人生巅峰，而他之前在HSA里的本金和收益总共收益10万美元。在2020年这年，他决定把HSA里的钱全拿出来，那么他的10万美元将需要算作2020年的收入被税，同时需要支付2万美元的罚款。假设张二狗2020年已经辞职且没有其它收入，那么他需要支付的联邦税为29,204 + 20000 = 49,204美元，可以说是非常不划算了。</p><p>当然如果你不着急，有两个办法把税降到最低（但20%的罚款无法避免）</p><p>第一个办法是，尽量降低每年从HSA里拿出来的金额，这样可以让你当年的收入变少，因此可以被税比例降低甚至是免税。</p><p>第二个办法是，尽量在回国之后（这样在美国就不再有收入）再慢慢把钱拿出来，这样你在美国的收入仅有HSA拿出来的部分，你可以选择一年只拿最低征收额以下，比如2019年如果你只拿9,324出来，一分钱税都不用交。</p><p>选择2，把钱放在HSA内增值（推荐）</p><p>如果手里不紧，这是我一贯的主张。在国内几乎没有任何资产配置可以跟美元+美国金融市场匹敌，不着急用钱的话没有任何理由把HSA里大量税收优惠的钱带回国。且实际操作来讲，如果你需要看病的时候，即使是在国内，也可以把看病的花销都记录下来，收据留好，每年报销一次。剩余的部分则在HSA帐户内增值。</p><h3 id="如果换了公司HSA帐户怎么办"><a href="#如果换了公司HSA帐户怎么办" class="headerlink" title="如果换了公司HSA帐户怎么办?"></a>如果换了公司HSA帐户怎么办?</h3><p>这个相对容易，HSA虽然是需要公司参与，但是受益人和操作人是你且只是你。因此如果换了公司，最多是跟给你提供HSA的银行打个电话，告诉他们你换公司了。通常来说你所在公司的HR也会协助你迁移。当然更好的办法是把HSA完全独立出来，所有信息都跟公司分离开来，我就是这么干的。这样即使换了公司，只是换了个每个月向HSA里存钱的帐户而已，相当方便。</p><h3 id="HSA可以买什么？"><a href="#HSA可以买什么？" class="headerlink" title="HSA可以买什么？"></a>HSA可以买什么？</h3><p>理论上HSA里的钱你可以买任何你想买的东西，只是有些东西不免税以及有惩罚而已。</p><p>所以这个问题的问题应该是，HSA帐户可以用于免税购买什么东西？</p><p>根据<a href="https://www.irs.gov/publications/p502" target="_blank" rel="noopener">IRS的指导</a>，你可以用于购买以下东西</p><ul><li>看医生的co-pay</li><li>IRS批准的医药中保险不报销的部分（i.e. out of pocket)</li><li>一些医用的产品，比如baby monitor，温度计之类；比较完整的列表见<a href="https://hsastore.com/HSA-Eligibility-List.aspx" target="_blank" rel="noopener">hsastore.com这个网站</a></li><li><a href="https://hsastore.com/Condoms-C78.aspx" target="_blank" rel="noopener">羞羞的橡胶制品</a></li><li>去看医生的路上的交通，包括巴士，出租，火车或者飞机等</li></ul><p>这里最后一条的解释就很有意思了。IRS的指导是</p><p>如果你的旅行相关的医疗开销对于治疗是必须的，那么这个旅行相关的开销就可以包含在HSA支付的范围。同时，IRS并没有指导医疗开销是不是必须在美国国内。那也就是，如果你觉得北京上海的医生对于你的病的治疗有更多帮助，那么飞到北京或者上海看病是属于合理的HSA可支付范围内。</p><p>当然本文不可能也没必要穷尽所有IRS允许的HSA免税开销，如果有特别需要的话，google一下通常会有相当多人讨论。</p><h3 id="HSA可以投资些什么？"><a href="#HSA可以投资些什么？" class="headerlink" title="HSA可以投资些什么？"></a>HSA可以投资些什么？</h3><p>HSA是一个银行帐户，而通常HSA帐户的提供商都会跟其它证券公司(broker)合作来提供购买投资产品的服务。</p><p>举个例子，美元先生用的HSA帐户提供商是HSABank，而 HSABank与TD-Ameritrade合作提供投资产品。</p><p>在TD-Ameritrade里，我可以选择购买个股，也可以选择购买其它股指基金，房地产基金等等，所以HSA的投资对象并不会受限定，基本是你想投啥都可以。</p><p>但是同时也要注意，如果你在读这篇文章的话，大概率是刚刚开始接触投资，不建议投资个股。如果你不确定投资些什么，优先推荐<a href="https://usdweekly.com/how-to-invest-etf/" target="_blank" rel="noopener">投资ETF基金</a>或共同基金。</p><p>针对这点，我在<a href="https://usdweekly.com/should-i-invest-stock-market/" target="_blank" rel="noopener">我应该投资股票吗一文中有更详细的解释</a>。</p><p>如果你的投资产品里看到Vanguard或者Fidelity, Charles Schwab的股指基金，那恭喜你，这些基金都是品质保障。</p><p>我在<a href="https://usdweekly.com/how-to-choose-vanguard-fund/" target="_blank" rel="noopener">为什么投资这些基金和Vanguard基金如何挑选</a>的文章里详细解释了为什么优先考虑投资Vanguard基金，或者以上提到的几家股指基金/共同基金。</p><h3 id="HSA可以给配偶用吗"><a href="#HSA可以给配偶用吗" class="headerlink" title="HSA可以给配偶用吗"></a>HSA可以给配偶用吗</h3><p>一句话，可以。同时如果你已经结婚的话，HSA的限额会增加，细节见上文“HSA限制”一章</p><h3 id="HSA报销麻烦吗？HSA报销需要收据吗？"><a href="#HSA报销麻烦吗？HSA报销需要收据吗？" class="headerlink" title="HSA报销麻烦吗？HSA报销需要收据吗？"></a>HSA报销麻烦吗？HSA报销需要收据吗？</h3><p>首先HSA报销不麻烦；严格讲这个不叫报销，这个叫向IRS申请使用你的免税额。</p><p>其次IRS不要求你在向你的HSA帐户里取钱时提供收据。需要收据的时候是，IRS抽查到你的时候，你能提供证明你取钱的时候取的部分是用于了医疗。当然了，最容易的证明方式就是把收据给IRS看了。</p><p>这里提供一个不但可以非常方便保存收据，同时可以最大化你的HSA收益的方式，也就是我们的：</p><h3 id="用HSA四步多挣50万"><a href="#用HSA四步多挣50万" class="headerlink" title="用HSA四步多挣50万"></a>用HSA四步多挣50万</h3><h4 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h4><p>在Dropbox/Google Photo或者任何照片同步软件里建一个folder，专门用来保存receipt</p><h4 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h4><p>每次看完病，去看病的路上，把产生的收据照下来，原件不用存</p><h4 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h4><p>不要报销，等到65岁或者过几年再一次性报销。如果你考虑要回国，回国前一次性报销</p><p>步骤四：</p><p>在HSA中选择指数基金或者共同基金，推荐Vanguard的低成本基金。把放到HSA帐户中的钱从脑子中抹去，让它定投和指数增益，不要管它</p><p>步骤一和二非常好理解，不多说</p><p>对于步骤三，逻辑是这样的，对于你所有在HSA里的钱，不要把它考虑为钱，应该把它考虑为equity。什么是equity？equity就是你睡觉时可以继续帮你挣钱的资产。</p><p>在比较早的时间，比如A点取出，和在比较晚的B点取出5万美元，对于资产的增值是有天差地别的区别的。如果在A点取出5万美元，即使考虑了通货膨胀，这部分钱本来也可以增值至B点的5*1.07^10 = 9.8万美元。</p><p>如果你在HSA里的钱全在指数基金或共同基金里，那么你的资产就是这些基金里含有的公司股票的股份，多放一年，平均来讲你HSA里的资产就会增加7%（通胀调整）或者10%（不含通胀调整）。那么要最大化你的收益，显然是让HSA里的资产增值越久越好。而IRS并没有规定医疗费用必须当年申报，因此你完全可以放心大胆把医疗费用的凭证放到一个地方，在你最终需要把钱拿出来时，再拿出来。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HSA虽然听起来是个跟看病相关的事情，但是其实它是在Roth, 401(K)的基础上，可以极大帮助你省税和提高投资效率的工具。</p><p>如果你之前从来没有听说过的话，也不要感觉自己很悲剧，因为即使美国人知道且在擅于利用HSA的也不多。2008年的数据是，只有8%的在职人员参与了HSA。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> finance </tag>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLO美国租房骗子</title>
      <link href="/2020/02/26/SOLO%E7%BE%8E%E5%9B%BD%E7%A7%9F%E6%88%BF%E9%AA%97%E5%AD%90/"/>
      <url>/2020/02/26/SOLO%E7%BE%8E%E5%9B%BD%E7%A7%9F%E6%88%BF%E9%AA%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个菜鸡，在下的上岸时间可谓是非常之晚了。上岸迟就会出现一个问题——房子租不出去。</p><p>在波士顿这个鬼地方，你想租房子至少得整一年，导致基本所有春季毕业的学生都会遇到房屋出租问题。很多亚马逊return的同学都花了一整个学期才把房子租出去。他们的出租对象往往是那些春季入学的人，所以好歹房子还能租出去。</p><p>我们这些春季才上岸的人就不同了——你要是想三月份出租你的房间，那就根本没有target用户。春季入学的新生们都是二月入住，你已经错过了；而波士顿这鬼地方工作机会也不是很多，没什么过来工作的新人。再加上因为波士顿学校多，租房产业过于发达，空房一大堆，想要租出去自己的房子，可谓难上加难。</p><p>我在各大租房微信群狂轰乱炸了几天，压根找不到要租的人。无奈之下跑到一亩三分地去发了个出租房间的帖子，大概描述了我房间的情况，然后留了微信和邮箱。</p><p>万万没想到一亩三分地如此牛逼，一晚上就有人进场了。这位选手就是我们的重量级人物——Linda Cui</p><h2 id="Linda-Cui-的第一封信"><a href="#Linda-Cui-的第一封信" class="headerlink" title="Linda Cui 的第一封信"></a>Linda Cui 的第一封信</h2><p>传奇通常都不是一蹴而就。</p><p>Linda Cui的第一封信，看起来有点像弱智儿童发的</p><blockquote><p>Hi, Is the room available and move in date? Thank you</p></blockquote><p>说实话当时我没看懂这句话的文法。不过这不要紧。看这发件人邮箱是[<a href="mailto:linyixiancu@hotmail.com">linyixiancu@hotmail.com</a>](mailto:Linda Cui )，姓名是“Linda Cui”。中国人嘛，英文不行没事，我寻思着。于是我回复了她，说我房子还健在，您老可以过来参观参观。move in么三月就行了，能搞快点就搞快点，我要溜溜球了</p><p>可万万没有想到的是，紧随而来的第二封信，竟然level up了如此之多</p><h2 id="Linda-Cui-的第二封信"><a href="#Linda-Cui-的第二封信" class="headerlink" title="Linda Cui 的第二封信"></a>Linda Cui 的第二封信</h2><p>（下面有翻译）</p><blockquote><p>Hello XX,</p><p>Thanks for writing back. I’m very much interested in renting the room and I really hope we could get along with each other. I plan to arrive on 10th of March.</p><p>About me: I’m a mixed race of Chinese and British and I speak Mandarin fluently, currently living in the United Kingdom, I’m 29 yrs old. I’m Educated (Undergraduate and Post Graduate Degree), a devoted Christian. I don’t smoke nor drink and I don’t mind if room mates do. I’m currently living at 65 Croydon Rd, Croydon CR0 4QE, I’m pretty quiet and neat, but not obsessively so. I’m responsible and will pull my weight around the apartment and pay bills on time. I like to cook, and it would be great to have people to cook with or eat with, but it’s definitely not a requirement in a room-mate. I’m social though, and get along well with most people.</p><p>And I would really want to secure the room before my arrival, More-so, to know if it would be possible for me to pay for the room before my arrival, So I would like to know the total amount of the room per month and the utility included. All this information are very important so that I can submit my proposal to my Uncle. My Uncle will be responsible for all the fees. Please let me know if I could give you any more info that would be helpful for making your decision. I would be glad if you can tell me little about you too.</p><p>Sorry for the email novel. I hope it isn’t a lot to read and I apologize for coming on strong, I’m just looking for a reliable place when I move down. I look forward to hearing positive from you again.</p><p>Thanks.<br>Linda.</p></blockquote><p>我了个捶捶怎么突然发万字长文给我，我人都傻了。</p><p>我定睛一看，这Linda自称是中英混血，住在大英帝国，29岁，并且受过较高程度的教育，甚至还是个基督教徒。她不喝酒不抽烟是个好女孩，但不介意你们在家乱嗨。下文直接列出一长串自己在大英帝国豪宅的地址，然后说自己干净整洁，及时交房租，会做饭，而且十分social。</p><p>她直接非常想要提前预定房子，然后问你要不要在她到来直接交定金，然后说她uncle会来给她交钱。又问你需不需要她的更多信息，所以你能把房子租给她！</p><p>她言语间的诚恳打动了我，我还以为是哪个欧美不谙世事的良家基督教徒呢！大姐你也太推心置腹了吧！但我寻思着我这波士顿这么多房子租不出去，应该是我怎么打动你而不是你怎么打动我吧？于是我反手一个万字长文，疯狂介绍我所住的公寓，然后给了我的价格。我紧接着说我们还是跟公寓签合同吧，你这样直接给我钱傻乎乎的不太好，随后问她是否需要租我的房子。</p><h2 id="Linda-Cui-的第三封信"><a href="#Linda-Cui-的第三封信" class="headerlink" title="Linda Cui 的第三封信"></a>Linda Cui 的第三封信</h2><blockquote><p>Subject: Security deposit…</p><p>Hiya XX,</p><p>How are you doing? Thanks for the pictures and details of the room, I’m really interested in renting the room for a year or two if possible please, I will keep you posted with my flight information as events unfold. I have jobs interview lined up for me as a Private (Science Tutor) and I’ve been guaranteed a spot as soon as I get there.</p><p>I just got in touch with my Uncle and he can assure you of paying the rent fee monthly without any hesitation and since he will be responsible for paying my rent fees and all, we thought of mailing the deposit payment this week in one of his business trips. Please let me know if this is OK with you. I will need you to email me your information (full name, mailing address, and a direct phone number to reach you) for the payment so that I can have it forwarded to my Uncle as requested.</p><p>If there is a rental agreement application, please understand that I will have it filled and signed out upon my arrival.</p><p>Also, let me know if you will be able to help me keep my little stuffs (dresser, art works, paintings as they will be shipped before my arrival.</p><p>Thanks for willing to give me the room, I can’t wait to meet you. Please remember my mother in your prayers as she will be going through Surgical operation next week.</p><p>Sincerely,<br>Linda.</p></blockquote><p>大意就是说，感谢你的公寓介绍嗷，我可想住你这房子了。我会一直告诉你我的行程的，来美帝我还想工作呢，想住你那几年！我uncle已经跟我说好啦，他会给我付钱的，请把你地址手机啥的信息给我，我好给你打押金！至于你说的跟公寓签合同签sublease的事情，那只能等我到了再说了，请你理解哈！还有，我甚至想提前寄东西到你那边公寓里，可以嘛！你能把公寓租给我，我实在是太高兴了。和你合作真是太愉快了，好希望赶快见到你嘞。</p><p>哦对了，我妈下周做手术了，记得帮我给她祈祷一下。</p><p>看完整封信我心里是满满的WTF，你这是给我钱给定了是吧怎么还不停跟我说要给我钱呢？你是脑子被驴踢了吗这么随便给别人钱的！我都说了我们直接签合同整sublease你给公寓钱啊！给我多不好啊！</p><p>于是我又发了一封信告诉她，解释了一下sublease的具体流程。你把你什么类型的签证告诉我，我去问公寓你需要什么材料，然后我们签sublease——你压根不用给我钱，你直接给公寓钱去，你给我钱我还膈应呢！</p><p>谁知道，这邮件一发，Linda Cui再也没有理我。</p><p>我以为我措辞出问题了。我仔细检查了下邮件，没毛病啊我还祝她妈尽快康复呢，咋就不理我了捏，被截胡了吗。这么推心置腹的好房客溜溜球了可不是好消息啊，毕竟波士顿房子根本租不出去啊！于是我茶饭不思，对她朝思暮想。惊慌中我还发了个我们公寓签sublease的官方agreement，表明我一切行为绝对正当。可Linda还是没有再给我任何回复</p><h2 id="来自朱哥的神助攻"><a href="#来自朱哥的神助攻" class="headerlink" title="来自朱哥的神助攻"></a>来自朱哥的神助攻</h2><p>我有一位儒雅随和的客厅室友。因为我也是儒雅随和的人，所以经常去跟他互动。我们的对话频率非常高，通常如下：</p><blockquote><p>吃饭吗？</p><p>点外卖吗？</p><p>吃啥？</p><p>开冲</p></blockquote><p>这几日我们在一起冲的时候，聊到了租房的问题。于是我给他看了Linda Cui的邮件。朱哥看完赞不绝口，觉得这简直是艺术品，人间瑰宝。对方也太有诚意了，整挺好。</p><p>可这日凌晨朱哥突然用微信发来一个链接，我点开一看，标题赫然写着：《<strong>挂一个租房骗子Linda Cui</strong>》。朱哥说他在一亩三分地首页看到的，要不是我给他看过Linda Cui的邮件，他肯定不会点进这帖子……</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200321011057.png"  alt="一亩三分地"></p><p>当时我就是一懵。点进去一看发现连邮件内容都一模一样，就是从第三封邮件开始会根据你的回复稍作一些修改。</p><p>其中链接分别是：</p><p><a href="https://hellogwu.com/thread-75629-1-1.html" target="_blank" rel="noopener">HelloGWU</a></p><p><a href="https://www.1point3acres.com/bbs/thread-596997-1-1.html" target="_blank" rel="noopener">一亩三分地</a></p><p><a href="https://www.psucssa.com/bbs/fang-wu-zu-ren/wo-jue-de-wo-yu-dao-yi-ge-zu-fang-pian-zi" target="_blank" rel="noopener">PSU CSSA论坛</a></p><p><a href="http://bbs.chineseofchicago.com/showtopic-61020.aspx" target="_blank" rel="noopener">芝加哥侨学网</a></p><p>真可谓是广撒种，啥地方的房她都租。信都不带改的，还骗了不少人。</p><p>大概的套路就是，你假如接受了她的deposit，她就会给你的住址发个价格不菲的支票。随后她会向你借钱，有人甚至直接被借了1500+1000+400刀。有人是兑换了支票，发现账号内钱增加了，以为兑换成功，便放松了警惕。随后在对方借钱时，因为对方推心置腹而且给自己打了钱，便不好意思拒绝。结果打完钱过了几天发现Linda的uncle寄过来的是假支票，银行取消了你的兑换，把钱扣除了。而你借给Linda的钱也再也无从追寻</p><p>其实我觉得这个事情吧，银行应该负主要责任。一张支票假如未兑换成功，你就应该显示processing，而不是直接把支票金额加到你的账户里去。就是因为这个账户金额的增加才会导致很多人放松警惕的</p><p>话说回来，支票这种应该只存在于上个世纪的东西，到底什么时候才能消失啊……</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>我就说为啥Linda突然不理我了，大概是我问了她签证之类的信息，她无法回答。而且我要签sublease，她似乎无法从其中捞到油水。</p><p>我现在打算告诉她我需要她寄给我deposit了。倒是很想看看假支票长啥样</p><p>要是我拿了支票就不理Linda，她会不会狂轰乱炸我呢？</p><p>不过也有可能我现在已经不会再收到来自Linda的邮件了</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OBS实现多音轨录制</title>
      <link href="/2020/02/21/OBS%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%9F%B3%E8%BD%A8%E5%BD%95%E5%88%B6/"/>
      <url>/2020/02/21/OBS%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%9F%B3%E8%BD%A8%E5%BD%95%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前段时间闲着无聊录制了一下古剑奇谭三的全剧情通关视频，发现自己小嘴叭叭的挺多余的，还不如光看视频（这里还要吐槽一下罗技G533耳机，我的妈耶你这麦克风也太弟弟了）。</p><p>可是自己的声音跟游戏声音已经被录到一个音轨里去了，没办法操作成普通视频。现在就记录一下OBS如何将人声和系统声分离</p><p>假如你不是Mac用户请直接跳到第二个h2标题</p><h2 id="解决Mac中OBS没有电脑声音的问题"><a href="#解决Mac中OBS没有电脑声音的问题" class="headerlink" title="解决Mac中OBS没有电脑声音的问题"></a>解决Mac中OBS没有电脑声音的问题</h2><p>你若在Mac中直接打开OBS，你会发现OBS并不能录制系统声。它的声音面板与Windows上的声音面板不同，只有mic一个声音输入。选择输出音频设备的时候，发现列表为空。如图所示：</p><div style="text-align:center"><img src="/" class="lazyload" data-src="/images/20200221/obs1.png"  alt="" width="80%"/></div><p>正常来说OBS既可以捕获输入音频设备（麦克风的音频），也可以捕获输出音频设备（电脑输出到耳机或音响的音频）。为了能让OBS获取到系统声音，我们需要安装<a href="https://github.com/mattingalls/Soundflower" target="_blank" rel="noopener">Soundflower</a>，这是它的<a href="https://github.com/mattingalls/Soundflower/releases" target="_blank" rel="noopener">release</a>，请从release链接中下载最新版本的dmg文件</p><p>注意，Soundflower插件是有签名的，可是installer并没有！你需要按住ctrl才能打开Soundflower.pkg的installer安装器</p><p>在你第一次运行安装器(Soundflower.pkg)时，它会要求你输入你的管理员密码，并且会<strong>安装失败</strong>！这时不用担心。一个安全警告（security alert）会出现，其上会有带你前往系统偏好（system preference）中Security &amp; Privacy - General面板的按钮。在你到了那里之后，那里会出现一个“allow”（允许）的按钮，请点击它，给它权限。随后，再次运行安装器installer，它会提示你安装成功。</p><ul><li>注意！</li></ul><p>假如你在 Security Preferences系统安全面板中看到了“open anyway”，这说明经你曾经用双击的方法打开过了installer，并且于安装过程中失败了。你在之前的尝试中没有按下ctrl并打开安装包。在这种情况下，请点击“open anyway”，然后再点击那个窗口上的“open”以打开installer。随后你应该能在security preference面板上看到allow按钮。</p><ul><li>假如你还是没有看到allow按钮</li></ul><p>如果你未曾关闭 Security Preferences那个窗口，请尝试关闭它，随后再进入 左上角的苹果图标-&gt;System Preference-&gt;Security Preferences-&gt;General，检查是否刷新出了allow按钮</p><hr><p>安装之后重启电脑。</p><p>然后装完你就发现OBS里还是什么都没有！惊不惊喜？意不意外？但是当你重启完电脑之后，在右上角的volume声音面板里（假如你没在右上角显示声音，请移步System Preference-&gt;Sound，勾选Show volume in menu bar），你就发现输出选项多了Soundflower(2ch)和Soundflower(64ch)。我们先选择Soundflower(2ch)进行输出。此时你假如在mac上播放了音乐，会发现音乐并没有从你的mac音响中输出，因为此时我们切换了输出方式</p><p>我们回到OBS当中，打开Settings-&gt;Audio，此时desktop audio应该处在默认disabled状态。我们选择Soundflower 2ch， 再次回到obs主界面。如果这时你再播放音乐，会发现系统声音已经能够出现在OBS的desktop音源当中</p><p>可这并不是我们想要的结果。我们希望的结果是既能录制desktop声音，也能听到desktop声音。</p><p>于是我们先切换到所有应用，搜索MIDI，应该会看到一个叫Audio MIDI setup的应用。在这个应用中我们点击左下角的加号，选择第二项create multi-output device，然后勾选你想听到有输出的设备（例如Macbook Pro Speakers，也就是默认电脑自带的扬声器），和Soundflower2。这意味着你的电脑会同时将声音输出给扬声器和Soundflower2。</p><p>我们回到右上角状态栏中的声音面板，output此时会多出一个叫multi-output device的选项。我们选择以它进行输出。如此，你就既能在OBS中收到系统音，又能在外部听到系统音了</p><p>需要注意的是，<strong>在切换输出设备到multi-output device之前，请先调整好系统音量，因为一旦你切换设备后，将无法改变音量大小。</strong></p><h2 id="OBS录制麦克风人声和系统声到不同音轨"><a href="#OBS录制麦克风人声和系统声到不同音轨" class="headerlink" title="OBS录制麦克风人声和系统声到不同音轨"></a>OBS录制麦克风人声和系统声到不同音轨</h2><ol><li>首先我们打开Settings-&gt;Output，然后在上方将设置从简易的simple模式调整至advanced模式</li><li>在streaming面板中将audio track设置为1（其他数字也可以，后面会再解释）</li><li>切换到recording面板，将audio track设置为2和3（三个轨道各不相同即可）<strong>注意</strong>：flv格式不支持这个操作，请切换到其他格式</li><li>回到OBS主界面,点击麦克风右侧的设置齿轮,选择advanced audio properties,随后将desktop audio的tracks设置为1和2,将mic的tracks设置为1和3</li></ol><p>因为我们之前设置的streaming模式中输出track为1,所以此时streaming的track1中会有desktop和mic的声音,直播的观众们会听到你的系统声和人声。而在录制的时候我们只在设置中录下了2和3两个track，2是desktop声，3是mic声。这两个声音会分成不同的音轨出现在视频里。</p>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初创企业股票基础知识</title>
      <link href="/2020/02/20/%E5%88%9D%E5%88%9B%E4%BC%81%E4%B8%9A%E8%82%A1%E7%A5%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/02/20/%E5%88%9D%E5%88%9B%E4%BC%81%E4%B8%9A%E8%82%A1%E7%A5%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文翻译自翻译自<a href="https://humaninterest.com/blog/startup-equity-basics-ask-stock-accept/" target="_blank" rel="noopener">Human Interest</a>，原作者Anisha Sekar</p><p>修正了google translate中出现的语病和错译</p><hr><p>您已经从一家初创公司那里获得了一份报价，作为薪酬待遇的一部分，您将在薪水之上获取公司股票。恭喜你！在你变成星星眼之前，您需要仔细评估报。您应该能够准确地评估offer股权的（潜在）价值，以将其和你的其他offer做比较，并利用您的理解来潜在地协商更高的薪水。我们将介绍startup股权的基本知识，您应该提出的问题，以及如何并行比较报价。</p><h2 id="股票基础：了解startup的股票"><a href="#股票基础：了解startup的股票" class="headerlink" title="股票基础：了解startup的股票"></a>股票基础：了解startup的股票</h2><p>顾名思义，股票可以使持有人拥有公司的一部分。如果一家公司有10,000股流通在外股票（shares outstanding），那么如果成功退出（successful exit），则每股股票将赋予所有者0.01％的公司收购价；如果公司成功上市，则每股0.01％的股份所有权；或者……不幸的是，如果startup失败了，则几乎没有收益。</p><h3 id="谁在创业公司中获得股份？"><a href="#谁在创业公司中获得股份？" class="headerlink" title="谁在创业公司中获得股份？"></a>谁在创业公司中获得股份？</h3><p>私人初创公司的股东通常分为以下三类之一：</p><ul><li><strong>创始人</strong>：最初，创始人控制着公司100％的股份。随着时间的流逝，他们很可能会控制更少的股票，因为他们以出让股票为代价来换取金钱或劳动力。</li><li><strong>投资者</strong>：风险资本家以一定数量的股份作为投资回报。随着公司筹集更多的资金，它将向投资者发行更多的股票，从而稀释了之前投资的所有人的股票。（不过，这不一定是一件坏事，因为该公司大概会用这笔钱来为每个人增加蛋糕）。</li><li><strong>员工</strong>：就是你！通常情况下，你的股票将被<em>授予</em> （vested）——不是立即让所有的股份，他们将发放出过一段时间来激励你留下来与你的雇主。</li></ul><h3 id="每股（share）价值多少？"><a href="#每股（share）价值多少？" class="headerlink" title="每股（share）价值多少？"></a>每股（share）价值多少？</h3><p>如果您持有一家上市公司的股份，您很快就会知道它的价值：您所要做的就是查找股票代码，以查看股份的交易价格。例如，您可以通过搜索“ TSLA”来查找特斯拉股票的价值。对于私营公司而言，这要困难得多（而且充满术语）。为了评估其价值，私营公司将进行409A估值（409A valuation），其中第三方基本上会估算该公司的价值。要确定股票的当前价值（称为公平市价 fair market value，即FMV），就用估值除以流通股数。</p><p>例如，如果一家公司的价值为100万美元，并且有100,000股流通在外，则每股FMV为10美元。如果同一家公司有50,000股流通在外股票，则FMV为20美元。如您所见，计数的是<em>相对</em>股份数量，而不是<em>绝对</em>数量。要约10,000股流通100,000股的要约与20,000股流通200,000股的要约值完全相同。在409a估值和流通股之间，您可以确定多少股票值得。</p><h3 id="股权授予与股票期权（Grants-versus-options）"><a href="#股权授予与股票期权（Grants-versus-options）" class="headerlink" title="股权授予与股票期权（Grants versus options）"></a>股权授予与股票期权（Grants versus options）</h3><p>在录取通知书中，您可能会获得股票授予（stock grant），股票期权（stock options）或两者的结合。</p><p><strong>股权授予</strong>Equity grant<strong>（RSU）：</strong> 股票授予（通常也称为限制性股票单位Restricted Stock Unit， RSU）非常简单：这意味着您可以在归属时直接获得股票。这对于非常早期的初创公司来说更为常见，因为这些公司的股份价值很少，因此更容易直接发行。但是，以免您担心初创公司股权的任何部分都太简单了，其中有很多初次创业的创始人都不了解的主要财务考虑。当您收到股票时，您将需要考虑向IRS提交填写83（b）。83（b）允许您在授予您的权益（when equity is granted to you）时向您征税，而不是在真正授予（vest）时。根据您的财务状况和创业公司的增长前景，提交83（b）可能会节省数千美元。您可以阅读有关83（b）的更多信息<a href="https://www.cooleygo.com/what-is-a-section-83b-election/" target="_blank" rel="noopener">在这里</a> ; 目前，需要注意的重要一点是，您必须在发行股票后<strong>30天内</strong>提交83（b），因此您需要立即考虑税收问题。</p><p><strong>股票期权</strong>Stock options<strong>（ISO和NSO / NQSO）</strong>：股票期权通常分为激励性股票期权（Incentive Stock Options）和不合格的股票期权（Non-qualified Stock Options）（<a href="http://www.startupcompanylawyer.com/2008/03/05/whats-the-difference-between-an-iso-and-an-nso/" target="_blank" rel="noopener">有关两者之间差异的更多信息</a>）。无论使用哪种方式，都可以选择以后购买股票。您将预先获得<em>行使价</em>（<em>exercise price</em>），这是您需要支付的股票价格。在您担任雇员期间，公司的价值将上升，因此您将能够以低于其实际价值的价格购买股票。有时，您的行使价会低于股票的当前价格，这会愈发增加你手中期权的价值。</p><h2 id="在评估股票期权时，您应该问什么问题？"><a href="#在评估股票期权时，您应该问什么问题？" class="headerlink" title="在评估股票期权时，您应该问什么问题？"></a>在评估股票期权时，您应该问什么问题？</h2><p>假设您收到的报价包含10,000股。这是您应该向您的潜在雇主提出的关键问题。</p><h3 id="有多少流通股（How-many-shares-are-outstanding）？"><a href="#有多少流通股（How-many-shares-are-outstanding）？" class="headerlink" title="有多少流通股（How many shares are outstanding）？"></a>有多少流通股（How many shares are outstanding）？</h3><p>如前所述，绝对股数无关紧要——您需要知道总股本的百分比。一些公司将发行大量股票，以使它们的报价看起来更令人印象深刻，因此不要被众多公司愚弄。如果公司不公开流通股数量，那将是一个很大的危险信号。</p><h3 id="董事会最近一次普通股评估（common-stock-appraisal）是什么？"><a href="#董事会最近一次普通股评估（common-stock-appraisal）是什么？" class="headerlink" title="董事会最近一次普通股评估（common stock appraisal）是什么？"></a>董事会最近一次普通股评估（common stock appraisal）是什么？</h3><p>如果您要购买股票期权，您的offer可能没有明确说明行使价。但是，这个数字将为您提供一个不错的指导，假设未来FMV会增加，您可以行使多少期权以及潜在的上涨空间。</p><h3 id="公司目前的估值是多少？"><a href="#公司目前的估值是多少？" class="headerlink" title="公司目前的估值是多少？"></a>公司目前的估值是多少？</h3><p>加上发行在外的股票数量，您将可以了解股票的价值，无论是它们将以赠款还是认股权形式被赠予您。</p><h3 id="归属时间表（vesting-schedule）是什么？"><a href="#归属时间表（vesting-schedule）是什么？" class="headerlink" title="归属时间表（vesting schedule）是什么？"></a>归属时间表（vesting schedule）是什么？</h3><p>为了激励您坚持下去，大多数公司会根据归属时间表发放股票或期权。最常见的时间表是，在您开始一年后拥有25％的期权，然后在每个月给你1/48的股份（这意味着四年后您将拥有所有的期权，或者被<em>完全归属</em>fully vested）。在您达到某个里程碑之前，这种保留期权的做法被称为<em>归属悬崖</em>（<em>vesting cliff</em>）。</p><h3 id="如果公司被收购（acquired）或我离开，将会发生什么？"><a href="#如果公司被收购（acquired）或我离开，将会发生什么？" class="headerlink" title="如果公司被收购（acquired）或我离开，将会发生什么？"></a>如果公司被收购（acquired）或我离开，将会发生什么？</h3><p>如果被公司收购，某些公司将允许加速归属（vest），这意味着您将在收购时或几个月后获得所有剩余股份。如果您不想最终被大公司收购，这可能会有所帮助。</p><p>另一方面，如果您离开公司，通常会保留当前已授予的股份和/或期权。通常，您必须在设定的时间段内（通常在离开后90天之内）行使这些选择。但是要当心：有些公司保留以行使价（exercise price）回购您的期权的权利，这意味着您从这些期权中没有任何价值。要记住的另一件重要事情是，您在行使期权时（而不是在实际出售股票时）可能必须为期权缴纳税款。</p><p>假设您有1,000股股票，当前价值为5美元，行使价为1美元。您将于2010年离开公司并行使股票。2016年，您以每股7美元的价格出售股票。在某些情况下，您将在行权时对估值与行使价之间的差额征税–也就是说，您将在2010年支付4,000美元（即1,000股<em>）（5美元的估值– 1美元的行使价）的税。2016年，则您应就所卖出的价格与其行使价之间的差额缴纳税款-即2,000美元或1,000股</em>（$ 7卖出-行使价$ 5）。</p><p>额外的4000美元应纳税所得额-根据2016年替代性最低税支付的1,120美元税款-似乎并不可怕，但如果您拥有大量股权，则税收负担的确会相当沉重。您不仅要行使期权（行使价乘以股票数量），还要对尚未行使的期权征税。确保您有足够的钱来支付这些费用；否则，您可能必须出售股票来支付行使股票的成本，并且您的税率会更高。查阅<a href="https://blog.wealthfront.com/when-to-exercise-stock-options/" target="_blank" rel="noopener">本指南</a>，了解您的选择以了解更多信息-这是您值得花费的时间。</p><h3 id="您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？"><a href="#您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？" class="headerlink" title="您打算什么时候筹集下一轮资金（raise your next round of funding）？"></a>您打算什么时候筹集下一轮资金（raise your next round of funding）？</h3><p>如前所述，投资者需要股票来换取资金。如果您的公司有100,000股流通在外的股票，并向您提供1,000股，那么您将获得公司的1％。但是，如果公司计划再进行一轮融资，它很快就会发现自己拥有20万股流通股。您的1,000股的价值将减少一半。</p><h3 id="你的退出策略是什么（exit-strategy）？"><a href="#你的退出策略是什么（exit-strategy）？" class="headerlink" title="你的退出策略是什么（exit strategy）？"></a>你的退出策略是什么（exit strategy）？</h3><p>如果公司计划收购或很快上市，那么您的股票更有价值。并非所有公司都会为您提供此信息，但是了解这一点很有帮助。</p><p>当然，这并不是一个详尽的问题清单，但足以让您了解您的股票或期权的价值，以及您对它们的价值的确定性。</p><h2 id="比较报价"><a href="#比较报价" class="headerlink" title="比较报价"></a>比较报价</h2><p>好的，这是向您抛出的许多信息。让我们来看一个具体的示例，比较初创公司BookFace和Moogle的报价。我们将不断汇总每个报价的“价值”。</p><p><strong>BookFace：</strong> 100,000美元的薪水，10,000股和5,000个期权</p><p><strong>Moogle：</strong>年薪140,000美元，6,000股和2,000个期权</p><h3 id="薪水"><a href="#薪水" class="headerlink" title="薪水"></a>薪水</h3><p>这很简单，将提供我们进行比较的基础。</p><p><strong>BookFace：</strong> 100,000美元的薪水</p><p><strong>Moogle：</strong>年薪140,000美元</p><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>现在您知道了如何评估股票赠款，现在就向BookFace和Moogle询问他们最近的409a估值以及多少流通股。BookFace告诉您，它有1000万流通股，价值为5000万美元。Moogle不会告诉您其估值，但会告诉您其股票的公平市值为4美元。</p><p><strong>BookFace：</strong> $100,000薪水+ $5,000万估值/ 1,000万股流通股*所发行的10,000股= $100,000+ $50,000= $150,000</p><p><strong>Moogle：</strong>薪金$ 140,000 + $ 4 FMV * 6,000股= $ 140,000 + $ 24,000 = $ 164,000</p><h3 id="股票期权"><a href="#股票期权" class="headerlink" title="股票期权"></a>股票期权</h3><p>现在，您问公司这些股票期权的行权价（exercise price）是多少。两者都将行使价定为1美元。您已经知道Moogle股票的近似值（4美元），但是要回到BookFace的股票中，您可以将估值除以发行在外的股票数量。这使您的每股收益为5美元。</p><p><strong>BookFace：</strong> $100,000薪水+ $50,000赠送股票+ 5,000个期权*（$5 FMV - $1行使价）= $150,000+ $20,000= $170,000</p><p><strong>Moogle：</strong> $ 140,000薪金+ $ 24,000赠送股票+ 2,000个期权*（$ 4 FMV – $ 1行使价）= $ 164,000 + $ 6,000 = $ 170,000</p><p>在这个示例中，BookFace和Moogle的报价“价值”相同。让我们深入研究改变其价值的模糊因素。</p><h3 id="定性因素"><a href="#定性因素" class="headerlink" title="定性因素"></a>定性因素</h3><ul><li><strong>公司成长有多快？</strong>如果您在一家如火箭般快速上升的公司工作，那最好是用股票而不是工资（这是BookFace的报价）来补偿。如果它很快就要进行收购或IPO，那么您的股票很可能会很有价值。</li><li><strong>公司是否计划尽快筹集资金？</strong>如果是这样，您的股票将被摊薄（diluted），您应相应地对赠款和期权进行贬值。</li><li><strong>归属时间表（</strong>vesting schedule<strong>）是什么？</strong>对自己诚实：您打算在公司呆多长时间？初创公司员工的平均任期<a href="http://www.theatlantic.com/business/archive/2014/12/statistically-speaking-what-does-the-average-startup-look-like/384019/" target="_blank" rel="noopener">仅为10.8个月</a>，因此您很可能没有足够长的时间来完全归属（fully vest）。在这种情况下，更快归属的公司，或是优先考虑薪资而不是股票的公司，会更有价值。</li><li><strong>还提供什么其他好处？</strong>健康和残障保险，育儿假（parental leave），401（k）（尤其是如果<a href="https://humaninterest.com/blog/is-a-401k-match-contribution-tax-deductible/" target="_blank" rel="noopener">与雇主匹配的话</a>），通勤津贴（commuter benefits）和免费餐食（free meals）也可以影响您的决定。</li></ul><p>最后一个问题是您必须问自己：您需要多少收入保障（income security）？股票是高风险，高回报的主张。您的股份可能会变得一文不值，或者使您成为百万富翁。另一方面，工资是可靠的。如果您的财务状况不安全，承担大量债务（抵押，学生贷款债务，家庭），或者想规避风险，则可能要优先考虑薪资而不是股票。</p><p>相较于用来比较startup offer或股权中的所有术语和数字，你的决定可能取决于更软的因素，例如，您对公司成功的信心到底有多深。</p><h2 id="如何计税？"><a href="#如何计税？" class="headerlink" title="如何计税？"></a>如何计税？</h2><p>原文自<a href="https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=138822&extra=page%3D1%26filter%3Dsortid%26sortid%3D320%26sortid%3D320" target="_blank" rel="noopener">一亩三分地</a>，原作者<a href="https://www.1point3acres.com/bbs/space-uid-42994.html" target="_blank" rel="noopener">wzf1943</a>，修正了错误</p><p>期权有很多种，市场上公开交易的期权和公司期权也有不少区别，但是本质都是以固定价格购买（卖出）股票的权利。</p><p>目前创业公司发Stock Option主要有两类</p><ul><li>ISO(Incentive Stock Option)</li><li>NSO(Non-Qualified Stock Option)</li></ul><p>两者在计税方面有很大区别。不过趋势是越来越多创业公司选择NSO作为Stock Option的发放方式。</p><p>先讲一讲Stock Option的大致阶段：</p><ul><li>你被公司录用，然后被赋予相当数量的期权。比如，可以用$5/股的行权价购买10000股的Option。</li><li>被赋予的期权都有一个分配的时间表，主流做法也是工作满一年拿到25%，之后36个月每月拿到剩余的1/36</li><li>在某个时间点，你决定行使期权的权利，也就是以行权价购买公司股票。可以在同时、或之后把行权所得的股票卖出，获得利润。</li></ul><p>先看NSO，计税不算复杂：阶段1-2不涉及实权兑现，因此不交税。阶段3行权且有潜在的利润，按收入税计税。</p><blockquote><p>假设小明加入一家创业公司，获得NSO，可以用行权价$5/股的价格购买10000股。再假设公司四年后上市，股价变成$25/股。</p><p>此时，小明所有期权都已被分配。进入阶段3：可以行使所有期权，其潜在收益是 ($25 - $5) * 10000 ＝ $200,000. 税额按收入税计算，外加州税，基本上需要交税一半左右($100,000)。外加行使权需要$5 * 10000 = $50000，总费用是$150,000，天价。更常见的做法是：小明可以选择只行使一部分期权，比如2000. 那么相应的总潜在收益是($25 - $5) * 2000 = $40000. 相应的，由于总收益的降低，计算收入税的税额就可能应用低一档的税率，可以省%4左右的税率。</p></blockquote><p>然后是ISO. 咳咳咳…为了不把本文变成没完没了的税法说明，小编建议有需要的读者自行搜索以下关键字：ISO, AMT, Tech Bubble, Bankcruptcy…没错，2000年大泡沫中破产的人大部分都是拜ISO中产生的AMT税所赐，故事非常精彩，祝大家阅读愉快。</p><p>写了这么多，估计很多读者没有心思读完全文，直接跳到结论。那好，小编给你个总结一下：</p><ul><li>如果公司提供了RSU，很好，你不需要多想，老老实实待满年头，坐等拿股票卖钱，如果你在加州，做好心里准备：基本上一半的收入去交税。</li><li>如果公司提供的是Stock Option，并且是NSO。你能做的也不太多，等公司上市后，好好盘算自己的收入，每年选择一部分Option行权并卖出股票获利。如果控制得当，税可能比RSU略少。</li><li>如果公司提供的是Stock Option，并且是ISO, 除非是极早期员工，否则请谨慎使用早起行权(early exercise)，建议做决定前先咨询专业税务人员。</li></ul><p>无论是RSU/Option, 只要公司没有办法上市或者被收购，或者你在此之前已经离开，这些RSU/Option则分文不值。（事实上并非如此，有的公司允许你买卖期权或是买卖你手中的股票，你需要向HR问清楚这些细节）</p><p>同样，高风险意味着高回报。创业公司给员工提供的RSU/Option要远比大公司慷慨，你只要熬到公司上市或被收购，回报自然丰厚</p>]]></content>
      
      
      <categories>
          
          <category> finance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旧金山准独角兽面试之行</title>
      <link href="/2020/02/04/%E6%97%A7%E9%87%91%E5%B1%B1%E5%87%86%E7%8B%AC%E8%A7%92%E5%85%BD%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%A1%8C/"/>
      <url>/2020/02/04/%E6%97%A7%E9%87%91%E5%B1%B1%E5%87%86%E7%8B%AC%E8%A7%92%E5%85%BD%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h2><p>首先是要介绍下这家公司，blend。你们可以在<a href="https://blend.com/" target="_blank" rel="noopener">Blend</a>找到更加详细的资料。它是一家fin-tech初创公司，主要业务是做SaaS，给银行提供些贷款方向的服务。</p><p>个人觉得这家公司和我有些谜一般的缘分。大概在十月的时候我突然在垃圾邮箱里发现了他们HR的邮件，说是我被内推成功了并过了简历关，若我对他们公司仍旧感兴趣的话，就会给我发OA(Online Assessment)。这是我第一次险些错失机会，因为当时我看到这封垃圾邮件的时候它已经快被系统自动删除了。我赶紧联系了HR并做完了OA。不多久之后便被告知将会有一轮HR电话面和两轮技术电话面试。</p><p>对于HR面和第一轮电面，我都没什么好说的，hr就是聊聊天，技术面也是洒洒水（其实我第一轮面的是这公司为数不多的非面经题，而且是这公司top3难度的题，还好我是老hashmap玩家了，三下五除二给做出来了……）可就在第一轮电面之后，HR忽然迷之消失。我给HR发邮件询问情况，收到个自动回复的邮件说她在training program，没法回复消息……以至于第二轮的时间被延迟，拖到了感恩节附近。约第二次面试时，HR问了我什么时候有空，并告知我她prefer the week after thanks giving。我便回复了她我的空闲时间，她也随后通知了我安排后的日期。当时我瞥了眼邮件，看到是周一，也就理所当然觉得是感恩节后的周一，毕竟她“prefer the week after thanks giving”。谁料在感恩节前的那个周一，我突然收到了个电话。我当时还在睡觉，迷糊着看到来电来自CA，于是一个鲤鱼打挺坐了起来，接起了电话。沉默一段时间后，尴尬的对话开始了，大概如下：</p><p>我：你哪位？</p><p>面试官：在下是blend的面试官。how’s your day?</p><p>我：等等，你再说一遍？beg your pardon？？？</p><p>面试官：我是来自blend的面试官。</p><p>我：不对啊，我面试约的是下周，你是不是搞错了（理直气壮，大声驳斥）</p><p>面试官：oh that’s interesting， 我去问问HR。</p><p>然后电话就在我自信的质问中结束了。随即我立刻去查了邮箱，发现约的时间确实在感恩节之前……只好立刻发了封道歉信给HR并询问能不能reschedule调整时间，好在HR还是通情达理帮忙改了时间，第二轮电话面试在十二月终于面上了。</p><p>面完之后一周，我正坐地铁呢，翻开手机一看看到封blend拒信，人直接呆滞了。我寻思着我面得挺好的啊，一看说是position filled，那属实没有办法了。这也不是我遇到的第一家position filled的公司了，我自己还错过了一次面试，也怪不得别人。于是我沮丧的关掉了那封邮件，却发现在那邮件之前，有个blend发的before you come onsite……</p><p>我缓缓打出一个问号，这到底是要面我还是不要面我啊？我立刻发了个邮件去问HR到底是咋回事。HR跟我说那个拒信发错了。嗯，从Bloomberg到Amazon再到blend，这大家的HR都身手不凡啊……</p><p>HR说发错了，那就是还有面试呗，我就接着等。可是等着等着等过了圣诞都没有任何动静。期间我还给HR发了个邮件询问到底有没有onsite，她也没有给我答复。直到一月我忍无可忍联系了我的内推人了。内推人表示系统显示我应该onsite了，说她会帮我联系看看。在她的联络下，HR终于再次联系了我。</p><p>HR表示她早就给我发了邮件了——我明明有天天查邮箱啊！spam我也每天查看！可能邮箱系统被黑客袭击了吧，那封邮件寄到异世界去了。</p><p>在HR的安排下onsite最初被安排在了一月中。可不久之后HR又告知我一月底高盛开会没酒店能订了。磨蹭来磨蹭去，最终时间终于定在Jan 23。</p><h2 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h2><p>作为一家初创公司，blend拥有一座downtown的五层小写字楼。这座楼不大但挺精致，就在Chinatown边上，其背后便是一个小公园。HR安排的两晚的住宿也就在Chinatown门口。对于这次面试，我并不是很紧张。自从挂掉Bloomberg的面试之后我就意外的不再面试紧张了。</p><p>于是进了大楼，和等在那的HR寒暄了几句，就被领去面试了。Blend的面试轮数出人意外的多，四轮技术面一轮manager面，题倒是不难，medium为主，掺杂OOD和改版hard。面到一半，中午会去顶楼吃饭。陪我吃饭的是个国人学姐，她告诉我今天有一个大组出门offsite去开卡丁车了，严厉的面试官都在那个组里。我心中大喜，差点没笑出声。大概因此我也自信了不少，下午面试一路顺利。</p><p>不过很尴尬的一件事就是每个面试官都会进来问一句，“How are you doing today?”我就回答“Great!”，然后他们就会说，“Wow you are so confident!”……那我怎么回答嘛，难道应该回答bad嘛。</p><h2 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h2><p>离开办公楼直接叫上小伙伴出门自由行去了。我们从Chinatown附近一路闲逛到了渔人码头，再从渔人码头一路走向了金门大桥。来到金门大桥的时候已是一片漆黑，我俩也累得不行，留了几张照片，叫了辆uber便回家了。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200321010853.png"  alt="Golden Bridge"></p><p>第二日我俩清早起来便用zipcar租了辆SUV，开始在旧金山溜达。旧金山这个地方到处都是小山坡，整个城市就在山上，简直就是手动挡噩梦。尽管我们租的自动挡，开起车来还是有些慌。我们先去小山头眺望了眼恶魔岛，随后又前往了花街与twin peaks俯瞰了旧金山。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200321010921.png"  alt="AlcatrazIsland"></p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200321010951.png"  alt="LombardStreet"></p><p>因为HR给我订的返程机票是在中午，所以十一点左右我便还了车回了酒店。万万没想到，打车去机场的时候竟然遇到了昨晚半夜从金门大桥送我们回来的同一个uber司机。我一开始并没有认出他来，反而是他突然问了句，“Where is your friend?”，我当时惊了，傻不拉几的问了句“Who?” “The guy who came back with you last night! I’m the driver who drove you back!” 我这才查了下uber app，发现真是同一个人……司机也惊奇地告诉我，我是他昨天最后一单也是今天第一单，他这么多年头一次遇见送同一个人back-to-back。</p><p>到了机场之后，安检的时候大家向外拿电脑，后面的人的电脑上赫然就是Blend的贴纸，而且跟我第二轮面试官一样也是金发。我又不能确定是不是那位面试官，就瑟瑟发抖不敢说话（主要是尬聊能力太差）我就赶紧在微信上问内推的学姐我那面试官在公司不。学姐让我放心，金发小哥还在公司，我才松了口气……学姐还告诉我金发小哥正在和其他面试官sync最终结果，说有消息会告诉我一声。没多久后我便收到了学姐发来的通过的消息。当时还是很激动的。</p><p>学姐此前告诉我她第五个最终面才拿到offer，我发现我也是第五个最终面才真正拿到offer。WHAT A COINCIDENCE！</p><p>尽管后来手机收到消息说飞机晚点了370分钟。Damn，应该在旧金山多玩一会的……</p><h2 id="回家"><a href="#回家" class="headerlink" title="回家"></a>回家</h2><p>在返程的路上遇到了一个西语司机。司机问我去哪儿了，我回答我去面试了。</p><p>“那么你一定通过了面试了，我能看得出来。”他说。我笑着点头，问他为何这么认为，他说：</p><p>“I know, I konw……You guys are smart. Today everything is made in China…”</p><p>我只好笑而不语……他紧接着就说他儿子是技校出生的水管工，现在想转而当程序员……说得我一脸震惊，真就万物转CS呗。他说他儿子觉得现在的生活不体面，想去上大学读软件工程，但是即使大学有奖学金，大学的学费也还是很贵（我问了一句结果发现是10000刀，害老哥，我们都是这样过来的啊，该投资要投资的）</p><p>我略加思索，然后轰出一堆很打击人的话，什么我投了五百家公司，然后只收到十家面试，只过了最后这一家之类的。（实际上没投这么多，不过比例确实相似）还有啥中美贸易战，饭碗都被打飞了云云……然后他又问了问我的薪资，这我倒没说谎。现在想来我有点刻薄，是不是应该多加鼓励的？自己在寒冬冻着了，就劝别人都别来滑雪了</p><p>最终大叔把我送到家楼下，问我有什么建议能给他儿子。</p><p>“多刷题，看算法。公司就爱考那玩意。”我说。</p>]]></content>
      
      
      <categories>
          
          <category> travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> travel </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bloomberg面试见闻</title>
      <link href="/2020/02/03/Bloomberg%E9%9D%A2%E8%AF%95%E8%A7%81%E9%97%BB/"/>
      <url>/2020/02/03/Bloomberg%E9%9D%A2%E8%AF%95%E8%A7%81%E9%97%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Bloomberg"><a href="#Bloomberg" class="headerlink" title="Bloomberg"></a>Bloomberg</h2><p>Bloomberg的大名想必各位早已有所耳闻。迈克尔彭博身为一位传奇商人，这位带兄弟不仅仅在2001年至2013年担任了纽约市长，今日更是想要竞选总统。Bloomberg旗下顶梁柱虽然是Bloomberg terminal等tech业务，但论名号，还是彭博社赫赫有名。其仅仅二十多年就踩过路透社走上王位，也算一段佳话。</p><p>我校是Bloomberg的target school，每到秋季他们便会来我校的career fair招生。因为我们的computer science不在ENG学院，而且有自己的career fair，所以bb（后文就将Bloomberg称作bb）会来我们学校两趟，一次来CS Day，一次来eng career fair。其后便会在career fair上收到的简历中筛查一波，举行个on campus interview，将四轮onsite面试迁到学校来，招一波学生。</p><p>我并没有这个运气参加bb的on campus interview。第一次我去和cs day上的bb小姐姐畅聊之后，杳无音信。第二次他们再来，我又给一帅气小哥一顿文化输出，结果还是杳无音讯。后来才得知过不过其实不是由当天跟你聊天的员工决定，而是HR筛的简历。</p><p>我室友有幸参与了on campus interview，并成功于bb上岸。室友升格成了布隆伯格工程师之后，我既为他激动，又有些生气——喵了个咪的为啥我连个面试都没有，我简历也不见得差啊。不料过了几天后便收到了邮件，让我电话面试。</p><p>这里就要吐槽下这位神奇的HR了。我第一次简历投递后她并不想理我，但是第二次简历投递之后她又想面我了，这简历筛选机制是不是不太稳定啊。这位HR还有一些其他的神奇操作，例如打错candidate的名字啊，写错面试时间啊，还有给了我波士顿同学philadelphia的打车券之类的……不过那又能怎么样呢，当然是选择原谅她了！</p><p>虽然错过了on campus interview，但是尚存一线机会，于是我一顿准备之后通过了电话面试，定下了在一月初前往Bloomberg HQ onsite。</p><p>说来搞笑，因为在十二月时有一位CS院的同学（因为他来自北大，后文便唤其北大哥）连面三大公司，并连斩三个offer。三offer分别来自Bloomberg，Amazon和一家startup。我当时也有三个面试ongoing，也是Bloomberg，Amazon和一家startup，迷信玄学的我决定复制一次北大哥的传奇！于是我照猫画虎把这三个面试放到了一起！（后来发现面试顺序安排错了，跟北大哥安排三家的顺序相反，气得我直拍大腿）</p><p>也正是为了模仿北大哥（事实证明模仿别人是没有出路的！），我选择了坐火车（Amtrak）前往Bloomberg，因为北大哥说火车站就在市中心，离bb很近，较飞机更加方便。bb说是给你订商务舱，其实那商务座和高铁二等座也差不多。国内的高铁是3+2，这所谓的商务舱也就2+2。下了火车之后先模仿北大哥去火车站边上的一兰拉面吃了碗拉面。我还坐到了店内的一号座位上。害，当时我还以为是什么祥兆呢。</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/8128/PicGo/master/20200321010442.png"  alt="一兰拉面"></p><p>吃完面就打算用bb给报销的打车券打的去旅馆。结果一打开uber app，发现这打车券用不了。再定睛一看发现自己只有两张打车券。原来bb这抠门公司只给坐飞机的人四张打车券，假如你选择坐火车的话只有两张打车券，也就是你家到你们城市火车站来回的打车券。我人傻在原地，看了眼走路要五十分钟，最要命的是刚才一顿找打车券的操作把我手机整没电了，我刚记下旅店在哪，我手机就彻底黑了……我只好徒步走了四十多分钟去了旅店。</p><p>假如你也要面bb，那你大概就是被安排住在fitzpatrick。可这fitzpatrick，每个人竟然也是不一样的。我被安排在了fitzpatrick manhattan，离bb大楼只有2分钟路程，我同学便被安排在了另一家，要走二十分钟……进去以后直接说自己是来面试bb的，接待便会给你房卡和早餐券。</p><p>这家旅馆装修尚可，只是一走进电梯便有种跨入大清的错觉，电梯缓缓的蠕动速度让我不禁怀疑这是不是天龙人电梯，是不是人力在拉动这玩意上下行走。房间总体装修很棒，除了窗帘实际上不挡视野——我往外一看，对面的人在房间里做什么被我看得一清二楚。</p><p>那晚简直煎熬。这不是我第一次面试，但我不知道为什么就是平静不下来，躺在床上心率都有120，张口闭口就是behavior question，why bloomberg。可能我当时已经意识到我们寝室只有一个headcount了。</p><p>于是第二天，没咋睡的我把头发吹成大人模样，熨了下衬衫就下楼吃早饭了。不得不说早饭还不错，并不是自助餐，你到楼下一做，把早餐券给服务员，一会他便端着热腾腾的面包，一盘水果和一杯红茶过来了。随便吃了点我便起身前往Bloomberg headquarter，731 Lexington avenue。</p><!--split--><h2 id="Bloomberg-HQ"><a href="#Bloomberg-HQ" class="headerlink" title="Bloomberg HQ"></a>Bloomberg HQ</h2><p>作为一家金融公司，牌面这一块必须安排的明明白白的。我刚走进去，估计是门卫觉得我配不上他们金融公司的高雅气质，主动跑过来问我是干嘛的。我这么儒雅随和的人，当然是平和谦虚地对傲然的保安说：我是来面试的。于是被领到台前拍了张照片，然后带着临时工牌就上了六楼。</p><p>六楼是布隆伯格的开放参观楼。当然说是开放参观，那你至少也得被邀请，不然你是门都进不来的。进去后小哥先让我去储物间放了大衣，然后让我坐在门口的沙发上，等HR过来。沙发前面就是摆放着各种零食饮料的大厅，大厅顶上还有各式各样的显示器，显示着各种金融数据，涨幅跌幅不同货币的汇率等等。我刚在那坐下来，边上的妹子便转过头来跟我打了个招呼握了个手。她说她是波士顿本地人，我听她说话的时候声音都在颤抖，搞得我也有些紧张，于是赶紧起身去打了杯热水让自己清醒点。</p><p>不一时来面试的人越来越多，最后约莫到了十多个人，其中女生比例还挺高的。在约定的时间十多分钟后，HR终于到来，是个挺可爱的亚裔妹子。她先介绍了下一边供参观的bloomberg terminal，然后带着我们下了旋转扶梯。“这是世界上屈指可数的旋转扶梯。虽然这栋楼不是我们的，但是这座扶梯属于bloomberg”</p><p>刚下电梯就能看见左侧的bloomberg播音台，和右边他们电视台的演播室，可谓十分炫酷。前方则是一排古董bloomberg机器，说是历史博物馆。这排古董机器前甚至禁止拍照。我眼尖，一眼看到里面一台二十年前的机子装的竟然是win7系统……你们确定这不是你们瞎搞的模型机吗？这是真机？</p><p>其后我们便到了他们的办公区域。这办公室便和好莱坞电影里的美国金融公司办公室没啥区别，只是所有会议室都是玻璃门。HR还和我们讲了他们的transparency准则。说迈克尔彭博要求整个公司公开透明，所以会议室内部都是从外部可见的，大楼也是透明玻璃外壳，你们能从外面看到里面。有几次彭博看到员工开会时把门关着，边去把门拉开了。不料过了段时间再去发现他们把门又关上了。于是彭博大怒，第二天就把那扇门拆除了……</p><p>她还说在彭博没有人有独自的封闭办公室，甚至连彭博本人也只是有个寻常工位而已，你甚至有时能在工位上见到他。她们彭博就是这么公开透明！</p><p>于是我不禁开始怀疑昨天能看到对面房间的旅馆，是不是也算Bloomberg transparency的具体实现方案……</p><p>之后我们便回到了最初的沙发处。此时已有一大堆面试官扎堆于沙发前，呼唤着你的名字。我便跟着我的面试官去了面试的会议厅。</p><p>面试并不顺利。一是我发挥失常，二是我很不习惯用白板，三是面试官也有点呆呆的竟然没看懂我代码……结合我后两次平常心就面过了的经验来看，心态放好才是面试的关键，刷题多少还是minor problem。</p><p>其中还有一段很尴尬的插曲。第一轮面完后两个面试官很热情地问我要不要去洗手间。我说不用不用，他们又问我要不要喝点热水，我想了想说好吧那我去接点水。于是我便从三楼的会议厅跟着他俩上了六楼……没想到上去了以后就下不来了！我再次企图从旋转扶梯那里下楼的时候被保安拦住了，告诉我“你这样的临时工牌只能待在六楼，除非有戴普通工牌的人陪同。”我大吃一惊，只好又去找接待。接待问我我面试官是谁，这我哪记得住啊，我只好报了我HR的名字。过了约莫半个小时，下一轮的面试官才前来把我接走了。也就因为这个事，我午饭也没吃就开始了第二轮……</p><p>第二轮结束后便被告知今日已all set，便是凉凉的意思（一个通过的人会有四轮）。我脑袋里轰隆一声，准备了这么久的公司就这样凉了，准备了半天的behavior question都没被问到，人就被赶出去了。可能我瞬间面色憔悴，形容枯槁，面试官为了安慰我，问我要不要去28楼看看风景。我摇了摇头，“不用不用，我自己走就行了”（所以你们看到的封面文章图片并不是我拍的，而是我另一个面试的同学拍的）</p><p>来到六楼后，我又跟他说不用再陪我了，我一人下去就行了。他坚持送我下去，说这是他的责任。一路到了门口，他告别的时候跟我说：“看你的表情，我知道你一路上可能想了很多，但是请不用太纠结于这两轮的面试，继续加油吧。”</p><p>even he rejected me he’s still a nice guy </p><h2 id="纽约火车站-Penn-station"><a href="#纽约火车站-Penn-station" class="headerlink" title="纽约火车站 Penn station"></a>纽约火车站 Penn station</h2><p>我端着我还没动过的午饭饭盒走出了bloomberg大楼，一副刚被解雇的落魄模样，开始漫无目的的在纽约转悠。bloomberg的火车票出发时间是5 pm，因为他默认你可能会面到四点。然而我两点不到就出来了，走到火车站时也才三点。刚进火车站便看到KFC老爷爷温暖人心的笑，我决定在快餐店门口座椅上休息会</p><p>我把bb给我的饭盒放在了桌上，坐在座位上刷起了一亩三分地。不一会一个年迈的黑人女性走到我边上，问我能不能坐在我边上。当时我还没警觉，我说你坐呗。于是她便坐了下来，在我身边吃完了她的三明治，然后走了。走的时候还对我说了句thank you。我疑惑，问thank you for what？她说thank you for let me sit here。这着实让我摸不着头脑。</p><p>结果不一时又一个黑人女性过来了，问我身上有没有钱，她想吃东西。我心情也不好，跟她说了句没有，便没再说话。可她却缠着我，不肯离开。我便从bb的午餐盒中拿出了bb的旅行报销prepaid card，接着把午餐盒推给了她。“你要吃东西你吃这个吧”我跟她说。不料她竟然还露出了一副嫌弃的表情！此时旁边的必胜客老板早就看这几个流浪汉不爽多时了，叫来了警察要赶走她。她见警察靠过来，便拿起我的bb饭盒走了……</p><p>我寻思着饭盒也给出去了，肚子也有点饿，还是买点KFC垫垫吧，于是去KFC排队买吮指原味鸡。不一时竟看到那拿了我饭盒的黑人女性转头回来了，开始坐下吃我饭盒里的三明治。不久后，远处一个高大壮硕的黑哥走了过来，开始跟拿了我饭盒的黑人女性聊天，聊完便向我这里走来。我心中暗道一声不好，但又无法溜溜球，只好噘嘴强装出一副李小龙的样子。只见那黑哥过来，“yo，you still have any free sandwich？”</p><p>“no, not any more. that’s the last one”</p><p>接着黑哥就冷哼一声，沉身猛力用肩膀朝我冲撞了过来。靠，要不是我李小龙附体，可能真被他撞倒，在下怎么也是70kg级选手，虽然晃了晃还是稳如泰山的站住了。</p><p>旋即警察们又来了一趟。这次是真正的把这流浪汉两兄妹赶走了。我总算是能平下心来吃了顿原味鸡，跑路回家。</p><p>总的来说bb的面试还是令人失望。倘若再给我一次机会，我一定不那么费劲心力了。花的时间太多，让我有种必须成功的压力。这过大的压力实在不一定是件好事。压力之下还是冷静比较重要。</p>]]></content>
      
      
      <categories>
          
          <category> travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> travel </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Jekyll博客技巧集</title>
      <link href="/2020/02/03/%E6%90%AD%E5%BB%BAJekyll%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7%E9%9B%86/"/>
      <url>/2020/02/03/%E6%90%AD%E5%BB%BAJekyll%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我个人在建立这个jekyll的博客中还是查询了不少资料的，其中有些已经过时，有些压根不能用。对于那些有用的信息，个人会在下方做一个总结，希望能对各位有所帮助。我会持续更新此blog</p><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>这实际上是jekyll博客最容易添加的功能之一。国外有<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>，国内似乎也有替代产品。添加disqus到你的jekyll博客中是件非常简单的事，你要做的只是登录他们的网站，注册你的账号，然后跟随着他的教程一步一步向下走。</p><p>一个小技巧就是把jekyll提供给你的脚本代码写到单独的一个html中，将html放入include文件夹。之后只要在模板中include这个html，你就可以在所有用了这个模板的网页中添加评论区了。</p><p>注意，假如你在网上跟着别的教程一步一步走，却发现最终出现在你post下方的不是评论区，而是加载失败的disqus，那么出错的很可能并不是你的tokens，而是你看的教程中的旧版代码。请从复制官方文档中最新的代码。旧版代码会导致disqus加载错误</p><h2 id="目录功能"><a href="#目录功能" class="headerlink" title="目录功能"></a>目录功能</h2><p>如果你想给blog添加目录，你可以在_config.yml中将Jekyll默认Markdown渲染器设置为kramdown。添加方法如下：</p><p>_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span>           <span class="string">kramdown</span></span><br><span class="line"><span class="attr">kramdown:</span></span><br><span class="line">  <span class="attr">toc_levels:</span>       <span class="number">1</span><span class="string">..6</span> <span class="comment">#此行表示从1-6级的标题将被放入目录</span></span><br></pre></td></tr></table></figure><p>随后在文章中标识 toc 的生成位置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>目录</span><br><span class="line">&#123;:toc&#125;</span><br></pre></td></tr></table></figure><p>其中，目录这一行是必需的，星号后面的内容则可随意填写。如果要把某标题从目录树中排除，则在该标题的下一行写上 <code>{:.no_toc}</code>。默认生成的目录列表会添加 id 值 markdown-toc，我们可以自定义 id 值，比如 {:toc #id}</p><p>如果你不想用kramdown，也不想用js或其他plugin（很多jekyll的plugin被GitHub给屏蔽了），你可以使用<a href="https://github.com/allejo/jekyll-toc" target="_blank" rel="noopener">jekyll-toc</a>，你只需要三步就能解决问题：</p><ol><li><p>下载最新版本的 <a href="https://github.com/allejo/jekyll-toc/blob/master/_includes/toc.html" target="_blank" rel="noopener"><code>toc.html</code></a> 文件（在GitHub仓库的_includes里）</p></li><li><p>将这个文件放到你的 <code>_includes</code> 文件夹去</p></li><li><p>找到你模板中的content位置，然后把toc.html给include进去，放到content的前面，html代码如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include toc.html html&#x3D;content</span><br></pre></td></tr></table></figure><p>别忘了在左边右边加上大括号和百分号</p><p>好了，大功告成。</p><h2 id="PicGo-Github-图床"><a href="#PicGo-Github-图床" class="headerlink" title="PicGo+Github 图床"></a>PicGo+Github 图床</h2><p>众所周知，markdown本身并不能存图片，要是想加入图片我们需要添加外链。</p><p>在这些图床中我介绍一下GitHub图床，因为GitHub图床基于你自己的GitHub，方便于你自己管理</p><h3 id="1-为图床创建GitHub-repository"><a href="#1-为图床创建GitHub-repository" class="headerlink" title="1. 为图床创建GitHub repository"></a>1. 为图床创建GitHub repository</h3><h3 id="2-生成操作repository的token"><a href="#2-生成操作repository的token" class="headerlink" title="2. 生成操作repository的token"></a>2. 生成操作repository的token</h3><ul><li>点击右上角头像</li><li>点击settings</li><li>点击developer settings</li><li>点击Personal access tokens</li><li>Generate token（这里只需要勾选第一个，所有repo权限即可）把token复制出来，token只会出现一次，可别马上把网站关了</li></ul><h3 id="3-安装PicGo"><a href="#3-安装PicGo" class="headerlink" title="3. 安装PicGo"></a>3. 安装PicGo</h3><p>可以去他们的<a href="https://github.com/Molunerfinn/picgo/releases" target="_blank" rel="noopener">GitHub</a>下载，<strong>注意了mac用户你们要下的是dmg版本可不是mac.zip那个</strong></p><h3 id="4-设置PicGo"><a href="#4-设置PicGo" class="headerlink" title="4. 设置PicGo"></a>4. 设置PicGo</h3><ul><li><p>打开PicGo，<strong>Mac用户点了app没反应，看看右上角状态栏里面是不是有PicGo图标，你可以右键-详细窗口</strong></p></li><li><p>点开图床设置-GitHub图床</p></li><li><p>仓库名要写全名，比如我的GitHub id是8128，这里就填8128/PicGo（PicGo是我之前新建的repo名）</p></li><li><p>分支名写master就行，随你</p></li><li><p>token把刚刚复制出来的token粘进去</p></li></ul><h3 id="5-使用PicGo"><a href="#5-使用PicGo" class="headerlink" title="5. 使用PicGo"></a>5. 使用PicGo</h3><p>把图片向状态栏图标拖或者打开详细窗口上传</p><h2 id="中文字数统计问题"><a href="#中文字数统计问题" class="headerlink" title="中文字数统计问题"></a>中文字数统计问题</h2><p>原文： <a href="http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/" target="_blank" rel="noopener">http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/</a></p><h3 id="字数统计方法"><a href="#字数统计方法" class="headerlink" title="字数统计方法"></a>字数统计方法</h3><p>如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:</p><ul><li>根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入<code>charCodeAt()</code>来判断字符属性是中文还是英文字母, 然后区分计算;</li><li>如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;</li><li>如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;</li><li>如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;</li></ul><h4 id="jekyll中的词数统计"><a href="#jekyll中的词数统计" class="headerlink" title="jekyll中的词数统计"></a>jekyll中的词数统计</h4><p><code>number_of_words</code>是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确…</p><h4 id="取巧的统计方式"><a href="#取巧的统计方式" class="headerlink" title="取巧的统计方式"></a>取巧的统计方式</h4><p>jekyll支持的众多filter中, 有这么一个<code>size</code>, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">Approximate number of English words: &#123;&#123; text | split: " " | size &#125;&#125;</span><br><span class="line">Approximate number of Chinese words: &#123;&#123; text | split: "" | size &#125;&#125;</span><br><span class="line">// 可以看到都是近似值~ 如果你对精度要求没那么高, 那么基本是够用了~</span><br><span class="line">// 实际上, 因为本身size支持文本, 所以对中文这里可以不用split: ""的</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>那么回过头, 我们如果要统计content里面的中文字数就可以利用<code>size</code>这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用<code>strip_html</code>以及<code>strip_newlines</code>两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&#123; &#123; content | strip_html | strip_newlines | size &#125; &#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>其实在jekyll的github issue中有人已经问过类似的问题<a href="https://github.com/jekyll/jekyll/issues/1921" target="_blank" rel="noopener">jekyll的中文切分问题</a>.</p><h3 id="阅读速度问题"><a href="#阅读速度问题" class="headerlink" title="阅读速度问题"></a>阅读速度问题</h3><p>既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用<code>divided_by</code>以及<code>round</code>两个函数就可以获得一个大致的分钟数了:<br>(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&#123; content | strip_html | strip_newlines | size | divided_by:350 | round&#125;&#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h2 id="访问统计"><a href="#访问统计" class="headerlink" title="访问统计"></a>访问统计</h2><p>家喻户晓的Google analytics就不必多说了，到Google analytics里注册个账号，新建项目，再新建一个web的property，（因为只是个博客，我们没必要用web&amp;app）把设置修改为https，然后将你的GitHub博客url输入进去。随后在该项目的左下角admin设置中，切换到tracking info的tracking code，那里会有一段带有你id的JavaScript代码。</p><p>将这代码直接复制到你需要监控的html中head的开头即可，随后便可到google analytics中查询网站的访问情况。建议新建一个tracking.html，存储你的google analytics脚本，随后在模板中的head里include这个tracking.html。</p><p>假如你确定了一切无误，但Google analytics的realtime面板中依然毫无信息，无论你在你的Chrome中刷新了多少次——仔细检查一下你是否使用了adblock！据说有些浏览器的do not track也会屏蔽Google analytics的js脚本。检查是否被屏蔽的方法如下：在Chrome中以F12打开开发者面板，在console中检查是否出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;你的tracking id</span><br><span class="line">net::ERR_BLOCKED_BY_CLIENT</span><br></pre></td></tr></table></figure><p>或在network tab下，是否有一个js?id=你的tracking id被blocked</p><p>当然，假如你嫌麻烦，不想做统计数据，只是单纯想在你的网站下方加个访问量，就可以直接使用<a href="https://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>，两行代码解决你的需求。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>为什么GitHub提示我有security alert？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">We found a potential security vulnerability in one of your dependencies.</span><br><span class="line">A dependency defined in .&#x2F;package-lock.json has known security vulnerabilities </span><br><span class="line">and should be updated.</span><br></pre></td></tr></table></figure><p>而且我根本没有package-lock.json文件？</p><ul><li>homebrew安装node，随后在project路径下npm install即可，会生成package-lock.json file，之后GitHub就不会继续提示你security alert了</li></ul>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Blog</title>
      <link href="/2020/02/03/New-Blog/"/>
      <url>/2020/02/03/New-Blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在世界回文字日，2020-02-02的后一天，本博客正式开张了。由于突然重感冒，本来计划的自驾游也随之取消。再加上近日新型肺炎肆虐，我并不想出门被人歧视，于是便在家里随便做点小项目，将以前的小破博客修整修整。当然，新博客出生，不能只说这些上不了台面的话。希望肺炎的阴霾早日消退，世界和平。</p><p>- Feb 3 2020 20:08 @ Malvern 40</p><p>从Massively迁移到了Jekflix，为博文添加了tag。</p><p>- Mar 20 2020 22:57</p><p>从Jekflix迁移到了Hexo，使用了Butterfly主题。</p><p>- Mar 28 2020 22:39</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
