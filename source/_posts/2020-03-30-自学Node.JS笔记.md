---
layout: post
title:  自学Node.JS笔记
date:   2020-03-30 19:56:00
description: 前后端兼备的语言
subtitle: 
comments: true
cover: https://raw.githubusercontent.com/8128/PicGo/master/20200321225737.png
optimized_image: 
category: javascript
tags:
  - tutorial
  - code
  - javascript
  - node
author: tty
hide: true
---

因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。

来源：Udemy Course：The complete node.js developer course (3rd edition)

这门课有个pdf，我看到哪就会记到哪。这门课的内容也都比较基础，不建议有js基础的人看

# Node.js Module System

## Importing Node.js Core Modules

The module system is built around the `require`  function. This function is used to load in a module and get access to its contents.`require`  is a global variable provided to all your Node.js scripts, so you can use it anywhere you like!

Let’s look at an example.

```js
const fs = require('fs')
fs.writeFileSync('notes.txt', 'I live in Philadelphia')
```

The script above uses require to load in the fs module. This is a built-in Node.js module that provides functions you can use to manipulate the file system. The script uses `writeFileSync` to write a message to `notes.txt`.

After you run the script, you’ll notice a new `notes.txt` file in your directory. Open it up and you’ll see, “I live in Philadelphia!”.

## Importing Your Own Files

You know how to use `require` to load in built-in modules. `require` can also be used to load in JavaScript files you’ve created. All you need to do is provide `require` with a relative path to the script you want to load. This path should start with `./` and then link to the file that needs to be loaded in.

```js
const checkUtils = require('./src/utils.js') checkUtils()
```

The code above uses require to load in a file called utils.js in the src directory. It stores the module contents in a variable, and then uses the contents in the script.

### Exporting from Files

Node.js runs the scripts that you require. That means the `require` call above will cause `utils.js` to run. Node.js provides the required script with a place to store values that should be exported as part of the library. This is on `module.exports`.

You can see `util.js` below. A function is defined and then assigned to `module.exports`. The value stored on `module.exports` will be the return value for `require`  when the script is imported. That means other scripts could load in the utilities to access the `check` function.

```js
const check = function () { console.log('Doing some work...')
}
module.exports = check
```

If you run the original script, you’ll see the message that logged from the `check` function in `utils.js`.

```bash
$ node app.js 
Doing some work...
```

 Your Node.js scripts don’t share a global score. This means variables created in one scripts are not accessible in a different script. The only way to share values between scripts is by using `require` with `module.exports`.

## Importing npm Modules

When you install Node.js, you also get npm. npm is a package manager that allows you to install and use third-party npm libraries in your code. This opens up a world of possibilities, as there are npm packages for everything from email sending to file uploading. In this lesson, you’ll learn how to integrate npm into your Node.js app.

### Initializing npm

Your Node.js application needs to initialize npm before npm can be used. You can run `npm init` from the root of your project to get that done. That command will ask you a series of questions about the project and it’ll use the information to generate a package.json file in the root of your project.

Here’s an example.

```json
{
	"name": "notes-app", 
  "version": "1.0.0", 
  "description": "", 
  "main": "app.js", 			
  "scripts": {
			"test": "echo \"Error: no test specified\" && exit 1" 
	},
	"author": "",
	"license": "ISC", 
}
```

You’re now ready to install an npm module. This is done using the `npm` command which was set up when Node.js was installed. You can use `npm install` to install a new module in your project.

```bash
$ npm install validator@10.8.0
```

The command above installs version 10.8.0 of validator. If you want to install the latest version of a module, you can leave off the version number as shown below.

```bash
$ npm install validator
```

This command does three important things:

First, it creates a `node_modules` directory. npm uses this directory to store all the code for the npm modules you have installed.

Second, npm adds the module as a dependency by listing it in the `dependencies` property in `package.json`. This allows you to track and manage the module you have installed.

Third, npm creates a `package-lock.json` file. This includes detailed information about the modules you’ve installed which helps keep things fast and secure.

You should never make changes to `node_modules` or `package-lock.json`. Both are managed by npm and will get changed as you run npm commands from the terminal.

### Importing an npm Module

npm modules can be imported into your script using `require`. To load in an npm module, pass the npm module name to `require`.

```js
const validator = require('validator') 
console.log(validator.isURL('https/mead.io')) // Print: true
```

The script above uses `require` to load in validator. The script then uses the `isURL` function provided by validator to check if a given string contains a valid URL.

## Global npm Modules and nodemon

You can use npm modules from outside of your scripts by installing them globally. Globally installed modules are designed to be used from the terminal and provide you with new commands you can run. In this lesson, you’ll learn how to install and work with global modules.

### Installing an npm Module Globally

npm modules can be installed globally by adding a `-g` flag to the installation command. Not all modules are designed to be installed globally, so be sure to refer to the module documentation to learn how it’s supposed to be used.

The command below installs version 1.18.5 of nodemon as a global module.

```bash
npm install -g nodemon@1.18.5
```

A globally installed module is not added as a dependency to your project. That means you won’t see it listed in `package.json` or `package-lock.json`. You also won’t find its code in `node_modules`. Globally installed modules are located in a special directory in your machine which is created and managed by npm.

When you install nodemon globally, you get access a new `nodemon` command from the terminal. This can be used to start and Node.js application and then restart the application any of the app scripts change. This means you won’t need to switch between the terminal and text editor to restart your application every time you make a change.

The command below runs `app.js` through nodemon.

```bash
nodemon app.js
```

P.S. You can stop nodemon by using ctrl + c from the terminal!

# File System and Command Line Args

## Getting Input from Users

### Accessing Command Line Arguments

Command line arguments are values passed into your application from the terminal. Your Node.js application can access the command line arguments that were provided using `process.argv`. This array contains at least two items. The first is the path to the Node.js executable. The second is the path to the JavaScript file that was executed. Everything after that is a command line argument.

Take a look at the example below.

```js
const command = process.argv[2]
if (command === 'add') { 
  console.log('Adding note!')
} else if (command === 'remove') { 
  console.log('Removing note!')
}
```

That script grabs the third item in `process.argv`. Since the first two are always provided, the third item is the first command line argument that was passed in. The script uses the value of that argument to figure out what it should do. A user could provide add to `add` a note or remove to `remove` a note.

The command below runs the script and provides `add` as the command line argument.

```bash
$ node app.js add 
Adding note!
```

## Argument Parsing with Yargs: Part I

### Setting Up Yargs

```bash
npm install yargs@12.0.2
```

Now, yargs can be used to make it easier to work with command line arguments. The example below shows how this can be done. First, `yargs.version` is used to set up a version for the command line tool. Next, `yargs.command` is used to add support for a new command.

```js
const yargs = require('yargs')

yargs.version('1.1.0')

yargs.command({ 
  command: 'add',
	describe: 'Add a new note', 
  handler: function () {
		console.log('Adding a new note!') 
  }
}) 

console.log(yargs.argv)
```

Now, this command can be triggered by providing its name as a command line argument.

```bash
$ node app.js add 
Adding a new note!
```

Yargs provides a couple useful commands by default. The first, shown below, lets a user get the version of the command line tool they’re running.

```bash
 $ node app.js --version 
 1.1.0
```

The second, shown below, shows the user autogenerated documentation that covers how the tool can be used. This would list out all available commands as well as the available options for each command.

```bash
$ node app.js --help
```

## Argument Parsing with Yargs: Part II

### Adding Command Options

Options are additional pieces of information passed along with the command. You can set up options for a command using the `builder` property as shown below.

Now, the add command can be used with two options. The first is `title` which is used for the title of the note being added. The second is `body` which is used for the body of the note being added. Both options are required because `demandOption` is set to `true`. Both are also set up to accept string input because `type` is set to `string`.

```js
yargs.command({ 
  command: 'add',
	describe: 'Add a new note', 
  builder: {
		title: {
			describe: 'Note title', 
      demandOption: true, 
      type: 'string'
		}, body: {
			describe: 'Note body', 
      demandOption: true, 
      type: 'string'
		} 
  },
	handler: function (argv) { 
    console.log('Title: ' + argv.title) 
    console.log('Body: ' + argv.body)
  } 
})
```

The add command can now be used with `--title` and `--body`

```bash
$ node app.js add --title="Buy" --body="Note body here" 
Title: Buy
Body: Note body here
```

## Storing Data with JSON

### Working with JSON

Since JSON is nothing more than a string, it can be used to store data in a text file or transfer data via an HTTP requests between two machines.

JavaScript provides two methods for working with JSON. The first is `JSON.stringify` and the second is `JSON.parse`.`JSON.stringify` converts a JavaScript object into a JSON string, while`JSON.parse`  converts a JSON string into a JavaScript object.

 ```js
const book = {
	title: 'Ego is the Enemy', 
  author: 'Ryan Holiday'
}

// Covert JavaScript object into JSON string
const bookJSON = JSON.stringify(book)

// Covert JSON string into object
const bookObject = JSON.parse(bookJSON) 
console.log(bookObject.title) // Print: Ego is the Enemy
 ```

JSON looks similar to a JavaScript object, but there are some differences. The most obvious is that all properties are wrapped in double-quotes. Single-quotes can’t be used here, as JSON only supports double-quotes. You can see this in the example JSON below.

```json
{"name":"Gunther","planet":"Earth","age":54}
```

## ES6 Aside: Arrow Functions

### Arrow Functions

Arrow functions offer up an alternative syntax from the standard ES5 function. The snippet below shows an example of a standard function and then an arrow function. While the syntax is obviously different, you still have the two important pieces, an arguments list and a function body.

```js
// const square function (x) {
//     return x * x
// }
const square = (x) => { 
  return x * x
}
console.log(square(2))
// Will print: 4
```

### Shorthand Syntax

Arrow functions have an optional shorthand syntax. This is useful when you have a function that immediately returns a value. The example below shows how this can be used.

```js
const squareAlt = (x) => x * x 
console.log(squareAlt(2)) // Will print: 4
```

Notice that two important things are missing from the function definition. First, the curly braces wrapping the function body have been removed as well as the return statement. In place of both is the value to be returned. There’s no need for an explicit return statement, as the value provide is implicitly returned.

### This Binding

Arrow functions don’t bind their own `this` value. Instead, the `this` value of the scope in which it was defined is accessible. This makes arrow functions bad candidates for methods, as `this` won’t be a reference to the object the method is defined on.

For methods, ES6 provides a new method definition syntax. You can see this in the definition of the `printGuestList` method below. That function is a standard function, just with a shorthand syntax which allows for the removal of the colon and the function keyword.

Because arrow functions don’t bind this, they work well for everything except methods. As shown below, the arrow function passed to `forEach` is able to access `this.name` correctly, as it’s defined as an arrow function and doesn’t have a this binding of its own. That code wouldn’t work if you swapped out the arrow function for a standard function.

```js
const event = {
	name: 'Birthday Party',
	guestList: ['Andrew', 'Jen', 'Mike'], 
  printGuestList() {
		console.log('Guest list for ' + this.name)
		this.guestList.forEach((guest) => { 
      console.log(guest + ' is attending ' + this.name)
		}) 
  }
}
event.printGuestList()
```

# Debugging Node.js

## Debugging Node.js

### Console.log

While it’s nice to have advanced debugging tools at the ready, there’s nothing wrong with using `console.log` to debug your application. It’s not the fanciest technique, but it works, and I use it daily.

When in doubt, use a few calls to `console.log` to figure out what’s going on. It’s great for dumping a variable to the terminal so you can check its value. It also works for figuring out what order your code is running in.

### Node Debugger

Printing values to the console with `console.log` is a good start, but there are often times where we need a more complete debugging solution. For that, Node.js ships with a built-in debugger. It builds off of the developer tools that Chrome and V8 use when debugging JavaScript code in the browser.

Start your application with `inspect` to use the debugger.

```bash
node inspect app.js
```

Next, visit chrome://inspect in the Chrome browser. There, you’ll see a list of all the Node.js processes that you’re able to debug. Click “inspect” next to your Node.js process to open up the developer tools. From there, you can click the blue “play” button near the top-right of the “sources” tab to start up the application.

When running the app in debug mode, you can add breakpoints into your application to stop it at a specific point in the code. This gives you a chance to explore to the application state and figure out what’s going wrong.

```js
console.log('Thing one)
            
debugger // Debug tools will pause here until your click play again 
            
console.log('Thing two)
```

# Asynchronous Node.js

## Asynchronous Basics

### Async 101

When running asynchronous code, your code won’t always execute in the order you might expect. To get started with asynchronous development, let’s use `setTimeout`.

`setTimeout` is a function that allows you to run some code after a specific amount of time has passed. `setTimeout` accepts two arguments. The first is a callback function. This function will run after the specified amount of time has passed. The second argument is the amount of time in milliseconds to wait.

Here’s an example.

```js
console.log('Starting')

// Wait 2 seconds before running the function
setTimeout(() => {
	console.log('2 Second Timer')
}, 2000) 

console.log('Stopping')
```

Run the script and you’ll see the logs in the following order.

```bash
$ node app.js 
Starting 
Stopping
2 Second Timer
```

Notice that “Stopping” prints before “2 Second Timer”. That’s because setTimeout is asynchronous and non-blocking. The setTimeout call doesn’t block Node.js from running other code while it’s waiting for the 2 seconds to pass.

This asynchronous and non-blocking nature makes Node.js ideal for backend development. Your server can wait for data from a database while also processing an incoming HTTP request.