---
layout: post
title:  自学Node.JS笔记
date:   2020-03-30 19:56:00
description: 前后端兼备的语言
subtitle: 
comments: true
cover: https://raw.githubusercontent.com/8128/PicGo/master/20200321225737.png
optimized_image: 
category: javascript
tags:
  - tutorial
  - code
  - javascript
  - node
author: tty
hide: false
---

因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。

来源：Udemy Course：The complete node.js developer course (3rd edition)

这门课有个pdf，我看到哪就会记到哪。这门课的内容也都比较基础，不建议有js基础的人看。pdf下载[传送门](https://github.com/8128/LC-solution/raw/master/test/src/com/node.pdf)

# 关于npm

就是个package管理系统，类似于java中maven的东西，使用`npm init`会初始化一个项目，自动新建一个`package.json`文件和一个`package-lock.json`文件。注意，你永远不应该编辑后者，因为那是根据前者自动生成的文件。使用`npm install`的包都会被记录到`package.json`里。假如你用`npm install -g`安装则会装到你系统环境里，不会显示到`package.json` file

在安装了本地依赖后，依赖会出现在`node_modules`文件夹下。但凡是npm安装的module，你都可以直接用`require('module name')`的方式来导入。比如`validator.js`作为依赖导入后，他的module名为`validator`，因此只需要`requre('validator.js')`即可

## 很有用的nodemon

```shell
npm install nodemon -g
```

能自动读取你对文件的改变并在console输出。

# 基础输入输出

`process.argv`可以获取到用户的所有输入。例如`node app.js Andrew`，利用它可以获取到长度为3的array，第一个为你的node路径，第二个为app.js路径，第三个为Andrew。

## 利用Yargs

```shell
npm install yargs
```

建议直接用`yargs --help`

### Simple Example

```js
#!/usr/bin/env node
const argv = require('yargs').argv
 
if (argv.ships > 3 && argv.distance < 53.5) {
  console.log('Plunder more riffiwobbles!')
} else {
  console.log('Retreat from the xupptumblers!')
}
```

```shell
$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!
 
$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
```

### Complex Example

```js
#!/usr/bin/env node
require('yargs') // eslint-disable-line
  .command('serve [port]', 'start the server', (yargs) => {
    yargs
      .positional('port', {
        describe: 'port to bind on',
        default: 5000
      })
  }, (argv) => {
    if (argv.verbose) console.info(`start server on :${argv.port}`)
    serve(argv.port)
  })
  .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Run with verbose logging'
  })
  .argv
```

Run the example above with `--help` to see the help for the application.

# 代码风格

变量遵循驼峰命名

$ dollar sign开头的函数一般表示getter setter

_ lowdash 开头一般表示对数据库的操作

# 异步

## 回调函数

来源：https://www.runoob.com/nodejs/nodejs-callback.html

Node.js 异步编程的直接体现就是回调。

异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。

回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。

例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。

回调函数一般作为函数的最后一个参数出现：

```js
function foo1(name, age, callback) { }
function foo2(value, callback1, callback2) { }
```

### 阻塞代码实例

创建一个文件 input.txt ，内容如下：

```
菜鸟教程官网地址：www.runoob.com
```

创建 main.js 文件, 代码如下：

```js
var fs = require("fs");

var data = fs.readFileSync('input.txt');

console.log(data.toString());
console.log("程序执行结束!");
```

以上代码执行结果如下：

```shell
$ node main.js
菜鸟教程官网地址：www.runoob.com

程序执行结束!
```

### 非阻塞代码实例

创建一个文件 input.txt ，内容如下：

```
菜鸟教程官网地址：www.runoob.com
```

创建 main.js 文件, 代码如下：

```js
var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log("程序执行结束!");
```

以上代码执行结果如下：

```shell
$ node main.js
程序执行结束!
菜鸟教程官网地址：www.runoob.com
```

以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。

因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。

## async

传送门：[async doc](https://caolan.github.io/async/v3/)

这是一个nodejs库

#### waterfall(tasks, callback*opt*)

有两个输入，第一个输入是所有waterfall中经过的函数，第二个输入是callback函数。你可以把第一个输入中的函数写在waterfall外部

Runs the `tasks` array of functions in series, each passing their results to the next in the array. However, if any of the `tasks` pass an error to their own callback, the next function is not executed, and the main `callback` is immediately called with the error.

##### Parameters:

| Name       | Type                | Description                                                  |
| :--------- | :------------------ | :----------------------------------------------------------- |
| `tasks`    | Array               | An array of [async functions](https://caolan.github.io/async/v3/global.html) to run. Each function should complete with any number of `result` values. The `result` values will be passed as arguments, in order, to the next task. |
| `callback` | function <optional> | An optional callback to run once all the functions have completed. This will be passed the results of the last task's callback. Invoked with (err, [results]). |

##### Returns:

undefined

##### Example

```js
async.waterfall([
    function(callback) {
        callback(null, 'one', 'two');
    },
    function(arg1, arg2, callback) {
        // arg1 now equals 'one' and arg2 now equals 'two'
        callback(null, 'three');
    },
    function(arg1, callback) {
        // arg1 now equals 'three'
        callback(null, 'done');
    }
], function (err, result) {
    // result now equals 'done'
});

// Or, with named functions:
async.waterfall([
    myFirstFunction,
    mySecondFunction,
    myLastFunction,
], function (err, result) {
    // result now equals 'done'
});
function myFirstFunction(callback) {
    callback(null, 'one', 'two');
}
function mySecondFunction(arg1, arg2, callback) {
    // arg1 now equals 'one' and arg2 now equals 'two'
    callback(null, 'three');
}
function myLastFunction(arg1, callback) {
    // arg1 now equals 'three'
    callback(null, 'done');
}
```