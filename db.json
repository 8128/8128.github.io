{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/comment_bg.png","path":"img/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/post_loadding.svg","path":"img/post_loadding.svg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/ind.jpg","path":"img/ind.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/post.jpg","path":"img/post.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/arch.jpg","path":"img/arch.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8c6400d7b921030a79e769d87bca7c0aaa9783ea","modified":1585465160712},{"_id":"themes/Butterfly/.DS_Store","hash":"e2fee49ec58173d34d20dc9ea8cbe956f6b085d6","modified":1585471763432},{"_id":"themes/Butterfly/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1585440304366},{"_id":"themes/Butterfly/README.md","hash":"820ea54f95d0bd44e335c7f644959ce87a425750","modified":1585440304366},{"_id":"themes/Butterfly/README_CN.md","hash":"06ef4ef4bffd1ac8f60e59c28f885c63a9481e0f","modified":1585440304366},{"_id":"themes/Butterfly/_config.yml","hash":"1e1f9f2a1d82489b7db98058c3fbf9cb4eb20f4f","modified":1585455845342},{"_id":"themes/Butterfly/package.json","hash":"95c1780b8d0bad746201bda689591ee1fed50d13","modified":1585440304374},{"_id":"source/_data/butterfly.yml","hash":"81e62d141b13e7de60562af10eb8f501fc436af1","modified":1585465311455},{"_id":"source/_data/link.yml","hash":"f30dc9258f9cef459fe02a733c0f71652a671533","modified":1585465160712},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1585468459246},{"_id":"source/_posts/2020-02-03-New-Blog.md","hash":"8cfed3821d4adb382dd264ac9da355fe7be2e02c","modified":1585465160713},{"_id":"source/_posts/2020-02-03-Bloomberg面试见闻.md","hash":"3a5463bd47f71116c2dfe7e89327136247f45341","modified":1585465160713},{"_id":"source/_posts/2020-02-03-搭建Jekyll博客技巧集.md","hash":"87c1cc01a30e5529400388790fb835a5396747b3","modified":1585465160713},{"_id":"source/_posts/2020-02-03-旧金山准独角兽面试之行.md","hash":"e93fa3c7be18b0e87994ee986c67aec2f869b571","modified":1585465160713},{"_id":"source/_posts/2020-02-20-初创企业股票基础知识.md","hash":"5a158a83d2a9a622b21f680275b8a1a412c24212","modified":1585465160713},{"_id":"source/_posts/2020-02-26-SOLO美国租房骗子.md","hash":"1a47375e56330e7ab143dd0e0bd6f347d10b5d53","modified":1585465160713},{"_id":"source/_posts/2020-02-21-OBS实现多音轨录制.md","hash":"eb2c22788cbdb8e18e29c31e062e427f6fa3c054","modified":1585465160713},{"_id":"source/_posts/2020-03-17-New-Hire-Benefit-全解.md","hash":"c2c6ddd28ab741a6940c706a4f486453933e3d94","modified":1585465160714},{"_id":"source/_posts/2020-03-17-为低分辨率屏幕开启HiDPI.md","hash":"d98341f8dba461c8a3db80ed0cdcaab2d8b11a1c","modified":1585465160714},{"_id":"source/_posts/2020-03-18-Make教程.md","hash":"ffdcdcf9f4885f2293c80a24e48d2dace6a9c03e","modified":1585465160714},{"_id":"source/_posts/2020-03-18-正则表达式教程.md","hash":"cf44820dbcf62eb2915c28e55a9ea6f9362d656c","modified":1585465160714},{"_id":"source/_posts/2020-03-19-Virtualenv教程.md","hash":"fbc5716c015cb46acd2f52d7092c50811881bf9b","modified":1585465160715},{"_id":"source/_posts/2020-03-19-Bash-Shell编程入门.md","hash":"724ab6bbcc0d06707b162adf53772f0d40af7324","modified":1585465160715},{"_id":"source/_posts/2020-03-20-Markdown教程.md","hash":"6c6fc412aa5bb1c54c28f135cbf03ebb77a16ac0","modified":1585465160716},{"_id":"source/_posts/2020-03-21-南疆游记.md","hash":"ff7ed45d77b08840b0101c8cc99652f844bb2943","modified":1585465160716},{"_id":"source/_posts/2020-03-21-自学Node.JS笔记.md","hash":"659f08b1e5a7c566e07148381d938ac3cc46cf1f","modified":1585465160716},{"_id":"source/_posts/2020-03-22-Git基础简明教程.md","hash":"e4ef3ba8142c89b3a17e8ac340eadb215f103d8b","modified":1585465160716},{"_id":"source/_posts/2020-03-22-程序员标配？Herman-Miller-Sayl.md","hash":"cd33b6037112cb477defc7085c4d8415ec838e02","modified":1585465160717},{"_id":"source/_posts/2020-03-23-MongoDB快速入门.md","hash":"1e96b092f449ff0c238c31390b096d198ff2d4b5","modified":1585465160717},{"_id":"source/_posts/2020-03-25-ES6特性笔记.md","hash":"e397421e5636c4abc865583ce2b01fe3ffa38604","modified":1585465160717},{"_id":"source/_posts/2020-03-25-Lodash笔记.md","hash":"ab477a9e1e14776347d9318f08ebbda268e9f100","modified":1585465160717},{"_id":"source/_posts/2020-03-26-JS测试教程.md","hash":"cabfb7d996b3e71c1e4c59cdd890faa257876b33","modified":1585465160718},{"_id":"source/_posts/2020-03-29-罗技MX Master 3简评.md","hash":"5da8f5f97a5d8f8ef5e724750383dc4f76ad1916","modified":1585471359618},{"_id":"source/categories/index.md","hash":"44bcba731a5152656a5089c06b9eb2edcb3a19a3","modified":1585465160718},{"_id":"source/link/index.md","hash":"57c286a2d26aac0fe966f0f1122d25818c17e088","modified":1585465160718},{"_id":"source/tags/index.md","hash":"4486582d827e991f800571f125daddf6aea4a44b","modified":1585465160718},{"_id":"themes/Butterfly/languages/default.yml","hash":"405d4413c47e87f00b3238b4ae8bb39b42ca22bb","modified":1585440304366},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"508065bba5376f5b24f783b75b599ffbc509a8d6","modified":1585440304366},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"50b84f0379d433b6247a56de94d6b3f9b7eae11b","modified":1585440304366},{"_id":"themes/Butterfly/languages/en.yml","hash":"405d4413c47e87f00b3238b4ae8bb39b42ca22bb","modified":1585440304366},{"_id":"themes/Butterfly/layout/404.pug","hash":"ca0740ff0bf095756dcecb4aaf2ac7ec222cd2df","modified":1585440304367},{"_id":"themes/Butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1585440304367},{"_id":"themes/Butterfly/layout/category.pug","hash":"6bf52ce6605972ae627dd169dcbc70a03184aa60","modified":1585440304367},{"_id":"themes/Butterfly/layout/flink.pug","hash":"2130228c1d0cff16deac551a98ef395830e5f36c","modified":1585440304367},{"_id":"themes/Butterfly/layout/index.pug","hash":"dd4b6760f799e990271f866d8d765e21df0d6838","modified":1585440304374},{"_id":"themes/Butterfly/layout/page-tags.pug","hash":"110c07cd0cc829ebbb51a373dd0a3f6ff7d757c8","modified":1585440304374},{"_id":"themes/Butterfly/layout/page.pug","hash":"c964aee467fa721618a7296904930c76fbe500a7","modified":1585440304374},{"_id":"themes/Butterfly/layout/post.pug","hash":"96e08b68df172fb1619f09358f1da8c50b584176","modified":1585440304374},{"_id":"themes/Butterfly/layout/tag.pug","hash":"5fda92181fbb8db726a3d3e97048b0672d4b7b8c","modified":1585440304374},{"_id":"themes/Butterfly/source/.DS_Store","hash":"604a64797fe8924d8e05217197c93fe9b2139a59","modified":1585463684055},{"_id":"themes/Butterfly/source/CNAME","hash":"61a8776e4ae3730eaa1af745fc4427fdcc002d82","modified":1585471695104},{"_id":"source/_posts/2020-03-22-入门JavaScript笔记.md","hash":"76206252bcaee6bc02caa0498f477bc1de681ea8","modified":1585465160716},{"_id":"source/_posts/2020-03-25-JS异步讲解-Asynchronous JavaScript.md","hash":"330453e674c71d4ae96600d02a42df7146cc8454","modified":1585465160717},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"d4969489466f02e3281cd442be8346136a0e45e9","modified":1585440304367},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"855c5d7e427730178c2f6e4f3e816d7fbee40198","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"b6a53054ddd8adb5bc39c36af140aadd1f4fb517","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"8f34a8ab1bf80da1570771ca23cbac2c514e9e0a","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"a6587bcbdd1477bfba8c6c6c6a327224ed5a3951","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/recent-posts.pug","hash":"6a0ef6a4a2096a053ca3bfeb4636c64d0f633aef","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"9ba725c0f9661a156f82dee35a422fdd4639a5ce","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"b41c97424c588209c0d24817f5120b50933135fd","modified":1585440304372},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"551bd94e99cc567b3e287e30720c34eb3f5b205d","modified":1585440304374},{"_id":"themes/Butterfly/scripts/events/replace-config.js","hash":"4acb5a4519e1b5a29c23c83d1f70c1e298931e30","modified":1585440304374},{"_id":"themes/Butterfly/scripts/filters/hide-post.js","hash":"15046d3b80cd0d981dbd4caccd53972f184e98e3","modified":1585440304375},{"_id":"themes/Butterfly/scripts/filters/post-lazyload.js","hash":"05d0768fde7151bb6317ee844a62caa95a7af30c","modified":1585440304375},{"_id":"themes/Butterfly/scripts/filters/random-cover.js","hash":"d9a7e393abee3e835b46f441c731c4f92ec6f673","modified":1585440304375},{"_id":"themes/Butterfly/scripts/helpers/list-archives.js","hash":"27ffc169be6711ec08f47d625e679c06d1478391","modified":1585440304375},{"_id":"themes/Butterfly/scripts/helpers/related-post.js","hash":"5b18f227462b500a22e21c8d9c10e5097e928de8","modified":1585440304375},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"23bc9b8d90c569a160c6299704cc59f5e26579ad","modified":1585440304375},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"ed32b4c668b53e0eb4f2076def51eea16b3ea4fd","modified":1585440304375},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"ea088b5bd601a3ac3dc8ca99cef09988546b8c46","modified":1585440304375},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"03d608278de2dc9c6b2af69e8d36c77c0272e2bf","modified":1585440304375},{"_id":"themes/Butterfly/source/css/index.styl","hash":"f5fae01f87c5e99a840456ba67f90e80cad4fb75","modified":1585440304379},{"_id":"themes/Butterfly/source/css/var.styl","hash":"1e1546545bc8c685fb2cf1da4edae089b203959e","modified":1585440304379},{"_id":"themes/Butterfly/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1585457890683},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1585440304379},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1585440304379},{"_id":"themes/Butterfly/source/img/comment_bg.png","hash":"1adfc4ee925fb4f922c24d7774e7c46d940fe31b","modified":1585440304380},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1585440304381},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1585440304383},{"_id":"themes/Butterfly/source/img/post_loadding.svg","hash":"549c58cd09dbeefd573ce10646c49ded8bcc48ec","modified":1585440304383},{"_id":"themes/Butterfly/source/js/main.js","hash":"1dd462d995e0d85ad9e1d60002a3d5ac02c88373","modified":1585440304383},{"_id":"themes/Butterfly/source/js/utils.js","hash":"e3423175d06a8fddc937d77990a172180476dbec","modified":1585440304386},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1585440304386},{"_id":"themes/Butterfly/source/img/alipay.jpg","hash":"3ffbb8bbde254531660674996f67a2f6d0dcf9c3","modified":1585448995887},{"_id":"themes/Butterfly/source/img/favicon.ico","hash":"98ea70c6639e4a59aace487c835079bb26784dea","modified":1585257943441},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1585440304381},{"_id":"themes/Butterfly/source/img/wechat.jpg","hash":"228fb2cadf0a4514ad3dd7acd872c551b0cb137e","modified":1585448986206},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"821d968122bab8ce1ce04dc553b731eaf8e0d181","modified":1585440304367},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"050085054a68942e8833c6a4033fb437b6b01e52","modified":1585440304367},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"91d361f12923a5750605ab6449cba33600c7868b","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"e98f5c199a76ad939a29a46c0dcbf7e85ec60ed2","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"00022f763085b6852bc172b0ba91b0eacb403389","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"9427cb07bcfe2bc7198755eeebf60f9fe430a342","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"e58e3d3e004ae1de4235993da901cf59b9bdcc53","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"90c872160a9d6e71d02a26517b35abac9ba56df1","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"8ec0609f14c284c3e6120940d7c4d7f1f201cd67","modified":1585440304368},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"7d59c68eafede1974380a139cad47ebf0bc64b24","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"b2aa39591062f68d92b24c11b74091f3798e18f3","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"2c7a5a097a2f815ba43a4e99c810405da3b9eebc","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"dcc8c01e1b0f8a4960ed873f49fb0f18d9912d21","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"54f091a1736e6186707a5ead25bf98fcd55e9661","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"ff4ceda534cdd711cfa2cb9e95e36258988674e1","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"47a10164395d8200c8d962df68a01e7deee4053b","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"be1ff710e4381fc684243313dcadf0140d7469de","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"f5c8ec73c797ff3455e732fa7c92c856692f3ce5","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"4816345ccad0cd9994291b93eea61ecfca8c5d00","modified":1585440304369},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"92527e432748c978aca4127db93421d263b7a4b8","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"61a5a52aff9b501b802a6b8c83a789086710831b","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"387ee38180784500439dac819a8e76763d0d57c5","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"25036c657069fbb2fb17e9b973571ca5168aa2bf","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d684f897fcdfe1e98300851b7fd955a30b68dd9","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"ec97f284626b67208370b5084e5c5822844fa30a","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"6ccfaa776fc913ccf8b34825d918ab2b4d457434","modified":1585440304370},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"db848ff451d4c58670af415882ca6bb2e0da971b","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/mixins/UI.pug","hash":"c5bb1e3cb5e0154f1c2b91eac484c60783a6e4eb","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"3d86443ad9bc1975a950ad9ca8c38fa35169404d","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"006c7156dff7a07b738d982433c0f52142826bb5","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"8efc0b7886bdb5959e173b5e11f5ffb8d1c5230e","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"f0594d919091ad1f9b88389cba3cee5eabca23f7","modified":1585440304371},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"a45b5453e35479e58cd44b6bd2af0e08789890af","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"bbf5b70460b17c4fecb9ee6880aa71cdb2d807a8","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"c341aaa00113681b22f945f5004e6b22c8a0ca69","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"07c62fda87785fb9294f9027a71d80197cd9d849","modified":1585440304372},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"b4acf48c98ba2a6a5a5fb5387a0fd610bdfd55ef","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"3f7de99f4307ac9bfd89e669aaa7c2ae54d5224a","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"53d784e8d1d1da34c7407d440bf71dd306c413a8","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"4abbd02c7dcb2c0a42062d6c18d87faa60988914","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"974d311f355bbdf8c816703447aaee1c8bc13084","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"7d4201dfe3a096c2470c2f1f4ded7b02e3250a40","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"a3efcad9b4cbd609cf57021d1759d0ef5e479187","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"284f10318cd7e048fcf6fad70c38c562520244b8","modified":1585440304373},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"6caff3cb958ccb0da7d88b51d87e22d27fcd9625","modified":1585440304374},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"97286029b3c5fde6b284e7b560ecc5f5a199ff71","modified":1585440304374},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"f512f4fe7a78862551f72fca4867a941b9e4d434","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"647d9451374df4786684397f82334d541929d66a","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"964d16c30f307ec354b47375aa5f00f0417c7bf0","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"efceb8105830544cef5e4afad3243326b3118fc1","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"e1efce89dcce9930bdd164d7d39135ea497ee7b0","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"7267043e52a9e620adfa860bdb3e4de400ff2596","modified":1585440304376},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"0631c50cdccd29ca41fbac3423b2fd91a9be49b8","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"d8709e29efcfa0a7356384026dfbaac8861d3baa","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/gallery.styl","hash":"750bfc09261fe3e06f17f934eee9fee96ee2b4c2","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"b4bb249bc38f75fc55dde3e2017b4890004a20bd","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"f2d5dbb8e0b0ec786f00a09f0f51a82a0fa41ae1","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/note.styl","hash":"1ec06d5ac4148798babd2475a5d10f0d3a1b5870","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"8df965312dc8eae05a3e34a72aa924a39629aed7","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"d6f0b7d9dc10761c15a5a2b84cc63e914a10d339","modified":1585440304377},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"814c8c712f2041f905ba4fcc75bb837d70aa1880","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1103f2cead8ab1aa9945c20c7d608bb4b829d2cd","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"92b615795f02eff2a018edb425f923968c9e9814","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"9a44881bd4c2aea0b0774809d91d58e4067496ed","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"33da3da65715ce1a85b8ecab92e0eab6ce620a58","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"c9a517fe216ef4d54f0ce5697d5cd460ddab4687","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"aebf5f315995d2e5eff763298bd3412a6fc95d2a","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"26342e889e8488f8a25249e0bb6da3362e8ff0f6","modified":1585440304378},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"280f621301da0bea641276e212f50e67f060b6d4","modified":1585440304379},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"d4c414d689bebe706021f7e904ec874c26a6cff6","modified":1585440304379},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"7e66ab006450b73f5a300d8c6a91a6c895975ffd","modified":1585440304379},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1585440304379},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"999966787de1906185344176b0c553fd4fda0b39","modified":1585454795041},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"bf9ebb4ac93ccdd93e9eb37f69d17d5327e01040","modified":1585440304384},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1585440304384},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1585440304384},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1585440304384},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1585440304384},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1585440304385},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"05fc79ebcf673e2d257583554eef62d162ade5e8","modified":1585440304385},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1585440304385},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1585440304385},{"_id":"themes/Butterfly/source/img/ind.jpg","hash":"94d135bd12fd9762264577e133fe504060f722ce","modified":1585459832536},{"_id":"themes/Butterfly/source/img/post.jpg","hash":"97e798e9d76d65382e10cc975db8b7a2303eef71","modified":1585455246820},{"_id":"themes/Butterfly/source/img/arch.jpg","hash":"26f4bc9d26c94361c21e13f30d3eee731aee6f6e","modified":1585455112948},{"_id":"public/search.xml","hash":"51c530fb1e3b45d269e67761d8177e3d6e1856ae","modified":1585472194127},{"_id":"public/categories/index.html","hash":"e404fb900a1317239a4007857e2eff8233a0ee81","modified":1585472194127},{"_id":"public/link/index.html","hash":"b4c27c86bf9c220a938f86a75b2e84eda23b80fa","modified":1585472194127},{"_id":"public/tags/index.html","hash":"7262c7ad86fcff23c9972b3224def8ba79ac10fa","modified":1585472194127},{"_id":"public/2020/03/29/罗技MX Master 3简评/index.html","hash":"e43b95a1b688fb94b4f147a385559533037f0b3c","modified":1585472194127},{"_id":"public/2020/03/26/JS测试教程/index.html","hash":"f6944306b16b9274b03e881597c7025ce059815c","modified":1585472194127},{"_id":"public/2020/03/25/ES6特性笔记/index.html","hash":"5e559e7277fdd6493a87ac0d27475e0ba235fb87","modified":1585472194127},{"_id":"public/2020/03/25/JS异步讲解-Asynchronous JavaScript/index.html","hash":"97dd062cafb0860e9db944d4319ffc8af92b881b","modified":1585472194127},{"_id":"public/2020/03/25/Lodash笔记/index.html","hash":"a402eb33c6a90e534421550ea2d4d8db6787057b","modified":1585472194127},{"_id":"public/2020/03/23/MongoDB快速入门/index.html","hash":"1306e788ef0e756f9fd64a064bd6b2cec52966ed","modified":1585472194127},{"_id":"public/2020/03/22/Git基础简明教程/index.html","hash":"3e918da7473511e3aeac7833b46c76888436e4c2","modified":1585472194127},{"_id":"public/2020/03/22/入门JavaScript笔记/index.html","hash":"cd64cf85cbe227ac47afe83977113ed8358b8cf3","modified":1585472194127},{"_id":"public/2020/03/22/程序员标配？Herman-Miller-Sayl/index.html","hash":"ea2a98794aa7b2da59a9ec79e3f10322b99a5de7","modified":1585472194127},{"_id":"public/2020/03/21/南疆游记/index.html","hash":"a7ea4a88ae421a9800048b3c93a6e3e20823d248","modified":1585472194127},{"_id":"public/2020/03/20/Markdown教程/index.html","hash":"30079476152619782876f0692fe8cf97590240ef","modified":1585472194127},{"_id":"public/2020/03/19/Virtualenv教程/index.html","hash":"7ba7fb7c4a1d65d116339a4f7a77e5f3612bac82","modified":1585472194127},{"_id":"public/2020/03/19/Bash-Shell编程入门/index.html","hash":"1462882e5233094f043a4b8acfd79d60560dfbd4","modified":1585472194127},{"_id":"public/2020/03/18/Make教程/index.html","hash":"b9084a278c305a33d641d5a2f1901731208a13e5","modified":1585472194127},{"_id":"public/2020/03/18/正则表达式教程/index.html","hash":"1387beb72d97bc93396f895f5d7476d51c7d773f","modified":1585472194127},{"_id":"public/2020/03/17/为低分辨率屏幕开启HiDPI/index.html","hash":"e66b3a398317e91f4290351ac5fe91a26bcceab6","modified":1585472194127},{"_id":"public/2020/03/17/New-Hire-Benefit-全解/index.html","hash":"afbf9c4c00d7ce6da18c043532648ac905af9686","modified":1585472194127},{"_id":"public/2020/02/26/SOLO美国租房骗子/index.html","hash":"01035e0806a182d81b71f697b732a3856e00a611","modified":1585472194127},{"_id":"public/2020/02/20/初创企业股票基础知识/index.html","hash":"8750a2ad3057295cea7479677c3668f9646dea7f","modified":1585472194127},{"_id":"public/2020/02/21/OBS实现多音轨录制/index.html","hash":"1cd84a51d05475ccb992c144595c744ea06bbace","modified":1585472194127},{"_id":"public/2020/02/04/旧金山准独角兽面试之行/index.html","hash":"d553ffdd3c3d0e635a86088224759fbc5a690478","modified":1585472194127},{"_id":"public/2020/02/03/Bloomberg面试见闻/index.html","hash":"22bf02c461fa1c9bae213ac84052821cf711e836","modified":1585472194127},{"_id":"public/2020/02/03/搭建Jekyll博客技巧集/index.html","hash":"909cd9edd21b28ac6a989ff457126d807349b9d2","modified":1585472194127},{"_id":"public/2020/02/03/New-Blog/index.html","hash":"268d8c295f6b82f6daa68338f1d807339c135b12","modified":1585472194127},{"_id":"public/2020/03/21/自学Node.JS笔记/index.html","hash":"f51c1ab00d81a4afeb85ffd859da56056363c5b6","modified":1585472194127},{"_id":"public/archives/index.html","hash":"a949655e767a4c8501378e4e963806fa000663cd","modified":1585472194127},{"_id":"public/archives/page/2/index.html","hash":"c02af6b26b69e51bbca0866f80079b71ec5ab34e","modified":1585472194127},{"_id":"public/archives/page/3/index.html","hash":"45e7931f2ebc5ccc4e645d7ad04d4950466f7cf0","modified":1585472194127},{"_id":"public/archives/2020/index.html","hash":"46502b0c58d930bb5c74fafbfdf77b15896b35e4","modified":1585472194127},{"_id":"public/archives/2020/page/2/index.html","hash":"d1742f9da699cc299a970e4f72e5f92dfe984383","modified":1585472194127},{"_id":"public/archives/2020/page/3/index.html","hash":"ecf6fedef79e76b21e0b92a0d506fbb83f1c06b1","modified":1585472194127},{"_id":"public/archives/2020/03/index.html","hash":"aede2e58a6a5eafb2beacd25bc9135e9cfa27062","modified":1585472194127},{"_id":"public/archives/2020/03/page/2/index.html","hash":"fa34650196de6ad00b3b6345d12dbb0791c13dea","modified":1585472194127},{"_id":"public/archives/2020/02/index.html","hash":"4c1fb12ea6170130bfe7f64d860539e96b3f6591","modified":1585472194127},{"_id":"public/index.html","hash":"2c943b3006b0972311d1b3ca1ebc6b83002c7a73","modified":1585472194127},{"_id":"public/page/2/index.html","hash":"f70fc02f98dfb5a8193c7a847e3a4313bb0ddb3b","modified":1585472194127},{"_id":"public/page/3/index.html","hash":"6ef8c5132ce160de40c1cabe0b9178d73daeae69","modified":1585472194127},{"_id":"public/categories/tutorial/index.html","hash":"1c95665de3a0c3d4ad054cbbdb7207eb4f694a04","modified":1585472194127},{"_id":"public/categories/tutorial/page/2/index.html","hash":"ad36587fd55d25232e886ccb5a027da9a1401234","modified":1585472194127},{"_id":"public/categories/travel/index.html","hash":"4e5808e6702c48bd9c60bfadd6b05eccef6ba1d8","modified":1585472194127},{"_id":"public/categories/financial/index.html","hash":"4d339e265072337861d5987598df3de88e63d3f3","modified":1585472194127},{"_id":"public/categories/blog/index.html","hash":"13c0348800ce9096b202960265385a0d4e277a95","modified":1585472194127},{"_id":"public/categories/life/index.html","hash":"e22979dfb68c3439995506d0c29c5fc1558a54dd","modified":1585472194127},{"_id":"public/categories/review/index.html","hash":"da41ab2dc50ea92ec2733793d133e9a2b3d3e7c2","modified":1585472194127},{"_id":"public/categories/database/index.html","hash":"9ce13bdbda9e473ded14ec351c1b74be1a782eb1","modified":1585472194127},{"_id":"public/categories/javascript/index.html","hash":"1ccd5c11ca2330ac03a0e75fb12b89f977b9c2cd","modified":1585472194127},{"_id":"public/tags/tutorial/index.html","hash":"f5c7f05f7a3bdbea19c973676599149f5b450eed","modified":1585472194127},{"_id":"public/tags/tutorial/page/2/index.html","hash":"a92ca67bf6e7bd9a781f8fb3f0bb60ea6ead43b2","modified":1585472194127},{"_id":"public/tags/code/index.html","hash":"3323738be6faa35f73f716bbcd284a1d6d0d9de8","modified":1585472194127},{"_id":"public/tags/code/page/2/index.html","hash":"a75c72876dc590447f941d903d0140f76d555ff1","modified":1585472194127},{"_id":"public/tags/javascript/index.html","hash":"affdb5b31b4bd6309c3b89ea8783e594555c4bc1","modified":1585472194127},{"_id":"public/tags/travel/index.html","hash":"44731e6c41feb691c03fb3abe14ee7a0f86a7a59","modified":1585472194127},{"_id":"public/tags/blog/index.html","hash":"c45c52770800ccd4c622d8c732af8ba848d6ea15","modified":1585472194127},{"_id":"public/tags/tips/index.html","hash":"1faf22ba4f7db0d429a9431525dd4eee25ad6293","modified":1585472194127},{"_id":"public/tags/financial/index.html","hash":"da612ca94904a0880eed14cf7c6b25721b43ec79","modified":1585472194127},{"_id":"public/tags/life/index.html","hash":"98219c6c9e75a90f5ac9d989c419400cd3cd1ae5","modified":1585472194127},{"_id":"public/tags/review/index.html","hash":"a3166dda4579619d988c81db22cae7ffdf8cba98","modified":1585472194127},{"_id":"public/tags/database/index.html","hash":"d6510127f3bea61da611dff57c60950312b9a159","modified":1585472194127},{"_id":"public/tags/tech/index.html","hash":"df3232d14a01e04dc31ff0a5c28c04633981a129","modified":1585472194127},{"_id":"public/tags/mouse/index.html","hash":"a2ebea2105f7092001571535f8fc24e827f293ac","modified":1585472194127},{"_id":"public/CNAME","hash":"61a8776e4ae3730eaa1af745fc4427fdcc002d82","modified":1585472194127},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1585472194127},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1585472194127},{"_id":"public/img/comment_bg.png","hash":"1adfc4ee925fb4f922c24d7774e7c46d940fe31b","modified":1585472194127},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1585472194127},{"_id":"public/img/post_loadding.svg","hash":"549c58cd09dbeefd573ce10646c49ded8bcc48ec","modified":1585472194127},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1585472194127},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1585472194127},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1585472194127},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1585472194127},{"_id":"public/img/alipay.jpg","hash":"3ffbb8bbde254531660674996f67a2f6d0dcf9c3","modified":1585472194127},{"_id":"public/img/favicon.ico","hash":"98ea70c6639e4a59aace487c835079bb26784dea","modified":1585472194127},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1585472194127},{"_id":"public/img/wechat.jpg","hash":"228fb2cadf0a4514ad3dd7acd872c551b0cb137e","modified":1585472194127},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1585472194127},{"_id":"public/js/utils.js","hash":"e3423175d06a8fddc937d77990a172180476dbec","modified":1585472194127},{"_id":"public/js/search/local-search.js","hash":"bf9ebb4ac93ccdd93e9eb37f69d17d5327e01040","modified":1585472194127},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1585472194127},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1585472194127},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1585472194127},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1585472194127},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"05fc79ebcf673e2d257583554eef62d162ade5e8","modified":1585472194127},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1585472194127},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1585472194127},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1585472194127},{"_id":"public/css/index.css","hash":"5ae60b6357c29a947a00bb59963651e9fe54071b","modified":1585472194127},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1585472194127},{"_id":"public/js/main.js","hash":"1dd462d995e0d85ad9e1d60002a3d5ac02c88373","modified":1585472194127},{"_id":"public/img/avatar.png","hash":"999966787de1906185344176b0c553fd4fda0b39","modified":1585472194127},{"_id":"public/img/post.jpg","hash":"97e798e9d76d65382e10cc975db8b7a2303eef71","modified":1585472194127},{"_id":"public/img/ind.jpg","hash":"94d135bd12fd9762264577e133fe504060f722ce","modified":1585472194127},{"_id":"public/img/arch.jpg","hash":"26f4bc9d26c94361c21e13f30d3eee731aee6f6e","modified":1585472194127}],"Category":[{"name":"tutorial","_id":"ck8ct7j5a0002gtvigu1286un"},{"name":"travel","_id":"ck8ct7j5f0007gtvicc919usp"},{"name":"financial","_id":"ck8ct7j5s000ngtvibpgc5puk"},{"name":"blog","_id":"ck8ct7j5u000xgtvi0qj4geyf"},{"name":"life","_id":"ck8ct7j5x0015gtvif9cq2pwp"},{"name":"review","_id":"ck8ct7j61001kgtvig9lc5qr2"},{"name":"database","_id":"ck8ct7j63001tgtvigpgr4trq"},{"name":"javascript","_id":"ck8ct7j65001zgtvib6ha3y0n"}],"Data":[{"_id":"butterfly","data":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"}}},{"_id":"link","data":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}],"Page":[{"title":"分類","date":"2018-01-05T08:00:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分類\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\ncomments: false\n---","updated":"2020-03-29T06:59:20.718Z","path":"categories/index.html","layout":"page","_id":"ck8ct7kgy003mgtvics5xg23c","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"cover":"/img/post.jpg","excerpt":"","more":""},{"title":"友情鏈接","date":"2018-06-08T05:17:49.000Z","type":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: 友情鏈接\ndate: 2018-06-07 22:17:49\ntype: \"link\"\ncomments: false\n---","updated":"2020-03-29T06:59:20.718Z","path":"link/index.html","layout":"page","_id":"ck8ct7kh0003ogtvigj9a899h","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"cover":"/img/post.jpg","excerpt":"","more":""},{"title":"標籤","date":"2018-01-05T08:00:00.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 標籤\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\ncomments: false\n---","updated":"2020-03-29T06:59:20.718Z","path":"tags/index.html","layout":"page","_id":"ck8ct7kh1003rgtvi9uka0yxo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"cover":"/img/post.jpg","excerpt":"","more":""}],"Post":[{"layout":"post","title":"New Blog","date":"2020-02-04T04:08:00.000Z","description":"新的开始","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/76CABFDC-D0E3-410E-B606-0C822BBEBE06_1_105_c.jpeg","optimized_image":null,"author":"tty","_content":"\n在世界回文字日，2020-02-02的后一天，本博客正式开张了。由于突然重感冒，本来计划的自驾游也随之取消。再加上近日新型肺炎肆虐，我并不想出门被人歧视，于是便在家里随便做点小项目，将以前的小破博客修整修整。当然，新博客出生，不能只说这些上不了台面的话。希望肺炎的阴霾早日消退，世界和平。\n\n\\- Feb 3 2020 20:08 @ Malvern 40\n\n\n\n从Massively迁移到了Jekflix，为博文添加了tag。\n\n\\- Mar 20 2020 22:57\n\n\n\n从Jekflix迁移到了Hexo，使用了Butterfly主题。\n\n\\- Mar 28 2020 22:39","source":"_posts/2020-02-03-New-Blog.md","raw":"---\nlayout: post\ntitle:  New Blog\ndate:   2020-02-03 20:08:00\ndescription: 新的开始\nsubtitle:\ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/76CABFDC-D0E3-410E-B606-0C822BBEBE06_1_105_c.jpeg\noptimized_image:\ncategory: tutorial\ntags:\n  - tutorial\n  - code\n  - javascript\nauthor: tty\n---\n\n在世界回文字日，2020-02-02的后一天，本博客正式开张了。由于突然重感冒，本来计划的自驾游也随之取消。再加上近日新型肺炎肆虐，我并不想出门被人歧视，于是便在家里随便做点小项目，将以前的小破博客修整修整。当然，新博客出生，不能只说这些上不了台面的话。希望肺炎的阴霾早日消退，世界和平。\n\n\\- Feb 3 2020 20:08 @ Malvern 40\n\n\n\n从Massively迁移到了Jekflix，为博文添加了tag。\n\n\\- Mar 20 2020 22:57\n\n\n\n从Jekflix迁移到了Hexo，使用了Butterfly主题。\n\n\\- Mar 28 2020 22:39","slug":"New-Blog","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j540000gtvi594i1te1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>在世界回文字日，2020-02-02的后一天，本博客正式开张了。由于突然重感冒，本来计划的自驾游也随之取消。再加上近日新型肺炎肆虐，我并不想出门被人歧视，于是便在家里随便做点小项目，将以前的小破博客修整修整。当然，新博客出生，不能只说这些上不了台面的话。希望肺炎的阴霾早日消退，世界和平。</p>\n<p>- Feb 3 2020 20:08 @ Malvern 40</p>\n<p>从Massively迁移到了Jekflix，为博文添加了tag。</p>\n<p>- Mar 20 2020 22:57</p>\n<p>从Jekflix迁移到了Hexo，使用了Butterfly主题。</p>\n<p>- Mar 28 2020 22:39</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>在世界回文字日，2020-02-02的后一天，本博客正式开张了。由于突然重感冒，本来计划的自驾游也随之取消。再加上近日新型肺炎肆虐，我并不想出门被人歧视，于是便在家里随便做点小项目，将以前的小破博客修整修整。当然，新博客出生，不能只说这些上不了台面的话。希望肺炎的阴霾早日消退，世界和平。</p>\n<p>- Feb 3 2020 20:08 @ Malvern 40</p>\n<p>从Massively迁移到了Jekflix，为博文添加了tag。</p>\n<p>- Mar 20 2020 22:57</p>\n<p>从Jekflix迁移到了Hexo，使用了Butterfly主题。</p>\n<p>- Mar 28 2020 22:39</p>\n"},{"layout":"post","title":"Bloomberg面试见闻","date":"2020-02-04T07:00:00.000Z","description":"繁华纽约中与homie互动","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321010223.png","optimized_image":null,"author":"tty","_content":"\n## Bloomberg\n\nBloomberg的大名想必各位早已有所耳闻。迈克尔彭博身为一位传奇商人，这位带兄弟不仅仅在2001年至2013年担任了纽约市长，今日更是想要竞选总统。Bloomberg旗下顶梁柱虽然是Bloomberg terminal等tech业务，但论名号，还是彭博社赫赫有名。其仅仅二十多年就踩过路透社走上王位，也算一段佳话。\n\n我校是Bloomberg的target school，每到秋季他们便会来我校的career fair招生。因为我们的computer science不在ENG学院，而且有自己的career fair，所以bb（后文就将Bloomberg称作bb）会来我们学校两趟，一次来CS Day，一次来eng career fair。其后便会在career fair上收到的简历中筛查一波，举行个on campus interview，将四轮onsite面试迁到学校来，招一波学生。\n\n我并没有这个运气参加bb的on campus interview。第一次我去和cs day上的bb小姐姐畅聊之后，杳无音信。第二次他们再来，我又给一帅气小哥一顿文化输出，结果还是杳无音讯。后来才得知过不过其实不是由当天跟你聊天的员工决定，而是HR筛的简历。\n\n我室友有幸参与了on campus interview，并成功于bb上岸。室友升格成了布隆伯格工程师之后，我既为他激动，又有些生气——喵了个咪的为啥我连个面试都没有，我简历也不见得差啊。不料过了几天后便收到了邮件，让我电话面试。\n\n这里就要吐槽下这位神奇的HR了。我第一次简历投递后她并不想理我，但是第二次简历投递之后她又想面我了，这简历筛选机制是不是不太稳定啊。这位HR还有一些其他的神奇操作，例如打错candidate的名字啊，写错面试时间啊，还有给了我波士顿同学philadelphia的打车券之类的……不过那又能怎么样呢，当然是选择原谅她了！\n\n虽然错过了on campus interview，但是尚存一线机会，于是我一顿准备之后通过了电话面试，定下了在一月初前往Bloomberg HQ onsite。\n\n说来搞笑，因为在十二月时有一位CS院的同学（因为他来自北大，后文便唤其北大哥）连面三大公司，并连斩三个offer。三offer分别来自Bloomberg，Amazon和一家startup。我当时也有三个面试ongoing，也是Bloomberg，Amazon和一家startup，迷信玄学的我决定复制一次北大哥的传奇！于是我照猫画虎把这三个面试放到了一起！（后来发现面试顺序安排错了，跟北大哥安排三家的顺序相反，气得我直拍大腿）\n\n也正是为了模仿北大哥（事实证明模仿别人是没有出路的！），我选择了坐火车（Amtrak）前往Bloomberg，因为北大哥说火车站就在市中心，离bb很近，较飞机更加方便。bb说是给你订商务舱，其实那商务座和高铁二等座也差不多。国内的高铁是3+2，这所谓的商务舱也就2+2。下了火车之后先模仿北大哥去火车站边上的一兰拉面吃了碗拉面。我还坐到了店内的一号座位上。害，当时我还以为是什么祥兆呢。\n\n![一兰拉面](https://raw.githubusercontent.com/8128/PicGo/master/20200321010442.png)\n\n吃完面就打算用bb给报销的打车券打的去旅馆。结果一打开uber app，发现这打车券用不了。再定睛一看发现自己只有两张打车券。原来bb这抠门公司只给坐飞机的人四张打车券，假如你选择坐火车的话只有两张打车券，也就是你家到你们城市火车站来回的打车券。我人傻在原地，看了眼走路要五十分钟，最要命的是刚才一顿找打车券的操作把我手机整没电了，我刚记下旅店在哪，我手机就彻底黑了……我只好徒步走了四十多分钟去了旅店。\n\n假如你也要面bb，那你大概就是被安排住在fitzpatrick。可这fitzpatrick，每个人竟然也是不一样的。我被安排在了fitzpatrick manhattan，离bb大楼只有2分钟路程，我同学便被安排在了另一家，要走二十分钟……进去以后直接说自己是来面试bb的，接待便会给你房卡和早餐券。\n\n这家旅馆装修尚可，只是一走进电梯便有种跨入大清的错觉，电梯缓缓的蠕动速度让我不禁怀疑这是不是天龙人电梯，是不是人力在拉动这玩意上下行走。房间总体装修很棒，除了窗帘实际上不挡视野——我往外一看，对面的人在房间里做什么被我看得一清二楚。\n\n那晚简直煎熬。这不是我第一次面试，但我不知道为什么就是平静不下来，躺在床上心率都有120，张口闭口就是behavior question，why bloomberg。可能我当时已经意识到我们寝室只有一个headcount了。\n\n于是第二天，没咋睡的我把头发吹成大人模样，熨了下衬衫就下楼吃早饭了。不得不说早饭还不错，并不是自助餐，你到楼下一做，把早餐券给服务员，一会他便端着热腾腾的面包，一盘水果和一杯红茶过来了。随便吃了点我便起身前往Bloomberg headquarter，731 Lexington avenue。\n\n<!--split-->\n\n## Bloomberg HQ\n\n作为一家金融公司，牌面这一块必须安排的明明白白的。我刚走进去，估计是门卫觉得我配不上他们金融公司的高雅气质，主动跑过来问我是干嘛的。我这么儒雅随和的人，当然是平和谦虚地对傲然的保安说：我是来面试的。于是被领到台前拍了张照片，然后带着临时工牌就上了六楼。\n\n六楼是布隆伯格的开放参观楼。当然说是开放参观，那你至少也得被邀请，不然你是门都进不来的。进去后小哥先让我去储物间放了大衣，然后让我坐在门口的沙发上，等HR过来。沙发前面就是摆放着各种零食饮料的大厅，大厅顶上还有各式各样的显示器，显示着各种金融数据，涨幅跌幅不同货币的汇率等等。我刚在那坐下来，边上的妹子便转过头来跟我打了个招呼握了个手。她说她是波士顿本地人，我听她说话的时候声音都在颤抖，搞得我也有些紧张，于是赶紧起身去打了杯热水让自己清醒点。\n\n不一时来面试的人越来越多，最后约莫到了十多个人，其中女生比例还挺高的。在约定的时间十多分钟后，HR终于到来，是个挺可爱的亚裔妹子。她先介绍了下一边供参观的bloomberg terminal，然后带着我们下了旋转扶梯。“这是世界上屈指可数的旋转扶梯。虽然这栋楼不是我们的，但是这座扶梯属于bloomberg”\n\n刚下电梯就能看见左侧的bloomberg播音台，和右边他们电视台的演播室，可谓十分炫酷。前方则是一排古董bloomberg机器，说是历史博物馆。这排古董机器前甚至禁止拍照。我眼尖，一眼看到里面一台二十年前的机子装的竟然是win7系统……你们确定这不是你们瞎搞的模型机吗？这是真机？\n\n其后我们便到了他们的办公区域。这办公室便和好莱坞电影里的美国金融公司办公室没啥区别，只是所有会议室都是玻璃门。HR还和我们讲了他们的transparency准则。说迈克尔彭博要求整个公司公开透明，所以会议室内部都是从外部可见的，大楼也是透明玻璃外壳，你们能从外面看到里面。有几次彭博看到员工开会时把门关着，边去把门拉开了。不料过了段时间再去发现他们把门又关上了。于是彭博大怒，第二天就把那扇门拆除了……\n\n她还说在彭博没有人有独自的封闭办公室，甚至连彭博本人也只是有个寻常工位而已，你甚至有时能在工位上见到他。她们彭博就是这么公开透明！\n\n于是我不禁开始怀疑昨天能看到对面房间的旅馆，是不是也算Bloomberg transparency的具体实现方案……\n\n之后我们便回到了最初的沙发处。此时已有一大堆面试官扎堆于沙发前，呼唤着你的名字。我便跟着我的面试官去了面试的会议厅。\n\n面试并不顺利。一是我发挥失常，二是我很不习惯用白板，三是面试官也有点呆呆的竟然没看懂我代码……结合我后两次平常心就面过了的经验来看，心态放好才是面试的关键，刷题多少还是minor problem。\n\n其中还有一段很尴尬的插曲。第一轮面完后两个面试官很热情地问我要不要去洗手间。我说不用不用，他们又问我要不要喝点热水，我想了想说好吧那我去接点水。于是我便从三楼的会议厅跟着他俩上了六楼……没想到上去了以后就下不来了！我再次企图从旋转扶梯那里下楼的时候被保安拦住了，告诉我“你这样的临时工牌只能待在六楼，除非有戴普通工牌的人陪同。”我大吃一惊，只好又去找接待。接待问我我面试官是谁，这我哪记得住啊，我只好报了我HR的名字。过了约莫半个小时，下一轮的面试官才前来把我接走了。也就因为这个事，我午饭也没吃就开始了第二轮……\n\n第二轮结束后便被告知今日已all set，便是凉凉的意思（一个通过的人会有四轮）。我脑袋里轰隆一声，准备了这么久的公司就这样凉了，准备了半天的behavior question都没被问到，人就被赶出去了。可能我瞬间面色憔悴，形容枯槁，面试官为了安慰我，问我要不要去28楼看看风景。我摇了摇头，“不用不用，我自己走就行了”（所以你们看到的封面文章图片并不是我拍的，而是我另一个面试的同学拍的）\n\n来到六楼后，我又跟他说不用再陪我了，我一人下去就行了。他坚持送我下去，说这是他的责任。一路到了门口，他告别的时候跟我说：“看你的表情，我知道你一路上可能想了很多，但是请不用太纠结于这两轮的面试，继续加油吧。”\n\neven he rejected me he's still a nice guy \n\n## 纽约火车站 Penn station\n\n我端着我还没动过的午饭饭盒走出了bloomberg大楼，一副刚被解雇的落魄模样，开始漫无目的的在纽约转悠。bloomberg的火车票出发时间是5 pm，因为他默认你可能会面到四点。然而我两点不到就出来了，走到火车站时也才三点。刚进火车站便看到KFC老爷爷温暖人心的笑，我决定在快餐店门口座椅上休息会\n\n我把bb给我的饭盒放在了桌上，坐在座位上刷起了一亩三分地。不一会一个年迈的黑人女性走到我边上，问我能不能坐在我边上。当时我还没警觉，我说你坐呗。于是她便坐了下来，在我身边吃完了她的三明治，然后走了。走的时候还对我说了句thank you。我疑惑，问thank you for what？她说thank you for let me sit here。这着实让我摸不着头脑。\n\n结果不一时又一个黑人女性过来了，问我身上有没有钱，她想吃东西。我心情也不好，跟她说了句没有，便没再说话。可她却缠着我，不肯离开。我便从bb的午餐盒中拿出了bb的旅行报销prepaid card，接着把午餐盒推给了她。“你要吃东西你吃这个吧”我跟她说。不料她竟然还露出了一副嫌弃的表情！此时旁边的必胜客老板早就看这几个流浪汉不爽多时了，叫来了警察要赶走她。她见警察靠过来，便拿起我的bb饭盒走了……\n\n我寻思着饭盒也给出去了，肚子也有点饿，还是买点KFC垫垫吧，于是去KFC排队买吮指原味鸡。不一时竟看到那拿了我饭盒的黑人女性转头回来了，开始坐下吃我饭盒里的三明治。不久后，远处一个高大壮硕的黑哥走了过来，开始跟拿了我饭盒的黑人女性聊天，聊完便向我这里走来。我心中暗道一声不好，但又无法溜溜球，只好噘嘴强装出一副李小龙的样子。只见那黑哥过来，“yo，you still have any free sandwich？”\n\n“no, not any more. that's the last one”\n\n接着黑哥就冷哼一声，沉身猛力用肩膀朝我冲撞了过来。靠，要不是我李小龙附体，可能真被他撞倒，在下怎么也是70kg级选手，虽然晃了晃还是稳如泰山的站住了。\n\n旋即警察们又来了一趟。这次是真正的把这流浪汉两兄妹赶走了。我总算是能平下心来吃了顿原味鸡，跑路回家。\n\n总的来说bb的面试还是令人失望。倘若再给我一次机会，我一定不那么费劲心力了。花的时间太多，让我有种必须成功的压力。这过大的压力实在不一定是件好事。压力之下还是冷静比较重要。","source":"_posts/2020-02-03-Bloomberg面试见闻.md","raw":"---\nlayout: post\ntitle:  Bloomberg面试见闻\ndate:   2020-02-03 23:00:00\ndescription: 繁华纽约中与homie互动\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321010223.png\noptimized_image: \ncategory: travel\ntags:\n  - travel\n  - blog\nauthor: tty\n---\n\n## Bloomberg\n\nBloomberg的大名想必各位早已有所耳闻。迈克尔彭博身为一位传奇商人，这位带兄弟不仅仅在2001年至2013年担任了纽约市长，今日更是想要竞选总统。Bloomberg旗下顶梁柱虽然是Bloomberg terminal等tech业务，但论名号，还是彭博社赫赫有名。其仅仅二十多年就踩过路透社走上王位，也算一段佳话。\n\n我校是Bloomberg的target school，每到秋季他们便会来我校的career fair招生。因为我们的computer science不在ENG学院，而且有自己的career fair，所以bb（后文就将Bloomberg称作bb）会来我们学校两趟，一次来CS Day，一次来eng career fair。其后便会在career fair上收到的简历中筛查一波，举行个on campus interview，将四轮onsite面试迁到学校来，招一波学生。\n\n我并没有这个运气参加bb的on campus interview。第一次我去和cs day上的bb小姐姐畅聊之后，杳无音信。第二次他们再来，我又给一帅气小哥一顿文化输出，结果还是杳无音讯。后来才得知过不过其实不是由当天跟你聊天的员工决定，而是HR筛的简历。\n\n我室友有幸参与了on campus interview，并成功于bb上岸。室友升格成了布隆伯格工程师之后，我既为他激动，又有些生气——喵了个咪的为啥我连个面试都没有，我简历也不见得差啊。不料过了几天后便收到了邮件，让我电话面试。\n\n这里就要吐槽下这位神奇的HR了。我第一次简历投递后她并不想理我，但是第二次简历投递之后她又想面我了，这简历筛选机制是不是不太稳定啊。这位HR还有一些其他的神奇操作，例如打错candidate的名字啊，写错面试时间啊，还有给了我波士顿同学philadelphia的打车券之类的……不过那又能怎么样呢，当然是选择原谅她了！\n\n虽然错过了on campus interview，但是尚存一线机会，于是我一顿准备之后通过了电话面试，定下了在一月初前往Bloomberg HQ onsite。\n\n说来搞笑，因为在十二月时有一位CS院的同学（因为他来自北大，后文便唤其北大哥）连面三大公司，并连斩三个offer。三offer分别来自Bloomberg，Amazon和一家startup。我当时也有三个面试ongoing，也是Bloomberg，Amazon和一家startup，迷信玄学的我决定复制一次北大哥的传奇！于是我照猫画虎把这三个面试放到了一起！（后来发现面试顺序安排错了，跟北大哥安排三家的顺序相反，气得我直拍大腿）\n\n也正是为了模仿北大哥（事实证明模仿别人是没有出路的！），我选择了坐火车（Amtrak）前往Bloomberg，因为北大哥说火车站就在市中心，离bb很近，较飞机更加方便。bb说是给你订商务舱，其实那商务座和高铁二等座也差不多。国内的高铁是3+2，这所谓的商务舱也就2+2。下了火车之后先模仿北大哥去火车站边上的一兰拉面吃了碗拉面。我还坐到了店内的一号座位上。害，当时我还以为是什么祥兆呢。\n\n![一兰拉面](https://raw.githubusercontent.com/8128/PicGo/master/20200321010442.png)\n\n吃完面就打算用bb给报销的打车券打的去旅馆。结果一打开uber app，发现这打车券用不了。再定睛一看发现自己只有两张打车券。原来bb这抠门公司只给坐飞机的人四张打车券，假如你选择坐火车的话只有两张打车券，也就是你家到你们城市火车站来回的打车券。我人傻在原地，看了眼走路要五十分钟，最要命的是刚才一顿找打车券的操作把我手机整没电了，我刚记下旅店在哪，我手机就彻底黑了……我只好徒步走了四十多分钟去了旅店。\n\n假如你也要面bb，那你大概就是被安排住在fitzpatrick。可这fitzpatrick，每个人竟然也是不一样的。我被安排在了fitzpatrick manhattan，离bb大楼只有2分钟路程，我同学便被安排在了另一家，要走二十分钟……进去以后直接说自己是来面试bb的，接待便会给你房卡和早餐券。\n\n这家旅馆装修尚可，只是一走进电梯便有种跨入大清的错觉，电梯缓缓的蠕动速度让我不禁怀疑这是不是天龙人电梯，是不是人力在拉动这玩意上下行走。房间总体装修很棒，除了窗帘实际上不挡视野——我往外一看，对面的人在房间里做什么被我看得一清二楚。\n\n那晚简直煎熬。这不是我第一次面试，但我不知道为什么就是平静不下来，躺在床上心率都有120，张口闭口就是behavior question，why bloomberg。可能我当时已经意识到我们寝室只有一个headcount了。\n\n于是第二天，没咋睡的我把头发吹成大人模样，熨了下衬衫就下楼吃早饭了。不得不说早饭还不错，并不是自助餐，你到楼下一做，把早餐券给服务员，一会他便端着热腾腾的面包，一盘水果和一杯红茶过来了。随便吃了点我便起身前往Bloomberg headquarter，731 Lexington avenue。\n\n<!--split-->\n\n## Bloomberg HQ\n\n作为一家金融公司，牌面这一块必须安排的明明白白的。我刚走进去，估计是门卫觉得我配不上他们金融公司的高雅气质，主动跑过来问我是干嘛的。我这么儒雅随和的人，当然是平和谦虚地对傲然的保安说：我是来面试的。于是被领到台前拍了张照片，然后带着临时工牌就上了六楼。\n\n六楼是布隆伯格的开放参观楼。当然说是开放参观，那你至少也得被邀请，不然你是门都进不来的。进去后小哥先让我去储物间放了大衣，然后让我坐在门口的沙发上，等HR过来。沙发前面就是摆放着各种零食饮料的大厅，大厅顶上还有各式各样的显示器，显示着各种金融数据，涨幅跌幅不同货币的汇率等等。我刚在那坐下来，边上的妹子便转过头来跟我打了个招呼握了个手。她说她是波士顿本地人，我听她说话的时候声音都在颤抖，搞得我也有些紧张，于是赶紧起身去打了杯热水让自己清醒点。\n\n不一时来面试的人越来越多，最后约莫到了十多个人，其中女生比例还挺高的。在约定的时间十多分钟后，HR终于到来，是个挺可爱的亚裔妹子。她先介绍了下一边供参观的bloomberg terminal，然后带着我们下了旋转扶梯。“这是世界上屈指可数的旋转扶梯。虽然这栋楼不是我们的，但是这座扶梯属于bloomberg”\n\n刚下电梯就能看见左侧的bloomberg播音台，和右边他们电视台的演播室，可谓十分炫酷。前方则是一排古董bloomberg机器，说是历史博物馆。这排古董机器前甚至禁止拍照。我眼尖，一眼看到里面一台二十年前的机子装的竟然是win7系统……你们确定这不是你们瞎搞的模型机吗？这是真机？\n\n其后我们便到了他们的办公区域。这办公室便和好莱坞电影里的美国金融公司办公室没啥区别，只是所有会议室都是玻璃门。HR还和我们讲了他们的transparency准则。说迈克尔彭博要求整个公司公开透明，所以会议室内部都是从外部可见的，大楼也是透明玻璃外壳，你们能从外面看到里面。有几次彭博看到员工开会时把门关着，边去把门拉开了。不料过了段时间再去发现他们把门又关上了。于是彭博大怒，第二天就把那扇门拆除了……\n\n她还说在彭博没有人有独自的封闭办公室，甚至连彭博本人也只是有个寻常工位而已，你甚至有时能在工位上见到他。她们彭博就是这么公开透明！\n\n于是我不禁开始怀疑昨天能看到对面房间的旅馆，是不是也算Bloomberg transparency的具体实现方案……\n\n之后我们便回到了最初的沙发处。此时已有一大堆面试官扎堆于沙发前，呼唤着你的名字。我便跟着我的面试官去了面试的会议厅。\n\n面试并不顺利。一是我发挥失常，二是我很不习惯用白板，三是面试官也有点呆呆的竟然没看懂我代码……结合我后两次平常心就面过了的经验来看，心态放好才是面试的关键，刷题多少还是minor problem。\n\n其中还有一段很尴尬的插曲。第一轮面完后两个面试官很热情地问我要不要去洗手间。我说不用不用，他们又问我要不要喝点热水，我想了想说好吧那我去接点水。于是我便从三楼的会议厅跟着他俩上了六楼……没想到上去了以后就下不来了！我再次企图从旋转扶梯那里下楼的时候被保安拦住了，告诉我“你这样的临时工牌只能待在六楼，除非有戴普通工牌的人陪同。”我大吃一惊，只好又去找接待。接待问我我面试官是谁，这我哪记得住啊，我只好报了我HR的名字。过了约莫半个小时，下一轮的面试官才前来把我接走了。也就因为这个事，我午饭也没吃就开始了第二轮……\n\n第二轮结束后便被告知今日已all set，便是凉凉的意思（一个通过的人会有四轮）。我脑袋里轰隆一声，准备了这么久的公司就这样凉了，准备了半天的behavior question都没被问到，人就被赶出去了。可能我瞬间面色憔悴，形容枯槁，面试官为了安慰我，问我要不要去28楼看看风景。我摇了摇头，“不用不用，我自己走就行了”（所以你们看到的封面文章图片并不是我拍的，而是我另一个面试的同学拍的）\n\n来到六楼后，我又跟他说不用再陪我了，我一人下去就行了。他坚持送我下去，说这是他的责任。一路到了门口，他告别的时候跟我说：“看你的表情，我知道你一路上可能想了很多，但是请不用太纠结于这两轮的面试，继续加油吧。”\n\neven he rejected me he's still a nice guy \n\n## 纽约火车站 Penn station\n\n我端着我还没动过的午饭饭盒走出了bloomberg大楼，一副刚被解雇的落魄模样，开始漫无目的的在纽约转悠。bloomberg的火车票出发时间是5 pm，因为他默认你可能会面到四点。然而我两点不到就出来了，走到火车站时也才三点。刚进火车站便看到KFC老爷爷温暖人心的笑，我决定在快餐店门口座椅上休息会\n\n我把bb给我的饭盒放在了桌上，坐在座位上刷起了一亩三分地。不一会一个年迈的黑人女性走到我边上，问我能不能坐在我边上。当时我还没警觉，我说你坐呗。于是她便坐了下来，在我身边吃完了她的三明治，然后走了。走的时候还对我说了句thank you。我疑惑，问thank you for what？她说thank you for let me sit here。这着实让我摸不着头脑。\n\n结果不一时又一个黑人女性过来了，问我身上有没有钱，她想吃东西。我心情也不好，跟她说了句没有，便没再说话。可她却缠着我，不肯离开。我便从bb的午餐盒中拿出了bb的旅行报销prepaid card，接着把午餐盒推给了她。“你要吃东西你吃这个吧”我跟她说。不料她竟然还露出了一副嫌弃的表情！此时旁边的必胜客老板早就看这几个流浪汉不爽多时了，叫来了警察要赶走她。她见警察靠过来，便拿起我的bb饭盒走了……\n\n我寻思着饭盒也给出去了，肚子也有点饿，还是买点KFC垫垫吧，于是去KFC排队买吮指原味鸡。不一时竟看到那拿了我饭盒的黑人女性转头回来了，开始坐下吃我饭盒里的三明治。不久后，远处一个高大壮硕的黑哥走了过来，开始跟拿了我饭盒的黑人女性聊天，聊完便向我这里走来。我心中暗道一声不好，但又无法溜溜球，只好噘嘴强装出一副李小龙的样子。只见那黑哥过来，“yo，you still have any free sandwich？”\n\n“no, not any more. that's the last one”\n\n接着黑哥就冷哼一声，沉身猛力用肩膀朝我冲撞了过来。靠，要不是我李小龙附体，可能真被他撞倒，在下怎么也是70kg级选手，虽然晃了晃还是稳如泰山的站住了。\n\n旋即警察们又来了一趟。这次是真正的把这流浪汉两兄妹赶走了。我总算是能平下心来吃了顿原味鸡，跑路回家。\n\n总的来说bb的面试还是令人失望。倘若再给我一次机会，我一定不那么费劲心力了。花的时间太多，让我有种必须成功的压力。这过大的压力实在不一定是件好事。压力之下还是冷静比较重要。","slug":"Bloomberg面试见闻","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j580001gtviflg7hzcj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"Bloomberg\"><a href=\"#Bloomberg\" class=\"headerlink\" title=\"Bloomberg\"></a>Bloomberg</h2><p>Bloomberg的大名想必各位早已有所耳闻。迈克尔彭博身为一位传奇商人，这位带兄弟不仅仅在2001年至2013年担任了纽约市长，今日更是想要竞选总统。Bloomberg旗下顶梁柱虽然是Bloomberg terminal等tech业务，但论名号，还是彭博社赫赫有名。其仅仅二十多年就踩过路透社走上王位，也算一段佳话。</p>\n<p>我校是Bloomberg的target school，每到秋季他们便会来我校的career fair招生。因为我们的computer science不在ENG学院，而且有自己的career fair，所以bb（后文就将Bloomberg称作bb）会来我们学校两趟，一次来CS Day，一次来eng career fair。其后便会在career fair上收到的简历中筛查一波，举行个on campus interview，将四轮onsite面试迁到学校来，招一波学生。</p>\n<p>我并没有这个运气参加bb的on campus interview。第一次我去和cs day上的bb小姐姐畅聊之后，杳无音信。第二次他们再来，我又给一帅气小哥一顿文化输出，结果还是杳无音讯。后来才得知过不过其实不是由当天跟你聊天的员工决定，而是HR筛的简历。</p>\n<p>我室友有幸参与了on campus interview，并成功于bb上岸。室友升格成了布隆伯格工程师之后，我既为他激动，又有些生气——喵了个咪的为啥我连个面试都没有，我简历也不见得差啊。不料过了几天后便收到了邮件，让我电话面试。</p>\n<p>这里就要吐槽下这位神奇的HR了。我第一次简历投递后她并不想理我，但是第二次简历投递之后她又想面我了，这简历筛选机制是不是不太稳定啊。这位HR还有一些其他的神奇操作，例如打错candidate的名字啊，写错面试时间啊，还有给了我波士顿同学philadelphia的打车券之类的……不过那又能怎么样呢，当然是选择原谅她了！</p>\n<p>虽然错过了on campus interview，但是尚存一线机会，于是我一顿准备之后通过了电话面试，定下了在一月初前往Bloomberg HQ onsite。</p>\n<p>说来搞笑，因为在十二月时有一位CS院的同学（因为他来自北大，后文便唤其北大哥）连面三大公司，并连斩三个offer。三offer分别来自Bloomberg，Amazon和一家startup。我当时也有三个面试ongoing，也是Bloomberg，Amazon和一家startup，迷信玄学的我决定复制一次北大哥的传奇！于是我照猫画虎把这三个面试放到了一起！（后来发现面试顺序安排错了，跟北大哥安排三家的顺序相反，气得我直拍大腿）</p>\n<p>也正是为了模仿北大哥（事实证明模仿别人是没有出路的！），我选择了坐火车（Amtrak）前往Bloomberg，因为北大哥说火车站就在市中心，离bb很近，较飞机更加方便。bb说是给你订商务舱，其实那商务座和高铁二等座也差不多。国内的高铁是3+2，这所谓的商务舱也就2+2。下了火车之后先模仿北大哥去火车站边上的一兰拉面吃了碗拉面。我还坐到了店内的一号座位上。害，当时我还以为是什么祥兆呢。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010442.png\"  alt=\"一兰拉面\"></p>\n<p>吃完面就打算用bb给报销的打车券打的去旅馆。结果一打开uber app，发现这打车券用不了。再定睛一看发现自己只有两张打车券。原来bb这抠门公司只给坐飞机的人四张打车券，假如你选择坐火车的话只有两张打车券，也就是你家到你们城市火车站来回的打车券。我人傻在原地，看了眼走路要五十分钟，最要命的是刚才一顿找打车券的操作把我手机整没电了，我刚记下旅店在哪，我手机就彻底黑了……我只好徒步走了四十多分钟去了旅店。</p>\n<p>假如你也要面bb，那你大概就是被安排住在fitzpatrick。可这fitzpatrick，每个人竟然也是不一样的。我被安排在了fitzpatrick manhattan，离bb大楼只有2分钟路程，我同学便被安排在了另一家，要走二十分钟……进去以后直接说自己是来面试bb的，接待便会给你房卡和早餐券。</p>\n<p>这家旅馆装修尚可，只是一走进电梯便有种跨入大清的错觉，电梯缓缓的蠕动速度让我不禁怀疑这是不是天龙人电梯，是不是人力在拉动这玩意上下行走。房间总体装修很棒，除了窗帘实际上不挡视野——我往外一看，对面的人在房间里做什么被我看得一清二楚。</p>\n<p>那晚简直煎熬。这不是我第一次面试，但我不知道为什么就是平静不下来，躺在床上心率都有120，张口闭口就是behavior question，why bloomberg。可能我当时已经意识到我们寝室只有一个headcount了。</p>\n<p>于是第二天，没咋睡的我把头发吹成大人模样，熨了下衬衫就下楼吃早饭了。不得不说早饭还不错，并不是自助餐，你到楼下一做，把早餐券给服务员，一会他便端着热腾腾的面包，一盘水果和一杯红茶过来了。随便吃了点我便起身前往Bloomberg headquarter，731 Lexington avenue。</p>\n<!--split-->\n\n<h2 id=\"Bloomberg-HQ\"><a href=\"#Bloomberg-HQ\" class=\"headerlink\" title=\"Bloomberg HQ\"></a>Bloomberg HQ</h2><p>作为一家金融公司，牌面这一块必须安排的明明白白的。我刚走进去，估计是门卫觉得我配不上他们金融公司的高雅气质，主动跑过来问我是干嘛的。我这么儒雅随和的人，当然是平和谦虚地对傲然的保安说：我是来面试的。于是被领到台前拍了张照片，然后带着临时工牌就上了六楼。</p>\n<p>六楼是布隆伯格的开放参观楼。当然说是开放参观，那你至少也得被邀请，不然你是门都进不来的。进去后小哥先让我去储物间放了大衣，然后让我坐在门口的沙发上，等HR过来。沙发前面就是摆放着各种零食饮料的大厅，大厅顶上还有各式各样的显示器，显示着各种金融数据，涨幅跌幅不同货币的汇率等等。我刚在那坐下来，边上的妹子便转过头来跟我打了个招呼握了个手。她说她是波士顿本地人，我听她说话的时候声音都在颤抖，搞得我也有些紧张，于是赶紧起身去打了杯热水让自己清醒点。</p>\n<p>不一时来面试的人越来越多，最后约莫到了十多个人，其中女生比例还挺高的。在约定的时间十多分钟后，HR终于到来，是个挺可爱的亚裔妹子。她先介绍了下一边供参观的bloomberg terminal，然后带着我们下了旋转扶梯。“这是世界上屈指可数的旋转扶梯。虽然这栋楼不是我们的，但是这座扶梯属于bloomberg”</p>\n<p>刚下电梯就能看见左侧的bloomberg播音台，和右边他们电视台的演播室，可谓十分炫酷。前方则是一排古董bloomberg机器，说是历史博物馆。这排古董机器前甚至禁止拍照。我眼尖，一眼看到里面一台二十年前的机子装的竟然是win7系统……你们确定这不是你们瞎搞的模型机吗？这是真机？</p>\n<p>其后我们便到了他们的办公区域。这办公室便和好莱坞电影里的美国金融公司办公室没啥区别，只是所有会议室都是玻璃门。HR还和我们讲了他们的transparency准则。说迈克尔彭博要求整个公司公开透明，所以会议室内部都是从外部可见的，大楼也是透明玻璃外壳，你们能从外面看到里面。有几次彭博看到员工开会时把门关着，边去把门拉开了。不料过了段时间再去发现他们把门又关上了。于是彭博大怒，第二天就把那扇门拆除了……</p>\n<p>她还说在彭博没有人有独自的封闭办公室，甚至连彭博本人也只是有个寻常工位而已，你甚至有时能在工位上见到他。她们彭博就是这么公开透明！</p>\n<p>于是我不禁开始怀疑昨天能看到对面房间的旅馆，是不是也算Bloomberg transparency的具体实现方案……</p>\n<p>之后我们便回到了最初的沙发处。此时已有一大堆面试官扎堆于沙发前，呼唤着你的名字。我便跟着我的面试官去了面试的会议厅。</p>\n<p>面试并不顺利。一是我发挥失常，二是我很不习惯用白板，三是面试官也有点呆呆的竟然没看懂我代码……结合我后两次平常心就面过了的经验来看，心态放好才是面试的关键，刷题多少还是minor problem。</p>\n<p>其中还有一段很尴尬的插曲。第一轮面完后两个面试官很热情地问我要不要去洗手间。我说不用不用，他们又问我要不要喝点热水，我想了想说好吧那我去接点水。于是我便从三楼的会议厅跟着他俩上了六楼……没想到上去了以后就下不来了！我再次企图从旋转扶梯那里下楼的时候被保安拦住了，告诉我“你这样的临时工牌只能待在六楼，除非有戴普通工牌的人陪同。”我大吃一惊，只好又去找接待。接待问我我面试官是谁，这我哪记得住啊，我只好报了我HR的名字。过了约莫半个小时，下一轮的面试官才前来把我接走了。也就因为这个事，我午饭也没吃就开始了第二轮……</p>\n<p>第二轮结束后便被告知今日已all set，便是凉凉的意思（一个通过的人会有四轮）。我脑袋里轰隆一声，准备了这么久的公司就这样凉了，准备了半天的behavior question都没被问到，人就被赶出去了。可能我瞬间面色憔悴，形容枯槁，面试官为了安慰我，问我要不要去28楼看看风景。我摇了摇头，“不用不用，我自己走就行了”（所以你们看到的封面文章图片并不是我拍的，而是我另一个面试的同学拍的）</p>\n<p>来到六楼后，我又跟他说不用再陪我了，我一人下去就行了。他坚持送我下去，说这是他的责任。一路到了门口，他告别的时候跟我说：“看你的表情，我知道你一路上可能想了很多，但是请不用太纠结于这两轮的面试，继续加油吧。”</p>\n<p>even he rejected me he’s still a nice guy </p>\n<h2 id=\"纽约火车站-Penn-station\"><a href=\"#纽约火车站-Penn-station\" class=\"headerlink\" title=\"纽约火车站 Penn station\"></a>纽约火车站 Penn station</h2><p>我端着我还没动过的午饭饭盒走出了bloomberg大楼，一副刚被解雇的落魄模样，开始漫无目的的在纽约转悠。bloomberg的火车票出发时间是5 pm，因为他默认你可能会面到四点。然而我两点不到就出来了，走到火车站时也才三点。刚进火车站便看到KFC老爷爷温暖人心的笑，我决定在快餐店门口座椅上休息会</p>\n<p>我把bb给我的饭盒放在了桌上，坐在座位上刷起了一亩三分地。不一会一个年迈的黑人女性走到我边上，问我能不能坐在我边上。当时我还没警觉，我说你坐呗。于是她便坐了下来，在我身边吃完了她的三明治，然后走了。走的时候还对我说了句thank you。我疑惑，问thank you for what？她说thank you for let me sit here。这着实让我摸不着头脑。</p>\n<p>结果不一时又一个黑人女性过来了，问我身上有没有钱，她想吃东西。我心情也不好，跟她说了句没有，便没再说话。可她却缠着我，不肯离开。我便从bb的午餐盒中拿出了bb的旅行报销prepaid card，接着把午餐盒推给了她。“你要吃东西你吃这个吧”我跟她说。不料她竟然还露出了一副嫌弃的表情！此时旁边的必胜客老板早就看这几个流浪汉不爽多时了，叫来了警察要赶走她。她见警察靠过来，便拿起我的bb饭盒走了……</p>\n<p>我寻思着饭盒也给出去了，肚子也有点饿，还是买点KFC垫垫吧，于是去KFC排队买吮指原味鸡。不一时竟看到那拿了我饭盒的黑人女性转头回来了，开始坐下吃我饭盒里的三明治。不久后，远处一个高大壮硕的黑哥走了过来，开始跟拿了我饭盒的黑人女性聊天，聊完便向我这里走来。我心中暗道一声不好，但又无法溜溜球，只好噘嘴强装出一副李小龙的样子。只见那黑哥过来，“yo，you still have any free sandwich？”</p>\n<p>“no, not any more. that’s the last one”</p>\n<p>接着黑哥就冷哼一声，沉身猛力用肩膀朝我冲撞了过来。靠，要不是我李小龙附体，可能真被他撞倒，在下怎么也是70kg级选手，虽然晃了晃还是稳如泰山的站住了。</p>\n<p>旋即警察们又来了一趟。这次是真正的把这流浪汉两兄妹赶走了。我总算是能平下心来吃了顿原味鸡，跑路回家。</p>\n<p>总的来说bb的面试还是令人失望。倘若再给我一次机会，我一定不那么费劲心力了。花的时间太多，让我有种必须成功的压力。这过大的压力实在不一定是件好事。压力之下还是冷静比较重要。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<h2 id=\"Bloomberg\"><a href=\"#Bloomberg\" class=\"headerlink\" title=\"Bloomberg\"></a>Bloomberg</h2><p>Bloomberg的大名想必各位早已有所耳闻。迈克尔彭博身为一位传奇商人，这位带兄弟不仅仅在2001年至2013年担任了纽约市长，今日更是想要竞选总统。Bloomberg旗下顶梁柱虽然是Bloomberg terminal等tech业务，但论名号，还是彭博社赫赫有名。其仅仅二十多年就踩过路透社走上王位，也算一段佳话。</p>\n<p>我校是Bloomberg的target school，每到秋季他们便会来我校的career fair招生。因为我们的computer science不在ENG学院，而且有自己的career fair，所以bb（后文就将Bloomberg称作bb）会来我们学校两趟，一次来CS Day，一次来eng career fair。其后便会在career fair上收到的简历中筛查一波，举行个on campus interview，将四轮onsite面试迁到学校来，招一波学生。</p>\n<p>我并没有这个运气参加bb的on campus interview。第一次我去和cs day上的bb小姐姐畅聊之后，杳无音信。第二次他们再来，我又给一帅气小哥一顿文化输出，结果还是杳无音讯。后来才得知过不过其实不是由当天跟你聊天的员工决定，而是HR筛的简历。</p>\n<p>我室友有幸参与了on campus interview，并成功于bb上岸。室友升格成了布隆伯格工程师之后，我既为他激动，又有些生气——喵了个咪的为啥我连个面试都没有，我简历也不见得差啊。不料过了几天后便收到了邮件，让我电话面试。</p>\n<p>这里就要吐槽下这位神奇的HR了。我第一次简历投递后她并不想理我，但是第二次简历投递之后她又想面我了，这简历筛选机制是不是不太稳定啊。这位HR还有一些其他的神奇操作，例如打错candidate的名字啊，写错面试时间啊，还有给了我波士顿同学philadelphia的打车券之类的……不过那又能怎么样呢，当然是选择原谅她了！</p>\n<p>虽然错过了on campus interview，但是尚存一线机会，于是我一顿准备之后通过了电话面试，定下了在一月初前往Bloomberg HQ onsite。</p>\n<p>说来搞笑，因为在十二月时有一位CS院的同学（因为他来自北大，后文便唤其北大哥）连面三大公司，并连斩三个offer。三offer分别来自Bloomberg，Amazon和一家startup。我当时也有三个面试ongoing，也是Bloomberg，Amazon和一家startup，迷信玄学的我决定复制一次北大哥的传奇！于是我照猫画虎把这三个面试放到了一起！（后来发现面试顺序安排错了，跟北大哥安排三家的顺序相反，气得我直拍大腿）</p>\n<p>也正是为了模仿北大哥（事实证明模仿别人是没有出路的！），我选择了坐火车（Amtrak）前往Bloomberg，因为北大哥说火车站就在市中心，离bb很近，较飞机更加方便。bb说是给你订商务舱，其实那商务座和高铁二等座也差不多。国内的高铁是3+2，这所谓的商务舱也就2+2。下了火车之后先模仿北大哥去火车站边上的一兰拉面吃了碗拉面。我还坐到了店内的一号座位上。害，当时我还以为是什么祥兆呢。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010442.png\" alt=\"一兰拉面\"></p>\n<p>吃完面就打算用bb给报销的打车券打的去旅馆。结果一打开uber app，发现这打车券用不了。再定睛一看发现自己只有两张打车券。原来bb这抠门公司只给坐飞机的人四张打车券，假如你选择坐火车的话只有两张打车券，也就是你家到你们城市火车站来回的打车券。我人傻在原地，看了眼走路要五十分钟，最要命的是刚才一顿找打车券的操作把我手机整没电了，我刚记下旅店在哪，我手机就彻底黑了……我只好徒步走了四十多分钟去了旅店。</p>\n<p>假如你也要面bb，那你大概就是被安排住在fitzpatrick。可这fitzpatrick，每个人竟然也是不一样的。我被安排在了fitzpatrick manhattan，离bb大楼只有2分钟路程，我同学便被安排在了另一家，要走二十分钟……进去以后直接说自己是来面试bb的，接待便会给你房卡和早餐券。</p>\n<p>这家旅馆装修尚可，只是一走进电梯便有种跨入大清的错觉，电梯缓缓的蠕动速度让我不禁怀疑这是不是天龙人电梯，是不是人力在拉动这玩意上下行走。房间总体装修很棒，除了窗帘实际上不挡视野——我往外一看，对面的人在房间里做什么被我看得一清二楚。</p>\n<p>那晚简直煎熬。这不是我第一次面试，但我不知道为什么就是平静不下来，躺在床上心率都有120，张口闭口就是behavior question，why bloomberg。可能我当时已经意识到我们寝室只有一个headcount了。</p>\n<p>于是第二天，没咋睡的我把头发吹成大人模样，熨了下衬衫就下楼吃早饭了。不得不说早饭还不错，并不是自助餐，你到楼下一做，把早餐券给服务员，一会他便端着热腾腾的面包，一盘水果和一杯红茶过来了。随便吃了点我便起身前往Bloomberg headquarter，731 Lexington avenue。</p>\n<!--split-->\n\n<h2 id=\"Bloomberg-HQ\"><a href=\"#Bloomberg-HQ\" class=\"headerlink\" title=\"Bloomberg HQ\"></a>Bloomberg HQ</h2><p>作为一家金融公司，牌面这一块必须安排的明明白白的。我刚走进去，估计是门卫觉得我配不上他们金融公司的高雅气质，主动跑过来问我是干嘛的。我这么儒雅随和的人，当然是平和谦虚地对傲然的保安说：我是来面试的。于是被领到台前拍了张照片，然后带着临时工牌就上了六楼。</p>\n<p>六楼是布隆伯格的开放参观楼。当然说是开放参观，那你至少也得被邀请，不然你是门都进不来的。进去后小哥先让我去储物间放了大衣，然后让我坐在门口的沙发上，等HR过来。沙发前面就是摆放着各种零食饮料的大厅，大厅顶上还有各式各样的显示器，显示着各种金融数据，涨幅跌幅不同货币的汇率等等。我刚在那坐下来，边上的妹子便转过头来跟我打了个招呼握了个手。她说她是波士顿本地人，我听她说话的时候声音都在颤抖，搞得我也有些紧张，于是赶紧起身去打了杯热水让自己清醒点。</p>\n<p>不一时来面试的人越来越多，最后约莫到了十多个人，其中女生比例还挺高的。在约定的时间十多分钟后，HR终于到来，是个挺可爱的亚裔妹子。她先介绍了下一边供参观的bloomberg terminal，然后带着我们下了旋转扶梯。“这是世界上屈指可数的旋转扶梯。虽然这栋楼不是我们的，但是这座扶梯属于bloomberg”</p>\n<p>刚下电梯就能看见左侧的bloomberg播音台，和右边他们电视台的演播室，可谓十分炫酷。前方则是一排古董bloomberg机器，说是历史博物馆。这排古董机器前甚至禁止拍照。我眼尖，一眼看到里面一台二十年前的机子装的竟然是win7系统……你们确定这不是你们瞎搞的模型机吗？这是真机？</p>\n<p>其后我们便到了他们的办公区域。这办公室便和好莱坞电影里的美国金融公司办公室没啥区别，只是所有会议室都是玻璃门。HR还和我们讲了他们的transparency准则。说迈克尔彭博要求整个公司公开透明，所以会议室内部都是从外部可见的，大楼也是透明玻璃外壳，你们能从外面看到里面。有几次彭博看到员工开会时把门关着，边去把门拉开了。不料过了段时间再去发现他们把门又关上了。于是彭博大怒，第二天就把那扇门拆除了……</p>\n<p>她还说在彭博没有人有独自的封闭办公室，甚至连彭博本人也只是有个寻常工位而已，你甚至有时能在工位上见到他。她们彭博就是这么公开透明！</p>\n<p>于是我不禁开始怀疑昨天能看到对面房间的旅馆，是不是也算Bloomberg transparency的具体实现方案……</p>\n<p>之后我们便回到了最初的沙发处。此时已有一大堆面试官扎堆于沙发前，呼唤着你的名字。我便跟着我的面试官去了面试的会议厅。</p>\n<p>面试并不顺利。一是我发挥失常，二是我很不习惯用白板，三是面试官也有点呆呆的竟然没看懂我代码……结合我后两次平常心就面过了的经验来看，心态放好才是面试的关键，刷题多少还是minor problem。</p>\n<p>其中还有一段很尴尬的插曲。第一轮面完后两个面试官很热情地问我要不要去洗手间。我说不用不用，他们又问我要不要喝点热水，我想了想说好吧那我去接点水。于是我便从三楼的会议厅跟着他俩上了六楼……没想到上去了以后就下不来了！我再次企图从旋转扶梯那里下楼的时候被保安拦住了，告诉我“你这样的临时工牌只能待在六楼，除非有戴普通工牌的人陪同。”我大吃一惊，只好又去找接待。接待问我我面试官是谁，这我哪记得住啊，我只好报了我HR的名字。过了约莫半个小时，下一轮的面试官才前来把我接走了。也就因为这个事，我午饭也没吃就开始了第二轮……</p>\n<p>第二轮结束后便被告知今日已all set，便是凉凉的意思（一个通过的人会有四轮）。我脑袋里轰隆一声，准备了这么久的公司就这样凉了，准备了半天的behavior question都没被问到，人就被赶出去了。可能我瞬间面色憔悴，形容枯槁，面试官为了安慰我，问我要不要去28楼看看风景。我摇了摇头，“不用不用，我自己走就行了”（所以你们看到的封面文章图片并不是我拍的，而是我另一个面试的同学拍的）</p>\n<p>来到六楼后，我又跟他说不用再陪我了，我一人下去就行了。他坚持送我下去，说这是他的责任。一路到了门口，他告别的时候跟我说：“看你的表情，我知道你一路上可能想了很多，但是请不用太纠结于这两轮的面试，继续加油吧。”</p>\n<p>even he rejected me he’s still a nice guy </p>\n<h2 id=\"纽约火车站-Penn-station\"><a href=\"#纽约火车站-Penn-station\" class=\"headerlink\" title=\"纽约火车站 Penn station\"></a>纽约火车站 Penn station</h2><p>我端着我还没动过的午饭饭盒走出了bloomberg大楼，一副刚被解雇的落魄模样，开始漫无目的的在纽约转悠。bloomberg的火车票出发时间是5 pm，因为他默认你可能会面到四点。然而我两点不到就出来了，走到火车站时也才三点。刚进火车站便看到KFC老爷爷温暖人心的笑，我决定在快餐店门口座椅上休息会</p>\n<p>我把bb给我的饭盒放在了桌上，坐在座位上刷起了一亩三分地。不一会一个年迈的黑人女性走到我边上，问我能不能坐在我边上。当时我还没警觉，我说你坐呗。于是她便坐了下来，在我身边吃完了她的三明治，然后走了。走的时候还对我说了句thank you。我疑惑，问thank you for what？她说thank you for let me sit here。这着实让我摸不着头脑。</p>\n<p>结果不一时又一个黑人女性过来了，问我身上有没有钱，她想吃东西。我心情也不好，跟她说了句没有，便没再说话。可她却缠着我，不肯离开。我便从bb的午餐盒中拿出了bb的旅行报销prepaid card，接着把午餐盒推给了她。“你要吃东西你吃这个吧”我跟她说。不料她竟然还露出了一副嫌弃的表情！此时旁边的必胜客老板早就看这几个流浪汉不爽多时了，叫来了警察要赶走她。她见警察靠过来，便拿起我的bb饭盒走了……</p>\n<p>我寻思着饭盒也给出去了，肚子也有点饿，还是买点KFC垫垫吧，于是去KFC排队买吮指原味鸡。不一时竟看到那拿了我饭盒的黑人女性转头回来了，开始坐下吃我饭盒里的三明治。不久后，远处一个高大壮硕的黑哥走了过来，开始跟拿了我饭盒的黑人女性聊天，聊完便向我这里走来。我心中暗道一声不好，但又无法溜溜球，只好噘嘴强装出一副李小龙的样子。只见那黑哥过来，“yo，you still have any free sandwich？”</p>\n<p>“no, not any more. that’s the last one”</p>\n<p>接着黑哥就冷哼一声，沉身猛力用肩膀朝我冲撞了过来。靠，要不是我李小龙附体，可能真被他撞倒，在下怎么也是70kg级选手，虽然晃了晃还是稳如泰山的站住了。</p>\n<p>旋即警察们又来了一趟。这次是真正的把这流浪汉两兄妹赶走了。我总算是能平下心来吃了顿原味鸡，跑路回家。</p>\n<p>总的来说bb的面试还是令人失望。倘若再给我一次机会，我一定不那么费劲心力了。花的时间太多，让我有种必须成功的压力。这过大的压力实在不一定是件好事。压力之下还是冷静比较重要。</p>\n"},{"layout":"post","title":"搭建Jekyll博客技巧集","date":"2020-02-04T07:00:00.000Z","description":"你是否想为你挂在GitHub的jekyll博客添加什么?","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321010401.png","optimized_image":null,"author":"tty","_content":"\n\n\n我个人在建立这个jekyll的博客中还是查询了不少资料的，其中有些已经过时，有些压根不能用。对于那些有用的信息，个人会在下方做一个总结，希望能对各位有所帮助。我会持续更新此blog\n\n## 评论功能\n\n这实际上是jekyll博客最容易添加的功能之一。国外有[Disqus](https://disqus.com/)，国内似乎也有替代产品。添加disqus到你的jekyll博客中是件非常简单的事，你要做的只是登录他们的网站，注册你的账号，然后跟随着他的教程一步一步向下走。\n\n一个小技巧就是把jekyll提供给你的脚本代码写到单独的一个html中，将html放入include文件夹。之后只要在模板中include这个html，你就可以在所有用了这个模板的网页中添加评论区了。\n\n注意，假如你在网上跟着别的教程一步一步走，却发现最终出现在你post下方的不是评论区，而是加载失败的disqus，那么出错的很可能并不是你的tokens，而是你看的教程中的旧版代码。请从复制官方文档中最新的代码。旧版代码会导致disqus加载错误\n\n## 目录功能\n\n如果你想给blog添加目录，你可以在_config.yml中将Jekyll默认Markdown渲染器设置为kramdown。添加方法如下：\n\n_config.yml\n\n```yml\nmarkdown:           kramdown\nkramdown:\n  toc_levels:       1..6 #此行表示从1-6级的标题将被放入目录\n```\n\n随后在文章中标识 toc 的生成位置：\n\n```markdown\n* 目录\n{:toc}\n```\n\n其中，目录这一行是必需的，星号后面的内容则可随意填写。如果要把某标题从目录树中排除，则在该标题的下一行写上 `{:.no_toc}`。默认生成的目录列表会添加 id 值 markdown-toc，我们可以自定义 id 值，比如 {:toc #id}\n\n\n\n如果你不想用kramdown，也不想用js或其他plugin（很多jekyll的plugin被GitHub给屏蔽了），你可以使用[jekyll-toc](https://github.com/allejo/jekyll-toc)，你只需要三步就能解决问题：\n\n1. 下载最新版本的 [`toc.html`](https://github.com/allejo/jekyll-toc/blob/master/_includes/toc.html) 文件（在GitHub仓库的_includes里）\n\n2. 将这个文件放到你的 `_includes` 文件夹去\n\n3. 找到你模板中的content位置，然后把toc.html给include进去，放到content的前面，html代码如下：\n   \n```\ninclude toc.html html=content\n```\n别忘了在左边右边加上大括号和百分号\n\n好了，大功告成。\n\n## PicGo+Github 图床\n\n众所周知，markdown本身并不能存图片，要是想加入图片我们需要添加外链。\n\n在这些图床中我介绍一下GitHub图床，因为GitHub图床基于你自己的GitHub，方便于你自己管理\n\n### 1. 为图床创建GitHub repository\n\n### 2. 生成操作repository的token\n\n- 点击右上角头像\n- 点击settings\n- 点击developer settings\n- 点击Personal access tokens\n- Generate token（这里只需要勾选第一个，所有repo权限即可）把token复制出来，token只会出现一次，可别马上把网站关了\n\n### 3. 安装PicGo\n\n可以去他们的[GitHub](https://github.com/Molunerfinn/picgo/releases)下载，**注意了mac用户你们要下的是dmg版本可不是mac.zip那个**\n\n### 4. 设置PicGo\n\n- 打开PicGo，**Mac用户点了app没反应，看看右上角状态栏里面是不是有PicGo图标，你可以右键-详细窗口**\n- 点开图床设置-GitHub图床\n\n- 仓库名要写全名，比如我的GitHub id是8128，这里就填8128/PicGo（PicGo是我之前新建的repo名）\n- 分支名写master就行，随你\n- token把刚刚复制出来的token粘进去\n\n### 5. 使用PicGo\n\n把图片向状态栏图标拖或者打开详细窗口上传\n\n## 中文字数统计问题\n\n原文： http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/\n\n### 字数统计方法\n\n如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:\n\n- 根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入`charCodeAt()`来判断字符属性是中文还是英文字母, 然后区分计算;\n- 如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;\n- 如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;\n- 如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;\n\n#### jekyll中的词数统计\n\n`number_of_words`是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确…\n\n#### 取巧的统计方式\n\njekyll支持的众多filter中, 有这么一个`size`, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:\n\n```html\n{% raw %}\nApproximate number of English words: {{ text | split: \" \" | size }}\nApproximate number of Chinese words: {{ text | split: \"\" | size }}\n// 可以看到都是近似值~ 如果你对精度要求没那么高, 那么基本是够用了~\n// 实际上, 因为本身size支持文本, 所以对中文这里可以不用split: \"\"的\n{% endraw %}\n```\n\n那么回过头, 我们如果要统计content里面的中文字数就可以利用`size`这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用`strip_html`以及`strip_newlines`两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:\n\n```html\n{% raw %}\n{ { content | strip_html | strip_newlines | size } }\n{% endraw %}\n```\n\n其实在jekyll的github issue中有人已经问过类似的问题[jekyll的中文切分问题](https://github.com/jekyll/jekyll/issues/1921).\n\n### 阅读速度问题\n\n既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用`divided_by`以及`round`两个函数就可以获得一个大致的分钟数了:\n(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)\n\n```html\n{% raw %}\n{ content | strip_html | strip_newlines | size | divided_by:350 | round}}\n{% endraw %}\n```\n\n## 访问统计\n\n家喻户晓的Google analytics就不必多说了，到Google analytics里注册个账号，新建项目，再新建一个web的property，（因为只是个博客，我们没必要用web&app）把设置修改为https，然后将你的GitHub博客url输入进去。随后在该项目的左下角admin设置中，切换到tracking info的tracking code，那里会有一段带有你id的JavaScript代码。\n\n将这代码直接复制到你需要监控的html中head的开头即可，随后便可到google analytics中查询网站的访问情况。建议新建一个tracking.html，存储你的google analytics脚本，随后在模板中的head里include这个tracking.html。\n\n假如你确定了一切无误，但Google analytics的realtime面板中依然毫无信息，无论你在你的Chrome中刷新了多少次——仔细检查一下你是否使用了adblock！据说有些浏览器的do not track也会屏蔽Google analytics的js脚本。检查是否被屏蔽的方法如下：在Chrome中以F12打开开发者面板，在console中检查是否出现\n\n```\nGET https://www.googletagmanager.com/gtag/js?id=你的tracking id\nnet::ERR_BLOCKED_BY_CLIENT\n```\n\n或在network tab下，是否有一个js?id=你的tracking id被blocked\n\n当然，假如你嫌麻烦，不想做统计数据，只是单纯想在你的网站下方加个访问量，就可以直接使用[不蒜子](https://busuanzi.ibruce.info/)，两行代码解决你的需求。\n\n## 常见问题\n\n1. 为什么GitHub提示我有security alert？\n\n```\nWe found a potential security vulnerability in one of your dependencies.\nA dependency defined in ./package-lock.json has known security vulnerabilities \nand should be updated.\n```\n\n而且我根本没有package-lock.json文件？\n\n- homebrew安装node，随后在project路径下npm install即可，会生成package-lock.json file，之后GitHub就不会继续提示你security alert了","source":"_posts/2020-02-03-搭建Jekyll博客技巧集.md","raw":"---\nlayout: post\ntitle:  搭建Jekyll博客技巧集\ndate:   2020-02-03 23:00:00\ndescription: 你是否想为你挂在GitHub的jekyll博客添加什么?\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321010401.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - tips\nauthor: tty\n---\n\n\n\n我个人在建立这个jekyll的博客中还是查询了不少资料的，其中有些已经过时，有些压根不能用。对于那些有用的信息，个人会在下方做一个总结，希望能对各位有所帮助。我会持续更新此blog\n\n## 评论功能\n\n这实际上是jekyll博客最容易添加的功能之一。国外有[Disqus](https://disqus.com/)，国内似乎也有替代产品。添加disqus到你的jekyll博客中是件非常简单的事，你要做的只是登录他们的网站，注册你的账号，然后跟随着他的教程一步一步向下走。\n\n一个小技巧就是把jekyll提供给你的脚本代码写到单独的一个html中，将html放入include文件夹。之后只要在模板中include这个html，你就可以在所有用了这个模板的网页中添加评论区了。\n\n注意，假如你在网上跟着别的教程一步一步走，却发现最终出现在你post下方的不是评论区，而是加载失败的disqus，那么出错的很可能并不是你的tokens，而是你看的教程中的旧版代码。请从复制官方文档中最新的代码。旧版代码会导致disqus加载错误\n\n## 目录功能\n\n如果你想给blog添加目录，你可以在_config.yml中将Jekyll默认Markdown渲染器设置为kramdown。添加方法如下：\n\n_config.yml\n\n```yml\nmarkdown:           kramdown\nkramdown:\n  toc_levels:       1..6 #此行表示从1-6级的标题将被放入目录\n```\n\n随后在文章中标识 toc 的生成位置：\n\n```markdown\n* 目录\n{:toc}\n```\n\n其中，目录这一行是必需的，星号后面的内容则可随意填写。如果要把某标题从目录树中排除，则在该标题的下一行写上 `{:.no_toc}`。默认生成的目录列表会添加 id 值 markdown-toc，我们可以自定义 id 值，比如 {:toc #id}\n\n\n\n如果你不想用kramdown，也不想用js或其他plugin（很多jekyll的plugin被GitHub给屏蔽了），你可以使用[jekyll-toc](https://github.com/allejo/jekyll-toc)，你只需要三步就能解决问题：\n\n1. 下载最新版本的 [`toc.html`](https://github.com/allejo/jekyll-toc/blob/master/_includes/toc.html) 文件（在GitHub仓库的_includes里）\n\n2. 将这个文件放到你的 `_includes` 文件夹去\n\n3. 找到你模板中的content位置，然后把toc.html给include进去，放到content的前面，html代码如下：\n   \n```\ninclude toc.html html=content\n```\n别忘了在左边右边加上大括号和百分号\n\n好了，大功告成。\n\n## PicGo+Github 图床\n\n众所周知，markdown本身并不能存图片，要是想加入图片我们需要添加外链。\n\n在这些图床中我介绍一下GitHub图床，因为GitHub图床基于你自己的GitHub，方便于你自己管理\n\n### 1. 为图床创建GitHub repository\n\n### 2. 生成操作repository的token\n\n- 点击右上角头像\n- 点击settings\n- 点击developer settings\n- 点击Personal access tokens\n- Generate token（这里只需要勾选第一个，所有repo权限即可）把token复制出来，token只会出现一次，可别马上把网站关了\n\n### 3. 安装PicGo\n\n可以去他们的[GitHub](https://github.com/Molunerfinn/picgo/releases)下载，**注意了mac用户你们要下的是dmg版本可不是mac.zip那个**\n\n### 4. 设置PicGo\n\n- 打开PicGo，**Mac用户点了app没反应，看看右上角状态栏里面是不是有PicGo图标，你可以右键-详细窗口**\n- 点开图床设置-GitHub图床\n\n- 仓库名要写全名，比如我的GitHub id是8128，这里就填8128/PicGo（PicGo是我之前新建的repo名）\n- 分支名写master就行，随你\n- token把刚刚复制出来的token粘进去\n\n### 5. 使用PicGo\n\n把图片向状态栏图标拖或者打开详细窗口上传\n\n## 中文字数统计问题\n\n原文： http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/\n\n### 字数统计方法\n\n如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:\n\n- 根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入`charCodeAt()`来判断字符属性是中文还是英文字母, 然后区分计算;\n- 如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;\n- 如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;\n- 如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;\n\n#### jekyll中的词数统计\n\n`number_of_words`是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确…\n\n#### 取巧的统计方式\n\njekyll支持的众多filter中, 有这么一个`size`, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:\n\n```html\n{% raw %}\nApproximate number of English words: {{ text | split: \" \" | size }}\nApproximate number of Chinese words: {{ text | split: \"\" | size }}\n// 可以看到都是近似值~ 如果你对精度要求没那么高, 那么基本是够用了~\n// 实际上, 因为本身size支持文本, 所以对中文这里可以不用split: \"\"的\n{% endraw %}\n```\n\n那么回过头, 我们如果要统计content里面的中文字数就可以利用`size`这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用`strip_html`以及`strip_newlines`两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:\n\n```html\n{% raw %}\n{ { content | strip_html | strip_newlines | size } }\n{% endraw %}\n```\n\n其实在jekyll的github issue中有人已经问过类似的问题[jekyll的中文切分问题](https://github.com/jekyll/jekyll/issues/1921).\n\n### 阅读速度问题\n\n既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用`divided_by`以及`round`两个函数就可以获得一个大致的分钟数了:\n(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)\n\n```html\n{% raw %}\n{ content | strip_html | strip_newlines | size | divided_by:350 | round}}\n{% endraw %}\n```\n\n## 访问统计\n\n家喻户晓的Google analytics就不必多说了，到Google analytics里注册个账号，新建项目，再新建一个web的property，（因为只是个博客，我们没必要用web&app）把设置修改为https，然后将你的GitHub博客url输入进去。随后在该项目的左下角admin设置中，切换到tracking info的tracking code，那里会有一段带有你id的JavaScript代码。\n\n将这代码直接复制到你需要监控的html中head的开头即可，随后便可到google analytics中查询网站的访问情况。建议新建一个tracking.html，存储你的google analytics脚本，随后在模板中的head里include这个tracking.html。\n\n假如你确定了一切无误，但Google analytics的realtime面板中依然毫无信息，无论你在你的Chrome中刷新了多少次——仔细检查一下你是否使用了adblock！据说有些浏览器的do not track也会屏蔽Google analytics的js脚本。检查是否被屏蔽的方法如下：在Chrome中以F12打开开发者面板，在console中检查是否出现\n\n```\nGET https://www.googletagmanager.com/gtag/js?id=你的tracking id\nnet::ERR_BLOCKED_BY_CLIENT\n```\n\n或在network tab下，是否有一个js?id=你的tracking id被blocked\n\n当然，假如你嫌麻烦，不想做统计数据，只是单纯想在你的网站下方加个访问量，就可以直接使用[不蒜子](https://busuanzi.ibruce.info/)，两行代码解决你的需求。\n\n## 常见问题\n\n1. 为什么GitHub提示我有security alert？\n\n```\nWe found a potential security vulnerability in one of your dependencies.\nA dependency defined in ./package-lock.json has known security vulnerabilities \nand should be updated.\n```\n\n而且我根本没有package-lock.json文件？\n\n- homebrew安装node，随后在project路径下npm install即可，会生成package-lock.json file，之后GitHub就不会继续提示你security alert了","slug":"搭建Jekyll博客技巧集","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j5c0004gtvi7cvt5opm","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我个人在建立这个jekyll的博客中还是查询了不少资料的，其中有些已经过时，有些压根不能用。对于那些有用的信息，个人会在下方做一个总结，希望能对各位有所帮助。我会持续更新此blog</p>\n<h2 id=\"评论功能\"><a href=\"#评论功能\" class=\"headerlink\" title=\"评论功能\"></a>评论功能</h2><p>这实际上是jekyll博客最容易添加的功能之一。国外有<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>，国内似乎也有替代产品。添加disqus到你的jekyll博客中是件非常简单的事，你要做的只是登录他们的网站，注册你的账号，然后跟随着他的教程一步一步向下走。</p>\n<p>一个小技巧就是把jekyll提供给你的脚本代码写到单独的一个html中，将html放入include文件夹。之后只要在模板中include这个html，你就可以在所有用了这个模板的网页中添加评论区了。</p>\n<p>注意，假如你在网上跟着别的教程一步一步走，却发现最终出现在你post下方的不是评论区，而是加载失败的disqus，那么出错的很可能并不是你的tokens，而是你看的教程中的旧版代码。请从复制官方文档中最新的代码。旧版代码会导致disqus加载错误</p>\n<h2 id=\"目录功能\"><a href=\"#目录功能\" class=\"headerlink\" title=\"目录功能\"></a>目录功能</h2><p>如果你想给blog添加目录，你可以在_config.yml中将Jekyll默认Markdown渲染器设置为kramdown。添加方法如下：</p>\n<p>_config.yml</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">markdown:</span>           <span class=\"string\">kramdown</span></span><br><span class=\"line\"><span class=\"attr\">kramdown:</span></span><br><span class=\"line\">  <span class=\"attr\">toc_levels:</span>       <span class=\"number\">1</span><span class=\"string\">..6</span> <span class=\"comment\">#此行表示从1-6级的标题将被放入目录</span></span><br></pre></td></tr></table></figure>\n\n<p>随后在文章中标识 toc 的生成位置：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">* </span>目录</span><br><span class=\"line\">&#123;:toc&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，目录这一行是必需的，星号后面的内容则可随意填写。如果要把某标题从目录树中排除，则在该标题的下一行写上 <code>{:.no_toc}</code>。默认生成的目录列表会添加 id 值 markdown-toc，我们可以自定义 id 值，比如 {:toc #id}</p>\n<p>如果你不想用kramdown，也不想用js或其他plugin（很多jekyll的plugin被GitHub给屏蔽了），你可以使用<a href=\"https://github.com/allejo/jekyll-toc\" target=\"_blank\" rel=\"noopener\">jekyll-toc</a>，你只需要三步就能解决问题：</p>\n<ol>\n<li><p>下载最新版本的 <a href=\"https://github.com/allejo/jekyll-toc/blob/master/_includes/toc.html\" target=\"_blank\" rel=\"noopener\"><code>toc.html</code></a> 文件（在GitHub仓库的_includes里）</p>\n</li>\n<li><p>将这个文件放到你的 <code>_includes</code> 文件夹去</p>\n</li>\n<li><p>找到你模板中的content位置，然后把toc.html给include进去，放到content的前面，html代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include toc.html html&#x3D;content</span><br></pre></td></tr></table></figure>\n<p>别忘了在左边右边加上大括号和百分号</p>\n<p>好了，大功告成。</p>\n<h2 id=\"PicGo-Github-图床\"><a href=\"#PicGo-Github-图床\" class=\"headerlink\" title=\"PicGo+Github 图床\"></a>PicGo+Github 图床</h2><p>众所周知，markdown本身并不能存图片，要是想加入图片我们需要添加外链。</p>\n<p>在这些图床中我介绍一下GitHub图床，因为GitHub图床基于你自己的GitHub，方便于你自己管理</p>\n<h3 id=\"1-为图床创建GitHub-repository\"><a href=\"#1-为图床创建GitHub-repository\" class=\"headerlink\" title=\"1. 为图床创建GitHub repository\"></a>1. 为图床创建GitHub repository</h3><h3 id=\"2-生成操作repository的token\"><a href=\"#2-生成操作repository的token\" class=\"headerlink\" title=\"2. 生成操作repository的token\"></a>2. 生成操作repository的token</h3><ul>\n<li>点击右上角头像</li>\n<li>点击settings</li>\n<li>点击developer settings</li>\n<li>点击Personal access tokens</li>\n<li>Generate token（这里只需要勾选第一个，所有repo权限即可）把token复制出来，token只会出现一次，可别马上把网站关了</li>\n</ul>\n<h3 id=\"3-安装PicGo\"><a href=\"#3-安装PicGo\" class=\"headerlink\" title=\"3. 安装PicGo\"></a>3. 安装PicGo</h3><p>可以去他们的<a href=\"https://github.com/Molunerfinn/picgo/releases\" target=\"_blank\" rel=\"noopener\">GitHub</a>下载，<strong>注意了mac用户你们要下的是dmg版本可不是mac.zip那个</strong></p>\n<h3 id=\"4-设置PicGo\"><a href=\"#4-设置PicGo\" class=\"headerlink\" title=\"4. 设置PicGo\"></a>4. 设置PicGo</h3><ul>\n<li><p>打开PicGo，<strong>Mac用户点了app没反应，看看右上角状态栏里面是不是有PicGo图标，你可以右键-详细窗口</strong></p>\n</li>\n<li><p>点开图床设置-GitHub图床</p>\n</li>\n<li><p>仓库名要写全名，比如我的GitHub id是8128，这里就填8128/PicGo（PicGo是我之前新建的repo名）</p>\n</li>\n<li><p>分支名写master就行，随你</p>\n</li>\n<li><p>token把刚刚复制出来的token粘进去</p>\n</li>\n</ul>\n<h3 id=\"5-使用PicGo\"><a href=\"#5-使用PicGo\" class=\"headerlink\" title=\"5. 使用PicGo\"></a>5. 使用PicGo</h3><p>把图片向状态栏图标拖或者打开详细窗口上传</p>\n<h2 id=\"中文字数统计问题\"><a href=\"#中文字数统计问题\" class=\"headerlink\" title=\"中文字数统计问题\"></a>中文字数统计问题</h2><p>原文： <a href=\"http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/\" target=\"_blank\" rel=\"noopener\">http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/</a></p>\n<h3 id=\"字数统计方法\"><a href=\"#字数统计方法\" class=\"headerlink\" title=\"字数统计方法\"></a>字数统计方法</h3><p>如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:</p>\n<ul>\n<li>根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入<code>charCodeAt()</code>来判断字符属性是中文还是英文字母, 然后区分计算;</li>\n<li>如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;</li>\n<li>如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;</li>\n<li>如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;</li>\n</ul>\n<h4 id=\"jekyll中的词数统计\"><a href=\"#jekyll中的词数统计\" class=\"headerlink\" title=\"jekyll中的词数统计\"></a>jekyll中的词数统计</h4><p><code>number_of_words</code>是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确…</p>\n<h4 id=\"取巧的统计方式\"><a href=\"#取巧的统计方式\" class=\"headerlink\" title=\"取巧的统计方式\"></a>取巧的统计方式</h4><p>jekyll支持的众多filter中, 有这么一个<code>size</code>, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">Approximate number of English words: &#123;&#123; text | split: \" \" | size &#125;&#125;</span><br><span class=\"line\">Approximate number of Chinese words: &#123;&#123; text | split: \"\" | size &#125;&#125;</span><br><span class=\"line\">// 可以看到都是近似值~ 如果你对精度要求没那么高, 那么基本是够用了~</span><br><span class=\"line\">// 实际上, 因为本身size支持文本, 所以对中文这里可以不用split: \"\"的</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么回过头, 我们如果要统计content里面的中文字数就可以利用<code>size</code>这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用<code>strip_html</code>以及<code>strip_newlines</code>两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">&#123; &#123; content | strip_html | strip_newlines | size &#125; &#125;</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实在jekyll的github issue中有人已经问过类似的问题<a href=\"https://github.com/jekyll/jekyll/issues/1921\" target=\"_blank\" rel=\"noopener\">jekyll的中文切分问题</a>.</p>\n<h3 id=\"阅读速度问题\"><a href=\"#阅读速度问题\" class=\"headerlink\" title=\"阅读速度问题\"></a>阅读速度问题</h3><p>既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用<code>divided_by</code>以及<code>round</code>两个函数就可以获得一个大致的分钟数了:<br>(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">&#123; content | strip_html | strip_newlines | size | divided_by:350 | round&#125;&#125;</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问统计\"><a href=\"#访问统计\" class=\"headerlink\" title=\"访问统计\"></a>访问统计</h2><p>家喻户晓的Google analytics就不必多说了，到Google analytics里注册个账号，新建项目，再新建一个web的property，（因为只是个博客，我们没必要用web&amp;app）把设置修改为https，然后将你的GitHub博客url输入进去。随后在该项目的左下角admin设置中，切换到tracking info的tracking code，那里会有一段带有你id的JavaScript代码。</p>\n<p>将这代码直接复制到你需要监控的html中head的开头即可，随后便可到google analytics中查询网站的访问情况。建议新建一个tracking.html，存储你的google analytics脚本，随后在模板中的head里include这个tracking.html。</p>\n<p>假如你确定了一切无误，但Google analytics的realtime面板中依然毫无信息，无论你在你的Chrome中刷新了多少次——仔细检查一下你是否使用了adblock！据说有些浏览器的do not track也会屏蔽Google analytics的js脚本。检查是否被屏蔽的方法如下：在Chrome中以F12打开开发者面板，在console中检查是否出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;你的tracking id</span><br><span class=\"line\">net::ERR_BLOCKED_BY_CLIENT</span><br></pre></td></tr></table></figure>\n\n<p>或在network tab下，是否有一个js?id=你的tracking id被blocked</p>\n<p>当然，假如你嫌麻烦，不想做统计数据，只是单纯想在你的网站下方加个访问量，就可以直接使用<a href=\"https://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a>，两行代码解决你的需求。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>为什么GitHub提示我有security alert？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">We found a potential security vulnerability in one of your dependencies.</span><br><span class=\"line\">A dependency defined in .&#x2F;package-lock.json has known security vulnerabilities </span><br><span class=\"line\">and should be updated.</span><br></pre></td></tr></table></figure>\n\n<p>而且我根本没有package-lock.json文件？</p>\n<ul>\n<li>homebrew安装node，随后在project路径下npm install即可，会生成package-lock.json file，之后GitHub就不会继续提示你security alert了</li>\n</ul>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>我个人在建立这个jekyll的博客中还是查询了不少资料的，其中有些已经过时，有些压根不能用。对于那些有用的信息，个人会在下方做一个总结，希望能对各位有所帮助。我会持续更新此blog</p>\n<h2 id=\"评论功能\"><a href=\"#评论功能\" class=\"headerlink\" title=\"评论功能\"></a>评论功能</h2><p>这实际上是jekyll博客最容易添加的功能之一。国外有<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>，国内似乎也有替代产品。添加disqus到你的jekyll博客中是件非常简单的事，你要做的只是登录他们的网站，注册你的账号，然后跟随着他的教程一步一步向下走。</p>\n<p>一个小技巧就是把jekyll提供给你的脚本代码写到单独的一个html中，将html放入include文件夹。之后只要在模板中include这个html，你就可以在所有用了这个模板的网页中添加评论区了。</p>\n<p>注意，假如你在网上跟着别的教程一步一步走，却发现最终出现在你post下方的不是评论区，而是加载失败的disqus，那么出错的很可能并不是你的tokens，而是你看的教程中的旧版代码。请从复制官方文档中最新的代码。旧版代码会导致disqus加载错误</p>\n<h2 id=\"目录功能\"><a href=\"#目录功能\" class=\"headerlink\" title=\"目录功能\"></a>目录功能</h2><p>如果你想给blog添加目录，你可以在_config.yml中将Jekyll默认Markdown渲染器设置为kramdown。添加方法如下：</p>\n<p>_config.yml</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">markdown:</span>           <span class=\"string\">kramdown</span></span><br><span class=\"line\"><span class=\"attr\">kramdown:</span></span><br><span class=\"line\">  <span class=\"attr\">toc_levels:</span>       <span class=\"number\">1</span><span class=\"string\">..6</span> <span class=\"comment\">#此行表示从1-6级的标题将被放入目录</span></span><br></pre></td></tr></table></figure>\n\n<p>随后在文章中标识 toc 的生成位置：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">* </span>目录</span><br><span class=\"line\">&#123;:toc&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，目录这一行是必需的，星号后面的内容则可随意填写。如果要把某标题从目录树中排除，则在该标题的下一行写上 <code>{:.no_toc}</code>。默认生成的目录列表会添加 id 值 markdown-toc，我们可以自定义 id 值，比如 {:toc #id}</p>\n<p>如果你不想用kramdown，也不想用js或其他plugin（很多jekyll的plugin被GitHub给屏蔽了），你可以使用<a href=\"https://github.com/allejo/jekyll-toc\" target=\"_blank\" rel=\"noopener\">jekyll-toc</a>，你只需要三步就能解决问题：</p>\n<ol>\n<li><p>下载最新版本的 <a href=\"https://github.com/allejo/jekyll-toc/blob/master/_includes/toc.html\" target=\"_blank\" rel=\"noopener\"><code>toc.html</code></a> 文件（在GitHub仓库的_includes里）</p>\n</li>\n<li><p>将这个文件放到你的 <code>_includes</code> 文件夹去</p>\n</li>\n<li><p>找到你模板中的content位置，然后把toc.html给include进去，放到content的前面，html代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include toc.html html&#x3D;content</span><br></pre></td></tr></table></figure>\n<p>别忘了在左边右边加上大括号和百分号</p>\n<p>好了，大功告成。</p>\n<h2 id=\"PicGo-Github-图床\"><a href=\"#PicGo-Github-图床\" class=\"headerlink\" title=\"PicGo+Github 图床\"></a>PicGo+Github 图床</h2><p>众所周知，markdown本身并不能存图片，要是想加入图片我们需要添加外链。</p>\n<p>在这些图床中我介绍一下GitHub图床，因为GitHub图床基于你自己的GitHub，方便于你自己管理</p>\n<h3 id=\"1-为图床创建GitHub-repository\"><a href=\"#1-为图床创建GitHub-repository\" class=\"headerlink\" title=\"1. 为图床创建GitHub repository\"></a>1. 为图床创建GitHub repository</h3><h3 id=\"2-生成操作repository的token\"><a href=\"#2-生成操作repository的token\" class=\"headerlink\" title=\"2. 生成操作repository的token\"></a>2. 生成操作repository的token</h3><ul>\n<li>点击右上角头像</li>\n<li>点击settings</li>\n<li>点击developer settings</li>\n<li>点击Personal access tokens</li>\n<li>Generate token（这里只需要勾选第一个，所有repo权限即可）把token复制出来，token只会出现一次，可别马上把网站关了</li>\n</ul>\n<h3 id=\"3-安装PicGo\"><a href=\"#3-安装PicGo\" class=\"headerlink\" title=\"3. 安装PicGo\"></a>3. 安装PicGo</h3><p>可以去他们的<a href=\"https://github.com/Molunerfinn/picgo/releases\" target=\"_blank\" rel=\"noopener\">GitHub</a>下载，<strong>注意了mac用户你们要下的是dmg版本可不是mac.zip那个</strong></p>\n<h3 id=\"4-设置PicGo\"><a href=\"#4-设置PicGo\" class=\"headerlink\" title=\"4. 设置PicGo\"></a>4. 设置PicGo</h3><ul>\n<li><p>打开PicGo，<strong>Mac用户点了app没反应，看看右上角状态栏里面是不是有PicGo图标，你可以右键-详细窗口</strong></p>\n</li>\n<li><p>点开图床设置-GitHub图床</p>\n</li>\n<li><p>仓库名要写全名，比如我的GitHub id是8128，这里就填8128/PicGo（PicGo是我之前新建的repo名）</p>\n</li>\n<li><p>分支名写master就行，随你</p>\n</li>\n<li><p>token把刚刚复制出来的token粘进去</p>\n</li>\n</ul>\n<h3 id=\"5-使用PicGo\"><a href=\"#5-使用PicGo\" class=\"headerlink\" title=\"5. 使用PicGo\"></a>5. 使用PicGo</h3><p>把图片向状态栏图标拖或者打开详细窗口上传</p>\n<h2 id=\"中文字数统计问题\"><a href=\"#中文字数统计问题\" class=\"headerlink\" title=\"中文字数统计问题\"></a>中文字数统计问题</h2><p>原文： <a href=\"http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/\" target=\"_blank\" rel=\"noopener\">http://taoalpha.github.io/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/</a></p>\n<h3 id=\"字数统计方法\"><a href=\"#字数统计方法\" class=\"headerlink\" title=\"字数统计方法\"></a>字数统计方法</h3><p>如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:</p>\n<ul>\n<li>根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入<code>charCodeAt()</code>来判断字符属性是中文还是英文字母, 然后区分计算;</li>\n<li>如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;</li>\n<li>如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;</li>\n<li>如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;</li>\n</ul>\n<h4 id=\"jekyll中的词数统计\"><a href=\"#jekyll中的词数统计\" class=\"headerlink\" title=\"jekyll中的词数统计\"></a>jekyll中的词数统计</h4><p><code>number_of_words</code>是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确…</p>\n<h4 id=\"取巧的统计方式\"><a href=\"#取巧的统计方式\" class=\"headerlink\" title=\"取巧的统计方式\"></a>取巧的统计方式</h4><p>jekyll支持的众多filter中, 有这么一个<code>size</code>, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">Approximate number of English words: &#123;&#123; text | split: \" \" | size &#125;&#125;</span><br><span class=\"line\">Approximate number of Chinese words: &#123;&#123; text | split: \"\" | size &#125;&#125;</span><br><span class=\"line\">// 可以看到都是近似值~ 如果你对精度要求没那么高, 那么基本是够用了~</span><br><span class=\"line\">// 实际上, 因为本身size支持文本, 所以对中文这里可以不用split: \"\"的</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么回过头, 我们如果要统计content里面的中文字数就可以利用<code>size</code>这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用<code>strip_html</code>以及<code>strip_newlines</code>两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">&#123; &#123; content | strip_html | strip_newlines | size &#125; &#125;</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实在jekyll的github issue中有人已经问过类似的问题<a href=\"https://github.com/jekyll/jekyll/issues/1921\" target=\"_blank\" rel=\"noopener\">jekyll的中文切分问题</a>.</p>\n<h3 id=\"阅读速度问题\"><a href=\"#阅读速度问题\" class=\"headerlink\" title=\"阅读速度问题\"></a>阅读速度问题</h3><p>既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用<code>divided_by</code>以及<code>round</code>两个函数就可以获得一个大致的分钟数了:<br>(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% raw %&#125;</span><br><span class=\"line\">&#123; content | strip_html | strip_newlines | size | divided_by:350 | round&#125;&#125;</span><br><span class=\"line\">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问统计\"><a href=\"#访问统计\" class=\"headerlink\" title=\"访问统计\"></a>访问统计</h2><p>家喻户晓的Google analytics就不必多说了，到Google analytics里注册个账号，新建项目，再新建一个web的property，（因为只是个博客，我们没必要用web&amp;app）把设置修改为https，然后将你的GitHub博客url输入进去。随后在该项目的左下角admin设置中，切换到tracking info的tracking code，那里会有一段带有你id的JavaScript代码。</p>\n<p>将这代码直接复制到你需要监控的html中head的开头即可，随后便可到google analytics中查询网站的访问情况。建议新建一个tracking.html，存储你的google analytics脚本，随后在模板中的head里include这个tracking.html。</p>\n<p>假如你确定了一切无误，但Google analytics的realtime面板中依然毫无信息，无论你在你的Chrome中刷新了多少次——仔细检查一下你是否使用了adblock！据说有些浏览器的do not track也会屏蔽Google analytics的js脚本。检查是否被屏蔽的方法如下：在Chrome中以F12打开开发者面板，在console中检查是否出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;你的tracking id</span><br><span class=\"line\">net::ERR_BLOCKED_BY_CLIENT</span><br></pre></td></tr></table></figure>\n\n<p>或在network tab下，是否有一个js?id=你的tracking id被blocked</p>\n<p>当然，假如你嫌麻烦，不想做统计数据，只是单纯想在你的网站下方加个访问量，就可以直接使用<a href=\"https://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a>，两行代码解决你的需求。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>为什么GitHub提示我有security alert？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">We found a potential security vulnerability in one of your dependencies.</span><br><span class=\"line\">A dependency defined in .&#x2F;package-lock.json has known security vulnerabilities </span><br><span class=\"line\">and should be updated.</span><br></pre></td></tr></table></figure>\n\n<p>而且我根本没有package-lock.json文件？</p>\n<ul>\n<li>homebrew安装node，随后在project路径下npm install即可，会生成package-lock.json file，之后GitHub就不会继续提示你security alert了</li>\n</ul>\n"},{"layout":"post","title":"旧金山准独角兽面试之行","date":"2020-02-04T09:00:00.000Z","description":"三番两日游","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321010044.png","optimized_image":null,"author":"tty","_content":"\n## 面试前\n\n首先是要介绍下这家公司，blend。你们可以在[Blend](https://blend.com/)找到更加详细的资料。它是一家fin-tech初创公司，主要业务是做SaaS，给银行提供些贷款方向的服务。\n\n个人觉得这家公司和我有些谜一般的缘分。大概在十月的时候我突然在垃圾邮箱里发现了他们HR的邮件，说是我被内推成功了并过了简历关，若我对他们公司仍旧感兴趣的话，就会给我发OA(Online Assessment)。这是我第一次险些错失机会，因为当时我看到这封垃圾邮件的时候它已经快被系统自动删除了。我赶紧联系了HR并做完了OA。不多久之后便被告知将会有一轮HR电话面和两轮技术电话面试。\n\n对于HR面和第一轮电面，我都没什么好说的，hr就是聊聊天，技术面也是洒洒水（其实我第一轮面的是这公司为数不多的非面经题，而且是这公司top3难度的题，还好我是老hashmap玩家了，三下五除二给做出来了……）可就在第一轮电面之后，HR忽然迷之消失。我给HR发邮件询问情况，收到个自动回复的邮件说她在training program，没法回复消息……以至于第二轮的时间被延迟，拖到了感恩节附近。约第二次面试时，HR问了我什么时候有空，并告知我她prefer the week after thanks giving。我便回复了她我的空闲时间，她也随后通知了我安排后的日期。当时我瞥了眼邮件，看到是周一，也就理所当然觉得是感恩节后的周一，毕竟她“prefer the week after thanks giving”。谁料在感恩节前的那个周一，我突然收到了个电话。我当时还在睡觉，迷糊着看到来电来自CA，于是一个鲤鱼打挺坐了起来，接起了电话。沉默一段时间后，尴尬的对话开始了，大概如下：\n\n我：你哪位？\n\n面试官：在下是blend的面试官。how's your day?\n\n我：等等，你再说一遍？beg your pardon？？？\n\n面试官：我是来自blend的面试官。\n\n我：不对啊，我面试约的是下周，你是不是搞错了（理直气壮，大声驳斥）\n\n面试官：oh that's interesting， 我去问问HR。\n\n然后电话就在我自信的质问中结束了。随即我立刻去查了邮箱，发现约的时间确实在感恩节之前……只好立刻发了封道歉信给HR并询问能不能reschedule调整时间，好在HR还是通情达理帮忙改了时间，第二轮电话面试在十二月终于面上了。\n\n面完之后一周，我正坐地铁呢，翻开手机一看看到封blend拒信，人直接呆滞了。我寻思着我面得挺好的啊，一看说是position filled，那属实没有办法了。这也不是我遇到的第一家position filled的公司了，我自己还错过了一次面试，也怪不得别人。于是我沮丧的关掉了那封邮件，却发现在那邮件之前，有个blend发的before you come onsite……\n\n我缓缓打出一个问号，这到底是要面我还是不要面我啊？我立刻发了个邮件去问HR到底是咋回事。HR跟我说那个拒信发错了。嗯，从Bloomberg到Amazon再到blend，这大家的HR都身手不凡啊……\n\nHR说发错了，那就是还有面试呗，我就接着等。可是等着等着等过了圣诞都没有任何动静。期间我还给HR发了个邮件询问到底有没有onsite，她也没有给我答复。直到一月我忍无可忍联系了我的内推人了。内推人表示系统显示我应该onsite了，说她会帮我联系看看。在她的联络下，HR终于再次联系了我。\n\nHR表示她早就给我发了邮件了——我明明有天天查邮箱啊！spam我也每天查看！可能邮箱系统被黑客袭击了吧，那封邮件寄到异世界去了。\n\n在HR的安排下onsite最初被安排在了一月中。可不久之后HR又告知我一月底高盛开会没酒店能订了。磨蹭来磨蹭去，最终时间终于定在Jan 23。\n\n## 面试中\n\n作为一家初创公司，blend拥有一座downtown的五层小写字楼。这座楼不大但挺精致，就在Chinatown边上，其背后便是一个小公园。HR安排的两晚的住宿也就在Chinatown门口。对于这次面试，我并不是很紧张。自从挂掉Bloomberg的面试之后我就意外的不再面试紧张了。\n\n于是进了大楼，和等在那的HR寒暄了几句，就被领去面试了。Blend的面试轮数出人意外的多，四轮技术面一轮manager面，题倒是不难，medium为主，掺杂OOD和改版hard。面到一半，中午会去顶楼吃饭。陪我吃饭的是个国人学姐，她告诉我今天有一个大组出门offsite去开卡丁车了，严厉的面试官都在那个组里。我心中大喜，差点没笑出声。大概因此我也自信了不少，下午面试一路顺利。\n\n不过很尴尬的一件事就是每个面试官都会进来问一句，“How are you doing today?”我就回答“Great!”，然后他们就会说，“Wow you are so confident!”……那我怎么回答嘛，难道应该回答bad嘛。\n\n## 面试后\n\n离开办公楼直接叫上小伙伴出门自由行去了。我们从Chinatown附近一路闲逛到了渔人码头，再从渔人码头一路走向了金门大桥。来到金门大桥的时候已是一片漆黑，我俩也累得不行，留了几张照片，叫了辆uber便回家了。\n\n![Golden Bridge](https://raw.githubusercontent.com/8128/PicGo/master/20200321010853.png)\n\n第二日我俩清早起来便用zipcar租了辆SUV，开始在旧金山溜达。旧金山这个地方到处都是小山坡，整个城市就在山上，简直就是手动挡噩梦。尽管我们租的自动挡，开起车来还是有些慌。我们先去小山头眺望了眼恶魔岛，随后又前往了花街与twin peaks俯瞰了旧金山。\n\n![AlcatrazIsland](https://raw.githubusercontent.com/8128/PicGo/master/20200321010921.png)\n\n![LombardStreet](https://raw.githubusercontent.com/8128/PicGo/master/20200321010951.png)\n\n因为HR给我订的返程机票是在中午，所以十一点左右我便还了车回了酒店。万万没想到，打车去机场的时候竟然遇到了昨晚半夜从金门大桥送我们回来的同一个uber司机。我一开始并没有认出他来，反而是他突然问了句，“Where is your friend?”，我当时惊了，傻不拉几的问了句“Who?” “The guy who came back with you last night! I'm the driver who drove you back!” 我这才查了下uber app，发现真是同一个人……司机也惊奇地告诉我，我是他昨天最后一单也是今天第一单，他这么多年头一次遇见送同一个人back-to-back。\n\n到了机场之后，安检的时候大家向外拿电脑，后面的人的电脑上赫然就是Blend的贴纸，而且跟我第二轮面试官一样也是金发。我又不能确定是不是那位面试官，就瑟瑟发抖不敢说话（主要是尬聊能力太差）我就赶紧在微信上问内推的学姐我那面试官在公司不。学姐让我放心，金发小哥还在公司，我才松了口气……学姐还告诉我金发小哥正在和其他面试官sync最终结果，说有消息会告诉我一声。没多久后我便收到了学姐发来的通过的消息。当时还是很激动的。\n\n学姐此前告诉我她第五个最终面才拿到offer，我发现我也是第五个最终面才真正拿到offer。WHAT A COINCIDENCE！\n\n尽管后来手机收到消息说飞机晚点了370分钟。Damn，应该在旧金山多玩一会的……\n\n## 回家\n\n在返程的路上遇到了一个西语司机。司机问我去哪儿了，我回答我去面试了。\n\n“那么你一定通过了面试了，我能看得出来。”他说。我笑着点头，问他为何这么认为，他说：\n\n“I know, I konw......You guys are smart. Today everything is made in China...”\n\n我只好笑而不语……他紧接着就说他儿子是技校出生的水管工，现在想转而当程序员……说得我一脸震惊，真就万物转CS呗。他说他儿子觉得现在的生活不体面，想去上大学读软件工程，但是即使大学有奖学金，大学的学费也还是很贵（我问了一句结果发现是10000刀，害老哥，我们都是这样过来的啊，该投资要投资的）\n\n我略加思索，然后轰出一堆很打击人的话，什么我投了五百家公司，然后只收到十家面试，只过了最后这一家之类的。（实际上没投这么多，不过比例确实相似）还有啥中美贸易战，饭碗都被打飞了云云……然后他又问了问我的薪资，这我倒没说谎。现在想来我有点刻薄，是不是应该多加鼓励的？自己在寒冬冻着了，就劝别人都别来滑雪了\n\n最终大叔把我送到家楼下，问我有什么建议能给他儿子。\n\n“多刷题，看算法。公司就爱考那玩意。”我说。","source":"_posts/2020-02-03-旧金山准独角兽面试之行.md","raw":"---\nlayout: post\ntitle:  旧金山准独角兽面试之行\ndate:   2020-02-04 01:00:00\ndescription: 三番两日游\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321010044.png\noptimized_image: \ncategory: travel\ntags:\n  - travel\n  - blog\nauthor: tty\n---\n\n## 面试前\n\n首先是要介绍下这家公司，blend。你们可以在[Blend](https://blend.com/)找到更加详细的资料。它是一家fin-tech初创公司，主要业务是做SaaS，给银行提供些贷款方向的服务。\n\n个人觉得这家公司和我有些谜一般的缘分。大概在十月的时候我突然在垃圾邮箱里发现了他们HR的邮件，说是我被内推成功了并过了简历关，若我对他们公司仍旧感兴趣的话，就会给我发OA(Online Assessment)。这是我第一次险些错失机会，因为当时我看到这封垃圾邮件的时候它已经快被系统自动删除了。我赶紧联系了HR并做完了OA。不多久之后便被告知将会有一轮HR电话面和两轮技术电话面试。\n\n对于HR面和第一轮电面，我都没什么好说的，hr就是聊聊天，技术面也是洒洒水（其实我第一轮面的是这公司为数不多的非面经题，而且是这公司top3难度的题，还好我是老hashmap玩家了，三下五除二给做出来了……）可就在第一轮电面之后，HR忽然迷之消失。我给HR发邮件询问情况，收到个自动回复的邮件说她在training program，没法回复消息……以至于第二轮的时间被延迟，拖到了感恩节附近。约第二次面试时，HR问了我什么时候有空，并告知我她prefer the week after thanks giving。我便回复了她我的空闲时间，她也随后通知了我安排后的日期。当时我瞥了眼邮件，看到是周一，也就理所当然觉得是感恩节后的周一，毕竟她“prefer the week after thanks giving”。谁料在感恩节前的那个周一，我突然收到了个电话。我当时还在睡觉，迷糊着看到来电来自CA，于是一个鲤鱼打挺坐了起来，接起了电话。沉默一段时间后，尴尬的对话开始了，大概如下：\n\n我：你哪位？\n\n面试官：在下是blend的面试官。how's your day?\n\n我：等等，你再说一遍？beg your pardon？？？\n\n面试官：我是来自blend的面试官。\n\n我：不对啊，我面试约的是下周，你是不是搞错了（理直气壮，大声驳斥）\n\n面试官：oh that's interesting， 我去问问HR。\n\n然后电话就在我自信的质问中结束了。随即我立刻去查了邮箱，发现约的时间确实在感恩节之前……只好立刻发了封道歉信给HR并询问能不能reschedule调整时间，好在HR还是通情达理帮忙改了时间，第二轮电话面试在十二月终于面上了。\n\n面完之后一周，我正坐地铁呢，翻开手机一看看到封blend拒信，人直接呆滞了。我寻思着我面得挺好的啊，一看说是position filled，那属实没有办法了。这也不是我遇到的第一家position filled的公司了，我自己还错过了一次面试，也怪不得别人。于是我沮丧的关掉了那封邮件，却发现在那邮件之前，有个blend发的before you come onsite……\n\n我缓缓打出一个问号，这到底是要面我还是不要面我啊？我立刻发了个邮件去问HR到底是咋回事。HR跟我说那个拒信发错了。嗯，从Bloomberg到Amazon再到blend，这大家的HR都身手不凡啊……\n\nHR说发错了，那就是还有面试呗，我就接着等。可是等着等着等过了圣诞都没有任何动静。期间我还给HR发了个邮件询问到底有没有onsite，她也没有给我答复。直到一月我忍无可忍联系了我的内推人了。内推人表示系统显示我应该onsite了，说她会帮我联系看看。在她的联络下，HR终于再次联系了我。\n\nHR表示她早就给我发了邮件了——我明明有天天查邮箱啊！spam我也每天查看！可能邮箱系统被黑客袭击了吧，那封邮件寄到异世界去了。\n\n在HR的安排下onsite最初被安排在了一月中。可不久之后HR又告知我一月底高盛开会没酒店能订了。磨蹭来磨蹭去，最终时间终于定在Jan 23。\n\n## 面试中\n\n作为一家初创公司，blend拥有一座downtown的五层小写字楼。这座楼不大但挺精致，就在Chinatown边上，其背后便是一个小公园。HR安排的两晚的住宿也就在Chinatown门口。对于这次面试，我并不是很紧张。自从挂掉Bloomberg的面试之后我就意外的不再面试紧张了。\n\n于是进了大楼，和等在那的HR寒暄了几句，就被领去面试了。Blend的面试轮数出人意外的多，四轮技术面一轮manager面，题倒是不难，medium为主，掺杂OOD和改版hard。面到一半，中午会去顶楼吃饭。陪我吃饭的是个国人学姐，她告诉我今天有一个大组出门offsite去开卡丁车了，严厉的面试官都在那个组里。我心中大喜，差点没笑出声。大概因此我也自信了不少，下午面试一路顺利。\n\n不过很尴尬的一件事就是每个面试官都会进来问一句，“How are you doing today?”我就回答“Great!”，然后他们就会说，“Wow you are so confident!”……那我怎么回答嘛，难道应该回答bad嘛。\n\n## 面试后\n\n离开办公楼直接叫上小伙伴出门自由行去了。我们从Chinatown附近一路闲逛到了渔人码头，再从渔人码头一路走向了金门大桥。来到金门大桥的时候已是一片漆黑，我俩也累得不行，留了几张照片，叫了辆uber便回家了。\n\n![Golden Bridge](https://raw.githubusercontent.com/8128/PicGo/master/20200321010853.png)\n\n第二日我俩清早起来便用zipcar租了辆SUV，开始在旧金山溜达。旧金山这个地方到处都是小山坡，整个城市就在山上，简直就是手动挡噩梦。尽管我们租的自动挡，开起车来还是有些慌。我们先去小山头眺望了眼恶魔岛，随后又前往了花街与twin peaks俯瞰了旧金山。\n\n![AlcatrazIsland](https://raw.githubusercontent.com/8128/PicGo/master/20200321010921.png)\n\n![LombardStreet](https://raw.githubusercontent.com/8128/PicGo/master/20200321010951.png)\n\n因为HR给我订的返程机票是在中午，所以十一点左右我便还了车回了酒店。万万没想到，打车去机场的时候竟然遇到了昨晚半夜从金门大桥送我们回来的同一个uber司机。我一开始并没有认出他来，反而是他突然问了句，“Where is your friend?”，我当时惊了，傻不拉几的问了句“Who?” “The guy who came back with you last night! I'm the driver who drove you back!” 我这才查了下uber app，发现真是同一个人……司机也惊奇地告诉我，我是他昨天最后一单也是今天第一单，他这么多年头一次遇见送同一个人back-to-back。\n\n到了机场之后，安检的时候大家向外拿电脑，后面的人的电脑上赫然就是Blend的贴纸，而且跟我第二轮面试官一样也是金发。我又不能确定是不是那位面试官，就瑟瑟发抖不敢说话（主要是尬聊能力太差）我就赶紧在微信上问内推的学姐我那面试官在公司不。学姐让我放心，金发小哥还在公司，我才松了口气……学姐还告诉我金发小哥正在和其他面试官sync最终结果，说有消息会告诉我一声。没多久后我便收到了学姐发来的通过的消息。当时还是很激动的。\n\n学姐此前告诉我她第五个最终面才拿到offer，我发现我也是第五个最终面才真正拿到offer。WHAT A COINCIDENCE！\n\n尽管后来手机收到消息说飞机晚点了370分钟。Damn，应该在旧金山多玩一会的……\n\n## 回家\n\n在返程的路上遇到了一个西语司机。司机问我去哪儿了，我回答我去面试了。\n\n“那么你一定通过了面试了，我能看得出来。”他说。我笑着点头，问他为何这么认为，他说：\n\n“I know, I konw......You guys are smart. Today everything is made in China...”\n\n我只好笑而不语……他紧接着就说他儿子是技校出生的水管工，现在想转而当程序员……说得我一脸震惊，真就万物转CS呗。他说他儿子觉得现在的生活不体面，想去上大学读软件工程，但是即使大学有奖学金，大学的学费也还是很贵（我问了一句结果发现是10000刀，害老哥，我们都是这样过来的啊，该投资要投资的）\n\n我略加思索，然后轰出一堆很打击人的话，什么我投了五百家公司，然后只收到十家面试，只过了最后这一家之类的。（实际上没投这么多，不过比例确实相似）还有啥中美贸易战，饭碗都被打飞了云云……然后他又问了问我的薪资，这我倒没说谎。现在想来我有点刻薄，是不是应该多加鼓励的？自己在寒冬冻着了，就劝别人都别来滑雪了\n\n最终大叔把我送到家楼下，问我有什么建议能给他儿子。\n\n“多刷题，看算法。公司就爱考那玩意。”我说。","slug":"旧金山准独角兽面试之行","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j5d0005gtvi3pxl3qlw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"面试前\"><a href=\"#面试前\" class=\"headerlink\" title=\"面试前\"></a>面试前</h2><p>首先是要介绍下这家公司，blend。你们可以在<a href=\"https://blend.com/\" target=\"_blank\" rel=\"noopener\">Blend</a>找到更加详细的资料。它是一家fin-tech初创公司，主要业务是做SaaS，给银行提供些贷款方向的服务。</p>\n<p>个人觉得这家公司和我有些谜一般的缘分。大概在十月的时候我突然在垃圾邮箱里发现了他们HR的邮件，说是我被内推成功了并过了简历关，若我对他们公司仍旧感兴趣的话，就会给我发OA(Online Assessment)。这是我第一次险些错失机会，因为当时我看到这封垃圾邮件的时候它已经快被系统自动删除了。我赶紧联系了HR并做完了OA。不多久之后便被告知将会有一轮HR电话面和两轮技术电话面试。</p>\n<p>对于HR面和第一轮电面，我都没什么好说的，hr就是聊聊天，技术面也是洒洒水（其实我第一轮面的是这公司为数不多的非面经题，而且是这公司top3难度的题，还好我是老hashmap玩家了，三下五除二给做出来了……）可就在第一轮电面之后，HR忽然迷之消失。我给HR发邮件询问情况，收到个自动回复的邮件说她在training program，没法回复消息……以至于第二轮的时间被延迟，拖到了感恩节附近。约第二次面试时，HR问了我什么时候有空，并告知我她prefer the week after thanks giving。我便回复了她我的空闲时间，她也随后通知了我安排后的日期。当时我瞥了眼邮件，看到是周一，也就理所当然觉得是感恩节后的周一，毕竟她“prefer the week after thanks giving”。谁料在感恩节前的那个周一，我突然收到了个电话。我当时还在睡觉，迷糊着看到来电来自CA，于是一个鲤鱼打挺坐了起来，接起了电话。沉默一段时间后，尴尬的对话开始了，大概如下：</p>\n<p>我：你哪位？</p>\n<p>面试官：在下是blend的面试官。how’s your day?</p>\n<p>我：等等，你再说一遍？beg your pardon？？？</p>\n<p>面试官：我是来自blend的面试官。</p>\n<p>我：不对啊，我面试约的是下周，你是不是搞错了（理直气壮，大声驳斥）</p>\n<p>面试官：oh that’s interesting， 我去问问HR。</p>\n<p>然后电话就在我自信的质问中结束了。随即我立刻去查了邮箱，发现约的时间确实在感恩节之前……只好立刻发了封道歉信给HR并询问能不能reschedule调整时间，好在HR还是通情达理帮忙改了时间，第二轮电话面试在十二月终于面上了。</p>\n<p>面完之后一周，我正坐地铁呢，翻开手机一看看到封blend拒信，人直接呆滞了。我寻思着我面得挺好的啊，一看说是position filled，那属实没有办法了。这也不是我遇到的第一家position filled的公司了，我自己还错过了一次面试，也怪不得别人。于是我沮丧的关掉了那封邮件，却发现在那邮件之前，有个blend发的before you come onsite……</p>\n<p>我缓缓打出一个问号，这到底是要面我还是不要面我啊？我立刻发了个邮件去问HR到底是咋回事。HR跟我说那个拒信发错了。嗯，从Bloomberg到Amazon再到blend，这大家的HR都身手不凡啊……</p>\n<p>HR说发错了，那就是还有面试呗，我就接着等。可是等着等着等过了圣诞都没有任何动静。期间我还给HR发了个邮件询问到底有没有onsite，她也没有给我答复。直到一月我忍无可忍联系了我的内推人了。内推人表示系统显示我应该onsite了，说她会帮我联系看看。在她的联络下，HR终于再次联系了我。</p>\n<p>HR表示她早就给我发了邮件了——我明明有天天查邮箱啊！spam我也每天查看！可能邮箱系统被黑客袭击了吧，那封邮件寄到异世界去了。</p>\n<p>在HR的安排下onsite最初被安排在了一月中。可不久之后HR又告知我一月底高盛开会没酒店能订了。磨蹭来磨蹭去，最终时间终于定在Jan 23。</p>\n<h2 id=\"面试中\"><a href=\"#面试中\" class=\"headerlink\" title=\"面试中\"></a>面试中</h2><p>作为一家初创公司，blend拥有一座downtown的五层小写字楼。这座楼不大但挺精致，就在Chinatown边上，其背后便是一个小公园。HR安排的两晚的住宿也就在Chinatown门口。对于这次面试，我并不是很紧张。自从挂掉Bloomberg的面试之后我就意外的不再面试紧张了。</p>\n<p>于是进了大楼，和等在那的HR寒暄了几句，就被领去面试了。Blend的面试轮数出人意外的多，四轮技术面一轮manager面，题倒是不难，medium为主，掺杂OOD和改版hard。面到一半，中午会去顶楼吃饭。陪我吃饭的是个国人学姐，她告诉我今天有一个大组出门offsite去开卡丁车了，严厉的面试官都在那个组里。我心中大喜，差点没笑出声。大概因此我也自信了不少，下午面试一路顺利。</p>\n<p>不过很尴尬的一件事就是每个面试官都会进来问一句，“How are you doing today?”我就回答“Great!”，然后他们就会说，“Wow you are so confident!”……那我怎么回答嘛，难道应该回答bad嘛。</p>\n<h2 id=\"面试后\"><a href=\"#面试后\" class=\"headerlink\" title=\"面试后\"></a>面试后</h2><p>离开办公楼直接叫上小伙伴出门自由行去了。我们从Chinatown附近一路闲逛到了渔人码头，再从渔人码头一路走向了金门大桥。来到金门大桥的时候已是一片漆黑，我俩也累得不行，留了几张照片，叫了辆uber便回家了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010853.png\"  alt=\"Golden Bridge\"></p>\n<p>第二日我俩清早起来便用zipcar租了辆SUV，开始在旧金山溜达。旧金山这个地方到处都是小山坡，整个城市就在山上，简直就是手动挡噩梦。尽管我们租的自动挡，开起车来还是有些慌。我们先去小山头眺望了眼恶魔岛，随后又前往了花街与twin peaks俯瞰了旧金山。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010921.png\"  alt=\"AlcatrazIsland\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010951.png\"  alt=\"LombardStreet\"></p>\n<p>因为HR给我订的返程机票是在中午，所以十一点左右我便还了车回了酒店。万万没想到，打车去机场的时候竟然遇到了昨晚半夜从金门大桥送我们回来的同一个uber司机。我一开始并没有认出他来，反而是他突然问了句，“Where is your friend?”，我当时惊了，傻不拉几的问了句“Who?” “The guy who came back with you last night! I’m the driver who drove you back!” 我这才查了下uber app，发现真是同一个人……司机也惊奇地告诉我，我是他昨天最后一单也是今天第一单，他这么多年头一次遇见送同一个人back-to-back。</p>\n<p>到了机场之后，安检的时候大家向外拿电脑，后面的人的电脑上赫然就是Blend的贴纸，而且跟我第二轮面试官一样也是金发。我又不能确定是不是那位面试官，就瑟瑟发抖不敢说话（主要是尬聊能力太差）我就赶紧在微信上问内推的学姐我那面试官在公司不。学姐让我放心，金发小哥还在公司，我才松了口气……学姐还告诉我金发小哥正在和其他面试官sync最终结果，说有消息会告诉我一声。没多久后我便收到了学姐发来的通过的消息。当时还是很激动的。</p>\n<p>学姐此前告诉我她第五个最终面才拿到offer，我发现我也是第五个最终面才真正拿到offer。WHAT A COINCIDENCE！</p>\n<p>尽管后来手机收到消息说飞机晚点了370分钟。Damn，应该在旧金山多玩一会的……</p>\n<h2 id=\"回家\"><a href=\"#回家\" class=\"headerlink\" title=\"回家\"></a>回家</h2><p>在返程的路上遇到了一个西语司机。司机问我去哪儿了，我回答我去面试了。</p>\n<p>“那么你一定通过了面试了，我能看得出来。”他说。我笑着点头，问他为何这么认为，他说：</p>\n<p>“I know, I konw……You guys are smart. Today everything is made in China…”</p>\n<p>我只好笑而不语……他紧接着就说他儿子是技校出生的水管工，现在想转而当程序员……说得我一脸震惊，真就万物转CS呗。他说他儿子觉得现在的生活不体面，想去上大学读软件工程，但是即使大学有奖学金，大学的学费也还是很贵（我问了一句结果发现是10000刀，害老哥，我们都是这样过来的啊，该投资要投资的）</p>\n<p>我略加思索，然后轰出一堆很打击人的话，什么我投了五百家公司，然后只收到十家面试，只过了最后这一家之类的。（实际上没投这么多，不过比例确实相似）还有啥中美贸易战，饭碗都被打飞了云云……然后他又问了问我的薪资，这我倒没说谎。现在想来我有点刻薄，是不是应该多加鼓励的？自己在寒冬冻着了，就劝别人都别来滑雪了</p>\n<p>最终大叔把我送到家楼下，问我有什么建议能给他儿子。</p>\n<p>“多刷题，看算法。公司就爱考那玩意。”我说。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<h2 id=\"面试前\"><a href=\"#面试前\" class=\"headerlink\" title=\"面试前\"></a>面试前</h2><p>首先是要介绍下这家公司，blend。你们可以在<a href=\"https://blend.com/\" target=\"_blank\" rel=\"noopener\">Blend</a>找到更加详细的资料。它是一家fin-tech初创公司，主要业务是做SaaS，给银行提供些贷款方向的服务。</p>\n<p>个人觉得这家公司和我有些谜一般的缘分。大概在十月的时候我突然在垃圾邮箱里发现了他们HR的邮件，说是我被内推成功了并过了简历关，若我对他们公司仍旧感兴趣的话，就会给我发OA(Online Assessment)。这是我第一次险些错失机会，因为当时我看到这封垃圾邮件的时候它已经快被系统自动删除了。我赶紧联系了HR并做完了OA。不多久之后便被告知将会有一轮HR电话面和两轮技术电话面试。</p>\n<p>对于HR面和第一轮电面，我都没什么好说的，hr就是聊聊天，技术面也是洒洒水（其实我第一轮面的是这公司为数不多的非面经题，而且是这公司top3难度的题，还好我是老hashmap玩家了，三下五除二给做出来了……）可就在第一轮电面之后，HR忽然迷之消失。我给HR发邮件询问情况，收到个自动回复的邮件说她在training program，没法回复消息……以至于第二轮的时间被延迟，拖到了感恩节附近。约第二次面试时，HR问了我什么时候有空，并告知我她prefer the week after thanks giving。我便回复了她我的空闲时间，她也随后通知了我安排后的日期。当时我瞥了眼邮件，看到是周一，也就理所当然觉得是感恩节后的周一，毕竟她“prefer the week after thanks giving”。谁料在感恩节前的那个周一，我突然收到了个电话。我当时还在睡觉，迷糊着看到来电来自CA，于是一个鲤鱼打挺坐了起来，接起了电话。沉默一段时间后，尴尬的对话开始了，大概如下：</p>\n<p>我：你哪位？</p>\n<p>面试官：在下是blend的面试官。how’s your day?</p>\n<p>我：等等，你再说一遍？beg your pardon？？？</p>\n<p>面试官：我是来自blend的面试官。</p>\n<p>我：不对啊，我面试约的是下周，你是不是搞错了（理直气壮，大声驳斥）</p>\n<p>面试官：oh that’s interesting， 我去问问HR。</p>\n<p>然后电话就在我自信的质问中结束了。随即我立刻去查了邮箱，发现约的时间确实在感恩节之前……只好立刻发了封道歉信给HR并询问能不能reschedule调整时间，好在HR还是通情达理帮忙改了时间，第二轮电话面试在十二月终于面上了。</p>\n<p>面完之后一周，我正坐地铁呢，翻开手机一看看到封blend拒信，人直接呆滞了。我寻思着我面得挺好的啊，一看说是position filled，那属实没有办法了。这也不是我遇到的第一家position filled的公司了，我自己还错过了一次面试，也怪不得别人。于是我沮丧的关掉了那封邮件，却发现在那邮件之前，有个blend发的before you come onsite……</p>\n<p>我缓缓打出一个问号，这到底是要面我还是不要面我啊？我立刻发了个邮件去问HR到底是咋回事。HR跟我说那个拒信发错了。嗯，从Bloomberg到Amazon再到blend，这大家的HR都身手不凡啊……</p>\n<p>HR说发错了，那就是还有面试呗，我就接着等。可是等着等着等过了圣诞都没有任何动静。期间我还给HR发了个邮件询问到底有没有onsite，她也没有给我答复。直到一月我忍无可忍联系了我的内推人了。内推人表示系统显示我应该onsite了，说她会帮我联系看看。在她的联络下，HR终于再次联系了我。</p>\n<p>HR表示她早就给我发了邮件了——我明明有天天查邮箱啊！spam我也每天查看！可能邮箱系统被黑客袭击了吧，那封邮件寄到异世界去了。</p>\n<p>在HR的安排下onsite最初被安排在了一月中。可不久之后HR又告知我一月底高盛开会没酒店能订了。磨蹭来磨蹭去，最终时间终于定在Jan 23。</p>\n<h2 id=\"面试中\"><a href=\"#面试中\" class=\"headerlink\" title=\"面试中\"></a>面试中</h2><p>作为一家初创公司，blend拥有一座downtown的五层小写字楼。这座楼不大但挺精致，就在Chinatown边上，其背后便是一个小公园。HR安排的两晚的住宿也就在Chinatown门口。对于这次面试，我并不是很紧张。自从挂掉Bloomberg的面试之后我就意外的不再面试紧张了。</p>\n<p>于是进了大楼，和等在那的HR寒暄了几句，就被领去面试了。Blend的面试轮数出人意外的多，四轮技术面一轮manager面，题倒是不难，medium为主，掺杂OOD和改版hard。面到一半，中午会去顶楼吃饭。陪我吃饭的是个国人学姐，她告诉我今天有一个大组出门offsite去开卡丁车了，严厉的面试官都在那个组里。我心中大喜，差点没笑出声。大概因此我也自信了不少，下午面试一路顺利。</p>\n<p>不过很尴尬的一件事就是每个面试官都会进来问一句，“How are you doing today?”我就回答“Great!”，然后他们就会说，“Wow you are so confident!”……那我怎么回答嘛，难道应该回答bad嘛。</p>\n<h2 id=\"面试后\"><a href=\"#面试后\" class=\"headerlink\" title=\"面试后\"></a>面试后</h2><p>离开办公楼直接叫上小伙伴出门自由行去了。我们从Chinatown附近一路闲逛到了渔人码头，再从渔人码头一路走向了金门大桥。来到金门大桥的时候已是一片漆黑，我俩也累得不行，留了几张照片，叫了辆uber便回家了。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010853.png\" alt=\"Golden Bridge\"></p>\n<p>第二日我俩清早起来便用zipcar租了辆SUV，开始在旧金山溜达。旧金山这个地方到处都是小山坡，整个城市就在山上，简直就是手动挡噩梦。尽管我们租的自动挡，开起车来还是有些慌。我们先去小山头眺望了眼恶魔岛，随后又前往了花街与twin peaks俯瞰了旧金山。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010921.png\" alt=\"AlcatrazIsland\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321010951.png\" alt=\"LombardStreet\"></p>\n<p>因为HR给我订的返程机票是在中午，所以十一点左右我便还了车回了酒店。万万没想到，打车去机场的时候竟然遇到了昨晚半夜从金门大桥送我们回来的同一个uber司机。我一开始并没有认出他来，反而是他突然问了句，“Where is your friend?”，我当时惊了，傻不拉几的问了句“Who?” “The guy who came back with you last night! I’m the driver who drove you back!” 我这才查了下uber app，发现真是同一个人……司机也惊奇地告诉我，我是他昨天最后一单也是今天第一单，他这么多年头一次遇见送同一个人back-to-back。</p>\n<p>到了机场之后，安检的时候大家向外拿电脑，后面的人的电脑上赫然就是Blend的贴纸，而且跟我第二轮面试官一样也是金发。我又不能确定是不是那位面试官，就瑟瑟发抖不敢说话（主要是尬聊能力太差）我就赶紧在微信上问内推的学姐我那面试官在公司不。学姐让我放心，金发小哥还在公司，我才松了口气……学姐还告诉我金发小哥正在和其他面试官sync最终结果，说有消息会告诉我一声。没多久后我便收到了学姐发来的通过的消息。当时还是很激动的。</p>\n<p>学姐此前告诉我她第五个最终面才拿到offer，我发现我也是第五个最终面才真正拿到offer。WHAT A COINCIDENCE！</p>\n<p>尽管后来手机收到消息说飞机晚点了370分钟。Damn，应该在旧金山多玩一会的……</p>\n<h2 id=\"回家\"><a href=\"#回家\" class=\"headerlink\" title=\"回家\"></a>回家</h2><p>在返程的路上遇到了一个西语司机。司机问我去哪儿了，我回答我去面试了。</p>\n<p>“那么你一定通过了面试了，我能看得出来。”他说。我笑着点头，问他为何这么认为，他说：</p>\n<p>“I know, I konw……You guys are smart. Today everything is made in China…”</p>\n<p>我只好笑而不语……他紧接着就说他儿子是技校出生的水管工，现在想转而当程序员……说得我一脸震惊，真就万物转CS呗。他说他儿子觉得现在的生活不体面，想去上大学读软件工程，但是即使大学有奖学金，大学的学费也还是很贵（我问了一句结果发现是10000刀，害老哥，我们都是这样过来的啊，该投资要投资的）</p>\n<p>我略加思索，然后轰出一堆很打击人的话，什么我投了五百家公司，然后只收到十家面试，只过了最后这一家之类的。（实际上没投这么多，不过比例确实相似）还有啥中美贸易战，饭碗都被打飞了云云……然后他又问了问我的薪资，这我倒没说谎。现在想来我有点刻薄，是不是应该多加鼓励的？自己在寒冬冻着了，就劝别人都别来滑雪了</p>\n<p>最终大叔把我送到家楼下，问我有什么建议能给他儿子。</p>\n<p>“多刷题，看算法。公司就爱考那玩意。”我说。</p>\n"},{"layout":"post","title":"初创企业股票基础知识","date":"2020-02-20T20:00:00.000Z","description":"什么是期权stock options？什么是限制性股票单位RSU？如何比较startup的offer？在接受股票之前要问什么？","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321005721.png","optimized_image":null,"author":"Human Interest","_content":"\n本文翻译自翻译自[Human Interest](https://humaninterest.com/blog/startup-equity-basics-ask-stock-accept/)，原作者Anisha Sekar\n\n修正了google translate中出现的语病和错译\n\n---\n\n\n\n您已经从一家初创公司那里获得了一份报价，作为薪酬待遇的一部分，您将在薪水之上获取公司股票。恭喜你！在你变成星星眼之前，您需要仔细评估报。您应该能够准确地评估offer股权的（潜在）价值，以将其和你的其他offer做比较，并利用您的理解来潜在地协商更高的薪水。我们将介绍startup股权的基本知识，您应该提出的问题，以及如何并行比较报价。\n\n## 股票基础：了解startup的股票\n\n顾名思义，股票可以使持有人拥有公司的一部分。如果一家公司有10,000股流通在外股票（shares outstanding），那么如果成功退出（successful exit），则每股股票将赋予所有者0.01％的公司收购价；如果公司成功上市，则每股0.01％的股份所有权；或者……不幸的是，如果startup失败了，则几乎没有收益。\n\n### 谁在创业公司中获得股份？\n\n私人初创公司的股东通常分为以下三类之一：\n\n- **创始人**：最初，创始人控制着公司100％的股份。随着时间的流逝，他们很可能会控制更少的股票，因为他们以出让股票为代价来换取金钱或劳动力。\n- **投资者**：风险资本家以一定数量的股份作为投资回报。随着公司筹集更多的资金，它将向投资者发行更多的股票，从而稀释了之前投资的所有人的股票。（不过，这不一定是一件坏事，因为该公司大概会用这笔钱来为每个人增加蛋糕）。\n- **员工**：就是你！通常情况下，你的股票将被*授予* （vested）——不是立即让所有的股份，他们将发放出过一段时间来激励你留下来与你的雇主。\n\n\n\n### 每股（share）价值多少？\n\n如果您持有一家上市公司的股份，您很快就会知道它的价值：您所要做的就是查找股票代码，以查看股份的交易价格。例如，您可以通过搜索“ TSLA”来查找特斯拉股票的价值。对于私营公司而言，这要困难得多（而且充满术语）。为了评估其价值，私营公司将进行409A估值（409A valuation），其中第三方基本上会估算该公司的价值。要确定股票的当前价值（称为公平市价 fair market value，即FMV），就用估值除以流通股数。\n\n例如，如果一家公司的价值为100万美元，并且有100,000股流通在外，则每股FMV为10美元。如果同一家公司有50,000股流通在外股票，则FMV为20美元。如您所见，计数的是*相对*股份数量，而不是*绝对*数量。要约10,000股流通100,000股的要约与20,000股流通200,000股的要约值完全相同。在409a估值和流通股之间，您可以确定多少股票值得。\n\n### 股权授予与股票期权（Grants versus options）\n\n在录取通知书中，您可能会获得股票授予（stock grant），股票期权（stock options）或两者的结合。\n\n**股权授予**Equity grant**（RSU）：** 股票授予（通常也称为限制性股票单位Restricted Stock Unit， RSU）非常简单：这意味着您可以在归属时直接获得股票。这对于非常早期的初创公司来说更为常见，因为这些公司的股份价值很少，因此更容易直接发行。但是，以免您担心初创公司股权的任何部分都太简单了，其中有很多初次创业的创始人都不了解的主要财务考虑。当您收到股票时，您将需要考虑向IRS提交填写83（b）。83（b）允许您在授予您的权益（when equity is granted to you）时向您征税，而不是在真正授予（vest）时。根据您的财务状况和创业公司的增长前景，提交83（b）可能会节省数千美元。您可以阅读有关83（b）的更多信息[在这里](https://www.cooleygo.com/what-is-a-section-83b-election/) ; 目前，需要注意的重要一点是，您必须在发行股票后**30天内**提交83（b），因此您需要立即考虑税收问题。\n\n**股票期权**Stock options**（ISO和NSO / NQSO）**：股票期权通常分为激励性股票期权（Incentive Stock Options）和不合格的股票期权（Non-qualified Stock Options）（[有关两者之间差异的更多信息](http://www.startupcompanylawyer.com/2008/03/05/whats-the-difference-between-an-iso-and-an-nso/)）。无论使用哪种方式，都可以选择以后购买股票。您将预先获得*行使价*（*exercise price*），这是您需要支付的股票价格。在您担任雇员期间，公司的价值将上升，因此您将能够以低于其实际价值的价格购买股票。有时，您的行使价会低于股票的当前价格，这会愈发增加你手中期权的价值。\n\n## 在评估股票期权时，您应该问什么问题？\n\n假设您收到的报价包含10,000股。这是您应该向您的潜在雇主提出的关键问题。\n\n### 有多少流通股（How many shares are outstanding）？\n\n如前所述，绝对股数无关紧要——您需要知道总股本的百分比。一些公司将发行大量股票，以使它们的报价看起来更令人印象深刻，因此不要被众多公司愚弄。如果公司不公开流通股数量，那将是一个很大的危险信号。\n\n### 董事会最近一次普通股评估（common stock appraisal）是什么？  \n\n如果您要购买股票期权，您的offer可能没有明确说明行使价。但是，这个数字将为您提供一个不错的指导，假设未来FMV会增加，您可以行使多少期权以及潜在的上涨空间。\n\n### 公司目前的估值是多少？\n\n加上发行在外的股票数量，您将可以了解股票的价值，无论是它们将以赠款还是认股权形式被赠予您。\n\n### 归属时间表（vesting schedule）是什么？\n\n为了激励您坚持下去，大多数公司会根据归属时间表发放股票或期权。最常见的时间表是，在您开始一年后拥有25％的期权，然后在每个月给你1/48的股份（这意味着四年后您将拥有所有的期权，或者被*完全归属*fully vested）。在您达到某个里程碑之前，这种保留期权的做法被称为*归属悬崖*（*vesting cliff*）。\n\n### 如果公司被收购（acquired）或我离开，将会发生什么？\n\n如果被公司收购，某些公司将允许加速归属（vest），这意味着您将在收购时或几个月后获得所有剩余股份。如果您不想最终被大公司收购，这可能会有所帮助。\n\n另一方面，如果您离开公司，通常会保留当前已授予的股份和/或期权。通常，您必须在设定的时间段内（通常在离开后90天之内）行使这些选择。但是要当心：有些公司保留以行使价（exercise price）回购您的期权的权利，这意味着您从这些期权中没有任何价值。要记住的另一件重要事情是，您在行使期权时（而不是在实际出售股票时）可能必须为期权缴纳税款。\n\n假设您有1,000股股票，当前价值为5美元，行使价为1美元。您将于2010年离开公司并行使股票。2016年，您以每股7美元的价格出售股票。在某些情况下，您将在行权时对估值与行使价之间的差额征税–也就是说，您将在2010年支付4,000美元（即1,000股*）（5美元的估值– 1美元的行使价）的税。2016年，则您应就所卖出的价格与其行使价之间的差额缴纳税款-即2,000美元或1,000股*（$ 7卖出-行使价$ 5）。\n\n额外的4000美元应纳税所得额-根据2016年替代性最低税支付的1,120美元税款-似乎并不可怕，但如果您拥有大量股权，则税收负担的确会相当沉重。您不仅要行使期权（行使价乘以股票数量），还要对尚未行使的期权征税。确保您有足够的钱来支付这些费用；否则，您可能必须出售股票来支付行使股票的成本，并且您的税率会更高。查阅[本指南](https://blog.wealthfront.com/when-to-exercise-stock-options/)，了解您的选择以了解更多信息-这是您值得花费的时间。\n\n### 您打算什么时候筹集下一轮资金（raise your next round of funding）？\n\n如前所述，投资者需要股票来换取资金。如果您的公司有100,000股流通在外的股票，并向您提供1,000股，那么您将获得公司的1％。但是，如果公司计划再进行一轮融资，它很快就会发现自己拥有20万股流通股。您的1,000股的价值将减少一半。\n\n### 你的退出策略是什么（exit strategy）？\n\n如果公司计划收购或很快上市，那么您的股票更有价值。并非所有公司都会为您提供此信息，但是了解这一点很有帮助。\n\n当然，这并不是一个详尽的问题清单，但足以让您了解您的股票或期权的价值，以及您对它们的价值的确定性。\n\n## 比较报价\n\n好的，这是向您抛出的许多信息。让我们来看一个具体的示例，比较初创公司BookFace和Moogle的报价。我们将不断汇总每个报价的“价值”。\n\n**BookFace：** 100,000美元的薪水，10,000股和5,000个期权\n\n**Moogle：**年薪140,000美元，6,000股和2,000个期权\n\n### 薪水\n\n这很简单，将提供我们进行比较的基础。\n\n**BookFace：** 100,000美元的薪水\n\n**Moogle：**年薪140,000美元\n\n### 分享\n\n现在您知道了如何评估股票赠款，现在就向BookFace和Moogle询问他们最近的409a估值以及多少流通股。BookFace告诉您，它有1000万流通股，价值为5000万美元。Moogle不会告诉您其估值，但会告诉您其股票的公平市值为4美元。\n\n**BookFace：** $100,000薪水+ $5,000万估值/ 1,000万股流通股*所发行的10,000股= $100,000+ $50,000= $150,000\n\n**Moogle：**薪金$ 140,000 + $ 4 FMV * 6,000股= $ 140,000 + $ 24,000 = $ 164,000\n\n### 股票期权\n\n现在，您问公司这些股票期权的行权价（exercise price）是多少。两者都将行使价定为1美元。您已经知道Moogle股票的近似值（4美元），但是要回到BookFace的股票中，您可以将估值除以发行在外的股票数量。这使您的每股收益为5美元。\n\n**BookFace：** $100,000薪水+ $50,000赠送股票+ 5,000个期权*（$5 FMV - $1行使价）= $150,000+ $20,000= $170,000\n\n**Moogle：** $ 140,000薪金+ $ 24,000赠送股票+ 2,000个期权*（$ 4 FMV – $ 1行使价）= $ 164,000 + $ 6,000 = $ 170,000\n\n在这个示例中，BookFace和Moogle的报价“价值”相同。让我们深入研究改变其价值的模糊因素。\n\n### 定性因素\n\n- **公司成长有多快？**如果您在一家如火箭般快速上升的公司工作，那最好是用股票而不是工资（这是BookFace的报价）来补偿。如果它很快就要进行收购或IPO，那么您的股票很可能会很有价值。\n- **公司是否计划尽快筹集资金？**如果是这样，您的股票将被摊薄（diluted），您应相应地对赠款和期权进行贬值。\n- **归属时间表（**vesting schedule**）是什么？**对自己诚实：您打算在公司呆多长时间？初创公司员工的平均任期[仅为10.8个月](http://www.theatlantic.com/business/archive/2014/12/statistically-speaking-what-does-the-average-startup-look-like/384019/)，因此您很可能没有足够长的时间来完全归属（fully vest）。在这种情况下，更快归属的公司，或是优先考虑薪资而不是股票的公司，会更有价值。\n- **还提供什么其他好处？**健康和残障保险，育儿假（parental leave），401（k）（尤其是如果[与雇主匹配的话](https://humaninterest.com/blog/is-a-401k-match-contribution-tax-deductible/)），通勤津贴（commuter benefits）和免费餐食（free meals）也可以影响您的决定。\n\n\n\n最后一个问题是您必须问自己：您需要多少收入保障（income security）？股票是高风险，高回报的主张。您的股份可能会变得一文不值，或者使您成为百万富翁。另一方面，工资是可靠的。如果您的财务状况不安全，承担大量债务（抵押，学生贷款债务，家庭），或者想规避风险，则可能要优先考虑薪资而不是股票。\n\n相较于用来比较startup offer或股权中的所有术语和数字，你的决定可能取决于更软的因素，例如，您对公司成功的信心到底有多深。\n\n## 如何计税？\n\n原文自[一亩三分地](https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=138822&extra=page%3D1%26filter%3Dsortid%26sortid%3D320%26sortid%3D320)，原作者[wzf1943](https://www.1point3acres.com/bbs/space-uid-42994.html)，修正了错误\n\n期权有很多种，市场上公开交易的期权和公司期权也有不少区别，但是本质都是以固定价格购买（卖出）股票的权利。\n\n目前创业公司发Stock Option主要有两类\n\n- ISO(Incentive Stock Option)\n- NSO(Non-Qualified Stock Option)\n\n两者在计税方面有很大区别。不过趋势是越来越多创业公司选择NSO作为Stock Option的发放方式。\n\n先讲一讲Stock Option的大致阶段：\n\n- 你被公司录用，然后被赋予相当数量的期权。比如，可以用$5/股的行权价购买10000股的Option。\n- 被赋予的期权都有一个分配的时间表，主流做法也是工作满一年拿到25%，之后36个月每月拿到剩余的1/36\n- 在某个时间点，你决定行使期权的权利，也就是以行权价购买公司股票。可以在同时、或之后把行权所得的股票卖出，获得利润。\n\n先看NSO，计税不算复杂：阶段1-2不涉及实权兑现，因此不交税。阶段3行权且有潜在的利润，按收入税计税。\n\n> 假设小明加入一家创业公司，获得NSO，可以用行权价$5/股的价格购买10000股。再假设公司四年后上市，股价变成$25/股。\n>\n> 此时，小明所有期权都已被分配。进入阶段3：可以行使所有期权，其潜在收益是 ($25 - $5) * 10000 ＝ $200,000. 税额按收入税计算，外加州税，基本上需要交税一半左右($100,000)。外加行使权需要$5 * 10000 = $50000，总费用是$150,000，天价。更常见的做法是：小明可以选择只行使一部分期权，比如2000. 那么相应的总潜在收益是($25 - $5) * 2000 = $40000. 相应的，由于总收益的降低，计算收入税的税额就可能应用低一档的税率，可以省%4左右的税率。\n\n然后是ISO. 咳咳咳...为了不把本文变成没完没了的税法说明，小编建议有需要的读者自行搜索以下关键字：ISO, AMT, Tech Bubble, Bankcruptcy...没错，2000年大泡沫中破产的人大部分都是拜ISO中产生的AMT税所赐，故事非常精彩，祝大家阅读愉快。\n\n\n\n写了这么多，估计很多读者没有心思读完全文，直接跳到结论。那好，小编给你个总结一下：\n\n- 如果公司提供了RSU，很好，你不需要多想，老老实实待满年头，坐等拿股票卖钱，如果你在加州，做好心里准备：基本上一半的收入去交税。\n- 如果公司提供的是Stock Option，并且是NSO。你能做的也不太多，等公司上市后，好好盘算自己的收入，每年选择一部分Option行权并卖出股票获利。如果控制得当，税可能比RSU略少。\n- 如果公司提供的是Stock Option，并且是ISO, 除非是极早期员工，否则请谨慎使用早起行权(early exercise)，建议做决定前先咨询专业税务人员。\n\n无论是RSU/Option, 只要公司没有办法上市或者被收购，或者你在此之前已经离开，这些RSU/Option则分文不值。（事实上并非如此，有的公司允许你买卖期权或是买卖你手中的股票，你需要向HR问清楚这些细节）\n\n同样，高风险意味着高回报。创业公司给员工提供的RSU/Option要远比大公司慷慨，你只要熬到公司上市或被收购，回报自然丰厚","source":"_posts/2020-02-20-初创企业股票基础知识.md","raw":"---\nlayout: post\ntitle:  初创企业股票基础知识\ndate:   2020-02-20 12:00:00\ndescription: 什么是期权stock options？什么是限制性股票单位RSU？如何比较startup的offer？在接受股票之前要问什么？\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321005721.png\noptimized_image: \ncategory: financial\ntags:\n  - tutorial\n  - financial\nauthor: Human Interest\n---\n\n本文翻译自翻译自[Human Interest](https://humaninterest.com/blog/startup-equity-basics-ask-stock-accept/)，原作者Anisha Sekar\n\n修正了google translate中出现的语病和错译\n\n---\n\n\n\n您已经从一家初创公司那里获得了一份报价，作为薪酬待遇的一部分，您将在薪水之上获取公司股票。恭喜你！在你变成星星眼之前，您需要仔细评估报。您应该能够准确地评估offer股权的（潜在）价值，以将其和你的其他offer做比较，并利用您的理解来潜在地协商更高的薪水。我们将介绍startup股权的基本知识，您应该提出的问题，以及如何并行比较报价。\n\n## 股票基础：了解startup的股票\n\n顾名思义，股票可以使持有人拥有公司的一部分。如果一家公司有10,000股流通在外股票（shares outstanding），那么如果成功退出（successful exit），则每股股票将赋予所有者0.01％的公司收购价；如果公司成功上市，则每股0.01％的股份所有权；或者……不幸的是，如果startup失败了，则几乎没有收益。\n\n### 谁在创业公司中获得股份？\n\n私人初创公司的股东通常分为以下三类之一：\n\n- **创始人**：最初，创始人控制着公司100％的股份。随着时间的流逝，他们很可能会控制更少的股票，因为他们以出让股票为代价来换取金钱或劳动力。\n- **投资者**：风险资本家以一定数量的股份作为投资回报。随着公司筹集更多的资金，它将向投资者发行更多的股票，从而稀释了之前投资的所有人的股票。（不过，这不一定是一件坏事，因为该公司大概会用这笔钱来为每个人增加蛋糕）。\n- **员工**：就是你！通常情况下，你的股票将被*授予* （vested）——不是立即让所有的股份，他们将发放出过一段时间来激励你留下来与你的雇主。\n\n\n\n### 每股（share）价值多少？\n\n如果您持有一家上市公司的股份，您很快就会知道它的价值：您所要做的就是查找股票代码，以查看股份的交易价格。例如，您可以通过搜索“ TSLA”来查找特斯拉股票的价值。对于私营公司而言，这要困难得多（而且充满术语）。为了评估其价值，私营公司将进行409A估值（409A valuation），其中第三方基本上会估算该公司的价值。要确定股票的当前价值（称为公平市价 fair market value，即FMV），就用估值除以流通股数。\n\n例如，如果一家公司的价值为100万美元，并且有100,000股流通在外，则每股FMV为10美元。如果同一家公司有50,000股流通在外股票，则FMV为20美元。如您所见，计数的是*相对*股份数量，而不是*绝对*数量。要约10,000股流通100,000股的要约与20,000股流通200,000股的要约值完全相同。在409a估值和流通股之间，您可以确定多少股票值得。\n\n### 股权授予与股票期权（Grants versus options）\n\n在录取通知书中，您可能会获得股票授予（stock grant），股票期权（stock options）或两者的结合。\n\n**股权授予**Equity grant**（RSU）：** 股票授予（通常也称为限制性股票单位Restricted Stock Unit， RSU）非常简单：这意味着您可以在归属时直接获得股票。这对于非常早期的初创公司来说更为常见，因为这些公司的股份价值很少，因此更容易直接发行。但是，以免您担心初创公司股权的任何部分都太简单了，其中有很多初次创业的创始人都不了解的主要财务考虑。当您收到股票时，您将需要考虑向IRS提交填写83（b）。83（b）允许您在授予您的权益（when equity is granted to you）时向您征税，而不是在真正授予（vest）时。根据您的财务状况和创业公司的增长前景，提交83（b）可能会节省数千美元。您可以阅读有关83（b）的更多信息[在这里](https://www.cooleygo.com/what-is-a-section-83b-election/) ; 目前，需要注意的重要一点是，您必须在发行股票后**30天内**提交83（b），因此您需要立即考虑税收问题。\n\n**股票期权**Stock options**（ISO和NSO / NQSO）**：股票期权通常分为激励性股票期权（Incentive Stock Options）和不合格的股票期权（Non-qualified Stock Options）（[有关两者之间差异的更多信息](http://www.startupcompanylawyer.com/2008/03/05/whats-the-difference-between-an-iso-and-an-nso/)）。无论使用哪种方式，都可以选择以后购买股票。您将预先获得*行使价*（*exercise price*），这是您需要支付的股票价格。在您担任雇员期间，公司的价值将上升，因此您将能够以低于其实际价值的价格购买股票。有时，您的行使价会低于股票的当前价格，这会愈发增加你手中期权的价值。\n\n## 在评估股票期权时，您应该问什么问题？\n\n假设您收到的报价包含10,000股。这是您应该向您的潜在雇主提出的关键问题。\n\n### 有多少流通股（How many shares are outstanding）？\n\n如前所述，绝对股数无关紧要——您需要知道总股本的百分比。一些公司将发行大量股票，以使它们的报价看起来更令人印象深刻，因此不要被众多公司愚弄。如果公司不公开流通股数量，那将是一个很大的危险信号。\n\n### 董事会最近一次普通股评估（common stock appraisal）是什么？  \n\n如果您要购买股票期权，您的offer可能没有明确说明行使价。但是，这个数字将为您提供一个不错的指导，假设未来FMV会增加，您可以行使多少期权以及潜在的上涨空间。\n\n### 公司目前的估值是多少？\n\n加上发行在外的股票数量，您将可以了解股票的价值，无论是它们将以赠款还是认股权形式被赠予您。\n\n### 归属时间表（vesting schedule）是什么？\n\n为了激励您坚持下去，大多数公司会根据归属时间表发放股票或期权。最常见的时间表是，在您开始一年后拥有25％的期权，然后在每个月给你1/48的股份（这意味着四年后您将拥有所有的期权，或者被*完全归属*fully vested）。在您达到某个里程碑之前，这种保留期权的做法被称为*归属悬崖*（*vesting cliff*）。\n\n### 如果公司被收购（acquired）或我离开，将会发生什么？\n\n如果被公司收购，某些公司将允许加速归属（vest），这意味着您将在收购时或几个月后获得所有剩余股份。如果您不想最终被大公司收购，这可能会有所帮助。\n\n另一方面，如果您离开公司，通常会保留当前已授予的股份和/或期权。通常，您必须在设定的时间段内（通常在离开后90天之内）行使这些选择。但是要当心：有些公司保留以行使价（exercise price）回购您的期权的权利，这意味着您从这些期权中没有任何价值。要记住的另一件重要事情是，您在行使期权时（而不是在实际出售股票时）可能必须为期权缴纳税款。\n\n假设您有1,000股股票，当前价值为5美元，行使价为1美元。您将于2010年离开公司并行使股票。2016年，您以每股7美元的价格出售股票。在某些情况下，您将在行权时对估值与行使价之间的差额征税–也就是说，您将在2010年支付4,000美元（即1,000股*）（5美元的估值– 1美元的行使价）的税。2016年，则您应就所卖出的价格与其行使价之间的差额缴纳税款-即2,000美元或1,000股*（$ 7卖出-行使价$ 5）。\n\n额外的4000美元应纳税所得额-根据2016年替代性最低税支付的1,120美元税款-似乎并不可怕，但如果您拥有大量股权，则税收负担的确会相当沉重。您不仅要行使期权（行使价乘以股票数量），还要对尚未行使的期权征税。确保您有足够的钱来支付这些费用；否则，您可能必须出售股票来支付行使股票的成本，并且您的税率会更高。查阅[本指南](https://blog.wealthfront.com/when-to-exercise-stock-options/)，了解您的选择以了解更多信息-这是您值得花费的时间。\n\n### 您打算什么时候筹集下一轮资金（raise your next round of funding）？\n\n如前所述，投资者需要股票来换取资金。如果您的公司有100,000股流通在外的股票，并向您提供1,000股，那么您将获得公司的1％。但是，如果公司计划再进行一轮融资，它很快就会发现自己拥有20万股流通股。您的1,000股的价值将减少一半。\n\n### 你的退出策略是什么（exit strategy）？\n\n如果公司计划收购或很快上市，那么您的股票更有价值。并非所有公司都会为您提供此信息，但是了解这一点很有帮助。\n\n当然，这并不是一个详尽的问题清单，但足以让您了解您的股票或期权的价值，以及您对它们的价值的确定性。\n\n## 比较报价\n\n好的，这是向您抛出的许多信息。让我们来看一个具体的示例，比较初创公司BookFace和Moogle的报价。我们将不断汇总每个报价的“价值”。\n\n**BookFace：** 100,000美元的薪水，10,000股和5,000个期权\n\n**Moogle：**年薪140,000美元，6,000股和2,000个期权\n\n### 薪水\n\n这很简单，将提供我们进行比较的基础。\n\n**BookFace：** 100,000美元的薪水\n\n**Moogle：**年薪140,000美元\n\n### 分享\n\n现在您知道了如何评估股票赠款，现在就向BookFace和Moogle询问他们最近的409a估值以及多少流通股。BookFace告诉您，它有1000万流通股，价值为5000万美元。Moogle不会告诉您其估值，但会告诉您其股票的公平市值为4美元。\n\n**BookFace：** $100,000薪水+ $5,000万估值/ 1,000万股流通股*所发行的10,000股= $100,000+ $50,000= $150,000\n\n**Moogle：**薪金$ 140,000 + $ 4 FMV * 6,000股= $ 140,000 + $ 24,000 = $ 164,000\n\n### 股票期权\n\n现在，您问公司这些股票期权的行权价（exercise price）是多少。两者都将行使价定为1美元。您已经知道Moogle股票的近似值（4美元），但是要回到BookFace的股票中，您可以将估值除以发行在外的股票数量。这使您的每股收益为5美元。\n\n**BookFace：** $100,000薪水+ $50,000赠送股票+ 5,000个期权*（$5 FMV - $1行使价）= $150,000+ $20,000= $170,000\n\n**Moogle：** $ 140,000薪金+ $ 24,000赠送股票+ 2,000个期权*（$ 4 FMV – $ 1行使价）= $ 164,000 + $ 6,000 = $ 170,000\n\n在这个示例中，BookFace和Moogle的报价“价值”相同。让我们深入研究改变其价值的模糊因素。\n\n### 定性因素\n\n- **公司成长有多快？**如果您在一家如火箭般快速上升的公司工作，那最好是用股票而不是工资（这是BookFace的报价）来补偿。如果它很快就要进行收购或IPO，那么您的股票很可能会很有价值。\n- **公司是否计划尽快筹集资金？**如果是这样，您的股票将被摊薄（diluted），您应相应地对赠款和期权进行贬值。\n- **归属时间表（**vesting schedule**）是什么？**对自己诚实：您打算在公司呆多长时间？初创公司员工的平均任期[仅为10.8个月](http://www.theatlantic.com/business/archive/2014/12/statistically-speaking-what-does-the-average-startup-look-like/384019/)，因此您很可能没有足够长的时间来完全归属（fully vest）。在这种情况下，更快归属的公司，或是优先考虑薪资而不是股票的公司，会更有价值。\n- **还提供什么其他好处？**健康和残障保险，育儿假（parental leave），401（k）（尤其是如果[与雇主匹配的话](https://humaninterest.com/blog/is-a-401k-match-contribution-tax-deductible/)），通勤津贴（commuter benefits）和免费餐食（free meals）也可以影响您的决定。\n\n\n\n最后一个问题是您必须问自己：您需要多少收入保障（income security）？股票是高风险，高回报的主张。您的股份可能会变得一文不值，或者使您成为百万富翁。另一方面，工资是可靠的。如果您的财务状况不安全，承担大量债务（抵押，学生贷款债务，家庭），或者想规避风险，则可能要优先考虑薪资而不是股票。\n\n相较于用来比较startup offer或股权中的所有术语和数字，你的决定可能取决于更软的因素，例如，您对公司成功的信心到底有多深。\n\n## 如何计税？\n\n原文自[一亩三分地](https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=138822&extra=page%3D1%26filter%3Dsortid%26sortid%3D320%26sortid%3D320)，原作者[wzf1943](https://www.1point3acres.com/bbs/space-uid-42994.html)，修正了错误\n\n期权有很多种，市场上公开交易的期权和公司期权也有不少区别，但是本质都是以固定价格购买（卖出）股票的权利。\n\n目前创业公司发Stock Option主要有两类\n\n- ISO(Incentive Stock Option)\n- NSO(Non-Qualified Stock Option)\n\n两者在计税方面有很大区别。不过趋势是越来越多创业公司选择NSO作为Stock Option的发放方式。\n\n先讲一讲Stock Option的大致阶段：\n\n- 你被公司录用，然后被赋予相当数量的期权。比如，可以用$5/股的行权价购买10000股的Option。\n- 被赋予的期权都有一个分配的时间表，主流做法也是工作满一年拿到25%，之后36个月每月拿到剩余的1/36\n- 在某个时间点，你决定行使期权的权利，也就是以行权价购买公司股票。可以在同时、或之后把行权所得的股票卖出，获得利润。\n\n先看NSO，计税不算复杂：阶段1-2不涉及实权兑现，因此不交税。阶段3行权且有潜在的利润，按收入税计税。\n\n> 假设小明加入一家创业公司，获得NSO，可以用行权价$5/股的价格购买10000股。再假设公司四年后上市，股价变成$25/股。\n>\n> 此时，小明所有期权都已被分配。进入阶段3：可以行使所有期权，其潜在收益是 ($25 - $5) * 10000 ＝ $200,000. 税额按收入税计算，外加州税，基本上需要交税一半左右($100,000)。外加行使权需要$5 * 10000 = $50000，总费用是$150,000，天价。更常见的做法是：小明可以选择只行使一部分期权，比如2000. 那么相应的总潜在收益是($25 - $5) * 2000 = $40000. 相应的，由于总收益的降低，计算收入税的税额就可能应用低一档的税率，可以省%4左右的税率。\n\n然后是ISO. 咳咳咳...为了不把本文变成没完没了的税法说明，小编建议有需要的读者自行搜索以下关键字：ISO, AMT, Tech Bubble, Bankcruptcy...没错，2000年大泡沫中破产的人大部分都是拜ISO中产生的AMT税所赐，故事非常精彩，祝大家阅读愉快。\n\n\n\n写了这么多，估计很多读者没有心思读完全文，直接跳到结论。那好，小编给你个总结一下：\n\n- 如果公司提供了RSU，很好，你不需要多想，老老实实待满年头，坐等拿股票卖钱，如果你在加州，做好心里准备：基本上一半的收入去交税。\n- 如果公司提供的是Stock Option，并且是NSO。你能做的也不太多，等公司上市后，好好盘算自己的收入，每年选择一部分Option行权并卖出股票获利。如果控制得当，税可能比RSU略少。\n- 如果公司提供的是Stock Option，并且是ISO, 除非是极早期员工，否则请谨慎使用早起行权(early exercise)，建议做决定前先咨询专业税务人员。\n\n无论是RSU/Option, 只要公司没有办法上市或者被收购，或者你在此之前已经离开，这些RSU/Option则分文不值。（事实上并非如此，有的公司允许你买卖期权或是买卖你手中的股票，你需要向HR问清楚这些细节）\n\n同样，高风险意味着高回报。创业公司给员工提供的RSU/Option要远比大公司慷慨，你只要熬到公司上市或被收购，回报自然丰厚","slug":"初创企业股票基础知识","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j5e0006gtvi09lp7lb2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本文翻译自翻译自<a href=\"https://humaninterest.com/blog/startup-equity-basics-ask-stock-accept/\" target=\"_blank\" rel=\"noopener\">Human Interest</a>，原作者Anisha Sekar</p>\n<p>修正了google translate中出现的语病和错译</p>\n<hr>\n<p>您已经从一家初创公司那里获得了一份报价，作为薪酬待遇的一部分，您将在薪水之上获取公司股票。恭喜你！在你变成星星眼之前，您需要仔细评估报。您应该能够准确地评估offer股权的（潜在）价值，以将其和你的其他offer做比较，并利用您的理解来潜在地协商更高的薪水。我们将介绍startup股权的基本知识，您应该提出的问题，以及如何并行比较报价。</p>\n<h2 id=\"股票基础：了解startup的股票\"><a href=\"#股票基础：了解startup的股票\" class=\"headerlink\" title=\"股票基础：了解startup的股票\"></a>股票基础：了解startup的股票</h2><p>顾名思义，股票可以使持有人拥有公司的一部分。如果一家公司有10,000股流通在外股票（shares outstanding），那么如果成功退出（successful exit），则每股股票将赋予所有者0.01％的公司收购价；如果公司成功上市，则每股0.01％的股份所有权；或者……不幸的是，如果startup失败了，则几乎没有收益。</p>\n<h3 id=\"谁在创业公司中获得股份？\"><a href=\"#谁在创业公司中获得股份？\" class=\"headerlink\" title=\"谁在创业公司中获得股份？\"></a>谁在创业公司中获得股份？</h3><p>私人初创公司的股东通常分为以下三类之一：</p>\n<ul>\n<li><strong>创始人</strong>：最初，创始人控制着公司100％的股份。随着时间的流逝，他们很可能会控制更少的股票，因为他们以出让股票为代价来换取金钱或劳动力。</li>\n<li><strong>投资者</strong>：风险资本家以一定数量的股份作为投资回报。随着公司筹集更多的资金，它将向投资者发行更多的股票，从而稀释了之前投资的所有人的股票。（不过，这不一定是一件坏事，因为该公司大概会用这笔钱来为每个人增加蛋糕）。</li>\n<li><strong>员工</strong>：就是你！通常情况下，你的股票将被<em>授予</em> （vested）——不是立即让所有的股份，他们将发放出过一段时间来激励你留下来与你的雇主。</li>\n</ul>\n<h3 id=\"每股（share）价值多少？\"><a href=\"#每股（share）价值多少？\" class=\"headerlink\" title=\"每股（share）价值多少？\"></a>每股（share）价值多少？</h3><p>如果您持有一家上市公司的股份，您很快就会知道它的价值：您所要做的就是查找股票代码，以查看股份的交易价格。例如，您可以通过搜索“ TSLA”来查找特斯拉股票的价值。对于私营公司而言，这要困难得多（而且充满术语）。为了评估其价值，私营公司将进行409A估值（409A valuation），其中第三方基本上会估算该公司的价值。要确定股票的当前价值（称为公平市价 fair market value，即FMV），就用估值除以流通股数。</p>\n<p>例如，如果一家公司的价值为100万美元，并且有100,000股流通在外，则每股FMV为10美元。如果同一家公司有50,000股流通在外股票，则FMV为20美元。如您所见，计数的是<em>相对</em>股份数量，而不是<em>绝对</em>数量。要约10,000股流通100,000股的要约与20,000股流通200,000股的要约值完全相同。在409a估值和流通股之间，您可以确定多少股票值得。</p>\n<h3 id=\"股权授予与股票期权（Grants-versus-options）\"><a href=\"#股权授予与股票期权（Grants-versus-options）\" class=\"headerlink\" title=\"股权授予与股票期权（Grants versus options）\"></a>股权授予与股票期权（Grants versus options）</h3><p>在录取通知书中，您可能会获得股票授予（stock grant），股票期权（stock options）或两者的结合。</p>\n<p><strong>股权授予</strong>Equity grant<strong>（RSU）：</strong> 股票授予（通常也称为限制性股票单位Restricted Stock Unit， RSU）非常简单：这意味着您可以在归属时直接获得股票。这对于非常早期的初创公司来说更为常见，因为这些公司的股份价值很少，因此更容易直接发行。但是，以免您担心初创公司股权的任何部分都太简单了，其中有很多初次创业的创始人都不了解的主要财务考虑。当您收到股票时，您将需要考虑向IRS提交填写83（b）。83（b）允许您在授予您的权益（when equity is granted to you）时向您征税，而不是在真正授予（vest）时。根据您的财务状况和创业公司的增长前景，提交83（b）可能会节省数千美元。您可以阅读有关83（b）的更多信息<a href=\"https://www.cooleygo.com/what-is-a-section-83b-election/\" target=\"_blank\" rel=\"noopener\">在这里</a> ; 目前，需要注意的重要一点是，您必须在发行股票后<strong>30天内</strong>提交83（b），因此您需要立即考虑税收问题。</p>\n<p><strong>股票期权</strong>Stock options<strong>（ISO和NSO / NQSO）</strong>：股票期权通常分为激励性股票期权（Incentive Stock Options）和不合格的股票期权（Non-qualified Stock Options）（<a href=\"http://www.startupcompanylawyer.com/2008/03/05/whats-the-difference-between-an-iso-and-an-nso/\" target=\"_blank\" rel=\"noopener\">有关两者之间差异的更多信息</a>）。无论使用哪种方式，都可以选择以后购买股票。您将预先获得<em>行使价</em>（<em>exercise price</em>），这是您需要支付的股票价格。在您担任雇员期间，公司的价值将上升，因此您将能够以低于其实际价值的价格购买股票。有时，您的行使价会低于股票的当前价格，这会愈发增加你手中期权的价值。</p>\n<h2 id=\"在评估股票期权时，您应该问什么问题？\"><a href=\"#在评估股票期权时，您应该问什么问题？\" class=\"headerlink\" title=\"在评估股票期权时，您应该问什么问题？\"></a>在评估股票期权时，您应该问什么问题？</h2><p>假设您收到的报价包含10,000股。这是您应该向您的潜在雇主提出的关键问题。</p>\n<h3 id=\"有多少流通股（How-many-shares-are-outstanding）？\"><a href=\"#有多少流通股（How-many-shares-are-outstanding）？\" class=\"headerlink\" title=\"有多少流通股（How many shares are outstanding）？\"></a>有多少流通股（How many shares are outstanding）？</h3><p>如前所述，绝对股数无关紧要——您需要知道总股本的百分比。一些公司将发行大量股票，以使它们的报价看起来更令人印象深刻，因此不要被众多公司愚弄。如果公司不公开流通股数量，那将是一个很大的危险信号。</p>\n<h3 id=\"董事会最近一次普通股评估（common-stock-appraisal）是什么？\"><a href=\"#董事会最近一次普通股评估（common-stock-appraisal）是什么？\" class=\"headerlink\" title=\"董事会最近一次普通股评估（common stock appraisal）是什么？\"></a>董事会最近一次普通股评估（common stock appraisal）是什么？</h3><p>如果您要购买股票期权，您的offer可能没有明确说明行使价。但是，这个数字将为您提供一个不错的指导，假设未来FMV会增加，您可以行使多少期权以及潜在的上涨空间。</p>\n<h3 id=\"公司目前的估值是多少？\"><a href=\"#公司目前的估值是多少？\" class=\"headerlink\" title=\"公司目前的估值是多少？\"></a>公司目前的估值是多少？</h3><p>加上发行在外的股票数量，您将可以了解股票的价值，无论是它们将以赠款还是认股权形式被赠予您。</p>\n<h3 id=\"归属时间表（vesting-schedule）是什么？\"><a href=\"#归属时间表（vesting-schedule）是什么？\" class=\"headerlink\" title=\"归属时间表（vesting schedule）是什么？\"></a>归属时间表（vesting schedule）是什么？</h3><p>为了激励您坚持下去，大多数公司会根据归属时间表发放股票或期权。最常见的时间表是，在您开始一年后拥有25％的期权，然后在每个月给你1/48的股份（这意味着四年后您将拥有所有的期权，或者被<em>完全归属</em>fully vested）。在您达到某个里程碑之前，这种保留期权的做法被称为<em>归属悬崖</em>（<em>vesting cliff</em>）。</p>\n<h3 id=\"如果公司被收购（acquired）或我离开，将会发生什么？\"><a href=\"#如果公司被收购（acquired）或我离开，将会发生什么？\" class=\"headerlink\" title=\"如果公司被收购（acquired）或我离开，将会发生什么？\"></a>如果公司被收购（acquired）或我离开，将会发生什么？</h3><p>如果被公司收购，某些公司将允许加速归属（vest），这意味着您将在收购时或几个月后获得所有剩余股份。如果您不想最终被大公司收购，这可能会有所帮助。</p>\n<p>另一方面，如果您离开公司，通常会保留当前已授予的股份和/或期权。通常，您必须在设定的时间段内（通常在离开后90天之内）行使这些选择。但是要当心：有些公司保留以行使价（exercise price）回购您的期权的权利，这意味着您从这些期权中没有任何价值。要记住的另一件重要事情是，您在行使期权时（而不是在实际出售股票时）可能必须为期权缴纳税款。</p>\n<p>假设您有1,000股股票，当前价值为5美元，行使价为1美元。您将于2010年离开公司并行使股票。2016年，您以每股7美元的价格出售股票。在某些情况下，您将在行权时对估值与行使价之间的差额征税–也就是说，您将在2010年支付4,000美元（即1,000股<em>）（5美元的估值– 1美元的行使价）的税。2016年，则您应就所卖出的价格与其行使价之间的差额缴纳税款-即2,000美元或1,000股</em>（$ 7卖出-行使价$ 5）。</p>\n<p>额外的4000美元应纳税所得额-根据2016年替代性最低税支付的1,120美元税款-似乎并不可怕，但如果您拥有大量股权，则税收负担的确会相当沉重。您不仅要行使期权（行使价乘以股票数量），还要对尚未行使的期权征税。确保您有足够的钱来支付这些费用；否则，您可能必须出售股票来支付行使股票的成本，并且您的税率会更高。查阅<a href=\"https://blog.wealthfront.com/when-to-exercise-stock-options/\" target=\"_blank\" rel=\"noopener\">本指南</a>，了解您的选择以了解更多信息-这是您值得花费的时间。</p>\n<h3 id=\"您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？\"><a href=\"#您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？\" class=\"headerlink\" title=\"您打算什么时候筹集下一轮资金（raise your next round of funding）？\"></a>您打算什么时候筹集下一轮资金（raise your next round of funding）？</h3><p>如前所述，投资者需要股票来换取资金。如果您的公司有100,000股流通在外的股票，并向您提供1,000股，那么您将获得公司的1％。但是，如果公司计划再进行一轮融资，它很快就会发现自己拥有20万股流通股。您的1,000股的价值将减少一半。</p>\n<h3 id=\"你的退出策略是什么（exit-strategy）？\"><a href=\"#你的退出策略是什么（exit-strategy）？\" class=\"headerlink\" title=\"你的退出策略是什么（exit strategy）？\"></a>你的退出策略是什么（exit strategy）？</h3><p>如果公司计划收购或很快上市，那么您的股票更有价值。并非所有公司都会为您提供此信息，但是了解这一点很有帮助。</p>\n<p>当然，这并不是一个详尽的问题清单，但足以让您了解您的股票或期权的价值，以及您对它们的价值的确定性。</p>\n<h2 id=\"比较报价\"><a href=\"#比较报价\" class=\"headerlink\" title=\"比较报价\"></a>比较报价</h2><p>好的，这是向您抛出的许多信息。让我们来看一个具体的示例，比较初创公司BookFace和Moogle的报价。我们将不断汇总每个报价的“价值”。</p>\n<p><strong>BookFace：</strong> 100,000美元的薪水，10,000股和5,000个期权</p>\n<p><strong>Moogle：</strong>年薪140,000美元，6,000股和2,000个期权</p>\n<h3 id=\"薪水\"><a href=\"#薪水\" class=\"headerlink\" title=\"薪水\"></a>薪水</h3><p>这很简单，将提供我们进行比较的基础。</p>\n<p><strong>BookFace：</strong> 100,000美元的薪水</p>\n<p><strong>Moogle：</strong>年薪140,000美元</p>\n<h3 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h3><p>现在您知道了如何评估股票赠款，现在就向BookFace和Moogle询问他们最近的409a估值以及多少流通股。BookFace告诉您，它有1000万流通股，价值为5000万美元。Moogle不会告诉您其估值，但会告诉您其股票的公平市值为4美元。</p>\n<p><strong>BookFace：</strong> $100,000薪水+ $5,000万估值/ 1,000万股流通股*所发行的10,000股= $100,000+ $50,000= $150,000</p>\n<p><strong>Moogle：</strong>薪金$ 140,000 + $ 4 FMV * 6,000股= $ 140,000 + $ 24,000 = $ 164,000</p>\n<h3 id=\"股票期权\"><a href=\"#股票期权\" class=\"headerlink\" title=\"股票期权\"></a>股票期权</h3><p>现在，您问公司这些股票期权的行权价（exercise price）是多少。两者都将行使价定为1美元。您已经知道Moogle股票的近似值（4美元），但是要回到BookFace的股票中，您可以将估值除以发行在外的股票数量。这使您的每股收益为5美元。</p>\n<p><strong>BookFace：</strong> $100,000薪水+ $50,000赠送股票+ 5,000个期权*（$5 FMV - $1行使价）= $150,000+ $20,000= $170,000</p>\n<p><strong>Moogle：</strong> $ 140,000薪金+ $ 24,000赠送股票+ 2,000个期权*（$ 4 FMV – $ 1行使价）= $ 164,000 + $ 6,000 = $ 170,000</p>\n<p>在这个示例中，BookFace和Moogle的报价“价值”相同。让我们深入研究改变其价值的模糊因素。</p>\n<h3 id=\"定性因素\"><a href=\"#定性因素\" class=\"headerlink\" title=\"定性因素\"></a>定性因素</h3><ul>\n<li><strong>公司成长有多快？</strong>如果您在一家如火箭般快速上升的公司工作，那最好是用股票而不是工资（这是BookFace的报价）来补偿。如果它很快就要进行收购或IPO，那么您的股票很可能会很有价值。</li>\n<li><strong>公司是否计划尽快筹集资金？</strong>如果是这样，您的股票将被摊薄（diluted），您应相应地对赠款和期权进行贬值。</li>\n<li><strong>归属时间表（</strong>vesting schedule<strong>）是什么？</strong>对自己诚实：您打算在公司呆多长时间？初创公司员工的平均任期<a href=\"http://www.theatlantic.com/business/archive/2014/12/statistically-speaking-what-does-the-average-startup-look-like/384019/\" target=\"_blank\" rel=\"noopener\">仅为10.8个月</a>，因此您很可能没有足够长的时间来完全归属（fully vest）。在这种情况下，更快归属的公司，或是优先考虑薪资而不是股票的公司，会更有价值。</li>\n<li><strong>还提供什么其他好处？</strong>健康和残障保险，育儿假（parental leave），401（k）（尤其是如果<a href=\"https://humaninterest.com/blog/is-a-401k-match-contribution-tax-deductible/\" target=\"_blank\" rel=\"noopener\">与雇主匹配的话</a>），通勤津贴（commuter benefits）和免费餐食（free meals）也可以影响您的决定。</li>\n</ul>\n<p>最后一个问题是您必须问自己：您需要多少收入保障（income security）？股票是高风险，高回报的主张。您的股份可能会变得一文不值，或者使您成为百万富翁。另一方面，工资是可靠的。如果您的财务状况不安全，承担大量债务（抵押，学生贷款债务，家庭），或者想规避风险，则可能要优先考虑薪资而不是股票。</p>\n<p>相较于用来比较startup offer或股权中的所有术语和数字，你的决定可能取决于更软的因素，例如，您对公司成功的信心到底有多深。</p>\n<h2 id=\"如何计税？\"><a href=\"#如何计税？\" class=\"headerlink\" title=\"如何计税？\"></a>如何计税？</h2><p>原文自<a href=\"https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=138822&extra=page%3D1%26filter%3Dsortid%26sortid%3D320%26sortid%3D320\" target=\"_blank\" rel=\"noopener\">一亩三分地</a>，原作者<a href=\"https://www.1point3acres.com/bbs/space-uid-42994.html\" target=\"_blank\" rel=\"noopener\">wzf1943</a>，修正了错误</p>\n<p>期权有很多种，市场上公开交易的期权和公司期权也有不少区别，但是本质都是以固定价格购买（卖出）股票的权利。</p>\n<p>目前创业公司发Stock Option主要有两类</p>\n<ul>\n<li>ISO(Incentive Stock Option)</li>\n<li>NSO(Non-Qualified Stock Option)</li>\n</ul>\n<p>两者在计税方面有很大区别。不过趋势是越来越多创业公司选择NSO作为Stock Option的发放方式。</p>\n<p>先讲一讲Stock Option的大致阶段：</p>\n<ul>\n<li>你被公司录用，然后被赋予相当数量的期权。比如，可以用$5/股的行权价购买10000股的Option。</li>\n<li>被赋予的期权都有一个分配的时间表，主流做法也是工作满一年拿到25%，之后36个月每月拿到剩余的1/36</li>\n<li>在某个时间点，你决定行使期权的权利，也就是以行权价购买公司股票。可以在同时、或之后把行权所得的股票卖出，获得利润。</li>\n</ul>\n<p>先看NSO，计税不算复杂：阶段1-2不涉及实权兑现，因此不交税。阶段3行权且有潜在的利润，按收入税计税。</p>\n<blockquote>\n<p>假设小明加入一家创业公司，获得NSO，可以用行权价$5/股的价格购买10000股。再假设公司四年后上市，股价变成$25/股。</p>\n<p>此时，小明所有期权都已被分配。进入阶段3：可以行使所有期权，其潜在收益是 ($25 - $5) * 10000 ＝ $200,000. 税额按收入税计算，外加州税，基本上需要交税一半左右($100,000)。外加行使权需要$5 * 10000 = $50000，总费用是$150,000，天价。更常见的做法是：小明可以选择只行使一部分期权，比如2000. 那么相应的总潜在收益是($25 - $5) * 2000 = $40000. 相应的，由于总收益的降低，计算收入税的税额就可能应用低一档的税率，可以省%4左右的税率。</p>\n</blockquote>\n<p>然后是ISO. 咳咳咳…为了不把本文变成没完没了的税法说明，小编建议有需要的读者自行搜索以下关键字：ISO, AMT, Tech Bubble, Bankcruptcy…没错，2000年大泡沫中破产的人大部分都是拜ISO中产生的AMT税所赐，故事非常精彩，祝大家阅读愉快。</p>\n<p>写了这么多，估计很多读者没有心思读完全文，直接跳到结论。那好，小编给你个总结一下：</p>\n<ul>\n<li>如果公司提供了RSU，很好，你不需要多想，老老实实待满年头，坐等拿股票卖钱，如果你在加州，做好心里准备：基本上一半的收入去交税。</li>\n<li>如果公司提供的是Stock Option，并且是NSO。你能做的也不太多，等公司上市后，好好盘算自己的收入，每年选择一部分Option行权并卖出股票获利。如果控制得当，税可能比RSU略少。</li>\n<li>如果公司提供的是Stock Option，并且是ISO, 除非是极早期员工，否则请谨慎使用早起行权(early exercise)，建议做决定前先咨询专业税务人员。</li>\n</ul>\n<p>无论是RSU/Option, 只要公司没有办法上市或者被收购，或者你在此之前已经离开，这些RSU/Option则分文不值。（事实上并非如此，有的公司允许你买卖期权或是买卖你手中的股票，你需要向HR问清楚这些细节）</p>\n<p>同样，高风险意味着高回报。创业公司给员工提供的RSU/Option要远比大公司慷慨，你只要熬到公司上市或被收购，回报自然丰厚</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>本文翻译自翻译自<a href=\"https://humaninterest.com/blog/startup-equity-basics-ask-stock-accept/\" target=\"_blank\" rel=\"noopener\">Human Interest</a>，原作者Anisha Sekar</p>\n<p>修正了google translate中出现的语病和错译</p>\n<hr>\n<p>您已经从一家初创公司那里获得了一份报价，作为薪酬待遇的一部分，您将在薪水之上获取公司股票。恭喜你！在你变成星星眼之前，您需要仔细评估报。您应该能够准确地评估offer股权的（潜在）价值，以将其和你的其他offer做比较，并利用您的理解来潜在地协商更高的薪水。我们将介绍startup股权的基本知识，您应该提出的问题，以及如何并行比较报价。</p>\n<h2 id=\"股票基础：了解startup的股票\"><a href=\"#股票基础：了解startup的股票\" class=\"headerlink\" title=\"股票基础：了解startup的股票\"></a>股票基础：了解startup的股票</h2><p>顾名思义，股票可以使持有人拥有公司的一部分。如果一家公司有10,000股流通在外股票（shares outstanding），那么如果成功退出（successful exit），则每股股票将赋予所有者0.01％的公司收购价；如果公司成功上市，则每股0.01％的股份所有权；或者……不幸的是，如果startup失败了，则几乎没有收益。</p>\n<h3 id=\"谁在创业公司中获得股份？\"><a href=\"#谁在创业公司中获得股份？\" class=\"headerlink\" title=\"谁在创业公司中获得股份？\"></a>谁在创业公司中获得股份？</h3><p>私人初创公司的股东通常分为以下三类之一：</p>\n<ul>\n<li><strong>创始人</strong>：最初，创始人控制着公司100％的股份。随着时间的流逝，他们很可能会控制更少的股票，因为他们以出让股票为代价来换取金钱或劳动力。</li>\n<li><strong>投资者</strong>：风险资本家以一定数量的股份作为投资回报。随着公司筹集更多的资金，它将向投资者发行更多的股票，从而稀释了之前投资的所有人的股票。（不过，这不一定是一件坏事，因为该公司大概会用这笔钱来为每个人增加蛋糕）。</li>\n<li><strong>员工</strong>：就是你！通常情况下，你的股票将被<em>授予</em> （vested）——不是立即让所有的股份，他们将发放出过一段时间来激励你留下来与你的雇主。</li>\n</ul>\n<h3 id=\"每股（share）价值多少？\"><a href=\"#每股（share）价值多少？\" class=\"headerlink\" title=\"每股（share）价值多少？\"></a>每股（share）价值多少？</h3><p>如果您持有一家上市公司的股份，您很快就会知道它的价值：您所要做的就是查找股票代码，以查看股份的交易价格。例如，您可以通过搜索“ TSLA”来查找特斯拉股票的价值。对于私营公司而言，这要困难得多（而且充满术语）。为了评估其价值，私营公司将进行409A估值（409A valuation），其中第三方基本上会估算该公司的价值。要确定股票的当前价值（称为公平市价 fair market value，即FMV），就用估值除以流通股数。</p>\n<p>例如，如果一家公司的价值为100万美元，并且有100,000股流通在外，则每股FMV为10美元。如果同一家公司有50,000股流通在外股票，则FMV为20美元。如您所见，计数的是<em>相对</em>股份数量，而不是<em>绝对</em>数量。要约10,000股流通100,000股的要约与20,000股流通200,000股的要约值完全相同。在409a估值和流通股之间，您可以确定多少股票值得。</p>\n<h3 id=\"股权授予与股票期权（Grants-versus-options）\"><a href=\"#股权授予与股票期权（Grants-versus-options）\" class=\"headerlink\" title=\"股权授予与股票期权（Grants versus options）\"></a>股权授予与股票期权（Grants versus options）</h3><p>在录取通知书中，您可能会获得股票授予（stock grant），股票期权（stock options）或两者的结合。</p>\n<p><strong>股权授予</strong>Equity grant<strong>（RSU）：</strong> 股票授予（通常也称为限制性股票单位Restricted Stock Unit， RSU）非常简单：这意味着您可以在归属时直接获得股票。这对于非常早期的初创公司来说更为常见，因为这些公司的股份价值很少，因此更容易直接发行。但是，以免您担心初创公司股权的任何部分都太简单了，其中有很多初次创业的创始人都不了解的主要财务考虑。当您收到股票时，您将需要考虑向IRS提交填写83（b）。83（b）允许您在授予您的权益（when equity is granted to you）时向您征税，而不是在真正授予（vest）时。根据您的财务状况和创业公司的增长前景，提交83（b）可能会节省数千美元。您可以阅读有关83（b）的更多信息<a href=\"https://www.cooleygo.com/what-is-a-section-83b-election/\" target=\"_blank\" rel=\"noopener\">在这里</a> ; 目前，需要注意的重要一点是，您必须在发行股票后<strong>30天内</strong>提交83（b），因此您需要立即考虑税收问题。</p>\n<p><strong>股票期权</strong>Stock options<strong>（ISO和NSO / NQSO）</strong>：股票期权通常分为激励性股票期权（Incentive Stock Options）和不合格的股票期权（Non-qualified Stock Options）（<a href=\"http://www.startupcompanylawyer.com/2008/03/05/whats-the-difference-between-an-iso-and-an-nso/\" target=\"_blank\" rel=\"noopener\">有关两者之间差异的更多信息</a>）。无论使用哪种方式，都可以选择以后购买股票。您将预先获得<em>行使价</em>（<em>exercise price</em>），这是您需要支付的股票价格。在您担任雇员期间，公司的价值将上升，因此您将能够以低于其实际价值的价格购买股票。有时，您的行使价会低于股票的当前价格，这会愈发增加你手中期权的价值。</p>\n<h2 id=\"在评估股票期权时，您应该问什么问题？\"><a href=\"#在评估股票期权时，您应该问什么问题？\" class=\"headerlink\" title=\"在评估股票期权时，您应该问什么问题？\"></a>在评估股票期权时，您应该问什么问题？</h2><p>假设您收到的报价包含10,000股。这是您应该向您的潜在雇主提出的关键问题。</p>\n<h3 id=\"有多少流通股（How-many-shares-are-outstanding）？\"><a href=\"#有多少流通股（How-many-shares-are-outstanding）？\" class=\"headerlink\" title=\"有多少流通股（How many shares are outstanding）？\"></a>有多少流通股（How many shares are outstanding）？</h3><p>如前所述，绝对股数无关紧要——您需要知道总股本的百分比。一些公司将发行大量股票，以使它们的报价看起来更令人印象深刻，因此不要被众多公司愚弄。如果公司不公开流通股数量，那将是一个很大的危险信号。</p>\n<h3 id=\"董事会最近一次普通股评估（common-stock-appraisal）是什么？\"><a href=\"#董事会最近一次普通股评估（common-stock-appraisal）是什么？\" class=\"headerlink\" title=\"董事会最近一次普通股评估（common stock appraisal）是什么？\"></a>董事会最近一次普通股评估（common stock appraisal）是什么？</h3><p>如果您要购买股票期权，您的offer可能没有明确说明行使价。但是，这个数字将为您提供一个不错的指导，假设未来FMV会增加，您可以行使多少期权以及潜在的上涨空间。</p>\n<h3 id=\"公司目前的估值是多少？\"><a href=\"#公司目前的估值是多少？\" class=\"headerlink\" title=\"公司目前的估值是多少？\"></a>公司目前的估值是多少？</h3><p>加上发行在外的股票数量，您将可以了解股票的价值，无论是它们将以赠款还是认股权形式被赠予您。</p>\n<h3 id=\"归属时间表（vesting-schedule）是什么？\"><a href=\"#归属时间表（vesting-schedule）是什么？\" class=\"headerlink\" title=\"归属时间表（vesting schedule）是什么？\"></a>归属时间表（vesting schedule）是什么？</h3><p>为了激励您坚持下去，大多数公司会根据归属时间表发放股票或期权。最常见的时间表是，在您开始一年后拥有25％的期权，然后在每个月给你1/48的股份（这意味着四年后您将拥有所有的期权，或者被<em>完全归属</em>fully vested）。在您达到某个里程碑之前，这种保留期权的做法被称为<em>归属悬崖</em>（<em>vesting cliff</em>）。</p>\n<h3 id=\"如果公司被收购（acquired）或我离开，将会发生什么？\"><a href=\"#如果公司被收购（acquired）或我离开，将会发生什么？\" class=\"headerlink\" title=\"如果公司被收购（acquired）或我离开，将会发生什么？\"></a>如果公司被收购（acquired）或我离开，将会发生什么？</h3><p>如果被公司收购，某些公司将允许加速归属（vest），这意味着您将在收购时或几个月后获得所有剩余股份。如果您不想最终被大公司收购，这可能会有所帮助。</p>\n<p>另一方面，如果您离开公司，通常会保留当前已授予的股份和/或期权。通常，您必须在设定的时间段内（通常在离开后90天之内）行使这些选择。但是要当心：有些公司保留以行使价（exercise price）回购您的期权的权利，这意味着您从这些期权中没有任何价值。要记住的另一件重要事情是，您在行使期权时（而不是在实际出售股票时）可能必须为期权缴纳税款。</p>\n<p>假设您有1,000股股票，当前价值为5美元，行使价为1美元。您将于2010年离开公司并行使股票。2016年，您以每股7美元的价格出售股票。在某些情况下，您将在行权时对估值与行使价之间的差额征税–也就是说，您将在2010年支付4,000美元（即1,000股<em>）（5美元的估值– 1美元的行使价）的税。2016年，则您应就所卖出的价格与其行使价之间的差额缴纳税款-即2,000美元或1,000股</em>（$ 7卖出-行使价$ 5）。</p>\n<p>额外的4000美元应纳税所得额-根据2016年替代性最低税支付的1,120美元税款-似乎并不可怕，但如果您拥有大量股权，则税收负担的确会相当沉重。您不仅要行使期权（行使价乘以股票数量），还要对尚未行使的期权征税。确保您有足够的钱来支付这些费用；否则，您可能必须出售股票来支付行使股票的成本，并且您的税率会更高。查阅<a href=\"https://blog.wealthfront.com/when-to-exercise-stock-options/\" target=\"_blank\" rel=\"noopener\">本指南</a>，了解您的选择以了解更多信息-这是您值得花费的时间。</p>\n<h3 id=\"您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？\"><a href=\"#您打算什么时候筹集下一轮资金（raise-your-next-round-of-funding）？\" class=\"headerlink\" title=\"您打算什么时候筹集下一轮资金（raise your next round of funding）？\"></a>您打算什么时候筹集下一轮资金（raise your next round of funding）？</h3><p>如前所述，投资者需要股票来换取资金。如果您的公司有100,000股流通在外的股票，并向您提供1,000股，那么您将获得公司的1％。但是，如果公司计划再进行一轮融资，它很快就会发现自己拥有20万股流通股。您的1,000股的价值将减少一半。</p>\n<h3 id=\"你的退出策略是什么（exit-strategy）？\"><a href=\"#你的退出策略是什么（exit-strategy）？\" class=\"headerlink\" title=\"你的退出策略是什么（exit strategy）？\"></a>你的退出策略是什么（exit strategy）？</h3><p>如果公司计划收购或很快上市，那么您的股票更有价值。并非所有公司都会为您提供此信息，但是了解这一点很有帮助。</p>\n<p>当然，这并不是一个详尽的问题清单，但足以让您了解您的股票或期权的价值，以及您对它们的价值的确定性。</p>\n<h2 id=\"比较报价\"><a href=\"#比较报价\" class=\"headerlink\" title=\"比较报价\"></a>比较报价</h2><p>好的，这是向您抛出的许多信息。让我们来看一个具体的示例，比较初创公司BookFace和Moogle的报价。我们将不断汇总每个报价的“价值”。</p>\n<p><strong>BookFace：</strong> 100,000美元的薪水，10,000股和5,000个期权</p>\n<p><strong>Moogle：</strong>年薪140,000美元，6,000股和2,000个期权</p>\n<h3 id=\"薪水\"><a href=\"#薪水\" class=\"headerlink\" title=\"薪水\"></a>薪水</h3><p>这很简单，将提供我们进行比较的基础。</p>\n<p><strong>BookFace：</strong> 100,000美元的薪水</p>\n<p><strong>Moogle：</strong>年薪140,000美元</p>\n<h3 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h3><p>现在您知道了如何评估股票赠款，现在就向BookFace和Moogle询问他们最近的409a估值以及多少流通股。BookFace告诉您，它有1000万流通股，价值为5000万美元。Moogle不会告诉您其估值，但会告诉您其股票的公平市值为4美元。</p>\n<p><strong>BookFace：</strong> $100,000薪水+ $5,000万估值/ 1,000万股流通股*所发行的10,000股= $100,000+ $50,000= $150,000</p>\n<p><strong>Moogle：</strong>薪金$ 140,000 + $ 4 FMV * 6,000股= $ 140,000 + $ 24,000 = $ 164,000</p>\n<h3 id=\"股票期权\"><a href=\"#股票期权\" class=\"headerlink\" title=\"股票期权\"></a>股票期权</h3><p>现在，您问公司这些股票期权的行权价（exercise price）是多少。两者都将行使价定为1美元。您已经知道Moogle股票的近似值（4美元），但是要回到BookFace的股票中，您可以将估值除以发行在外的股票数量。这使您的每股收益为5美元。</p>\n<p><strong>BookFace：</strong> $100,000薪水+ $50,000赠送股票+ 5,000个期权*（$5 FMV - $1行使价）= $150,000+ $20,000= $170,000</p>\n<p><strong>Moogle：</strong> $ 140,000薪金+ $ 24,000赠送股票+ 2,000个期权*（$ 4 FMV – $ 1行使价）= $ 164,000 + $ 6,000 = $ 170,000</p>\n<p>在这个示例中，BookFace和Moogle的报价“价值”相同。让我们深入研究改变其价值的模糊因素。</p>\n<h3 id=\"定性因素\"><a href=\"#定性因素\" class=\"headerlink\" title=\"定性因素\"></a>定性因素</h3><ul>\n<li><strong>公司成长有多快？</strong>如果您在一家如火箭般快速上升的公司工作，那最好是用股票而不是工资（这是BookFace的报价）来补偿。如果它很快就要进行收购或IPO，那么您的股票很可能会很有价值。</li>\n<li><strong>公司是否计划尽快筹集资金？</strong>如果是这样，您的股票将被摊薄（diluted），您应相应地对赠款和期权进行贬值。</li>\n<li><strong>归属时间表（</strong>vesting schedule<strong>）是什么？</strong>对自己诚实：您打算在公司呆多长时间？初创公司员工的平均任期<a href=\"http://www.theatlantic.com/business/archive/2014/12/statistically-speaking-what-does-the-average-startup-look-like/384019/\" target=\"_blank\" rel=\"noopener\">仅为10.8个月</a>，因此您很可能没有足够长的时间来完全归属（fully vest）。在这种情况下，更快归属的公司，或是优先考虑薪资而不是股票的公司，会更有价值。</li>\n<li><strong>还提供什么其他好处？</strong>健康和残障保险，育儿假（parental leave），401（k）（尤其是如果<a href=\"https://humaninterest.com/blog/is-a-401k-match-contribution-tax-deductible/\" target=\"_blank\" rel=\"noopener\">与雇主匹配的话</a>），通勤津贴（commuter benefits）和免费餐食（free meals）也可以影响您的决定。</li>\n</ul>\n<p>最后一个问题是您必须问自己：您需要多少收入保障（income security）？股票是高风险，高回报的主张。您的股份可能会变得一文不值，或者使您成为百万富翁。另一方面，工资是可靠的。如果您的财务状况不安全，承担大量债务（抵押，学生贷款债务，家庭），或者想规避风险，则可能要优先考虑薪资而不是股票。</p>\n<p>相较于用来比较startup offer或股权中的所有术语和数字，你的决定可能取决于更软的因素，例如，您对公司成功的信心到底有多深。</p>\n<h2 id=\"如何计税？\"><a href=\"#如何计税？\" class=\"headerlink\" title=\"如何计税？\"></a>如何计税？</h2><p>原文自<a href=\"https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=138822&extra=page%3D1%26filter%3Dsortid%26sortid%3D320%26sortid%3D320\" target=\"_blank\" rel=\"noopener\">一亩三分地</a>，原作者<a href=\"https://www.1point3acres.com/bbs/space-uid-42994.html\" target=\"_blank\" rel=\"noopener\">wzf1943</a>，修正了错误</p>\n<p>期权有很多种，市场上公开交易的期权和公司期权也有不少区别，但是本质都是以固定价格购买（卖出）股票的权利。</p>\n<p>目前创业公司发Stock Option主要有两类</p>\n<ul>\n<li>ISO(Incentive Stock Option)</li>\n<li>NSO(Non-Qualified Stock Option)</li>\n</ul>\n<p>两者在计税方面有很大区别。不过趋势是越来越多创业公司选择NSO作为Stock Option的发放方式。</p>\n<p>先讲一讲Stock Option的大致阶段：</p>\n<ul>\n<li>你被公司录用，然后被赋予相当数量的期权。比如，可以用$5/股的行权价购买10000股的Option。</li>\n<li>被赋予的期权都有一个分配的时间表，主流做法也是工作满一年拿到25%，之后36个月每月拿到剩余的1/36</li>\n<li>在某个时间点，你决定行使期权的权利，也就是以行权价购买公司股票。可以在同时、或之后把行权所得的股票卖出，获得利润。</li>\n</ul>\n<p>先看NSO，计税不算复杂：阶段1-2不涉及实权兑现，因此不交税。阶段3行权且有潜在的利润，按收入税计税。</p>\n<blockquote>\n<p>假设小明加入一家创业公司，获得NSO，可以用行权价$5/股的价格购买10000股。再假设公司四年后上市，股价变成$25/股。</p>\n<p>此时，小明所有期权都已被分配。进入阶段3：可以行使所有期权，其潜在收益是 ($25 - $5) * 10000 ＝ $200,000. 税额按收入税计算，外加州税，基本上需要交税一半左右($100,000)。外加行使权需要$5 * 10000 = $50000，总费用是$150,000，天价。更常见的做法是：小明可以选择只行使一部分期权，比如2000. 那么相应的总潜在收益是($25 - $5) * 2000 = $40000. 相应的，由于总收益的降低，计算收入税的税额就可能应用低一档的税率，可以省%4左右的税率。</p>\n</blockquote>\n<p>然后是ISO. 咳咳咳…为了不把本文变成没完没了的税法说明，小编建议有需要的读者自行搜索以下关键字：ISO, AMT, Tech Bubble, Bankcruptcy…没错，2000年大泡沫中破产的人大部分都是拜ISO中产生的AMT税所赐，故事非常精彩，祝大家阅读愉快。</p>\n<p>写了这么多，估计很多读者没有心思读完全文，直接跳到结论。那好，小编给你个总结一下：</p>\n<ul>\n<li>如果公司提供了RSU，很好，你不需要多想，老老实实待满年头，坐等拿股票卖钱，如果你在加州，做好心里准备：基本上一半的收入去交税。</li>\n<li>如果公司提供的是Stock Option，并且是NSO。你能做的也不太多，等公司上市后，好好盘算自己的收入，每年选择一部分Option行权并卖出股票获利。如果控制得当，税可能比RSU略少。</li>\n<li>如果公司提供的是Stock Option，并且是ISO, 除非是极早期员工，否则请谨慎使用早起行权(early exercise)，建议做决定前先咨询专业税务人员。</li>\n</ul>\n<p>无论是RSU/Option, 只要公司没有办法上市或者被收购，或者你在此之前已经离开，这些RSU/Option则分文不值。（事实上并非如此，有的公司允许你买卖期权或是买卖你手中的股票，你需要向HR问清楚这些细节）</p>\n<p>同样，高风险意味着高回报。创业公司给员工提供的RSU/Option要远比大公司慷慨，你只要熬到公司上市或被收购，回报自然丰厚</p>\n"},{"layout":"post","title":"SOLO美国租房骗子","date":"2020-02-26T20:00:00.000Z","description":"Linda Cui，曾让我朝思暮想的女人","cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321005208.png","subtitle":null,"comments":1,"optimized_image":null,"author":"tty","_content":"\n作为一个菜鸡，在下的上岸时间可谓是非常之晚了。上岸迟就会出现一个问题——房子租不出去。\n\n在波士顿这个鬼地方，你想租房子至少得整一年，导致基本所有春季毕业的学生都会遇到房屋出租问题。很多亚马逊return的同学都花了一整个学期才把房子租出去。他们的出租对象往往是那些春季入学的人，所以好歹房子还能租出去。\n\n我们这些春季才上岸的人就不同了——你要是想三月份出租你的房间，那就根本没有target用户。春季入学的新生们都是二月入住，你已经错过了；而波士顿这鬼地方工作机会也不是很多，没什么过来工作的新人。再加上因为波士顿学校多，租房产业过于发达，空房一大堆，想要租出去自己的房子，可谓难上加难。\n\n我在各大租房微信群狂轰乱炸了几天，压根找不到要租的人。无奈之下跑到一亩三分地去发了个出租房间的帖子，大概描述了我房间的情况，然后留了微信和邮箱。\n\n万万没想到一亩三分地如此牛逼，一晚上就有人进场了。这位选手就是我们的重量级人物——Linda Cui\n\n## Linda Cui 的第一封信\n\n传奇通常都不是一蹴而就。\n\nLinda Cui的第一封信，看起来有点像弱智儿童发的\n\n> Hi, Is the room available and move in date? Thank you\n\n说实话当时我没看懂这句话的文法。不过这不要紧。看这发件人邮箱是[linyixiancu@hotmail.com](mailto:Linda Cui )，姓名是“Linda Cui”。中国人嘛，英文不行没事，我寻思着。于是我回复了她，说我房子还健在，您老可以过来参观参观。move in么三月就行了，能搞快点就搞快点，我要溜溜球了\n\n可万万没有想到的是，紧随而来的第二封信，竟然level up了如此之多\n\n## Linda Cui 的第二封信\n\n（下面有翻译）\n\n> Hello XX,\n>\n> Thanks for writing back. I'm very much interested in renting the room and I really hope we could get along with each other. I plan to arrive on 10th of March.\n>\n> About me: I'm a mixed race of Chinese and British and I speak Mandarin fluently, currently living in the United Kingdom, I'm 29 yrs old. I'm Educated (Undergraduate and Post Graduate Degree), a devoted Christian. I don't smoke nor drink and I don't mind if room mates do. I'm currently living at 65 Croydon Rd, Croydon CR0 4QE, I'm pretty quiet and neat, but not obsessively so. I'm responsible and will pull my weight around the apartment and pay bills on time. I like to cook, and it would be great to have people to cook with or eat with, but it's definitely not a requirement in a room-mate. I'm social though, and get along well with most people.\n>\n> And I would really want to secure the room before my arrival, More-so, to know if it would be possible for me to pay for the room before my arrival, So I would like to know the total amount of the room per month and the utility included. All this information are very important so that I can submit my proposal to my Uncle. My Uncle will be responsible for all the fees. Please let me know if I could give you any more info that would be helpful for making your decision. I would be glad if you can tell me little about you too.\n>\n> Sorry for the email novel. I hope it isn't a lot to read and I apologize for coming on strong, I'm just looking for a reliable place when I move down. I look forward to hearing positive from you again.\n>\n> Thanks.\n> Linda.\n\n我了个捶捶怎么突然发万字长文给我，我人都傻了。\n\n我定睛一看，这Linda自称是中英混血，住在大英帝国，29岁，并且受过较高程度的教育，甚至还是个基督教徒。她不喝酒不抽烟是个好女孩，但不介意你们在家乱嗨。下文直接列出一长串自己在大英帝国豪宅的地址，然后说自己干净整洁，及时交房租，会做饭，而且十分social。\n\n她直接非常想要提前预定房子，然后问你要不要在她到来直接交定金，然后说她uncle会来给她交钱。又问你需不需要她的更多信息，所以你能把房子租给她！\n\n她言语间的诚恳打动了我，我还以为是哪个欧美不谙世事的良家基督教徒呢！大姐你也太推心置腹了吧！但我寻思着我这波士顿这么多房子租不出去，应该是我怎么打动你而不是你怎么打动我吧？于是我反手一个万字长文，疯狂介绍我所住的公寓，然后给了我的价格。我紧接着说我们还是跟公寓签合同吧，你这样直接给我钱傻乎乎的不太好，随后问她是否需要租我的房子。\n\n## Linda Cui 的第三封信\n\n> Subject: Security deposit...\n>\n> Hiya XX,\n>\n> How are you doing? Thanks for the pictures and details of the room, I'm really interested in renting the room for a year or two if possible please, I will keep you posted with my flight information as events unfold. I have jobs interview lined up for me as a Private (Science Tutor) and I've been guaranteed a spot as soon as I get there.\n>\n> I just got in touch with my Uncle and he can assure you of paying the rent fee monthly without any hesitation and since he will be responsible for paying my rent fees and all, we thought of mailing the deposit payment this week in one of his business trips. Please let me know if this is OK with you. I will need you to email me your information (full name, mailing address, and a direct phone number to reach you) for the payment so that I can have it forwarded to my Uncle as requested.\n>\n> If there is a rental agreement application, please understand that I will have it filled and signed out upon my arrival.\n>\n> Also, let me know if you will be able to help me keep my little stuffs (dresser, art works, paintings as they will be shipped before my arrival.\n>\n> Thanks for willing to give me the room, I can't wait to meet you. Please remember my mother in your prayers as she will be going through Surgical operation next week.\n>\n> Sincerely,\n> Linda.\n\n大意就是说，感谢你的公寓介绍嗷，我可想住你这房子了。我会一直告诉你我的行程的，来美帝我还想工作呢，想住你那几年！我uncle已经跟我说好啦，他会给我付钱的，请把你地址手机啥的信息给我，我好给你打押金！至于你说的跟公寓签合同签sublease的事情，那只能等我到了再说了，请你理解哈！还有，我甚至想提前寄东西到你那边公寓里，可以嘛！你能把公寓租给我，我实在是太高兴了。和你合作真是太愉快了，好希望赶快见到你嘞。\n\n哦对了，我妈下周做手术了，记得帮我给她祈祷一下。\n\n看完整封信我心里是满满的WTF，你这是给我钱给定了是吧怎么还不停跟我说要给我钱呢？你是脑子被驴踢了吗这么随便给别人钱的！我都说了我们直接签合同整sublease你给公寓钱啊！给我多不好啊！\n\n于是我又发了一封信告诉她，解释了一下sublease的具体流程。你把你什么类型的签证告诉我，我去问公寓你需要什么材料，然后我们签sublease——你压根不用给我钱，你直接给公寓钱去，你给我钱我还膈应呢！\n\n谁知道，这邮件一发，Linda Cui再也没有理我。\n\n我以为我措辞出问题了。我仔细检查了下邮件，没毛病啊我还祝她妈尽快康复呢，咋就不理我了捏，被截胡了吗。这么推心置腹的好房客溜溜球了可不是好消息啊，毕竟波士顿房子根本租不出去啊！于是我茶饭不思，对她朝思暮想。惊慌中我还发了个我们公寓签sublease的官方agreement，表明我一切行为绝对正当。可Linda还是没有再给我任何回复\n\n## 来自朱哥的神助攻\n\n我有一位儒雅随和的客厅室友。因为我也是儒雅随和的人，所以经常去跟他互动。我们的对话频率非常高，通常如下：\n\n>吃饭吗？\n>\n>点外卖吗？\n>\n>吃啥？\n>\n>开冲\n\n这几日我们在一起冲的时候，聊到了租房的问题。于是我给他看了Linda Cui的邮件。朱哥看完赞不绝口，觉得这简直是艺术品，人间瑰宝。对方也太有诚意了，整挺好。\n\n可这日凌晨朱哥突然用微信发来一个链接，我点开一看，标题赫然写着：《**挂一个租房骗子Linda Cui**》。朱哥说他在一亩三分地首页看到的，要不是我给他看过Linda Cui的邮件，他肯定不会点进这帖子……\n\n![一亩三分地](https://raw.githubusercontent.com/8128/PicGo/master/20200321011057.png)\n\n当时我就是一懵。点进去一看发现连邮件内容都一模一样，就是从第三封邮件开始会根据你的回复稍作一些修改。\n\n其中链接分别是：\n\n[HelloGWU](https://hellogwu.com/thread-75629-1-1.html)\n\n[一亩三分地](https://www.1point3acres.com/bbs/thread-596997-1-1.html)\n\n[PSU CSSA论坛](https://www.psucssa.com/bbs/fang-wu-zu-ren/wo-jue-de-wo-yu-dao-yi-ge-zu-fang-pian-zi)\n\n[芝加哥侨学网](http://bbs.chineseofchicago.com/showtopic-61020.aspx)\n\n真可谓是广撒种，啥地方的房她都租。信都不带改的，还骗了不少人。\n\n大概的套路就是，你假如接受了她的deposit，她就会给你的住址发个价格不菲的支票。随后她会向你借钱，有人甚至直接被借了1500+1000+400刀。有人是兑换了支票，发现账号内钱增加了，以为兑换成功，便放松了警惕。随后在对方借钱时，因为对方推心置腹而且给自己打了钱，便不好意思拒绝。结果打完钱过了几天发现Linda的uncle寄过来的是假支票，银行取消了你的兑换，把钱扣除了。而你借给Linda的钱也再也无从追寻\n\n其实我觉得这个事情吧，银行应该负主要责任。一张支票假如未兑换成功，你就应该显示processing，而不是直接把支票金额加到你的账户里去。就是因为这个账户金额的增加才会导致很多人放松警惕的\n\n话说回来，支票这种应该只存在于上个世纪的东西，到底什么时候才能消失啊……\n\n## 后续\n\n我就说为啥Linda突然不理我了，大概是我问了她签证之类的信息，她无法回答。而且我要签sublease，她似乎无法从其中捞到油水。\n\n我现在打算告诉她我需要她寄给我deposit了。倒是很想看看假支票长啥样\n\n要是我拿了支票就不理Linda，她会不会狂轰乱炸我呢？\n\n不过也有可能我现在已经不会再收到来自Linda的邮件了\n\n","source":"_posts/2020-02-26-SOLO美国租房骗子.md","raw":"---\nlayout: post\ntitle:  SOLO美国租房骗子\ndate:   2020-02-26 12:00:00\ndescription: Linda Cui，曾让我朝思暮想的女人\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321005208.png\nsubtitle: \ncomments: true\noptimized_image: \ncategory: blog\ntags:\n  - blog\n  - life\nauthor: tty\n---\n\n作为一个菜鸡，在下的上岸时间可谓是非常之晚了。上岸迟就会出现一个问题——房子租不出去。\n\n在波士顿这个鬼地方，你想租房子至少得整一年，导致基本所有春季毕业的学生都会遇到房屋出租问题。很多亚马逊return的同学都花了一整个学期才把房子租出去。他们的出租对象往往是那些春季入学的人，所以好歹房子还能租出去。\n\n我们这些春季才上岸的人就不同了——你要是想三月份出租你的房间，那就根本没有target用户。春季入学的新生们都是二月入住，你已经错过了；而波士顿这鬼地方工作机会也不是很多，没什么过来工作的新人。再加上因为波士顿学校多，租房产业过于发达，空房一大堆，想要租出去自己的房子，可谓难上加难。\n\n我在各大租房微信群狂轰乱炸了几天，压根找不到要租的人。无奈之下跑到一亩三分地去发了个出租房间的帖子，大概描述了我房间的情况，然后留了微信和邮箱。\n\n万万没想到一亩三分地如此牛逼，一晚上就有人进场了。这位选手就是我们的重量级人物——Linda Cui\n\n## Linda Cui 的第一封信\n\n传奇通常都不是一蹴而就。\n\nLinda Cui的第一封信，看起来有点像弱智儿童发的\n\n> Hi, Is the room available and move in date? Thank you\n\n说实话当时我没看懂这句话的文法。不过这不要紧。看这发件人邮箱是[linyixiancu@hotmail.com](mailto:Linda Cui )，姓名是“Linda Cui”。中国人嘛，英文不行没事，我寻思着。于是我回复了她，说我房子还健在，您老可以过来参观参观。move in么三月就行了，能搞快点就搞快点，我要溜溜球了\n\n可万万没有想到的是，紧随而来的第二封信，竟然level up了如此之多\n\n## Linda Cui 的第二封信\n\n（下面有翻译）\n\n> Hello XX,\n>\n> Thanks for writing back. I'm very much interested in renting the room and I really hope we could get along with each other. I plan to arrive on 10th of March.\n>\n> About me: I'm a mixed race of Chinese and British and I speak Mandarin fluently, currently living in the United Kingdom, I'm 29 yrs old. I'm Educated (Undergraduate and Post Graduate Degree), a devoted Christian. I don't smoke nor drink and I don't mind if room mates do. I'm currently living at 65 Croydon Rd, Croydon CR0 4QE, I'm pretty quiet and neat, but not obsessively so. I'm responsible and will pull my weight around the apartment and pay bills on time. I like to cook, and it would be great to have people to cook with or eat with, but it's definitely not a requirement in a room-mate. I'm social though, and get along well with most people.\n>\n> And I would really want to secure the room before my arrival, More-so, to know if it would be possible for me to pay for the room before my arrival, So I would like to know the total amount of the room per month and the utility included. All this information are very important so that I can submit my proposal to my Uncle. My Uncle will be responsible for all the fees. Please let me know if I could give you any more info that would be helpful for making your decision. I would be glad if you can tell me little about you too.\n>\n> Sorry for the email novel. I hope it isn't a lot to read and I apologize for coming on strong, I'm just looking for a reliable place when I move down. I look forward to hearing positive from you again.\n>\n> Thanks.\n> Linda.\n\n我了个捶捶怎么突然发万字长文给我，我人都傻了。\n\n我定睛一看，这Linda自称是中英混血，住在大英帝国，29岁，并且受过较高程度的教育，甚至还是个基督教徒。她不喝酒不抽烟是个好女孩，但不介意你们在家乱嗨。下文直接列出一长串自己在大英帝国豪宅的地址，然后说自己干净整洁，及时交房租，会做饭，而且十分social。\n\n她直接非常想要提前预定房子，然后问你要不要在她到来直接交定金，然后说她uncle会来给她交钱。又问你需不需要她的更多信息，所以你能把房子租给她！\n\n她言语间的诚恳打动了我，我还以为是哪个欧美不谙世事的良家基督教徒呢！大姐你也太推心置腹了吧！但我寻思着我这波士顿这么多房子租不出去，应该是我怎么打动你而不是你怎么打动我吧？于是我反手一个万字长文，疯狂介绍我所住的公寓，然后给了我的价格。我紧接着说我们还是跟公寓签合同吧，你这样直接给我钱傻乎乎的不太好，随后问她是否需要租我的房子。\n\n## Linda Cui 的第三封信\n\n> Subject: Security deposit...\n>\n> Hiya XX,\n>\n> How are you doing? Thanks for the pictures and details of the room, I'm really interested in renting the room for a year or two if possible please, I will keep you posted with my flight information as events unfold. I have jobs interview lined up for me as a Private (Science Tutor) and I've been guaranteed a spot as soon as I get there.\n>\n> I just got in touch with my Uncle and he can assure you of paying the rent fee monthly without any hesitation and since he will be responsible for paying my rent fees and all, we thought of mailing the deposit payment this week in one of his business trips. Please let me know if this is OK with you. I will need you to email me your information (full name, mailing address, and a direct phone number to reach you) for the payment so that I can have it forwarded to my Uncle as requested.\n>\n> If there is a rental agreement application, please understand that I will have it filled and signed out upon my arrival.\n>\n> Also, let me know if you will be able to help me keep my little stuffs (dresser, art works, paintings as they will be shipped before my arrival.\n>\n> Thanks for willing to give me the room, I can't wait to meet you. Please remember my mother in your prayers as she will be going through Surgical operation next week.\n>\n> Sincerely,\n> Linda.\n\n大意就是说，感谢你的公寓介绍嗷，我可想住你这房子了。我会一直告诉你我的行程的，来美帝我还想工作呢，想住你那几年！我uncle已经跟我说好啦，他会给我付钱的，请把你地址手机啥的信息给我，我好给你打押金！至于你说的跟公寓签合同签sublease的事情，那只能等我到了再说了，请你理解哈！还有，我甚至想提前寄东西到你那边公寓里，可以嘛！你能把公寓租给我，我实在是太高兴了。和你合作真是太愉快了，好希望赶快见到你嘞。\n\n哦对了，我妈下周做手术了，记得帮我给她祈祷一下。\n\n看完整封信我心里是满满的WTF，你这是给我钱给定了是吧怎么还不停跟我说要给我钱呢？你是脑子被驴踢了吗这么随便给别人钱的！我都说了我们直接签合同整sublease你给公寓钱啊！给我多不好啊！\n\n于是我又发了一封信告诉她，解释了一下sublease的具体流程。你把你什么类型的签证告诉我，我去问公寓你需要什么材料，然后我们签sublease——你压根不用给我钱，你直接给公寓钱去，你给我钱我还膈应呢！\n\n谁知道，这邮件一发，Linda Cui再也没有理我。\n\n我以为我措辞出问题了。我仔细检查了下邮件，没毛病啊我还祝她妈尽快康复呢，咋就不理我了捏，被截胡了吗。这么推心置腹的好房客溜溜球了可不是好消息啊，毕竟波士顿房子根本租不出去啊！于是我茶饭不思，对她朝思暮想。惊慌中我还发了个我们公寓签sublease的官方agreement，表明我一切行为绝对正当。可Linda还是没有再给我任何回复\n\n## 来自朱哥的神助攻\n\n我有一位儒雅随和的客厅室友。因为我也是儒雅随和的人，所以经常去跟他互动。我们的对话频率非常高，通常如下：\n\n>吃饭吗？\n>\n>点外卖吗？\n>\n>吃啥？\n>\n>开冲\n\n这几日我们在一起冲的时候，聊到了租房的问题。于是我给他看了Linda Cui的邮件。朱哥看完赞不绝口，觉得这简直是艺术品，人间瑰宝。对方也太有诚意了，整挺好。\n\n可这日凌晨朱哥突然用微信发来一个链接，我点开一看，标题赫然写着：《**挂一个租房骗子Linda Cui**》。朱哥说他在一亩三分地首页看到的，要不是我给他看过Linda Cui的邮件，他肯定不会点进这帖子……\n\n![一亩三分地](https://raw.githubusercontent.com/8128/PicGo/master/20200321011057.png)\n\n当时我就是一懵。点进去一看发现连邮件内容都一模一样，就是从第三封邮件开始会根据你的回复稍作一些修改。\n\n其中链接分别是：\n\n[HelloGWU](https://hellogwu.com/thread-75629-1-1.html)\n\n[一亩三分地](https://www.1point3acres.com/bbs/thread-596997-1-1.html)\n\n[PSU CSSA论坛](https://www.psucssa.com/bbs/fang-wu-zu-ren/wo-jue-de-wo-yu-dao-yi-ge-zu-fang-pian-zi)\n\n[芝加哥侨学网](http://bbs.chineseofchicago.com/showtopic-61020.aspx)\n\n真可谓是广撒种，啥地方的房她都租。信都不带改的，还骗了不少人。\n\n大概的套路就是，你假如接受了她的deposit，她就会给你的住址发个价格不菲的支票。随后她会向你借钱，有人甚至直接被借了1500+1000+400刀。有人是兑换了支票，发现账号内钱增加了，以为兑换成功，便放松了警惕。随后在对方借钱时，因为对方推心置腹而且给自己打了钱，便不好意思拒绝。结果打完钱过了几天发现Linda的uncle寄过来的是假支票，银行取消了你的兑换，把钱扣除了。而你借给Linda的钱也再也无从追寻\n\n其实我觉得这个事情吧，银行应该负主要责任。一张支票假如未兑换成功，你就应该显示processing，而不是直接把支票金额加到你的账户里去。就是因为这个账户金额的增加才会导致很多人放松警惕的\n\n话说回来，支票这种应该只存在于上个世纪的东西，到底什么时候才能消失啊……\n\n## 后续\n\n我就说为啥Linda突然不理我了，大概是我问了她签证之类的信息，她无法回答。而且我要签sublease，她似乎无法从其中捞到油水。\n\n我现在打算告诉她我需要她寄给我deposit了。倒是很想看看假支票长啥样\n\n要是我拿了支票就不理Linda，她会不会狂轰乱炸我呢？\n\n不过也有可能我现在已经不会再收到来自Linda的邮件了\n\n","slug":"SOLO美国租房骗子","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j5g0009gtvi9odq7ojg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>作为一个菜鸡，在下的上岸时间可谓是非常之晚了。上岸迟就会出现一个问题——房子租不出去。</p>\n<p>在波士顿这个鬼地方，你想租房子至少得整一年，导致基本所有春季毕业的学生都会遇到房屋出租问题。很多亚马逊return的同学都花了一整个学期才把房子租出去。他们的出租对象往往是那些春季入学的人，所以好歹房子还能租出去。</p>\n<p>我们这些春季才上岸的人就不同了——你要是想三月份出租你的房间，那就根本没有target用户。春季入学的新生们都是二月入住，你已经错过了；而波士顿这鬼地方工作机会也不是很多，没什么过来工作的新人。再加上因为波士顿学校多，租房产业过于发达，空房一大堆，想要租出去自己的房子，可谓难上加难。</p>\n<p>我在各大租房微信群狂轰乱炸了几天，压根找不到要租的人。无奈之下跑到一亩三分地去发了个出租房间的帖子，大概描述了我房间的情况，然后留了微信和邮箱。</p>\n<p>万万没想到一亩三分地如此牛逼，一晚上就有人进场了。这位选手就是我们的重量级人物——Linda Cui</p>\n<h2 id=\"Linda-Cui-的第一封信\"><a href=\"#Linda-Cui-的第一封信\" class=\"headerlink\" title=\"Linda Cui 的第一封信\"></a>Linda Cui 的第一封信</h2><p>传奇通常都不是一蹴而就。</p>\n<p>Linda Cui的第一封信，看起来有点像弱智儿童发的</p>\n<blockquote>\n<p>Hi, Is the room available and move in date? Thank you</p>\n</blockquote>\n<p>说实话当时我没看懂这句话的文法。不过这不要紧。看这发件人邮箱是[<a href=\"mailto:linyixiancu@hotmail.com\">linyixiancu@hotmail.com</a>](mailto:Linda Cui )，姓名是“Linda Cui”。中国人嘛，英文不行没事，我寻思着。于是我回复了她，说我房子还健在，您老可以过来参观参观。move in么三月就行了，能搞快点就搞快点，我要溜溜球了</p>\n<p>可万万没有想到的是，紧随而来的第二封信，竟然level up了如此之多</p>\n<h2 id=\"Linda-Cui-的第二封信\"><a href=\"#Linda-Cui-的第二封信\" class=\"headerlink\" title=\"Linda Cui 的第二封信\"></a>Linda Cui 的第二封信</h2><p>（下面有翻译）</p>\n<blockquote>\n<p>Hello XX,</p>\n<p>Thanks for writing back. I’m very much interested in renting the room and I really hope we could get along with each other. I plan to arrive on 10th of March.</p>\n<p>About me: I’m a mixed race of Chinese and British and I speak Mandarin fluently, currently living in the United Kingdom, I’m 29 yrs old. I’m Educated (Undergraduate and Post Graduate Degree), a devoted Christian. I don’t smoke nor drink and I don’t mind if room mates do. I’m currently living at 65 Croydon Rd, Croydon CR0 4QE, I’m pretty quiet and neat, but not obsessively so. I’m responsible and will pull my weight around the apartment and pay bills on time. I like to cook, and it would be great to have people to cook with or eat with, but it’s definitely not a requirement in a room-mate. I’m social though, and get along well with most people.</p>\n<p>And I would really want to secure the room before my arrival, More-so, to know if it would be possible for me to pay for the room before my arrival, So I would like to know the total amount of the room per month and the utility included. All this information are very important so that I can submit my proposal to my Uncle. My Uncle will be responsible for all the fees. Please let me know if I could give you any more info that would be helpful for making your decision. I would be glad if you can tell me little about you too.</p>\n<p>Sorry for the email novel. I hope it isn’t a lot to read and I apologize for coming on strong, I’m just looking for a reliable place when I move down. I look forward to hearing positive from you again.</p>\n<p>Thanks.<br>Linda.</p>\n</blockquote>\n<p>我了个捶捶怎么突然发万字长文给我，我人都傻了。</p>\n<p>我定睛一看，这Linda自称是中英混血，住在大英帝国，29岁，并且受过较高程度的教育，甚至还是个基督教徒。她不喝酒不抽烟是个好女孩，但不介意你们在家乱嗨。下文直接列出一长串自己在大英帝国豪宅的地址，然后说自己干净整洁，及时交房租，会做饭，而且十分social。</p>\n<p>她直接非常想要提前预定房子，然后问你要不要在她到来直接交定金，然后说她uncle会来给她交钱。又问你需不需要她的更多信息，所以你能把房子租给她！</p>\n<p>她言语间的诚恳打动了我，我还以为是哪个欧美不谙世事的良家基督教徒呢！大姐你也太推心置腹了吧！但我寻思着我这波士顿这么多房子租不出去，应该是我怎么打动你而不是你怎么打动我吧？于是我反手一个万字长文，疯狂介绍我所住的公寓，然后给了我的价格。我紧接着说我们还是跟公寓签合同吧，你这样直接给我钱傻乎乎的不太好，随后问她是否需要租我的房子。</p>\n<h2 id=\"Linda-Cui-的第三封信\"><a href=\"#Linda-Cui-的第三封信\" class=\"headerlink\" title=\"Linda Cui 的第三封信\"></a>Linda Cui 的第三封信</h2><blockquote>\n<p>Subject: Security deposit…</p>\n<p>Hiya XX,</p>\n<p>How are you doing? Thanks for the pictures and details of the room, I’m really interested in renting the room for a year or two if possible please, I will keep you posted with my flight information as events unfold. I have jobs interview lined up for me as a Private (Science Tutor) and I’ve been guaranteed a spot as soon as I get there.</p>\n<p>I just got in touch with my Uncle and he can assure you of paying the rent fee monthly without any hesitation and since he will be responsible for paying my rent fees and all, we thought of mailing the deposit payment this week in one of his business trips. Please let me know if this is OK with you. I will need you to email me your information (full name, mailing address, and a direct phone number to reach you) for the payment so that I can have it forwarded to my Uncle as requested.</p>\n<p>If there is a rental agreement application, please understand that I will have it filled and signed out upon my arrival.</p>\n<p>Also, let me know if you will be able to help me keep my little stuffs (dresser, art works, paintings as they will be shipped before my arrival.</p>\n<p>Thanks for willing to give me the room, I can’t wait to meet you. Please remember my mother in your prayers as she will be going through Surgical operation next week.</p>\n<p>Sincerely,<br>Linda.</p>\n</blockquote>\n<p>大意就是说，感谢你的公寓介绍嗷，我可想住你这房子了。我会一直告诉你我的行程的，来美帝我还想工作呢，想住你那几年！我uncle已经跟我说好啦，他会给我付钱的，请把你地址手机啥的信息给我，我好给你打押金！至于你说的跟公寓签合同签sublease的事情，那只能等我到了再说了，请你理解哈！还有，我甚至想提前寄东西到你那边公寓里，可以嘛！你能把公寓租给我，我实在是太高兴了。和你合作真是太愉快了，好希望赶快见到你嘞。</p>\n<p>哦对了，我妈下周做手术了，记得帮我给她祈祷一下。</p>\n<p>看完整封信我心里是满满的WTF，你这是给我钱给定了是吧怎么还不停跟我说要给我钱呢？你是脑子被驴踢了吗这么随便给别人钱的！我都说了我们直接签合同整sublease你给公寓钱啊！给我多不好啊！</p>\n<p>于是我又发了一封信告诉她，解释了一下sublease的具体流程。你把你什么类型的签证告诉我，我去问公寓你需要什么材料，然后我们签sublease——你压根不用给我钱，你直接给公寓钱去，你给我钱我还膈应呢！</p>\n<p>谁知道，这邮件一发，Linda Cui再也没有理我。</p>\n<p>我以为我措辞出问题了。我仔细检查了下邮件，没毛病啊我还祝她妈尽快康复呢，咋就不理我了捏，被截胡了吗。这么推心置腹的好房客溜溜球了可不是好消息啊，毕竟波士顿房子根本租不出去啊！于是我茶饭不思，对她朝思暮想。惊慌中我还发了个我们公寓签sublease的官方agreement，表明我一切行为绝对正当。可Linda还是没有再给我任何回复</p>\n<h2 id=\"来自朱哥的神助攻\"><a href=\"#来自朱哥的神助攻\" class=\"headerlink\" title=\"来自朱哥的神助攻\"></a>来自朱哥的神助攻</h2><p>我有一位儒雅随和的客厅室友。因为我也是儒雅随和的人，所以经常去跟他互动。我们的对话频率非常高，通常如下：</p>\n<blockquote>\n<p>吃饭吗？</p>\n<p>点外卖吗？</p>\n<p>吃啥？</p>\n<p>开冲</p>\n</blockquote>\n<p>这几日我们在一起冲的时候，聊到了租房的问题。于是我给他看了Linda Cui的邮件。朱哥看完赞不绝口，觉得这简直是艺术品，人间瑰宝。对方也太有诚意了，整挺好。</p>\n<p>可这日凌晨朱哥突然用微信发来一个链接，我点开一看，标题赫然写着：《<strong>挂一个租房骗子Linda Cui</strong>》。朱哥说他在一亩三分地首页看到的，要不是我给他看过Linda Cui的邮件，他肯定不会点进这帖子……</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321011057.png\"  alt=\"一亩三分地\"></p>\n<p>当时我就是一懵。点进去一看发现连邮件内容都一模一样，就是从第三封邮件开始会根据你的回复稍作一些修改。</p>\n<p>其中链接分别是：</p>\n<p><a href=\"https://hellogwu.com/thread-75629-1-1.html\" target=\"_blank\" rel=\"noopener\">HelloGWU</a></p>\n<p><a href=\"https://www.1point3acres.com/bbs/thread-596997-1-1.html\" target=\"_blank\" rel=\"noopener\">一亩三分地</a></p>\n<p><a href=\"https://www.psucssa.com/bbs/fang-wu-zu-ren/wo-jue-de-wo-yu-dao-yi-ge-zu-fang-pian-zi\" target=\"_blank\" rel=\"noopener\">PSU CSSA论坛</a></p>\n<p><a href=\"http://bbs.chineseofchicago.com/showtopic-61020.aspx\" target=\"_blank\" rel=\"noopener\">芝加哥侨学网</a></p>\n<p>真可谓是广撒种，啥地方的房她都租。信都不带改的，还骗了不少人。</p>\n<p>大概的套路就是，你假如接受了她的deposit，她就会给你的住址发个价格不菲的支票。随后她会向你借钱，有人甚至直接被借了1500+1000+400刀。有人是兑换了支票，发现账号内钱增加了，以为兑换成功，便放松了警惕。随后在对方借钱时，因为对方推心置腹而且给自己打了钱，便不好意思拒绝。结果打完钱过了几天发现Linda的uncle寄过来的是假支票，银行取消了你的兑换，把钱扣除了。而你借给Linda的钱也再也无从追寻</p>\n<p>其实我觉得这个事情吧，银行应该负主要责任。一张支票假如未兑换成功，你就应该显示processing，而不是直接把支票金额加到你的账户里去。就是因为这个账户金额的增加才会导致很多人放松警惕的</p>\n<p>话说回来，支票这种应该只存在于上个世纪的东西，到底什么时候才能消失啊……</p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>我就说为啥Linda突然不理我了，大概是我问了她签证之类的信息，她无法回答。而且我要签sublease，她似乎无法从其中捞到油水。</p>\n<p>我现在打算告诉她我需要她寄给我deposit了。倒是很想看看假支票长啥样</p>\n<p>要是我拿了支票就不理Linda，她会不会狂轰乱炸我呢？</p>\n<p>不过也有可能我现在已经不会再收到来自Linda的邮件了</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>作为一个菜鸡，在下的上岸时间可谓是非常之晚了。上岸迟就会出现一个问题——房子租不出去。</p>\n<p>在波士顿这个鬼地方，你想租房子至少得整一年，导致基本所有春季毕业的学生都会遇到房屋出租问题。很多亚马逊return的同学都花了一整个学期才把房子租出去。他们的出租对象往往是那些春季入学的人，所以好歹房子还能租出去。</p>\n<p>我们这些春季才上岸的人就不同了——你要是想三月份出租你的房间，那就根本没有target用户。春季入学的新生们都是二月入住，你已经错过了；而波士顿这鬼地方工作机会也不是很多，没什么过来工作的新人。再加上因为波士顿学校多，租房产业过于发达，空房一大堆，想要租出去自己的房子，可谓难上加难。</p>\n<p>我在各大租房微信群狂轰乱炸了几天，压根找不到要租的人。无奈之下跑到一亩三分地去发了个出租房间的帖子，大概描述了我房间的情况，然后留了微信和邮箱。</p>\n<p>万万没想到一亩三分地如此牛逼，一晚上就有人进场了。这位选手就是我们的重量级人物——Linda Cui</p>\n<h2 id=\"Linda-Cui-的第一封信\"><a href=\"#Linda-Cui-的第一封信\" class=\"headerlink\" title=\"Linda Cui 的第一封信\"></a>Linda Cui 的第一封信</h2><p>传奇通常都不是一蹴而就。</p>\n<p>Linda Cui的第一封信，看起来有点像弱智儿童发的</p>\n<blockquote>\n<p>Hi, Is the room available and move in date? Thank you</p>\n</blockquote>\n<p>说实话当时我没看懂这句话的文法。不过这不要紧。看这发件人邮箱是[<a href=\"mailto:linyixiancu@hotmail.com\">linyixiancu@hotmail.com</a>](mailto:Linda Cui )，姓名是“Linda Cui”。中国人嘛，英文不行没事，我寻思着。于是我回复了她，说我房子还健在，您老可以过来参观参观。move in么三月就行了，能搞快点就搞快点，我要溜溜球了</p>\n<p>可万万没有想到的是，紧随而来的第二封信，竟然level up了如此之多</p>\n<h2 id=\"Linda-Cui-的第二封信\"><a href=\"#Linda-Cui-的第二封信\" class=\"headerlink\" title=\"Linda Cui 的第二封信\"></a>Linda Cui 的第二封信</h2><p>（下面有翻译）</p>\n<blockquote>\n<p>Hello XX,</p>\n<p>Thanks for writing back. I’m very much interested in renting the room and I really hope we could get along with each other. I plan to arrive on 10th of March.</p>\n<p>About me: I’m a mixed race of Chinese and British and I speak Mandarin fluently, currently living in the United Kingdom, I’m 29 yrs old. I’m Educated (Undergraduate and Post Graduate Degree), a devoted Christian. I don’t smoke nor drink and I don’t mind if room mates do. I’m currently living at 65 Croydon Rd, Croydon CR0 4QE, I’m pretty quiet and neat, but not obsessively so. I’m responsible and will pull my weight around the apartment and pay bills on time. I like to cook, and it would be great to have people to cook with or eat with, but it’s definitely not a requirement in a room-mate. I’m social though, and get along well with most people.</p>\n<p>And I would really want to secure the room before my arrival, More-so, to know if it would be possible for me to pay for the room before my arrival, So I would like to know the total amount of the room per month and the utility included. All this information are very important so that I can submit my proposal to my Uncle. My Uncle will be responsible for all the fees. Please let me know if I could give you any more info that would be helpful for making your decision. I would be glad if you can tell me little about you too.</p>\n<p>Sorry for the email novel. I hope it isn’t a lot to read and I apologize for coming on strong, I’m just looking for a reliable place when I move down. I look forward to hearing positive from you again.</p>\n<p>Thanks.<br>Linda.</p>\n</blockquote>\n<p>我了个捶捶怎么突然发万字长文给我，我人都傻了。</p>\n<p>我定睛一看，这Linda自称是中英混血，住在大英帝国，29岁，并且受过较高程度的教育，甚至还是个基督教徒。她不喝酒不抽烟是个好女孩，但不介意你们在家乱嗨。下文直接列出一长串自己在大英帝国豪宅的地址，然后说自己干净整洁，及时交房租，会做饭，而且十分social。</p>\n<p>她直接非常想要提前预定房子，然后问你要不要在她到来直接交定金，然后说她uncle会来给她交钱。又问你需不需要她的更多信息，所以你能把房子租给她！</p>\n<p>她言语间的诚恳打动了我，我还以为是哪个欧美不谙世事的良家基督教徒呢！大姐你也太推心置腹了吧！但我寻思着我这波士顿这么多房子租不出去，应该是我怎么打动你而不是你怎么打动我吧？于是我反手一个万字长文，疯狂介绍我所住的公寓，然后给了我的价格。我紧接着说我们还是跟公寓签合同吧，你这样直接给我钱傻乎乎的不太好，随后问她是否需要租我的房子。</p>\n<h2 id=\"Linda-Cui-的第三封信\"><a href=\"#Linda-Cui-的第三封信\" class=\"headerlink\" title=\"Linda Cui 的第三封信\"></a>Linda Cui 的第三封信</h2><blockquote>\n<p>Subject: Security deposit…</p>\n<p>Hiya XX,</p>\n<p>How are you doing? Thanks for the pictures and details of the room, I’m really interested in renting the room for a year or two if possible please, I will keep you posted with my flight information as events unfold. I have jobs interview lined up for me as a Private (Science Tutor) and I’ve been guaranteed a spot as soon as I get there.</p>\n<p>I just got in touch with my Uncle and he can assure you of paying the rent fee monthly without any hesitation and since he will be responsible for paying my rent fees and all, we thought of mailing the deposit payment this week in one of his business trips. Please let me know if this is OK with you. I will need you to email me your information (full name, mailing address, and a direct phone number to reach you) for the payment so that I can have it forwarded to my Uncle as requested.</p>\n<p>If there is a rental agreement application, please understand that I will have it filled and signed out upon my arrival.</p>\n<p>Also, let me know if you will be able to help me keep my little stuffs (dresser, art works, paintings as they will be shipped before my arrival.</p>\n<p>Thanks for willing to give me the room, I can’t wait to meet you. Please remember my mother in your prayers as she will be going through Surgical operation next week.</p>\n<p>Sincerely,<br>Linda.</p>\n</blockquote>\n<p>大意就是说，感谢你的公寓介绍嗷，我可想住你这房子了。我会一直告诉你我的行程的，来美帝我还想工作呢，想住你那几年！我uncle已经跟我说好啦，他会给我付钱的，请把你地址手机啥的信息给我，我好给你打押金！至于你说的跟公寓签合同签sublease的事情，那只能等我到了再说了，请你理解哈！还有，我甚至想提前寄东西到你那边公寓里，可以嘛！你能把公寓租给我，我实在是太高兴了。和你合作真是太愉快了，好希望赶快见到你嘞。</p>\n<p>哦对了，我妈下周做手术了，记得帮我给她祈祷一下。</p>\n<p>看完整封信我心里是满满的WTF，你这是给我钱给定了是吧怎么还不停跟我说要给我钱呢？你是脑子被驴踢了吗这么随便给别人钱的！我都说了我们直接签合同整sublease你给公寓钱啊！给我多不好啊！</p>\n<p>于是我又发了一封信告诉她，解释了一下sublease的具体流程。你把你什么类型的签证告诉我，我去问公寓你需要什么材料，然后我们签sublease——你压根不用给我钱，你直接给公寓钱去，你给我钱我还膈应呢！</p>\n<p>谁知道，这邮件一发，Linda Cui再也没有理我。</p>\n<p>我以为我措辞出问题了。我仔细检查了下邮件，没毛病啊我还祝她妈尽快康复呢，咋就不理我了捏，被截胡了吗。这么推心置腹的好房客溜溜球了可不是好消息啊，毕竟波士顿房子根本租不出去啊！于是我茶饭不思，对她朝思暮想。惊慌中我还发了个我们公寓签sublease的官方agreement，表明我一切行为绝对正当。可Linda还是没有再给我任何回复</p>\n<h2 id=\"来自朱哥的神助攻\"><a href=\"#来自朱哥的神助攻\" class=\"headerlink\" title=\"来自朱哥的神助攻\"></a>来自朱哥的神助攻</h2><p>我有一位儒雅随和的客厅室友。因为我也是儒雅随和的人，所以经常去跟他互动。我们的对话频率非常高，通常如下：</p>\n<blockquote>\n<p>吃饭吗？</p>\n<p>点外卖吗？</p>\n<p>吃啥？</p>\n<p>开冲</p>\n</blockquote>\n<p>这几日我们在一起冲的时候，聊到了租房的问题。于是我给他看了Linda Cui的邮件。朱哥看完赞不绝口，觉得这简直是艺术品，人间瑰宝。对方也太有诚意了，整挺好。</p>\n<p>可这日凌晨朱哥突然用微信发来一个链接，我点开一看，标题赫然写着：《<strong>挂一个租房骗子Linda Cui</strong>》。朱哥说他在一亩三分地首页看到的，要不是我给他看过Linda Cui的邮件，他肯定不会点进这帖子……</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200321011057.png\" alt=\"一亩三分地\"></p>\n<p>当时我就是一懵。点进去一看发现连邮件内容都一模一样，就是从第三封邮件开始会根据你的回复稍作一些修改。</p>\n<p>其中链接分别是：</p>\n<p><a href=\"https://hellogwu.com/thread-75629-1-1.html\" target=\"_blank\" rel=\"noopener\">HelloGWU</a></p>\n<p><a href=\"https://www.1point3acres.com/bbs/thread-596997-1-1.html\" target=\"_blank\" rel=\"noopener\">一亩三分地</a></p>\n<p><a href=\"https://www.psucssa.com/bbs/fang-wu-zu-ren/wo-jue-de-wo-yu-dao-yi-ge-zu-fang-pian-zi\" target=\"_blank\" rel=\"noopener\">PSU CSSA论坛</a></p>\n<p><a href=\"http://bbs.chineseofchicago.com/showtopic-61020.aspx\" target=\"_blank\" rel=\"noopener\">芝加哥侨学网</a></p>\n<p>真可谓是广撒种，啥地方的房她都租。信都不带改的，还骗了不少人。</p>\n<p>大概的套路就是，你假如接受了她的deposit，她就会给你的住址发个价格不菲的支票。随后她会向你借钱，有人甚至直接被借了1500+1000+400刀。有人是兑换了支票，发现账号内钱增加了，以为兑换成功，便放松了警惕。随后在对方借钱时，因为对方推心置腹而且给自己打了钱，便不好意思拒绝。结果打完钱过了几天发现Linda的uncle寄过来的是假支票，银行取消了你的兑换，把钱扣除了。而你借给Linda的钱也再也无从追寻</p>\n<p>其实我觉得这个事情吧，银行应该负主要责任。一张支票假如未兑换成功，你就应该显示processing，而不是直接把支票金额加到你的账户里去。就是因为这个账户金额的增加才会导致很多人放松警惕的</p>\n<p>话说回来，支票这种应该只存在于上个世纪的东西，到底什么时候才能消失啊……</p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>我就说为啥Linda突然不理我了，大概是我问了她签证之类的信息，她无法回答。而且我要签sublease，她似乎无法从其中捞到油水。</p>\n<p>我现在打算告诉她我需要她寄给我deposit了。倒是很想看看假支票长啥样</p>\n<p>要是我拿了支票就不理Linda，她会不会狂轰乱炸我呢？</p>\n<p>不过也有可能我现在已经不会再收到来自Linda的邮件了</p>\n"},{"layout":"post","title":"OBS实现多音轨录制","date":"2020-02-21T20:00:00.000Z","description":"分离视频录制/直播中的麦克风人声、系统声（音响声），让后期制作更加容易","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321005545.png","optimized_image":null,"author":"tty","_content":"\n前段时间闲着无聊录制了一下古剑奇谭三的全剧情通关视频，发现自己小嘴叭叭的挺多余的，还不如光看视频（这里还要吐槽一下罗技G533耳机，我的妈耶你这麦克风也太弟弟了）。\n\n可是自己的声音跟游戏声音已经被录到一个音轨里去了，没办法操作成普通视频。现在就记录一下OBS如何将人声和系统声分离\n\n假如你不是Mac用户请直接跳到第二个h2标题\n\n## 解决Mac中OBS没有电脑声音的问题\n\n你若在Mac中直接打开OBS，你会发现OBS并不能录制系统声。它的声音面板与Windows上的声音面板不同，只有mic一个声音输入。选择输出音频设备的时候，发现列表为空。如图所示：\n\n\n<div style=\"text-align:center\">\n<img src=\"/images/20200221/obs1.png\" alt=\"\" width=\"80%\"/>\n</div>\n\n正常来说OBS既可以捕获输入音频设备（麦克风的音频），也可以捕获输出音频设备（电脑输出到耳机或音响的音频）。为了能让OBS获取到系统声音，我们需要安装[Soundflower](https://github.com/mattingalls/Soundflower)，这是它的[release](https://github.com/mattingalls/Soundflower/releases)，请从release链接中下载最新版本的dmg文件\n\n注意，Soundflower插件是有签名的，可是installer并没有！你需要按住ctrl才能打开Soundflower.pkg的installer安装器\n\n在你第一次运行安装器(Soundflower.pkg)时，它会要求你输入你的管理员密码，并且会**安装失败**！这时不用担心。一个安全警告（security alert）会出现，其上会有带你前往系统偏好（system preference）中Security & Privacy - General面板的按钮。在你到了那里之后，那里会出现一个“allow”（允许）的按钮，请点击它，给它权限。随后，再次运行安装器installer，它会提示你安装成功。\n\n- 注意！\n\n假如你在 Security Preferences系统安全面板中看到了“open anyway”，这说明经你曾经用双击的方法打开过了installer，并且于安装过程中失败了。你在之前的尝试中没有按下ctrl并打开安装包。在这种情况下，请点击“open anyway”，然后再点击那个窗口上的“open”以打开installer。随后你应该能在security preference面板上看到allow按钮。\n\n- 假如你还是没有看到allow按钮\n\n如果你未曾关闭 Security Preferences那个窗口，请尝试关闭它，随后再进入 左上角的苹果图标->System Preference->Security Preferences->General，检查是否刷新出了allow按钮\n\n---\n\n安装之后重启电脑。\n\n然后装完你就发现OBS里还是什么都没有！惊不惊喜？意不意外？但是当你重启完电脑之后，在右上角的volume声音面板里（假如你没在右上角显示声音，请移步System Preference->Sound，勾选Show volume in menu bar），你就发现输出选项多了Soundflower(2ch)和Soundflower(64ch)。我们先选择Soundflower(2ch)进行输出。此时你假如在mac上播放了音乐，会发现音乐并没有从你的mac音响中输出，因为此时我们切换了输出方式\n\n我们回到OBS当中，打开Settings->Audio，此时desktop audio应该处在默认disabled状态。我们选择Soundflower 2ch， 再次回到obs主界面。如果这时你再播放音乐，会发现系统声音已经能够出现在OBS的desktop音源当中\n\n可这并不是我们想要的结果。我们希望的结果是既能录制desktop声音，也能听到desktop声音。\n\n于是我们先切换到所有应用，搜索MIDI，应该会看到一个叫Audio MIDI setup的应用。在这个应用中我们点击左下角的加号，选择第二项create multi-output device，然后勾选你想听到有输出的设备（例如Macbook Pro Speakers，也就是默认电脑自带的扬声器），和Soundflower2。这意味着你的电脑会同时将声音输出给扬声器和Soundflower2。\n\n我们回到右上角状态栏中的声音面板，output此时会多出一个叫multi-output device的选项。我们选择以它进行输出。如此，你就既能在OBS中收到系统音，又能在外部听到系统音了\n\n需要注意的是，**在切换输出设备到multi-output device之前，请先调整好系统音量，因为一旦你切换设备后，将无法改变音量大小。**\n\n## OBS录制麦克风人声和系统声到不同音轨\n\n1. 首先我们打开Settings->Output，然后在上方将设置从简易的simple模式调整至advanced模式\n2. 在streaming面板中将audio track设置为1（其他数字也可以，后面会再解释）\n3. 切换到recording面板，将audio track设置为2和3（三个轨道各不相同即可）**注意**：flv格式不支持这个操作，请切换到其他格式\n4. 回到OBS主界面,点击麦克风右侧的设置齿轮,选择advanced audio properties,随后将desktop audio的tracks设置为1和2,将mic的tracks设置为1和3\n\n因为我们之前设置的streaming模式中输出track为1,所以此时streaming的track1中会有desktop和mic的声音,直播的观众们会听到你的系统声和人声。而在录制的时候我们只在设置中录下了2和3两个track，2是desktop声，3是mic声。这两个声音会分成不同的音轨出现在视频里。\n\n","source":"_posts/2020-02-21-OBS实现多音轨录制.md","raw":"---\nlayout: post\ntitle:  OBS实现多音轨录制\ndate:   2020-02-21 12:00:00\ndescription: 分离视频录制/直播中的麦克风人声、系统声（音响声），让后期制作更加容易\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321005545.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - tips\nauthor: tty\n---\n\n前段时间闲着无聊录制了一下古剑奇谭三的全剧情通关视频，发现自己小嘴叭叭的挺多余的，还不如光看视频（这里还要吐槽一下罗技G533耳机，我的妈耶你这麦克风也太弟弟了）。\n\n可是自己的声音跟游戏声音已经被录到一个音轨里去了，没办法操作成普通视频。现在就记录一下OBS如何将人声和系统声分离\n\n假如你不是Mac用户请直接跳到第二个h2标题\n\n## 解决Mac中OBS没有电脑声音的问题\n\n你若在Mac中直接打开OBS，你会发现OBS并不能录制系统声。它的声音面板与Windows上的声音面板不同，只有mic一个声音输入。选择输出音频设备的时候，发现列表为空。如图所示：\n\n\n<div style=\"text-align:center\">\n<img src=\"/images/20200221/obs1.png\" alt=\"\" width=\"80%\"/>\n</div>\n\n正常来说OBS既可以捕获输入音频设备（麦克风的音频），也可以捕获输出音频设备（电脑输出到耳机或音响的音频）。为了能让OBS获取到系统声音，我们需要安装[Soundflower](https://github.com/mattingalls/Soundflower)，这是它的[release](https://github.com/mattingalls/Soundflower/releases)，请从release链接中下载最新版本的dmg文件\n\n注意，Soundflower插件是有签名的，可是installer并没有！你需要按住ctrl才能打开Soundflower.pkg的installer安装器\n\n在你第一次运行安装器(Soundflower.pkg)时，它会要求你输入你的管理员密码，并且会**安装失败**！这时不用担心。一个安全警告（security alert）会出现，其上会有带你前往系统偏好（system preference）中Security & Privacy - General面板的按钮。在你到了那里之后，那里会出现一个“allow”（允许）的按钮，请点击它，给它权限。随后，再次运行安装器installer，它会提示你安装成功。\n\n- 注意！\n\n假如你在 Security Preferences系统安全面板中看到了“open anyway”，这说明经你曾经用双击的方法打开过了installer，并且于安装过程中失败了。你在之前的尝试中没有按下ctrl并打开安装包。在这种情况下，请点击“open anyway”，然后再点击那个窗口上的“open”以打开installer。随后你应该能在security preference面板上看到allow按钮。\n\n- 假如你还是没有看到allow按钮\n\n如果你未曾关闭 Security Preferences那个窗口，请尝试关闭它，随后再进入 左上角的苹果图标->System Preference->Security Preferences->General，检查是否刷新出了allow按钮\n\n---\n\n安装之后重启电脑。\n\n然后装完你就发现OBS里还是什么都没有！惊不惊喜？意不意外？但是当你重启完电脑之后，在右上角的volume声音面板里（假如你没在右上角显示声音，请移步System Preference->Sound，勾选Show volume in menu bar），你就发现输出选项多了Soundflower(2ch)和Soundflower(64ch)。我们先选择Soundflower(2ch)进行输出。此时你假如在mac上播放了音乐，会发现音乐并没有从你的mac音响中输出，因为此时我们切换了输出方式\n\n我们回到OBS当中，打开Settings->Audio，此时desktop audio应该处在默认disabled状态。我们选择Soundflower 2ch， 再次回到obs主界面。如果这时你再播放音乐，会发现系统声音已经能够出现在OBS的desktop音源当中\n\n可这并不是我们想要的结果。我们希望的结果是既能录制desktop声音，也能听到desktop声音。\n\n于是我们先切换到所有应用，搜索MIDI，应该会看到一个叫Audio MIDI setup的应用。在这个应用中我们点击左下角的加号，选择第二项create multi-output device，然后勾选你想听到有输出的设备（例如Macbook Pro Speakers，也就是默认电脑自带的扬声器），和Soundflower2。这意味着你的电脑会同时将声音输出给扬声器和Soundflower2。\n\n我们回到右上角状态栏中的声音面板，output此时会多出一个叫multi-output device的选项。我们选择以它进行输出。如此，你就既能在OBS中收到系统音，又能在外部听到系统音了\n\n需要注意的是，**在切换输出设备到multi-output device之前，请先调整好系统音量，因为一旦你切换设备后，将无法改变音量大小。**\n\n## OBS录制麦克风人声和系统声到不同音轨\n\n1. 首先我们打开Settings->Output，然后在上方将设置从简易的simple模式调整至advanced模式\n2. 在streaming面板中将audio track设置为1（其他数字也可以，后面会再解释）\n3. 切换到recording面板，将audio track设置为2和3（三个轨道各不相同即可）**注意**：flv格式不支持这个操作，请切换到其他格式\n4. 回到OBS主界面,点击麦克风右侧的设置齿轮,选择advanced audio properties,随后将desktop audio的tracks设置为1和2,将mic的tracks设置为1和3\n\n因为我们之前设置的streaming模式中输出track为1,所以此时streaming的track1中会有desktop和mic的声音,直播的观众们会听到你的系统声和人声。而在录制的时候我们只在设置中录下了2和3两个track，2是desktop声，3是mic声。这两个声音会分成不同的音轨出现在视频里。\n\n","slug":"OBS实现多音轨录制","published":1,"updated":"2020-03-29T06:59:20.713Z","photos":[],"link":"","_id":"ck8ct7j5i000agtvievlbgbkx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>前段时间闲着无聊录制了一下古剑奇谭三的全剧情通关视频，发现自己小嘴叭叭的挺多余的，还不如光看视频（这里还要吐槽一下罗技G533耳机，我的妈耶你这麦克风也太弟弟了）。</p>\n<p>可是自己的声音跟游戏声音已经被录到一个音轨里去了，没办法操作成普通视频。现在就记录一下OBS如何将人声和系统声分离</p>\n<p>假如你不是Mac用户请直接跳到第二个h2标题</p>\n<h2 id=\"解决Mac中OBS没有电脑声音的问题\"><a href=\"#解决Mac中OBS没有电脑声音的问题\" class=\"headerlink\" title=\"解决Mac中OBS没有电脑声音的问题\"></a>解决Mac中OBS没有电脑声音的问题</h2><p>你若在Mac中直接打开OBS，你会发现OBS并不能录制系统声。它的声音面板与Windows上的声音面板不同，只有mic一个声音输入。选择输出音频设备的时候，发现列表为空。如图所示：</p>\n<div style=\"text-align:center\">\n<img src=\"/\" class=\"lazyload\" data-src=\"/images/20200221/obs1.png\"  alt=\"\" width=\"80%\"/>\n</div>\n\n<p>正常来说OBS既可以捕获输入音频设备（麦克风的音频），也可以捕获输出音频设备（电脑输出到耳机或音响的音频）。为了能让OBS获取到系统声音，我们需要安装<a href=\"https://github.com/mattingalls/Soundflower\" target=\"_blank\" rel=\"noopener\">Soundflower</a>，这是它的<a href=\"https://github.com/mattingalls/Soundflower/releases\" target=\"_blank\" rel=\"noopener\">release</a>，请从release链接中下载最新版本的dmg文件</p>\n<p>注意，Soundflower插件是有签名的，可是installer并没有！你需要按住ctrl才能打开Soundflower.pkg的installer安装器</p>\n<p>在你第一次运行安装器(Soundflower.pkg)时，它会要求你输入你的管理员密码，并且会<strong>安装失败</strong>！这时不用担心。一个安全警告（security alert）会出现，其上会有带你前往系统偏好（system preference）中Security &amp; Privacy - General面板的按钮。在你到了那里之后，那里会出现一个“allow”（允许）的按钮，请点击它，给它权限。随后，再次运行安装器installer，它会提示你安装成功。</p>\n<ul>\n<li>注意！</li>\n</ul>\n<p>假如你在 Security Preferences系统安全面板中看到了“open anyway”，这说明经你曾经用双击的方法打开过了installer，并且于安装过程中失败了。你在之前的尝试中没有按下ctrl并打开安装包。在这种情况下，请点击“open anyway”，然后再点击那个窗口上的“open”以打开installer。随后你应该能在security preference面板上看到allow按钮。</p>\n<ul>\n<li>假如你还是没有看到allow按钮</li>\n</ul>\n<p>如果你未曾关闭 Security Preferences那个窗口，请尝试关闭它，随后再进入 左上角的苹果图标-&gt;System Preference-&gt;Security Preferences-&gt;General，检查是否刷新出了allow按钮</p>\n<hr>\n<p>安装之后重启电脑。</p>\n<p>然后装完你就发现OBS里还是什么都没有！惊不惊喜？意不意外？但是当你重启完电脑之后，在右上角的volume声音面板里（假如你没在右上角显示声音，请移步System Preference-&gt;Sound，勾选Show volume in menu bar），你就发现输出选项多了Soundflower(2ch)和Soundflower(64ch)。我们先选择Soundflower(2ch)进行输出。此时你假如在mac上播放了音乐，会发现音乐并没有从你的mac音响中输出，因为此时我们切换了输出方式</p>\n<p>我们回到OBS当中，打开Settings-&gt;Audio，此时desktop audio应该处在默认disabled状态。我们选择Soundflower 2ch， 再次回到obs主界面。如果这时你再播放音乐，会发现系统声音已经能够出现在OBS的desktop音源当中</p>\n<p>可这并不是我们想要的结果。我们希望的结果是既能录制desktop声音，也能听到desktop声音。</p>\n<p>于是我们先切换到所有应用，搜索MIDI，应该会看到一个叫Audio MIDI setup的应用。在这个应用中我们点击左下角的加号，选择第二项create multi-output device，然后勾选你想听到有输出的设备（例如Macbook Pro Speakers，也就是默认电脑自带的扬声器），和Soundflower2。这意味着你的电脑会同时将声音输出给扬声器和Soundflower2。</p>\n<p>我们回到右上角状态栏中的声音面板，output此时会多出一个叫multi-output device的选项。我们选择以它进行输出。如此，你就既能在OBS中收到系统音，又能在外部听到系统音了</p>\n<p>需要注意的是，<strong>在切换输出设备到multi-output device之前，请先调整好系统音量，因为一旦你切换设备后，将无法改变音量大小。</strong></p>\n<h2 id=\"OBS录制麦克风人声和系统声到不同音轨\"><a href=\"#OBS录制麦克风人声和系统声到不同音轨\" class=\"headerlink\" title=\"OBS录制麦克风人声和系统声到不同音轨\"></a>OBS录制麦克风人声和系统声到不同音轨</h2><ol>\n<li>首先我们打开Settings-&gt;Output，然后在上方将设置从简易的simple模式调整至advanced模式</li>\n<li>在streaming面板中将audio track设置为1（其他数字也可以，后面会再解释）</li>\n<li>切换到recording面板，将audio track设置为2和3（三个轨道各不相同即可）<strong>注意</strong>：flv格式不支持这个操作，请切换到其他格式</li>\n<li>回到OBS主界面,点击麦克风右侧的设置齿轮,选择advanced audio properties,随后将desktop audio的tracks设置为1和2,将mic的tracks设置为1和3</li>\n</ol>\n<p>因为我们之前设置的streaming模式中输出track为1,所以此时streaming的track1中会有desktop和mic的声音,直播的观众们会听到你的系统声和人声。而在录制的时候我们只在设置中录下了2和3两个track，2是desktop声，3是mic声。这两个声音会分成不同的音轨出现在视频里。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>前段时间闲着无聊录制了一下古剑奇谭三的全剧情通关视频，发现自己小嘴叭叭的挺多余的，还不如光看视频（这里还要吐槽一下罗技G533耳机，我的妈耶你这麦克风也太弟弟了）。</p>\n<p>可是自己的声音跟游戏声音已经被录到一个音轨里去了，没办法操作成普通视频。现在就记录一下OBS如何将人声和系统声分离</p>\n<p>假如你不是Mac用户请直接跳到第二个h2标题</p>\n<h2 id=\"解决Mac中OBS没有电脑声音的问题\"><a href=\"#解决Mac中OBS没有电脑声音的问题\" class=\"headerlink\" title=\"解决Mac中OBS没有电脑声音的问题\"></a>解决Mac中OBS没有电脑声音的问题</h2><p>你若在Mac中直接打开OBS，你会发现OBS并不能录制系统声。它的声音面板与Windows上的声音面板不同，只有mic一个声音输入。选择输出音频设备的时候，发现列表为空。如图所示：</p>\n<div style=\"text-align:center\">\n<img src=\"/images/20200221/obs1.png\" alt=\"\" width=\"80%\"/>\n</div>\n\n<p>正常来说OBS既可以捕获输入音频设备（麦克风的音频），也可以捕获输出音频设备（电脑输出到耳机或音响的音频）。为了能让OBS获取到系统声音，我们需要安装<a href=\"https://github.com/mattingalls/Soundflower\" target=\"_blank\" rel=\"noopener\">Soundflower</a>，这是它的<a href=\"https://github.com/mattingalls/Soundflower/releases\" target=\"_blank\" rel=\"noopener\">release</a>，请从release链接中下载最新版本的dmg文件</p>\n<p>注意，Soundflower插件是有签名的，可是installer并没有！你需要按住ctrl才能打开Soundflower.pkg的installer安装器</p>\n<p>在你第一次运行安装器(Soundflower.pkg)时，它会要求你输入你的管理员密码，并且会<strong>安装失败</strong>！这时不用担心。一个安全警告（security alert）会出现，其上会有带你前往系统偏好（system preference）中Security &amp; Privacy - General面板的按钮。在你到了那里之后，那里会出现一个“allow”（允许）的按钮，请点击它，给它权限。随后，再次运行安装器installer，它会提示你安装成功。</p>\n<ul>\n<li>注意！</li>\n</ul>\n<p>假如你在 Security Preferences系统安全面板中看到了“open anyway”，这说明经你曾经用双击的方法打开过了installer，并且于安装过程中失败了。你在之前的尝试中没有按下ctrl并打开安装包。在这种情况下，请点击“open anyway”，然后再点击那个窗口上的“open”以打开installer。随后你应该能在security preference面板上看到allow按钮。</p>\n<ul>\n<li>假如你还是没有看到allow按钮</li>\n</ul>\n<p>如果你未曾关闭 Security Preferences那个窗口，请尝试关闭它，随后再进入 左上角的苹果图标-&gt;System Preference-&gt;Security Preferences-&gt;General，检查是否刷新出了allow按钮</p>\n<hr>\n<p>安装之后重启电脑。</p>\n<p>然后装完你就发现OBS里还是什么都没有！惊不惊喜？意不意外？但是当你重启完电脑之后，在右上角的volume声音面板里（假如你没在右上角显示声音，请移步System Preference-&gt;Sound，勾选Show volume in menu bar），你就发现输出选项多了Soundflower(2ch)和Soundflower(64ch)。我们先选择Soundflower(2ch)进行输出。此时你假如在mac上播放了音乐，会发现音乐并没有从你的mac音响中输出，因为此时我们切换了输出方式</p>\n<p>我们回到OBS当中，打开Settings-&gt;Audio，此时desktop audio应该处在默认disabled状态。我们选择Soundflower 2ch， 再次回到obs主界面。如果这时你再播放音乐，会发现系统声音已经能够出现在OBS的desktop音源当中</p>\n<p>可这并不是我们想要的结果。我们希望的结果是既能录制desktop声音，也能听到desktop声音。</p>\n<p>于是我们先切换到所有应用，搜索MIDI，应该会看到一个叫Audio MIDI setup的应用。在这个应用中我们点击左下角的加号，选择第二项create multi-output device，然后勾选你想听到有输出的设备（例如Macbook Pro Speakers，也就是默认电脑自带的扬声器），和Soundflower2。这意味着你的电脑会同时将声音输出给扬声器和Soundflower2。</p>\n<p>我们回到右上角状态栏中的声音面板，output此时会多出一个叫multi-output device的选项。我们选择以它进行输出。如此，你就既能在OBS中收到系统音，又能在外部听到系统音了</p>\n<p>需要注意的是，<strong>在切换输出设备到multi-output device之前，请先调整好系统音量，因为一旦你切换设备后，将无法改变音量大小。</strong></p>\n<h2 id=\"OBS录制麦克风人声和系统声到不同音轨\"><a href=\"#OBS录制麦克风人声和系统声到不同音轨\" class=\"headerlink\" title=\"OBS录制麦克风人声和系统声到不同音轨\"></a>OBS录制麦克风人声和系统声到不同音轨</h2><ol>\n<li>首先我们打开Settings-&gt;Output，然后在上方将设置从简易的simple模式调整至advanced模式</li>\n<li>在streaming面板中将audio track设置为1（其他数字也可以，后面会再解释）</li>\n<li>切换到recording面板，将audio track设置为2和3（三个轨道各不相同即可）<strong>注意</strong>：flv格式不支持这个操作，请切换到其他格式</li>\n<li>回到OBS主界面,点击麦克风右侧的设置齿轮,选择advanced audio properties,随后将desktop audio的tracks设置为1和2,将mic的tracks设置为1和3</li>\n</ol>\n<p>因为我们之前设置的streaming模式中输出track为1,所以此时streaming的track1中会有desktop和mic的声音,直播的观众们会听到你的系统声和人声。而在录制的时候我们只在设置中录下了2和3两个track，2是desktop声，3是mic声。这两个声音会分成不同的音轨出现在视频里。</p>\n"},{"layout":"post","title":"为低分辨率屏幕开启HiDPI","date":"2020-03-17T19:00:00.000Z","description":"解决MacOS在低分辨率显示器(1080P, 2560x1440[2k], 3440x1440[2k 21:9])上显示效果差的问题","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321004801.png","optimized_image":null,"author":"tty","_content":"\n我一直不推荐Mac用户购买21:9的显示器，理由有很多。光是不买21:9的理由就不少，因为就个人的使用体验来说，21:9的生产力是远远不及双屏的生产力的，双屏的分屏控制不知道比21:9要高到哪里去了。\n\n再者，Mac对4K以下的分辨率十分不友好，在2K，1080p中，字体发虚模糊都是很正常的事情。一切换成Windows，你就立马觉得字体变得清晰了很多，足以看出Mac对于低分屏有多不用心了。\n\n但是因为AW3420DW近期在打折，我看也没啥4K屏有好价，便干脆再次入手了一个，希望它在AW3418DW之上有所改观。一插上电我就后悔了，熟悉的发虚字体又回来了。\n\n这个时候唯一的解决办法就是HiDPI了。这个功能MacOS并不在低分屏上开启，所以我们要手动开启。其一共有三个步骤\n\n## 1. 关闭SIP（System Integrity Protection）\n\n1. Click the **Apple symbol** in the Menu bar.\n2. Click **Restart**\n3. Hold down **Command-R** to reboot into Recovery Mode.\n4. Click **Utilities**.\n5. Select **Terminal**.\n6. Type **`csrutil disable`**.\n7. Press **Return** or **Enter** on your keyboard.\n8. Click the **Apple symbol** in the Menu bar.\n9. Click **Restart**\n\n## 2. 使用一键脚本\n\n[One Key HiDPI](https://github.com/xzhih/one-key-hidpi)\n\n阅读其readme，中英双语，相信身为高材生的你不难搞定\n\n其中，我们21:9的用户由于并不常见，可以选择手动输入分辨率，输入2560x1072 5120x2144就好\n\n接下来重启，应该就能看到效果，选择一个合适的缩放即可\n\n假如你觉得视觉效果还是不行，那是这个显示器分辨率不够高。你已经到显示效果极限了。假如你并不满意，建议还是上双4K屏幕，省心省力，而且清晰\n","source":"_posts/2020-03-17-为低分辨率屏幕开启HiDPI.md","raw":"---\nlayout: post\ntitle:  为低分辨率屏幕开启HiDPI\ndate:   2020-03-17 12:00:00\ndescription: 解决MacOS在低分辨率显示器(1080P, 2560x1440[2k], 3440x1440[2k 21:9])上显示效果差的问题\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321004801.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - tips\nauthor: tty\n---\n\n我一直不推荐Mac用户购买21:9的显示器，理由有很多。光是不买21:9的理由就不少，因为就个人的使用体验来说，21:9的生产力是远远不及双屏的生产力的，双屏的分屏控制不知道比21:9要高到哪里去了。\n\n再者，Mac对4K以下的分辨率十分不友好，在2K，1080p中，字体发虚模糊都是很正常的事情。一切换成Windows，你就立马觉得字体变得清晰了很多，足以看出Mac对于低分屏有多不用心了。\n\n但是因为AW3420DW近期在打折，我看也没啥4K屏有好价，便干脆再次入手了一个，希望它在AW3418DW之上有所改观。一插上电我就后悔了，熟悉的发虚字体又回来了。\n\n这个时候唯一的解决办法就是HiDPI了。这个功能MacOS并不在低分屏上开启，所以我们要手动开启。其一共有三个步骤\n\n## 1. 关闭SIP（System Integrity Protection）\n\n1. Click the **Apple symbol** in the Menu bar.\n2. Click **Restart**\n3. Hold down **Command-R** to reboot into Recovery Mode.\n4. Click **Utilities**.\n5. Select **Terminal**.\n6. Type **`csrutil disable`**.\n7. Press **Return** or **Enter** on your keyboard.\n8. Click the **Apple symbol** in the Menu bar.\n9. Click **Restart**\n\n## 2. 使用一键脚本\n\n[One Key HiDPI](https://github.com/xzhih/one-key-hidpi)\n\n阅读其readme，中英双语，相信身为高材生的你不难搞定\n\n其中，我们21:9的用户由于并不常见，可以选择手动输入分辨率，输入2560x1072 5120x2144就好\n\n接下来重启，应该就能看到效果，选择一个合适的缩放即可\n\n假如你觉得视觉效果还是不行，那是这个显示器分辨率不够高。你已经到显示效果极限了。假如你并不满意，建议还是上双4K屏幕，省心省力，而且清晰\n","slug":"为低分辨率屏幕开启HiDPI","published":1,"updated":"2020-03-29T06:59:20.714Z","photos":[],"link":"","_id":"ck8ct7j5k000egtvi52cphgi5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我一直不推荐Mac用户购买21:9的显示器，理由有很多。光是不买21:9的理由就不少，因为就个人的使用体验来说，21:9的生产力是远远不及双屏的生产力的，双屏的分屏控制不知道比21:9要高到哪里去了。</p>\n<p>再者，Mac对4K以下的分辨率十分不友好，在2K，1080p中，字体发虚模糊都是很正常的事情。一切换成Windows，你就立马觉得字体变得清晰了很多，足以看出Mac对于低分屏有多不用心了。</p>\n<p>但是因为AW3420DW近期在打折，我看也没啥4K屏有好价，便干脆再次入手了一个，希望它在AW3418DW之上有所改观。一插上电我就后悔了，熟悉的发虚字体又回来了。</p>\n<p>这个时候唯一的解决办法就是HiDPI了。这个功能MacOS并不在低分屏上开启，所以我们要手动开启。其一共有三个步骤</p>\n<h2 id=\"1-关闭SIP（System-Integrity-Protection）\"><a href=\"#1-关闭SIP（System-Integrity-Protection）\" class=\"headerlink\" title=\"1. 关闭SIP（System Integrity Protection）\"></a>1. 关闭SIP（System Integrity Protection）</h2><ol>\n<li>Click the <strong>Apple symbol</strong> in the Menu bar.</li>\n<li>Click <strong>Restart</strong></li>\n<li>Hold down <strong>Command-R</strong> to reboot into Recovery Mode.</li>\n<li>Click <strong>Utilities</strong>.</li>\n<li>Select <strong>Terminal</strong>.</li>\n<li>Type <strong><code>csrutil disable</code></strong>.</li>\n<li>Press <strong>Return</strong> or <strong>Enter</strong> on your keyboard.</li>\n<li>Click the <strong>Apple symbol</strong> in the Menu bar.</li>\n<li>Click <strong>Restart</strong></li>\n</ol>\n<h2 id=\"2-使用一键脚本\"><a href=\"#2-使用一键脚本\" class=\"headerlink\" title=\"2. 使用一键脚本\"></a>2. 使用一键脚本</h2><p><a href=\"https://github.com/xzhih/one-key-hidpi\" target=\"_blank\" rel=\"noopener\">One Key HiDPI</a></p>\n<p>阅读其readme，中英双语，相信身为高材生的你不难搞定</p>\n<p>其中，我们21:9的用户由于并不常见，可以选择手动输入分辨率，输入2560x1072 5120x2144就好</p>\n<p>接下来重启，应该就能看到效果，选择一个合适的缩放即可</p>\n<p>假如你觉得视觉效果还是不行，那是这个显示器分辨率不够高。你已经到显示效果极限了。假如你并不满意，建议还是上双4K屏幕，省心省力，而且清晰</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>我一直不推荐Mac用户购买21:9的显示器，理由有很多。光是不买21:9的理由就不少，因为就个人的使用体验来说，21:9的生产力是远远不及双屏的生产力的，双屏的分屏控制不知道比21:9要高到哪里去了。</p>\n<p>再者，Mac对4K以下的分辨率十分不友好，在2K，1080p中，字体发虚模糊都是很正常的事情。一切换成Windows，你就立马觉得字体变得清晰了很多，足以看出Mac对于低分屏有多不用心了。</p>\n<p>但是因为AW3420DW近期在打折，我看也没啥4K屏有好价，便干脆再次入手了一个，希望它在AW3418DW之上有所改观。一插上电我就后悔了，熟悉的发虚字体又回来了。</p>\n<p>这个时候唯一的解决办法就是HiDPI了。这个功能MacOS并不在低分屏上开启，所以我们要手动开启。其一共有三个步骤</p>\n<h2 id=\"1-关闭SIP（System-Integrity-Protection）\"><a href=\"#1-关闭SIP（System-Integrity-Protection）\" class=\"headerlink\" title=\"1. 关闭SIP（System Integrity Protection）\"></a>1. 关闭SIP（System Integrity Protection）</h2><ol>\n<li>Click the <strong>Apple symbol</strong> in the Menu bar.</li>\n<li>Click <strong>Restart</strong></li>\n<li>Hold down <strong>Command-R</strong> to reboot into Recovery Mode.</li>\n<li>Click <strong>Utilities</strong>.</li>\n<li>Select <strong>Terminal</strong>.</li>\n<li>Type <strong><code>csrutil disable</code></strong>.</li>\n<li>Press <strong>Return</strong> or <strong>Enter</strong> on your keyboard.</li>\n<li>Click the <strong>Apple symbol</strong> in the Menu bar.</li>\n<li>Click <strong>Restart</strong></li>\n</ol>\n<h2 id=\"2-使用一键脚本\"><a href=\"#2-使用一键脚本\" class=\"headerlink\" title=\"2. 使用一键脚本\"></a>2. 使用一键脚本</h2><p><a href=\"https://github.com/xzhih/one-key-hidpi\" target=\"_blank\" rel=\"noopener\">One Key HiDPI</a></p>\n<p>阅读其readme，中英双语，相信身为高材生的你不难搞定</p>\n<p>其中，我们21:9的用户由于并不常见，可以选择手动输入分辨率，输入2560x1072 5120x2144就好</p>\n<p>接下来重启，应该就能看到效果，选择一个合适的缩放即可</p>\n<p>假如你觉得视觉效果还是不行，那是这个显示器分辨率不够高。你已经到显示效果极限了。假如你并不满意，建议还是上双4K屏幕，省心省力，而且清晰</p>\n"},{"layout":"post","title":"New Hire Benefit 全解","date":"2020-03-17T19:00:00.000Z","description":"让你听明白benefit部门的人到底在说什","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321005039.png","optimized_image":null,"author":"tty","_content":"\n**本文纯属转载**\n\n第一天remote onboarding，benefit的人上来对保险一顿讲解，讲得我头晕眼花。回来仔细查查，才好了解自己到底要买哪个。虽然现在新冠疫情严重，我早已决定把保险拉满（冲\n\n## Medical Insurance\n\nFirst of all there are some terms that you need to know, because these are the main differences of all the insurances.\n\n**此处部分原文来源[虎虎保险](https://tigerless.com/how-to-choose-us-health-insurance/)**\n\n- **1 保险费(Premium)**\n\n  **不要贪图便宜选保险费(Premium)低的**\n\n  保险费 （Premium）。保险费是指你购买健保时，定期要支付给保险公司的费用，一般是每月支付。保险费与受保人年龄、健康状况等相关。一般受保人年龄越高，保险费越贵。一定要先了解公司的保险费（Premium）是多少， 一般每个保险公司都会给出不同(价位的保险选择来迎合不同的受保人需要。但保险费（Premium）不是越低越好？保险费越低意味着赔偿支付也越低，并且限制条件会比较多。\n\n- **2 Out-Of-Pocket**\n\n  指自己看病后实际上需要交的钱\n\n- **2 最高限额（Maximum Payment）**\n\n  **保险公司的 Maximum Payment 额高很重要**\n\n  最高保险支付额(Maximum Payment) 是保险公司愿意为你买单的上限。不要天真的以为，看什么病，花多少钱，买了医疗保险，保险公司就都会为你买单。事实上，一般的美国医疗保险都会有一个支付额度的上限。如果你选的保险支付额越低，那么你自己生了大病，要掏腰包的钱就越多。 美国随便做个手术，几万美金小意思~\n\n- **3 自付额(Deductible)**\n\n  **自付额低很重要**\n\n  一般保险公司要求个人支付500美元到5000美元不等的自付款。也就是你一年要先自付一笔钱之后，保险公司才会开始付。总之就是当然是自付额越少越好。有些保险甚至没有自付额，但是每月的Premium就会变高，也就是每月固定支付的钱增加。\n\n- **4 挂号费(Copay)**\n\n  **挂号费高低因人而异**\n\n  定额手续费（copay）是指受保人每次看普通门诊或购买处方药时需当场支付的一笔固定费用。例如，每次看医生门诊个人需支付20美元，购买处方药时需支付15美元。具体的定额手续费金额，看保险合同。一般来说copay从20-50美元都有，也有0的。如果你是医院的“常客”，建议你选择copay低一点的美国医保，但是这样的医疗保险保险费可能相对较高。如果你身体很好，又年轻，不怎么进医院，可以选择保险费相对低的，copay高一点也就无所谓了。\n\n- **5 特殊限制(Special Limits)**\n\n  **那么医保公司到底可以付多少？需要仔细阅读保险的条款，特别是你有一些疾病，需要长期治疗的。**\n\n  对于一些特殊医疗服务，包括住院、手术、麻醉、心理治疗等，不少保险公司规定有一定的支付限额。有些规定一年只报一次Image, 一次体检，需要更多则要自己掏钱。\n\n- **6 排除支付条款(Exclusion)**\n\n  **每一份保险都会有一个Exclusion list，购买之前一定要仔细阅读哪些医疗项目不在保险支付范围之内。**\n\n  在美国看牙，是出了名的贵，牙科/眼科一般都是单门的医保项目。\n\n\n- **HMO(Health Maintenance Organization)**\n\n  Cost less, but you have less choice of doctors, when you choose HMO, you have to name a specific doctor who manages all of your cares, often called primary care doctor. You must go to see this specific doctor before you see any other doctors when you are sick or need care. You will have to make a pre-defined payment, known as copay every time you see your primary doctor and any specialists she or he may send you to for care.\n\n- **PPO(Preferred Provider Organization)**\n\n  Give you more freedom to choose from a larger pool of doctors, generally cost you more paychecks. You still need to see the doctors \"in network\" to get the most coverage from the plan. You still need to pay the copay each time you visit the specialist\n\n\n- **HDHP(High Deductible Health Plan) or CDHP**\n\n  Cost the least but have a higher deductible. A health Saving account- or HSA- can be attached to a HDHP to help cover the expenses\n\n## Flexible Spending Account (FSA)\n\n**本文来源：[美元先生](https://usdweekly.com/what-is-fsa/)**\n\n### FSA是什么？\n\nFSA的全称叫Flexible Saving Account，它的主要作用是国税局考虑到贫苦大众们面对生活的摩擦，在生病时总得给点安慰。于是，国税局在1978年开始，正式开始将FSA作为一个福利推出。\n\nFSA是一个用于给你自己报销医疗花销的储蓄帐户\n\n最简单的理解是，FSA就是一个银行帐户，在你的工资被扣税前，你可以选择存一部分到这个帐户中。\n\n存入的这个部分，国税局不会对你征税。\n\n举个例子，你一年收入是10万美元，而今年你决定把2000美元整放到FSA中，那么你的征税收入计算是98,000而非10万。\n\n### FSA报销怎么理解？\n\nFSA的报销是指，你自己报销向自己报销花销。这个概念一开始很难理解，哪有人自己找自己报销的？我们用一个例子来说明\n\n还是继续上面的假设，你今年在FSA里放了2000美元，注意这2000美元IRS没跟你要过一分钱税，而是直接从你工资税前部分存入的。\n\n然后你很不幸地摔了，看病花了1000美元，这1000美元是你用你自己Chase卡付的。*注意，这里的1000美元花的是你税后的钱*（不管你用的是Chase信用卡还是借记卡都是你税后的钱）\n\n现在，你决定去跟自己的FSA报销。你FSA的余额还有2000美元，而你需要报销1000美元出来。你提交了医疗凭证（收据、医生处方），被批准后，FSA往你的银行存入1000美元。这整个过程结果是，你用1000美元税钱的钱看好了病，也即你向自己的FSA成功报销了一次。\n\n### 怎么用FSA省钱？\n\nFSA省钱的策略比HSA简单太多了。\n\n最基本的理解就是，存入FSA的钱不需要交税，而用这个帐户付钱的时候，只要是付***医疗相关***的费用（需要证明）就可以被允许（或俗称的，可报销）。\n\n假设你今年在FSA里存入了2000美元，这2000美元拿去打针吃药是完全没有问题的。最棒的是，FSA还可以报销一些你不太想得到的开销\n\n### FSA可以报销哪些开销\n\n再次夸一次IRS，或者说瞪一眼美国国税局——由于这个资本主义国家发展的年代已经非常久远，税收的体制已经非常健全，你能想到的漏洞它基本已经帮你想好且堵住了。\n\n比如说，一个自然的想法就是，FSA里的钱如果可以拿去支付任何开销的话，那不就等于现金了吗？\n\n非常遗憾的是，IRS不仅对花销的种类有限制，甚至逐条列出来了你可以报销的具体东西，比如\n\n- 处方药\n- 血糖测剂\n- 计生用品（我的天，这个词我打出来的时候都觉得中文真是博大精深）\n- 验孕棒（怎么样，IRS心思细不细）\n- 胰岛素\n- 绷带\n- 拐杖（怎么样，再一次，就问你细不细）\n- 针灸\n- 理疗\n- 心理医生费用\n- 戒烟项目费用\n- 牙医\n- **Child care**\n\n写到这里我真的是不禁联想，国内规定的特点是爱用”相关物品“，比如说”医疗相关用品“，这就留下了很多解释的空间。而IRS则相反，把FSA可以报销的东西一件件列出来，如果感兴趣可以看[IRS的这个解释](https://www.irs.gov/pub/irs-pdf/p969.pdf#page=16)\n\n注意上面列表里最后一项，Child care被FSA认为是可以报销的项目。因此，如果你有小朋友需要child care，那么FSA可以用税前的钱来搞定。这也是为什么FSA可能对宝妈们特别有用。\n\n### 为什么不选FSA?\n\n大转折来了\n\n尽管有免税的好处，而且报销的范围比HSA广，FSA仍然不是一个非常好的金融工具。原因如下\n\n**原因一：FSA的保持期只有一年**\n\n如果你在一个税务年之前（通常是报税终止之前）FSA里的钱没有用完，那你的FSA帐户非常大的概率会被清空（不被清楚的情况太特殊不讨论）\n\n**原因二：FSA的钱不可以用于投资**\n\n接上条，既然FSA的钱每年会清空，那也就没什么复利增加的意义了。同时，FSA帐户不提供投资的途径，因此断了复利增长这条路。可惜的是，复利增长几乎所有金融工具能帮我们[实现财富独立](https://usdweekly.com/what-is-financial-independence/)的基础\n\n**原因三：FSA只跟着雇主走，换工作清空**\n\n因此，如果你有的是FSA帐户，请确保在换工作前一定把里面的钱花完。可以考虑多看一次牙医，存一些药之类\n\n正是因为上面三个原因，FSA几乎不应该成为任何人的首选，除非你真的认为用税前的钱来支付Child care之类开销非常重要（HSA不能用于支付Child care）。但是理性来说，如果对比[HSA在30年内可以帮你多挣50万美元](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)的能力，FSA这点可怜的好处几乎不值一提\n\n### FSA这么没用，为什么它还卑微地存在呢？\n\n原因很简单，iPhone是不是一代比一代好？\n\nFSA/HSA这样的项目也类似，在收集前面的反馈的时候，后续项目会有一些相关的调整。\n\n考虑FSA和HSA推出的时间\n\nFSA是1978年咱改革开放那年出品，而HSA是2003年布什总统在位时出品的二代产品\n\n这样看起来，咱就把HSA当作iPhone X，把FSA当作iPhone 4吧 🤔\n\n从另一个角度，FSA也并不是一无事处。注意不是每个公司都有给员工提供HSA的福利，有的公司只有FSA，那也只能矮子里面挑高个了\n\n### 总结一下\n\nFSA是个有趣的项目，有一些特点。\n\n比如它的报销范围比较广，可以报销牙医、Child care等项目。\n\n但它也有些致命的缺点，每年会被清空，且它是跟着雇主走的帐户，一换工作也要清空，因此它并不能有效地帮助我们实现财富独立。\n\n相比而言，如果你的公司提供HSA，那么你可以用HSA在30年内用复利增长多挣50万美元。具体步骤请读这篇文章：[如何用HSA投资且多挣50万美元](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)\n\n本文参考：\n\n- https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/\n- https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/\n- https://en.wikipedia.org/wiki/Flexible_spending_account#History\n- https://dpath.com/2019-fsa-contribution-limits/\n- https://www.investopedia.com/insurance/hsa-vs-fsa/\n- https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/\n\n## Dependent Care FSA\n\n### **1、如何使用 Dependent Care FSA报账**\n\n首先要说明的一点是，**FSA并不是国家统一管理的，也不是所有公司雇主都提供，提供FSA的雇主各自有自己的管理公司**，你需要在规定的管理公司的网站上注册账号，这样就可以随时检查余额、提交申请了。另外，FSA是在大家每年的福利开放登记（benefit open enrollment）期间登记注册，而且一般每年都要重新登记，不会像医疗保险那样自动保留你上一年的选择。\n\nFSA登记注册好之后，你选择的缴纳金额按pay schedule进入账户，钱到账之后，你就可以在网上提交你的Daycare费用支付收据。这里要提醒大家注意的是，DCFSA和MFSA不一样，MFSA是你自1月1日起一整年的全部花费都可以获得补偿，而DFSA只有已到帐的余额才能用，而且补偿的必须是已经发生的服务。\n\n举个很简单的例子，如果你是在3月底交的4月份的学费，无法在3月底得到补偿，而是要等到4月结束后。因此，你的Daycare支付费用收据上最好除了社会保险号之外，还要有提供服务的日期（service period from xxx to xxxx）\n\n### **2、DCFSA的好处和最高限额**\n\nFSA 享有很好的免税待遇，FSA的补偿金完全是税前的，不用交SSN、Medicare、Federal and State tax，但是这个免税优惠是有条件的，那就是你的花销得是花在符合资格的个体身上，而且不超过IRS规定的补偿限制。**Dependent Care FSA目前的最高限额是每个家庭5000美元**，夫妻双方任何一人使用都可以，也就是两个人加起来不能超过5000美元的最高限额。\n\n另外需要注意的是，这里所能享受到的免税额度和夫妻双方的收入是有关系的：如果夫妻双方的收入都多于5000美元，则5000美元都可以免税；如果有一方的收入少于5000美元，比如只有2000美元的话，那么无论你的贡献金额为多少，能免税的都只有那2000美元；如果有一方没有收入，那么你的FSA的贡献金额不管是多少都不能满足免税条件（夫妻中有一方或双方是全职学生或残障人士的情况除外）。\n\n### **3、享受DCFSA的免税补偿需要满足的条件**\n\n那么什么才算是有资格的个体呢？除了开头讲到的无生活自理能力的被抚养者之外，对于大多数的妈妈们来说，符合这个资格的就是年龄不超过13岁的孩子（孩子满13岁的这一年要按实际接受的服务来计算价钱）。也就是说，**DCFSA只有在夫妻为双职工或正在找工作（或夫妻一方为全日制学生），且孩子在13岁之下才能获得补偿。**如果夫妻中有一方为全职妈妈或全职爸爸，收入为0，就无法享受这项免税优惠。\n\nP.S.判定自身或配偶属于全职学生的要求为：必须满足至少五个月的在学校全职上学的条件，这里所指的学校不包括在职培训课程、函授学校或只通过互联网授课的学校。\n\n**与照顾孩子相关的这些费用可以享受DCFSA的免税补偿：**\n\n①Fees for licensed day care（持有牌照经营的Daycare费用。）\n\n②Amounts paid for services (including babysitters or nursery school) – provided in or outside of your home – for the care of a qualified dependent necessary to allow you and your spouse to work, look for work, or attend school full-time.（付给照顾孩子的保姆或nursery school所产生的费用。）\n\n③Summer day camp for children under age 13 qualifies if attendance allows you and your spouse to work, look for work, or for your spouse to attend school full-time.（13岁以下孩子参加夏令营所产生的费用。）\n\n④Before and after school care programs for dependents under age 13.（在上学前、上学后提供照看13岁以下孩子服务所产生的费用。）\n\n⑤Payment to a relative (age 19 or older who is not your dependent) who cares for your qualified dependent.（请19岁以上的亲戚来照看孩子所产生的费用，这个亲戚不能是你的被抚养者。）\n\n⑥Payment to a housekeeper whose duties also include dependent day care.（请同样承担照看孩子工作的家庭管家所产生的费用。）\n\n请参考www.irs.com所给出的官方说明：\nhttps://www.irs.gov/pub/irs-pdf/i2441.pdf\nhttps://www.irs.gov/pub/irs-pdf/p503.pdf\n\n## HSA\n\n**本文来源：[美元先生](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)**\n\n### 到底什么是HSA帐户?\n\n要了解怎么样用HSA省税挣钱，需要先大致对美国税法有一个基本了解：在美国，IRS可能是比FBI更难惹的一个部门\n\n一来后者关乎犯罪，我等良民不太容易惹得到，而前者则跟每个在美国生活、投资的人息息相关。而美国税制最神奇的一个地方是，你不光需要遵守税法，且你需要对自己不懂税法负责——不情的情况下报税错误？不好意思，也要罚款坐牢\n\nHSA的全称是Health Savings Account，以下我将会简称其为HSA。顾名思义，这个帐户应该是跟医保储蓄之类的事情相关的。但这个帐户跟你大摇大摆走进一家银行，跟柜员开户的银行帐户完全是两个概念。\n\n首先，HSA不是一个具体的“银行帐户”概念。相反，它是一种减轻减轻特定人群税务负担的行政手段。\n\n你可以把HSA理解为，政府为了帮助有医疗需求的人（也即几乎所有在美国生活的人）减轻税务负担而单独开设的减税计划。\n\n用白话说，就是政府看到有些居民生活困难，而如果碰到医疗开销的话更将会雪上加霜。那么政府决定，由IRS出面，给这些人士一个特殊的“帐户”，这些帐户的唯一作用是，如果往这个帐户里存钱，那么政府将认为这些钱会最终用于你或家人的医疗开销，**而这部分存入的钱是不收税的**。\n\n举个例子，张二狗同学年收入十万美元，他把7000块存入HSA帐户内。那么他被征税的部分就是93,000美元，存入的7000美元部分免税。\n\n### HSA的限制\n\n上面的例子听起来很刺激对不对?\n\n假设你是一位程序写得飞起的Google工程师，每年收25万美元整，那么你可以把25万美元全部存到HSA帐户里喜滋滋把税免了？\n\n当然不行，IRS这么容易让你钻空子就不是IRS了:)\n\n通常来说，使用HSA有这么几个限制\n\n1. HSA有每年的存入限额\n2. 你，你的公司和IRS三方需要介入整个过程\n3. 多数HSA需要你用的医保是High-deductible的\n\n我们一条一条来分析\n\n限制1，HSA有每年的存入限额\n\n虽然有限额，但是这个限额从历史上来看，是每年严格递增的，也就是说随着时间增加每年你能通过HSA避的税会逐年增加。同时注意HSA的限制对于个人和家庭来说是不一样的，而如果你超过55岁，还可以享受一个“落后生”优惠：每年可以比其它人多存一部分。\n\n具体年每年IRS允许往HSA帐户里存入的限额如下表（摘自[wikipedia](https://en.wikipedia.org/wiki/Health_savings_account))\n\n**HSA存入限额（按年）**\n\n| 年份                                                         | 单身HSA限额 | 家庭HSA限额 | 55岁以上可补交 |\n| :----------------------------------------------------------- | :---------- | :---------- | :------------- |\n| 2010[[26\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-26) | $3,050      | $6,150      | $1,000         |\n| 2011[[27\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-27) | $3,050      | $6,150      | $1,000         |\n| 2012[[28\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-28) | $3,100      | $6,250      | $1,000         |\n| 2013[[29\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-29) | $3,250      | $6,450      | $1,000         |\n| 2014[[30\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-30) | $3,300      | $6,550      | $1,000         |\n| 2015[[31\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-31) | $3,350      | $6,650      | $1,000         |\n| 2016[[32\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-32) | $3,350      | $6,750      | $1,000         |\n| 2017[[33\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-33) | $3,400      | $6,750      | $1,000         |\n| 2018[[34\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-34) | $3,450      | $6,900      | $1,000         |\n| 2019[[35\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-35) | $3,500      | $7,000      | $1,000         |\n\n限制2，你，你的公司和IRS三方需要介入整个过程\n\n如上文所说，你不能走进一家银行要求”开一个HSA“帐户。到目前为止，你如果需要往HSA帐户里存钱的话，只能通过你的雇主。对于你是自己在创业的同学，你有可能可以搞一个self-employed HSA（相对少见这里不展开讨论了）。而对于IRS在这里的作用则更多是监督你把省的税和投资收益用来买药，而不会把HSA的税务优惠用来买兰博基尼 🙂\n\n限制3，多数HSA需要你用的医保是High-deductible\n\n这一条要求搞糊涂了不少人。其实简单点讲，high-deductible plan就是每次去医院的时候需要自己掏腰包的部分稍多一点。但是只要你不是天天去医院，对99%的50岁以下年轻人来说，high-deductible完全够用。同时，比起多出来那一点co-pay和多掏的腰包，HSA能给你带来的收益大得多得多（下文会有具体的计算）\n\n### 如何理解HSA\n\n很多人在理解HSA的时候，包括我自己最初在试图搞清楚它的时候，都被各种概念搞晕。其实要理解HSA，只要脑中简单地有一个概念即可：HSA是一个杯子（容器）\n\n而你往HSA里放钱的时候，是在把这个杯子换为更大号的杯子。比如说，前三年你往HSA里存入了2万美元，那么你的HSA就是一个容积为2升的杯子。\n\n而这个杯子的用途就多了，你可以把杯子当作装饰，放在桌上不管它（对应HSA里的钱当作现金）；也可以把杯子里装满茶（对应HSA帐号里的钱用来购买国债）；也可以把杯子里装满咖啡（对应HSA帐号里的钱用来购买mutual fund或者[购买ETF基金](https://usdweekly.com/how-to-invest-etf/)）\n\n总之，这个杯子里装茶还是咖啡，甚至是一半茶一半咖啡，都是可以的。\n\n### 如何用HSA帐户进行投资\n\n这一节的副标题应该叫：如何用HSA多挣50万美元😍\n\n到这里为止，你应该大致了解了政府设立HSA的动机是什么，以及HSA的一些限制。那么这一章我就详细讲解一下如何用HSA来帮你多挣50万。\n\n首先我们做一些简单的假设：\n\n1. 你每年将会在HSA里放满允许存入的金额。比如2019年你将会放满7000美金\n2. 你还会工作30年直到你退休\n3. 在退休前你不会碰HSA里的钱（千万不要拿出来）\n\n**对于绝大多数HSA帐户，如果你存入超过1000美金，这个帐户就可以用于购买股票、债券或者指数基金。**\n\n而绝大多数HSA提供商（比如我的是HSAbank）都会允许你购买股票、基金或者共同基金\n\nHSABank的功能界面 – 提供了investments的选项\n\n那么如何用HSA帐户多挣美元的问题，就转化成了，年定投7000美金30年复利增长可以收益多少的问题。同样，我们用标普500的历史数据来做这个基本分析。我们的基本参数如下：\n\n年存入: $7000 (2019年家庭限额）\n\n年限: 30年\n\n预计年收益：10% (标普500 80年平均）\n\n复利频率：1年\n\n用于计算复利的参数\n\n那么到2048年，我们的总余额将达到126万美元，其中本金仅为21万左右\n\n当然你可能会说，考虑通货膨胀的话，到2048年这些钱可能就是30年前的万元户手里的一万美元了。其实不然，即使调整了通胀的收益，收益也会是非常可观的数字。本金同样为21万，收益则为50万美元。\n\n### HSA如何帮你省税\n\n如同乔帮主常说的，just one more thing…\n\nHSA的超强吸引力，不光在于它可以让你免税开始存钱，更可怕的是，它的收益也可以做到部分免税（医疗报销），而这是401(K)，Traditional IRA, Roth IRA等任何储蓄计划都做不到的。\n\n具体来说\n\n1. 你的工资、收入在存入HSA时，是不收税的\n2. 你存入HSA的钱，在收益增值的过程中，是不收税的\n3. 如果你生病了，需要在中途把一部分钱拿出来（不建议，下文讨论如何看病省钱两不误的操作），你可以把钱拿出来且不用交任何税\n4. 如果你到了65岁，你可以把所有的钱一次性拿出来，仅按收入税交税\n\n举个具体例子，张二狗同学25岁从弟伦比亚大学毕业，到湾区成为了一位光荣的年薪20万美元的初级软件工程师。\n\n读完这篇文章后张二狗同学决定每年把7000美元拿出来放到HSA中，首先20万美元中的7000美元被划分开，IRS决定对这7000美元免税。即，张二狗同学可能被扣税的收入减少为19万3千美元。\n\n张二狗同学把HSA中所有的美元全部购买了指数基金。\n\n到45岁时，张二狗同学的颈椎病发作，但他手里还有一些多余的现金，因此他只把看病时的收据拍照留下了，而在HSA帐户里的基金继续增值。\n\n到55岁时，张二狗同学决定跟翠花辞职退休，环游世界。30年过去，这时他的HSA帐户中已经有了126万美元，而这30年他仅仅往帐户里存入过21万美元。他需要一些钱来支付环游世界的费用。于是他找出来之前看病时的收据，于55岁这年从HSA帐户里拿出6万美金用于环游世界。\n\n终于到了65岁，张二狗同学决定把HSA里的钱全拿出来。而此时HSA帐户中已经有了300万美元！这就是复利的力量。这时候二狗同学的身体已经不太好了，累积了50万美元的医疗开销。而张二狗同学在把这300万美元拿出来的过程中，50万美元的部分不必交税，仅余下的250万需要交收入税。\n\n这就是HSA最大的威力：收入免税+复利增长+部分收益免税\n\n### 有关HSA的常见问题\n\n这里解答一些关于HSA的常见问题\n\n### 回国了HSA怎么办?\n\n如果你已经决定了在65岁前回国，那么你有两个选择\n\n选择1，提前把钱退出来（不推荐）\n\n虽然你可以提前把HSA里的钱拿出来，但是如果不是手头真的紧的话，并不建议。原因是你在把钱放入HSA时，没有交税。那么如果你要提前拿出来，不但你要把拿出来的部分的税补交上，且要加上[20%的惩罚](https://hsastore.com/)。\n\n举个例子，张二狗同学拿到了假格基金的投资，毅然决然决定2020年启程回国担任CEO走上人生巅峰，而他之前在HSA里的本金和收益总共收益10万美元。在2020年这年，他决定把HSA里的钱全拿出来，那么他的10万美元将需要算作2020年的收入被税，同时需要支付2万美元的罚款。假设张二狗2020年已经辞职且没有其它收入，那么他需要支付的联邦税为29,204 + 20000 = 49,204美元，可以说是非常不划算了。\n\n当然如果你不着急，有两个办法把税降到最低（但20%的罚款无法避免）\n\n第一个办法是，尽量降低每年从HSA里拿出来的金额，这样可以让你当年的收入变少，因此可以被税比例降低甚至是免税。\n\n第二个办法是，尽量在回国之后（这样在美国就不再有收入）再慢慢把钱拿出来，这样你在美国的收入仅有HSA拿出来的部分，你可以选择一年只拿最低征收额以下，比如2019年如果你只拿9,324出来，一分钱税都不用交。\n\n选择2，把钱放在HSA内增值（推荐）\n\n如果手里不紧，这是我一贯的主张。在国内几乎没有任何资产配置可以跟美元+美国金融市场匹敌，不着急用钱的话没有任何理由把HSA里大量税收优惠的钱带回国。且实际操作来讲，如果你需要看病的时候，即使是在国内，也可以把看病的花销都记录下来，收据留好，每年报销一次。剩余的部分则在HSA帐户内增值。\n\n### 如果换了公司HSA帐户怎么办?\n\n这个相对容易，HSA虽然是需要公司参与，但是受益人和操作人是你且只是你。因此如果换了公司，最多是跟给你提供HSA的银行打个电话，告诉他们你换公司了。通常来说你所在公司的HR也会协助你迁移。当然更好的办法是把HSA完全独立出来，所有信息都跟公司分离开来，我就是这么干的。这样即使换了公司，只是换了个每个月向HSA里存钱的帐户而已，相当方便。\n\n### HSA可以买什么？\n\n理论上HSA里的钱你可以买任何你想买的东西，只是有些东西不免税以及有惩罚而已。\n\n所以这个问题的问题应该是，HSA帐户可以用于免税购买什么东西？\n\n根据[IRS的指导](https://www.irs.gov/publications/p502)，你可以用于购买以下东西\n\n- 看医生的co-pay\n- IRS批准的医药中保险不报销的部分（i.e. out of pocket)\n- 一些医用的产品，比如baby monitor，温度计之类；比较完整的列表见[hsastore.com这个网站](https://hsastore.com/HSA-Eligibility-List.aspx)\n- [羞羞的橡胶制品](https://hsastore.com/Condoms-C78.aspx)\n- 去看医生的路上的交通，包括巴士，出租，火车或者飞机等\n\n这里最后一条的解释就很有意思了。IRS的指导是\n\n如果你的旅行相关的医疗开销对于治疗是必须的，那么这个旅行相关的开销就可以包含在HSA支付的范围。同时，IRS并没有指导医疗开销是不是必须在美国国内。那也就是，如果你觉得北京上海的医生对于你的病的治疗有更多帮助，那么飞到北京或者上海看病是属于合理的HSA可支付范围内。\n\n当然本文不可能也没必要穷尽所有IRS允许的HSA免税开销，如果有特别需要的话，google一下通常会有相当多人讨论。\n\n### HSA可以投资些什么？\n\nHSA是一个银行帐户，而通常HSA帐户的提供商都会跟其它证券公司(broker)合作来提供购买投资产品的服务。\n\n举个例子，美元先生用的HSA帐户提供商是HSABank，而 HSABank与TD-Ameritrade合作提供投资产品。\n\n在TD-Ameritrade里，我可以选择购买个股，也可以选择购买其它股指基金，房地产基金等等，所以HSA的投资对象并不会受限定，基本是你想投啥都可以。\n\n但是同时也要注意，如果你在读这篇文章的话，大概率是刚刚开始接触投资，不建议投资个股。如果你不确定投资些什么，优先推荐[投资ETF基金](https://usdweekly.com/how-to-invest-etf/)或共同基金。\n\n针对这点，我在[我应该投资股票吗一文中有更详细的解释](https://usdweekly.com/should-i-invest-stock-market/)。\n\n如果你的投资产品里看到Vanguard或者Fidelity, Charles Schwab的股指基金，那恭喜你，这些基金都是品质保障。\n\n我在[为什么投资这些基金和Vanguard基金如何挑选](https://usdweekly.com/how-to-choose-vanguard-fund/)的文章里详细解释了为什么优先考虑投资Vanguard基金，或者以上提到的几家股指基金/共同基金。\n\n### HSA可以给配偶用吗\n\n一句话，可以。同时如果你已经结婚的话，HSA的限额会增加，细节见上文“HSA限制”一章\n\n### HSA报销麻烦吗？HSA报销需要收据吗？\n\n首先HSA报销不麻烦；严格讲这个不叫报销，这个叫向IRS申请使用你的免税额。\n\n其次IRS不要求你在向你的HSA帐户里取钱时提供收据。需要收据的时候是，IRS抽查到你的时候，你能提供证明你取钱的时候取的部分是用于了医疗。当然了，最容易的证明方式就是把收据给IRS看了。\n\n这里提供一个不但可以非常方便保存收据，同时可以最大化你的HSA收益的方式，也就是我们的：\n\n### 用HSA四步多挣50万\n\n#### 步骤一：\n\n在Dropbox/Google Photo或者任何照片同步软件里建一个folder，专门用来保存receipt\n\n#### 步骤二：\n\n每次看完病，去看病的路上，把产生的收据照下来，原件不用存\n\n#### 步骤三：\n\n不要报销，等到65岁或者过几年再一次性报销。如果你考虑要回国，回国前一次性报销\n\n步骤四：\n\n在HSA中选择指数基金或者共同基金，推荐Vanguard的低成本基金。把放到HSA帐户中的钱从脑子中抹去，让它定投和指数增益，不要管它\n\n步骤一和二非常好理解，不多说\n\n对于步骤三，逻辑是这样的，对于你所有在HSA里的钱，不要把它考虑为钱，应该把它考虑为equity。什么是equity？equity就是你睡觉时可以继续帮你挣钱的资产。\n\n在比较早的时间，比如A点取出，和在比较晚的B点取出5万美元，对于资产的增值是有天差地别的区别的。如果在A点取出5万美元，即使考虑了通货膨胀，这部分钱本来也可以增值至B点的5*1.07^10 = 9.8万美元。\n\n如果你在HSA里的钱全在指数基金或共同基金里，那么你的资产就是这些基金里含有的公司股票的股份，多放一年，平均来讲你HSA里的资产就会增加7%（通胀调整）或者10%（不含通胀调整）。那么要最大化你的收益，显然是让HSA里的资产增值越久越好。而IRS并没有规定医疗费用必须当年申报，因此你完全可以放心大胆把医疗费用的凭证放到一个地方，在你最终需要把钱拿出来时，再拿出来。\n\n### 总结\n\nHSA虽然听起来是个跟看病相关的事情，但是其实它是在Roth, 401(K)的基础上，可以极大帮助你省税和提高投资效率的工具。\n\n如果你之前从来没有听说过的话，也不要感觉自己很悲剧，因为即使美国人知道且在擅于利用HSA的也不多。2008年的数据是，只有8%的在职人员参与了HSA。\n","source":"_posts/2020-03-17-New-Hire-Benefit-全解.md","raw":"---\nlayout: post\ntitle:  New Hire Benefit 全解\ndate:   2020-03-17 12:00:00\ndescription: 让你听明白benefit部门的人到底在说什\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321005039.png\noptimized_image: \ncategory: life\ntags:\n  - life\n  - tips\n  - financial\nauthor: tty\n---\n\n**本文纯属转载**\n\n第一天remote onboarding，benefit的人上来对保险一顿讲解，讲得我头晕眼花。回来仔细查查，才好了解自己到底要买哪个。虽然现在新冠疫情严重，我早已决定把保险拉满（冲\n\n## Medical Insurance\n\nFirst of all there are some terms that you need to know, because these are the main differences of all the insurances.\n\n**此处部分原文来源[虎虎保险](https://tigerless.com/how-to-choose-us-health-insurance/)**\n\n- **1 保险费(Premium)**\n\n  **不要贪图便宜选保险费(Premium)低的**\n\n  保险费 （Premium）。保险费是指你购买健保时，定期要支付给保险公司的费用，一般是每月支付。保险费与受保人年龄、健康状况等相关。一般受保人年龄越高，保险费越贵。一定要先了解公司的保险费（Premium）是多少， 一般每个保险公司都会给出不同(价位的保险选择来迎合不同的受保人需要。但保险费（Premium）不是越低越好？保险费越低意味着赔偿支付也越低，并且限制条件会比较多。\n\n- **2 Out-Of-Pocket**\n\n  指自己看病后实际上需要交的钱\n\n- **2 最高限额（Maximum Payment）**\n\n  **保险公司的 Maximum Payment 额高很重要**\n\n  最高保险支付额(Maximum Payment) 是保险公司愿意为你买单的上限。不要天真的以为，看什么病，花多少钱，买了医疗保险，保险公司就都会为你买单。事实上，一般的美国医疗保险都会有一个支付额度的上限。如果你选的保险支付额越低，那么你自己生了大病，要掏腰包的钱就越多。 美国随便做个手术，几万美金小意思~\n\n- **3 自付额(Deductible)**\n\n  **自付额低很重要**\n\n  一般保险公司要求个人支付500美元到5000美元不等的自付款。也就是你一年要先自付一笔钱之后，保险公司才会开始付。总之就是当然是自付额越少越好。有些保险甚至没有自付额，但是每月的Premium就会变高，也就是每月固定支付的钱增加。\n\n- **4 挂号费(Copay)**\n\n  **挂号费高低因人而异**\n\n  定额手续费（copay）是指受保人每次看普通门诊或购买处方药时需当场支付的一笔固定费用。例如，每次看医生门诊个人需支付20美元，购买处方药时需支付15美元。具体的定额手续费金额，看保险合同。一般来说copay从20-50美元都有，也有0的。如果你是医院的“常客”，建议你选择copay低一点的美国医保，但是这样的医疗保险保险费可能相对较高。如果你身体很好，又年轻，不怎么进医院，可以选择保险费相对低的，copay高一点也就无所谓了。\n\n- **5 特殊限制(Special Limits)**\n\n  **那么医保公司到底可以付多少？需要仔细阅读保险的条款，特别是你有一些疾病，需要长期治疗的。**\n\n  对于一些特殊医疗服务，包括住院、手术、麻醉、心理治疗等，不少保险公司规定有一定的支付限额。有些规定一年只报一次Image, 一次体检，需要更多则要自己掏钱。\n\n- **6 排除支付条款(Exclusion)**\n\n  **每一份保险都会有一个Exclusion list，购买之前一定要仔细阅读哪些医疗项目不在保险支付范围之内。**\n\n  在美国看牙，是出了名的贵，牙科/眼科一般都是单门的医保项目。\n\n\n- **HMO(Health Maintenance Organization)**\n\n  Cost less, but you have less choice of doctors, when you choose HMO, you have to name a specific doctor who manages all of your cares, often called primary care doctor. You must go to see this specific doctor before you see any other doctors when you are sick or need care. You will have to make a pre-defined payment, known as copay every time you see your primary doctor and any specialists she or he may send you to for care.\n\n- **PPO(Preferred Provider Organization)**\n\n  Give you more freedom to choose from a larger pool of doctors, generally cost you more paychecks. You still need to see the doctors \"in network\" to get the most coverage from the plan. You still need to pay the copay each time you visit the specialist\n\n\n- **HDHP(High Deductible Health Plan) or CDHP**\n\n  Cost the least but have a higher deductible. A health Saving account- or HSA- can be attached to a HDHP to help cover the expenses\n\n## Flexible Spending Account (FSA)\n\n**本文来源：[美元先生](https://usdweekly.com/what-is-fsa/)**\n\n### FSA是什么？\n\nFSA的全称叫Flexible Saving Account，它的主要作用是国税局考虑到贫苦大众们面对生活的摩擦，在生病时总得给点安慰。于是，国税局在1978年开始，正式开始将FSA作为一个福利推出。\n\nFSA是一个用于给你自己报销医疗花销的储蓄帐户\n\n最简单的理解是，FSA就是一个银行帐户，在你的工资被扣税前，你可以选择存一部分到这个帐户中。\n\n存入的这个部分，国税局不会对你征税。\n\n举个例子，你一年收入是10万美元，而今年你决定把2000美元整放到FSA中，那么你的征税收入计算是98,000而非10万。\n\n### FSA报销怎么理解？\n\nFSA的报销是指，你自己报销向自己报销花销。这个概念一开始很难理解，哪有人自己找自己报销的？我们用一个例子来说明\n\n还是继续上面的假设，你今年在FSA里放了2000美元，注意这2000美元IRS没跟你要过一分钱税，而是直接从你工资税前部分存入的。\n\n然后你很不幸地摔了，看病花了1000美元，这1000美元是你用你自己Chase卡付的。*注意，这里的1000美元花的是你税后的钱*（不管你用的是Chase信用卡还是借记卡都是你税后的钱）\n\n现在，你决定去跟自己的FSA报销。你FSA的余额还有2000美元，而你需要报销1000美元出来。你提交了医疗凭证（收据、医生处方），被批准后，FSA往你的银行存入1000美元。这整个过程结果是，你用1000美元税钱的钱看好了病，也即你向自己的FSA成功报销了一次。\n\n### 怎么用FSA省钱？\n\nFSA省钱的策略比HSA简单太多了。\n\n最基本的理解就是，存入FSA的钱不需要交税，而用这个帐户付钱的时候，只要是付***医疗相关***的费用（需要证明）就可以被允许（或俗称的，可报销）。\n\n假设你今年在FSA里存入了2000美元，这2000美元拿去打针吃药是完全没有问题的。最棒的是，FSA还可以报销一些你不太想得到的开销\n\n### FSA可以报销哪些开销\n\n再次夸一次IRS，或者说瞪一眼美国国税局——由于这个资本主义国家发展的年代已经非常久远，税收的体制已经非常健全，你能想到的漏洞它基本已经帮你想好且堵住了。\n\n比如说，一个自然的想法就是，FSA里的钱如果可以拿去支付任何开销的话，那不就等于现金了吗？\n\n非常遗憾的是，IRS不仅对花销的种类有限制，甚至逐条列出来了你可以报销的具体东西，比如\n\n- 处方药\n- 血糖测剂\n- 计生用品（我的天，这个词我打出来的时候都觉得中文真是博大精深）\n- 验孕棒（怎么样，IRS心思细不细）\n- 胰岛素\n- 绷带\n- 拐杖（怎么样，再一次，就问你细不细）\n- 针灸\n- 理疗\n- 心理医生费用\n- 戒烟项目费用\n- 牙医\n- **Child care**\n\n写到这里我真的是不禁联想，国内规定的特点是爱用”相关物品“，比如说”医疗相关用品“，这就留下了很多解释的空间。而IRS则相反，把FSA可以报销的东西一件件列出来，如果感兴趣可以看[IRS的这个解释](https://www.irs.gov/pub/irs-pdf/p969.pdf#page=16)\n\n注意上面列表里最后一项，Child care被FSA认为是可以报销的项目。因此，如果你有小朋友需要child care，那么FSA可以用税前的钱来搞定。这也是为什么FSA可能对宝妈们特别有用。\n\n### 为什么不选FSA?\n\n大转折来了\n\n尽管有免税的好处，而且报销的范围比HSA广，FSA仍然不是一个非常好的金融工具。原因如下\n\n**原因一：FSA的保持期只有一年**\n\n如果你在一个税务年之前（通常是报税终止之前）FSA里的钱没有用完，那你的FSA帐户非常大的概率会被清空（不被清楚的情况太特殊不讨论）\n\n**原因二：FSA的钱不可以用于投资**\n\n接上条，既然FSA的钱每年会清空，那也就没什么复利增加的意义了。同时，FSA帐户不提供投资的途径，因此断了复利增长这条路。可惜的是，复利增长几乎所有金融工具能帮我们[实现财富独立](https://usdweekly.com/what-is-financial-independence/)的基础\n\n**原因三：FSA只跟着雇主走，换工作清空**\n\n因此，如果你有的是FSA帐户，请确保在换工作前一定把里面的钱花完。可以考虑多看一次牙医，存一些药之类\n\n正是因为上面三个原因，FSA几乎不应该成为任何人的首选，除非你真的认为用税前的钱来支付Child care之类开销非常重要（HSA不能用于支付Child care）。但是理性来说，如果对比[HSA在30年内可以帮你多挣50万美元](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)的能力，FSA这点可怜的好处几乎不值一提\n\n### FSA这么没用，为什么它还卑微地存在呢？\n\n原因很简单，iPhone是不是一代比一代好？\n\nFSA/HSA这样的项目也类似，在收集前面的反馈的时候，后续项目会有一些相关的调整。\n\n考虑FSA和HSA推出的时间\n\nFSA是1978年咱改革开放那年出品，而HSA是2003年布什总统在位时出品的二代产品\n\n这样看起来，咱就把HSA当作iPhone X，把FSA当作iPhone 4吧 🤔\n\n从另一个角度，FSA也并不是一无事处。注意不是每个公司都有给员工提供HSA的福利，有的公司只有FSA，那也只能矮子里面挑高个了\n\n### 总结一下\n\nFSA是个有趣的项目，有一些特点。\n\n比如它的报销范围比较广，可以报销牙医、Child care等项目。\n\n但它也有些致命的缺点，每年会被清空，且它是跟着雇主走的帐户，一换工作也要清空，因此它并不能有效地帮助我们实现财富独立。\n\n相比而言，如果你的公司提供HSA，那么你可以用HSA在30年内用复利增长多挣50万美元。具体步骤请读这篇文章：[如何用HSA投资且多挣50万美元](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)\n\n本文参考：\n\n- https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/\n- https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/\n- https://en.wikipedia.org/wiki/Flexible_spending_account#History\n- https://dpath.com/2019-fsa-contribution-limits/\n- https://www.investopedia.com/insurance/hsa-vs-fsa/\n- https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/\n\n## Dependent Care FSA\n\n### **1、如何使用 Dependent Care FSA报账**\n\n首先要说明的一点是，**FSA并不是国家统一管理的，也不是所有公司雇主都提供，提供FSA的雇主各自有自己的管理公司**，你需要在规定的管理公司的网站上注册账号，这样就可以随时检查余额、提交申请了。另外，FSA是在大家每年的福利开放登记（benefit open enrollment）期间登记注册，而且一般每年都要重新登记，不会像医疗保险那样自动保留你上一年的选择。\n\nFSA登记注册好之后，你选择的缴纳金额按pay schedule进入账户，钱到账之后，你就可以在网上提交你的Daycare费用支付收据。这里要提醒大家注意的是，DCFSA和MFSA不一样，MFSA是你自1月1日起一整年的全部花费都可以获得补偿，而DFSA只有已到帐的余额才能用，而且补偿的必须是已经发生的服务。\n\n举个很简单的例子，如果你是在3月底交的4月份的学费，无法在3月底得到补偿，而是要等到4月结束后。因此，你的Daycare支付费用收据上最好除了社会保险号之外，还要有提供服务的日期（service period from xxx to xxxx）\n\n### **2、DCFSA的好处和最高限额**\n\nFSA 享有很好的免税待遇，FSA的补偿金完全是税前的，不用交SSN、Medicare、Federal and State tax，但是这个免税优惠是有条件的，那就是你的花销得是花在符合资格的个体身上，而且不超过IRS规定的补偿限制。**Dependent Care FSA目前的最高限额是每个家庭5000美元**，夫妻双方任何一人使用都可以，也就是两个人加起来不能超过5000美元的最高限额。\n\n另外需要注意的是，这里所能享受到的免税额度和夫妻双方的收入是有关系的：如果夫妻双方的收入都多于5000美元，则5000美元都可以免税；如果有一方的收入少于5000美元，比如只有2000美元的话，那么无论你的贡献金额为多少，能免税的都只有那2000美元；如果有一方没有收入，那么你的FSA的贡献金额不管是多少都不能满足免税条件（夫妻中有一方或双方是全职学生或残障人士的情况除外）。\n\n### **3、享受DCFSA的免税补偿需要满足的条件**\n\n那么什么才算是有资格的个体呢？除了开头讲到的无生活自理能力的被抚养者之外，对于大多数的妈妈们来说，符合这个资格的就是年龄不超过13岁的孩子（孩子满13岁的这一年要按实际接受的服务来计算价钱）。也就是说，**DCFSA只有在夫妻为双职工或正在找工作（或夫妻一方为全日制学生），且孩子在13岁之下才能获得补偿。**如果夫妻中有一方为全职妈妈或全职爸爸，收入为0，就无法享受这项免税优惠。\n\nP.S.判定自身或配偶属于全职学生的要求为：必须满足至少五个月的在学校全职上学的条件，这里所指的学校不包括在职培训课程、函授学校或只通过互联网授课的学校。\n\n**与照顾孩子相关的这些费用可以享受DCFSA的免税补偿：**\n\n①Fees for licensed day care（持有牌照经营的Daycare费用。）\n\n②Amounts paid for services (including babysitters or nursery school) – provided in or outside of your home – for the care of a qualified dependent necessary to allow you and your spouse to work, look for work, or attend school full-time.（付给照顾孩子的保姆或nursery school所产生的费用。）\n\n③Summer day camp for children under age 13 qualifies if attendance allows you and your spouse to work, look for work, or for your spouse to attend school full-time.（13岁以下孩子参加夏令营所产生的费用。）\n\n④Before and after school care programs for dependents under age 13.（在上学前、上学后提供照看13岁以下孩子服务所产生的费用。）\n\n⑤Payment to a relative (age 19 or older who is not your dependent) who cares for your qualified dependent.（请19岁以上的亲戚来照看孩子所产生的费用，这个亲戚不能是你的被抚养者。）\n\n⑥Payment to a housekeeper whose duties also include dependent day care.（请同样承担照看孩子工作的家庭管家所产生的费用。）\n\n请参考www.irs.com所给出的官方说明：\nhttps://www.irs.gov/pub/irs-pdf/i2441.pdf\nhttps://www.irs.gov/pub/irs-pdf/p503.pdf\n\n## HSA\n\n**本文来源：[美元先生](https://usdweekly.com/hsa-save-investment-tax-saving-guide/)**\n\n### 到底什么是HSA帐户?\n\n要了解怎么样用HSA省税挣钱，需要先大致对美国税法有一个基本了解：在美国，IRS可能是比FBI更难惹的一个部门\n\n一来后者关乎犯罪，我等良民不太容易惹得到，而前者则跟每个在美国生活、投资的人息息相关。而美国税制最神奇的一个地方是，你不光需要遵守税法，且你需要对自己不懂税法负责——不情的情况下报税错误？不好意思，也要罚款坐牢\n\nHSA的全称是Health Savings Account，以下我将会简称其为HSA。顾名思义，这个帐户应该是跟医保储蓄之类的事情相关的。但这个帐户跟你大摇大摆走进一家银行，跟柜员开户的银行帐户完全是两个概念。\n\n首先，HSA不是一个具体的“银行帐户”概念。相反，它是一种减轻减轻特定人群税务负担的行政手段。\n\n你可以把HSA理解为，政府为了帮助有医疗需求的人（也即几乎所有在美国生活的人）减轻税务负担而单独开设的减税计划。\n\n用白话说，就是政府看到有些居民生活困难，而如果碰到医疗开销的话更将会雪上加霜。那么政府决定，由IRS出面，给这些人士一个特殊的“帐户”，这些帐户的唯一作用是，如果往这个帐户里存钱，那么政府将认为这些钱会最终用于你或家人的医疗开销，**而这部分存入的钱是不收税的**。\n\n举个例子，张二狗同学年收入十万美元，他把7000块存入HSA帐户内。那么他被征税的部分就是93,000美元，存入的7000美元部分免税。\n\n### HSA的限制\n\n上面的例子听起来很刺激对不对?\n\n假设你是一位程序写得飞起的Google工程师，每年收25万美元整，那么你可以把25万美元全部存到HSA帐户里喜滋滋把税免了？\n\n当然不行，IRS这么容易让你钻空子就不是IRS了:)\n\n通常来说，使用HSA有这么几个限制\n\n1. HSA有每年的存入限额\n2. 你，你的公司和IRS三方需要介入整个过程\n3. 多数HSA需要你用的医保是High-deductible的\n\n我们一条一条来分析\n\n限制1，HSA有每年的存入限额\n\n虽然有限额，但是这个限额从历史上来看，是每年严格递增的，也就是说随着时间增加每年你能通过HSA避的税会逐年增加。同时注意HSA的限制对于个人和家庭来说是不一样的，而如果你超过55岁，还可以享受一个“落后生”优惠：每年可以比其它人多存一部分。\n\n具体年每年IRS允许往HSA帐户里存入的限额如下表（摘自[wikipedia](https://en.wikipedia.org/wiki/Health_savings_account))\n\n**HSA存入限额（按年）**\n\n| 年份                                                         | 单身HSA限额 | 家庭HSA限额 | 55岁以上可补交 |\n| :----------------------------------------------------------- | :---------- | :---------- | :------------- |\n| 2010[[26\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-26) | $3,050      | $6,150      | $1,000         |\n| 2011[[27\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-27) | $3,050      | $6,150      | $1,000         |\n| 2012[[28\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-28) | $3,100      | $6,250      | $1,000         |\n| 2013[[29\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-29) | $3,250      | $6,450      | $1,000         |\n| 2014[[30\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-30) | $3,300      | $6,550      | $1,000         |\n| 2015[[31\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-31) | $3,350      | $6,650      | $1,000         |\n| 2016[[32\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-32) | $3,350      | $6,750      | $1,000         |\n| 2017[[33\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-33) | $3,400      | $6,750      | $1,000         |\n| 2018[[34\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-34) | $3,450      | $6,900      | $1,000         |\n| 2019[[35\\]](https://en.wikipedia.org/wiki/Health_savings_account#cite_note-35) | $3,500      | $7,000      | $1,000         |\n\n限制2，你，你的公司和IRS三方需要介入整个过程\n\n如上文所说，你不能走进一家银行要求”开一个HSA“帐户。到目前为止，你如果需要往HSA帐户里存钱的话，只能通过你的雇主。对于你是自己在创业的同学，你有可能可以搞一个self-employed HSA（相对少见这里不展开讨论了）。而对于IRS在这里的作用则更多是监督你把省的税和投资收益用来买药，而不会把HSA的税务优惠用来买兰博基尼 🙂\n\n限制3，多数HSA需要你用的医保是High-deductible\n\n这一条要求搞糊涂了不少人。其实简单点讲，high-deductible plan就是每次去医院的时候需要自己掏腰包的部分稍多一点。但是只要你不是天天去医院，对99%的50岁以下年轻人来说，high-deductible完全够用。同时，比起多出来那一点co-pay和多掏的腰包，HSA能给你带来的收益大得多得多（下文会有具体的计算）\n\n### 如何理解HSA\n\n很多人在理解HSA的时候，包括我自己最初在试图搞清楚它的时候，都被各种概念搞晕。其实要理解HSA，只要脑中简单地有一个概念即可：HSA是一个杯子（容器）\n\n而你往HSA里放钱的时候，是在把这个杯子换为更大号的杯子。比如说，前三年你往HSA里存入了2万美元，那么你的HSA就是一个容积为2升的杯子。\n\n而这个杯子的用途就多了，你可以把杯子当作装饰，放在桌上不管它（对应HSA里的钱当作现金）；也可以把杯子里装满茶（对应HSA帐号里的钱用来购买国债）；也可以把杯子里装满咖啡（对应HSA帐号里的钱用来购买mutual fund或者[购买ETF基金](https://usdweekly.com/how-to-invest-etf/)）\n\n总之，这个杯子里装茶还是咖啡，甚至是一半茶一半咖啡，都是可以的。\n\n### 如何用HSA帐户进行投资\n\n这一节的副标题应该叫：如何用HSA多挣50万美元😍\n\n到这里为止，你应该大致了解了政府设立HSA的动机是什么，以及HSA的一些限制。那么这一章我就详细讲解一下如何用HSA来帮你多挣50万。\n\n首先我们做一些简单的假设：\n\n1. 你每年将会在HSA里放满允许存入的金额。比如2019年你将会放满7000美金\n2. 你还会工作30年直到你退休\n3. 在退休前你不会碰HSA里的钱（千万不要拿出来）\n\n**对于绝大多数HSA帐户，如果你存入超过1000美金，这个帐户就可以用于购买股票、债券或者指数基金。**\n\n而绝大多数HSA提供商（比如我的是HSAbank）都会允许你购买股票、基金或者共同基金\n\nHSABank的功能界面 – 提供了investments的选项\n\n那么如何用HSA帐户多挣美元的问题，就转化成了，年定投7000美金30年复利增长可以收益多少的问题。同样，我们用标普500的历史数据来做这个基本分析。我们的基本参数如下：\n\n年存入: $7000 (2019年家庭限额）\n\n年限: 30年\n\n预计年收益：10% (标普500 80年平均）\n\n复利频率：1年\n\n用于计算复利的参数\n\n那么到2048年，我们的总余额将达到126万美元，其中本金仅为21万左右\n\n当然你可能会说，考虑通货膨胀的话，到2048年这些钱可能就是30年前的万元户手里的一万美元了。其实不然，即使调整了通胀的收益，收益也会是非常可观的数字。本金同样为21万，收益则为50万美元。\n\n### HSA如何帮你省税\n\n如同乔帮主常说的，just one more thing…\n\nHSA的超强吸引力，不光在于它可以让你免税开始存钱，更可怕的是，它的收益也可以做到部分免税（医疗报销），而这是401(K)，Traditional IRA, Roth IRA等任何储蓄计划都做不到的。\n\n具体来说\n\n1. 你的工资、收入在存入HSA时，是不收税的\n2. 你存入HSA的钱，在收益增值的过程中，是不收税的\n3. 如果你生病了，需要在中途把一部分钱拿出来（不建议，下文讨论如何看病省钱两不误的操作），你可以把钱拿出来且不用交任何税\n4. 如果你到了65岁，你可以把所有的钱一次性拿出来，仅按收入税交税\n\n举个具体例子，张二狗同学25岁从弟伦比亚大学毕业，到湾区成为了一位光荣的年薪20万美元的初级软件工程师。\n\n读完这篇文章后张二狗同学决定每年把7000美元拿出来放到HSA中，首先20万美元中的7000美元被划分开，IRS决定对这7000美元免税。即，张二狗同学可能被扣税的收入减少为19万3千美元。\n\n张二狗同学把HSA中所有的美元全部购买了指数基金。\n\n到45岁时，张二狗同学的颈椎病发作，但他手里还有一些多余的现金，因此他只把看病时的收据拍照留下了，而在HSA帐户里的基金继续增值。\n\n到55岁时，张二狗同学决定跟翠花辞职退休，环游世界。30年过去，这时他的HSA帐户中已经有了126万美元，而这30年他仅仅往帐户里存入过21万美元。他需要一些钱来支付环游世界的费用。于是他找出来之前看病时的收据，于55岁这年从HSA帐户里拿出6万美金用于环游世界。\n\n终于到了65岁，张二狗同学决定把HSA里的钱全拿出来。而此时HSA帐户中已经有了300万美元！这就是复利的力量。这时候二狗同学的身体已经不太好了，累积了50万美元的医疗开销。而张二狗同学在把这300万美元拿出来的过程中，50万美元的部分不必交税，仅余下的250万需要交收入税。\n\n这就是HSA最大的威力：收入免税+复利增长+部分收益免税\n\n### 有关HSA的常见问题\n\n这里解答一些关于HSA的常见问题\n\n### 回国了HSA怎么办?\n\n如果你已经决定了在65岁前回国，那么你有两个选择\n\n选择1，提前把钱退出来（不推荐）\n\n虽然你可以提前把HSA里的钱拿出来，但是如果不是手头真的紧的话，并不建议。原因是你在把钱放入HSA时，没有交税。那么如果你要提前拿出来，不但你要把拿出来的部分的税补交上，且要加上[20%的惩罚](https://hsastore.com/)。\n\n举个例子，张二狗同学拿到了假格基金的投资，毅然决然决定2020年启程回国担任CEO走上人生巅峰，而他之前在HSA里的本金和收益总共收益10万美元。在2020年这年，他决定把HSA里的钱全拿出来，那么他的10万美元将需要算作2020年的收入被税，同时需要支付2万美元的罚款。假设张二狗2020年已经辞职且没有其它收入，那么他需要支付的联邦税为29,204 + 20000 = 49,204美元，可以说是非常不划算了。\n\n当然如果你不着急，有两个办法把税降到最低（但20%的罚款无法避免）\n\n第一个办法是，尽量降低每年从HSA里拿出来的金额，这样可以让你当年的收入变少，因此可以被税比例降低甚至是免税。\n\n第二个办法是，尽量在回国之后（这样在美国就不再有收入）再慢慢把钱拿出来，这样你在美国的收入仅有HSA拿出来的部分，你可以选择一年只拿最低征收额以下，比如2019年如果你只拿9,324出来，一分钱税都不用交。\n\n选择2，把钱放在HSA内增值（推荐）\n\n如果手里不紧，这是我一贯的主张。在国内几乎没有任何资产配置可以跟美元+美国金融市场匹敌，不着急用钱的话没有任何理由把HSA里大量税收优惠的钱带回国。且实际操作来讲，如果你需要看病的时候，即使是在国内，也可以把看病的花销都记录下来，收据留好，每年报销一次。剩余的部分则在HSA帐户内增值。\n\n### 如果换了公司HSA帐户怎么办?\n\n这个相对容易，HSA虽然是需要公司参与，但是受益人和操作人是你且只是你。因此如果换了公司，最多是跟给你提供HSA的银行打个电话，告诉他们你换公司了。通常来说你所在公司的HR也会协助你迁移。当然更好的办法是把HSA完全独立出来，所有信息都跟公司分离开来，我就是这么干的。这样即使换了公司，只是换了个每个月向HSA里存钱的帐户而已，相当方便。\n\n### HSA可以买什么？\n\n理论上HSA里的钱你可以买任何你想买的东西，只是有些东西不免税以及有惩罚而已。\n\n所以这个问题的问题应该是，HSA帐户可以用于免税购买什么东西？\n\n根据[IRS的指导](https://www.irs.gov/publications/p502)，你可以用于购买以下东西\n\n- 看医生的co-pay\n- IRS批准的医药中保险不报销的部分（i.e. out of pocket)\n- 一些医用的产品，比如baby monitor，温度计之类；比较完整的列表见[hsastore.com这个网站](https://hsastore.com/HSA-Eligibility-List.aspx)\n- [羞羞的橡胶制品](https://hsastore.com/Condoms-C78.aspx)\n- 去看医生的路上的交通，包括巴士，出租，火车或者飞机等\n\n这里最后一条的解释就很有意思了。IRS的指导是\n\n如果你的旅行相关的医疗开销对于治疗是必须的，那么这个旅行相关的开销就可以包含在HSA支付的范围。同时，IRS并没有指导医疗开销是不是必须在美国国内。那也就是，如果你觉得北京上海的医生对于你的病的治疗有更多帮助，那么飞到北京或者上海看病是属于合理的HSA可支付范围内。\n\n当然本文不可能也没必要穷尽所有IRS允许的HSA免税开销，如果有特别需要的话，google一下通常会有相当多人讨论。\n\n### HSA可以投资些什么？\n\nHSA是一个银行帐户，而通常HSA帐户的提供商都会跟其它证券公司(broker)合作来提供购买投资产品的服务。\n\n举个例子，美元先生用的HSA帐户提供商是HSABank，而 HSABank与TD-Ameritrade合作提供投资产品。\n\n在TD-Ameritrade里，我可以选择购买个股，也可以选择购买其它股指基金，房地产基金等等，所以HSA的投资对象并不会受限定，基本是你想投啥都可以。\n\n但是同时也要注意，如果你在读这篇文章的话，大概率是刚刚开始接触投资，不建议投资个股。如果你不确定投资些什么，优先推荐[投资ETF基金](https://usdweekly.com/how-to-invest-etf/)或共同基金。\n\n针对这点，我在[我应该投资股票吗一文中有更详细的解释](https://usdweekly.com/should-i-invest-stock-market/)。\n\n如果你的投资产品里看到Vanguard或者Fidelity, Charles Schwab的股指基金，那恭喜你，这些基金都是品质保障。\n\n我在[为什么投资这些基金和Vanguard基金如何挑选](https://usdweekly.com/how-to-choose-vanguard-fund/)的文章里详细解释了为什么优先考虑投资Vanguard基金，或者以上提到的几家股指基金/共同基金。\n\n### HSA可以给配偶用吗\n\n一句话，可以。同时如果你已经结婚的话，HSA的限额会增加，细节见上文“HSA限制”一章\n\n### HSA报销麻烦吗？HSA报销需要收据吗？\n\n首先HSA报销不麻烦；严格讲这个不叫报销，这个叫向IRS申请使用你的免税额。\n\n其次IRS不要求你在向你的HSA帐户里取钱时提供收据。需要收据的时候是，IRS抽查到你的时候，你能提供证明你取钱的时候取的部分是用于了医疗。当然了，最容易的证明方式就是把收据给IRS看了。\n\n这里提供一个不但可以非常方便保存收据，同时可以最大化你的HSA收益的方式，也就是我们的：\n\n### 用HSA四步多挣50万\n\n#### 步骤一：\n\n在Dropbox/Google Photo或者任何照片同步软件里建一个folder，专门用来保存receipt\n\n#### 步骤二：\n\n每次看完病，去看病的路上，把产生的收据照下来，原件不用存\n\n#### 步骤三：\n\n不要报销，等到65岁或者过几年再一次性报销。如果你考虑要回国，回国前一次性报销\n\n步骤四：\n\n在HSA中选择指数基金或者共同基金，推荐Vanguard的低成本基金。把放到HSA帐户中的钱从脑子中抹去，让它定投和指数增益，不要管它\n\n步骤一和二非常好理解，不多说\n\n对于步骤三，逻辑是这样的，对于你所有在HSA里的钱，不要把它考虑为钱，应该把它考虑为equity。什么是equity？equity就是你睡觉时可以继续帮你挣钱的资产。\n\n在比较早的时间，比如A点取出，和在比较晚的B点取出5万美元，对于资产的增值是有天差地别的区别的。如果在A点取出5万美元，即使考虑了通货膨胀，这部分钱本来也可以增值至B点的5*1.07^10 = 9.8万美元。\n\n如果你在HSA里的钱全在指数基金或共同基金里，那么你的资产就是这些基金里含有的公司股票的股份，多放一年，平均来讲你HSA里的资产就会增加7%（通胀调整）或者10%（不含通胀调整）。那么要最大化你的收益，显然是让HSA里的资产增值越久越好。而IRS并没有规定医疗费用必须当年申报，因此你完全可以放心大胆把医疗费用的凭证放到一个地方，在你最终需要把钱拿出来时，再拿出来。\n\n### 总结\n\nHSA虽然听起来是个跟看病相关的事情，但是其实它是在Roth, 401(K)的基础上，可以极大帮助你省税和提高投资效率的工具。\n\n如果你之前从来没有听说过的话，也不要感觉自己很悲剧，因为即使美国人知道且在擅于利用HSA的也不多。2008年的数据是，只有8%的在职人员参与了HSA。\n","slug":"New-Hire-Benefit-全解","published":1,"updated":"2020-03-29T06:59:20.714Z","photos":[],"link":"","_id":"ck8ct7j5l000fgtvi891mhoho","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>本文纯属转载</strong></p>\n<p>第一天remote onboarding，benefit的人上来对保险一顿讲解，讲得我头晕眼花。回来仔细查查，才好了解自己到底要买哪个。虽然现在新冠疫情严重，我早已决定把保险拉满（冲</p>\n<h2 id=\"Medical-Insurance\"><a href=\"#Medical-Insurance\" class=\"headerlink\" title=\"Medical Insurance\"></a>Medical Insurance</h2><p>First of all there are some terms that you need to know, because these are the main differences of all the insurances.</p>\n<p><strong>此处部分原文来源<a href=\"https://tigerless.com/how-to-choose-us-health-insurance/\" target=\"_blank\" rel=\"noopener\">虎虎保险</a></strong></p>\n<ul>\n<li><p><strong>1 保险费(Premium)</strong></p>\n<p><strong>不要贪图便宜选保险费(Premium)低的</strong></p>\n<p>保险费 （Premium）。保险费是指你购买健保时，定期要支付给保险公司的费用，一般是每月支付。保险费与受保人年龄、健康状况等相关。一般受保人年龄越高，保险费越贵。一定要先了解公司的保险费（Premium）是多少， 一般每个保险公司都会给出不同(价位的保险选择来迎合不同的受保人需要。但保险费（Premium）不是越低越好？保险费越低意味着赔偿支付也越低，并且限制条件会比较多。</p>\n</li>\n<li><p><strong>2 Out-Of-Pocket</strong></p>\n<p>指自己看病后实际上需要交的钱</p>\n</li>\n<li><p><strong>2 最高限额（Maximum Payment）</strong></p>\n<p><strong>保险公司的 Maximum Payment 额高很重要</strong></p>\n<p>最高保险支付额(Maximum Payment) 是保险公司愿意为你买单的上限。不要天真的以为，看什么病，花多少钱，买了医疗保险，保险公司就都会为你买单。事实上，一般的美国医疗保险都会有一个支付额度的上限。如果你选的保险支付额越低，那么你自己生了大病，要掏腰包的钱就越多。 美国随便做个手术，几万美金小意思~</p>\n</li>\n<li><p><strong>3 自付额(Deductible)</strong></p>\n<p><strong>自付额低很重要</strong></p>\n<p>一般保险公司要求个人支付500美元到5000美元不等的自付款。也就是你一年要先自付一笔钱之后，保险公司才会开始付。总之就是当然是自付额越少越好。有些保险甚至没有自付额，但是每月的Premium就会变高，也就是每月固定支付的钱增加。</p>\n</li>\n<li><p><strong>4 挂号费(Copay)</strong></p>\n<p><strong>挂号费高低因人而异</strong></p>\n<p>定额手续费（copay）是指受保人每次看普通门诊或购买处方药时需当场支付的一笔固定费用。例如，每次看医生门诊个人需支付20美元，购买处方药时需支付15美元。具体的定额手续费金额，看保险合同。一般来说copay从20-50美元都有，也有0的。如果你是医院的“常客”，建议你选择copay低一点的美国医保，但是这样的医疗保险保险费可能相对较高。如果你身体很好，又年轻，不怎么进医院，可以选择保险费相对低的，copay高一点也就无所谓了。</p>\n</li>\n<li><p><strong>5 特殊限制(Special Limits)</strong></p>\n<p><strong>那么医保公司到底可以付多少？需要仔细阅读保险的条款，特别是你有一些疾病，需要长期治疗的。</strong></p>\n<p>对于一些特殊医疗服务，包括住院、手术、麻醉、心理治疗等，不少保险公司规定有一定的支付限额。有些规定一年只报一次Image, 一次体检，需要更多则要自己掏钱。</p>\n</li>\n<li><p><strong>6 排除支付条款(Exclusion)</strong></p>\n<p><strong>每一份保险都会有一个Exclusion list，购买之前一定要仔细阅读哪些医疗项目不在保险支付范围之内。</strong></p>\n<p>在美国看牙，是出了名的贵，牙科/眼科一般都是单门的医保项目。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>HMO(Health Maintenance Organization)</strong></p>\n<p>Cost less, but you have less choice of doctors, when you choose HMO, you have to name a specific doctor who manages all of your cares, often called primary care doctor. You must go to see this specific doctor before you see any other doctors when you are sick or need care. You will have to make a pre-defined payment, known as copay every time you see your primary doctor and any specialists she or he may send you to for care.</p>\n</li>\n<li><p><strong>PPO(Preferred Provider Organization)</strong></p>\n<p>Give you more freedom to choose from a larger pool of doctors, generally cost you more paychecks. You still need to see the doctors “in network” to get the most coverage from the plan. You still need to pay the copay each time you visit the specialist</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>HDHP(High Deductible Health Plan) or CDHP</strong></p>\n<p>Cost the least but have a higher deductible. A health Saving account- or HSA- can be attached to a HDHP to help cover the expenses</p>\n</li>\n</ul>\n<h2 id=\"Flexible-Spending-Account-FSA\"><a href=\"#Flexible-Spending-Account-FSA\" class=\"headerlink\" title=\"Flexible Spending Account (FSA)\"></a>Flexible Spending Account (FSA)</h2><p><strong>本文来源：<a href=\"https://usdweekly.com/what-is-fsa/\" target=\"_blank\" rel=\"noopener\">美元先生</a></strong></p>\n<h3 id=\"FSA是什么？\"><a href=\"#FSA是什么？\" class=\"headerlink\" title=\"FSA是什么？\"></a>FSA是什么？</h3><p>FSA的全称叫Flexible Saving Account，它的主要作用是国税局考虑到贫苦大众们面对生活的摩擦，在生病时总得给点安慰。于是，国税局在1978年开始，正式开始将FSA作为一个福利推出。</p>\n<p>FSA是一个用于给你自己报销医疗花销的储蓄帐户</p>\n<p>最简单的理解是，FSA就是一个银行帐户，在你的工资被扣税前，你可以选择存一部分到这个帐户中。</p>\n<p>存入的这个部分，国税局不会对你征税。</p>\n<p>举个例子，你一年收入是10万美元，而今年你决定把2000美元整放到FSA中，那么你的征税收入计算是98,000而非10万。</p>\n<h3 id=\"FSA报销怎么理解？\"><a href=\"#FSA报销怎么理解？\" class=\"headerlink\" title=\"FSA报销怎么理解？\"></a>FSA报销怎么理解？</h3><p>FSA的报销是指，你自己报销向自己报销花销。这个概念一开始很难理解，哪有人自己找自己报销的？我们用一个例子来说明</p>\n<p>还是继续上面的假设，你今年在FSA里放了2000美元，注意这2000美元IRS没跟你要过一分钱税，而是直接从你工资税前部分存入的。</p>\n<p>然后你很不幸地摔了，看病花了1000美元，这1000美元是你用你自己Chase卡付的。<em>注意，这里的1000美元花的是你税后的钱</em>（不管你用的是Chase信用卡还是借记卡都是你税后的钱）</p>\n<p>现在，你决定去跟自己的FSA报销。你FSA的余额还有2000美元，而你需要报销1000美元出来。你提交了医疗凭证（收据、医生处方），被批准后，FSA往你的银行存入1000美元。这整个过程结果是，你用1000美元税钱的钱看好了病，也即你向自己的FSA成功报销了一次。</p>\n<h3 id=\"怎么用FSA省钱？\"><a href=\"#怎么用FSA省钱？\" class=\"headerlink\" title=\"怎么用FSA省钱？\"></a>怎么用FSA省钱？</h3><p>FSA省钱的策略比HSA简单太多了。</p>\n<p>最基本的理解就是，存入FSA的钱不需要交税，而用这个帐户付钱的时候，只要是付<strong><em>医疗相关</em></strong>的费用（需要证明）就可以被允许（或俗称的，可报销）。</p>\n<p>假设你今年在FSA里存入了2000美元，这2000美元拿去打针吃药是完全没有问题的。最棒的是，FSA还可以报销一些你不太想得到的开销</p>\n<h3 id=\"FSA可以报销哪些开销\"><a href=\"#FSA可以报销哪些开销\" class=\"headerlink\" title=\"FSA可以报销哪些开销\"></a>FSA可以报销哪些开销</h3><p>再次夸一次IRS，或者说瞪一眼美国国税局——由于这个资本主义国家发展的年代已经非常久远，税收的体制已经非常健全，你能想到的漏洞它基本已经帮你想好且堵住了。</p>\n<p>比如说，一个自然的想法就是，FSA里的钱如果可以拿去支付任何开销的话，那不就等于现金了吗？</p>\n<p>非常遗憾的是，IRS不仅对花销的种类有限制，甚至逐条列出来了你可以报销的具体东西，比如</p>\n<ul>\n<li>处方药</li>\n<li>血糖测剂</li>\n<li>计生用品（我的天，这个词我打出来的时候都觉得中文真是博大精深）</li>\n<li>验孕棒（怎么样，IRS心思细不细）</li>\n<li>胰岛素</li>\n<li>绷带</li>\n<li>拐杖（怎么样，再一次，就问你细不细）</li>\n<li>针灸</li>\n<li>理疗</li>\n<li>心理医生费用</li>\n<li>戒烟项目费用</li>\n<li>牙医</li>\n<li><strong>Child care</strong></li>\n</ul>\n<p>写到这里我真的是不禁联想，国内规定的特点是爱用”相关物品“，比如说”医疗相关用品“，这就留下了很多解释的空间。而IRS则相反，把FSA可以报销的东西一件件列出来，如果感兴趣可以看<a href=\"https://www.irs.gov/pub/irs-pdf/p969.pdf#page=16\" target=\"_blank\" rel=\"noopener\">IRS的这个解释</a></p>\n<p>注意上面列表里最后一项，Child care被FSA认为是可以报销的项目。因此，如果你有小朋友需要child care，那么FSA可以用税前的钱来搞定。这也是为什么FSA可能对宝妈们特别有用。</p>\n<h3 id=\"为什么不选FSA\"><a href=\"#为什么不选FSA\" class=\"headerlink\" title=\"为什么不选FSA?\"></a>为什么不选FSA?</h3><p>大转折来了</p>\n<p>尽管有免税的好处，而且报销的范围比HSA广，FSA仍然不是一个非常好的金融工具。原因如下</p>\n<p><strong>原因一：FSA的保持期只有一年</strong></p>\n<p>如果你在一个税务年之前（通常是报税终止之前）FSA里的钱没有用完，那你的FSA帐户非常大的概率会被清空（不被清楚的情况太特殊不讨论）</p>\n<p><strong>原因二：FSA的钱不可以用于投资</strong></p>\n<p>接上条，既然FSA的钱每年会清空，那也就没什么复利增加的意义了。同时，FSA帐户不提供投资的途径，因此断了复利增长这条路。可惜的是，复利增长几乎所有金融工具能帮我们<a href=\"https://usdweekly.com/what-is-financial-independence/\" target=\"_blank\" rel=\"noopener\">实现财富独立</a>的基础</p>\n<p><strong>原因三：FSA只跟着雇主走，换工作清空</strong></p>\n<p>因此，如果你有的是FSA帐户，请确保在换工作前一定把里面的钱花完。可以考虑多看一次牙医，存一些药之类</p>\n<p>正是因为上面三个原因，FSA几乎不应该成为任何人的首选，除非你真的认为用税前的钱来支付Child care之类开销非常重要（HSA不能用于支付Child care）。但是理性来说，如果对比<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">HSA在30年内可以帮你多挣50万美元</a>的能力，FSA这点可怜的好处几乎不值一提</p>\n<h3 id=\"FSA这么没用，为什么它还卑微地存在呢？\"><a href=\"#FSA这么没用，为什么它还卑微地存在呢？\" class=\"headerlink\" title=\"FSA这么没用，为什么它还卑微地存在呢？\"></a>FSA这么没用，为什么它还卑微地存在呢？</h3><p>原因很简单，iPhone是不是一代比一代好？</p>\n<p>FSA/HSA这样的项目也类似，在收集前面的反馈的时候，后续项目会有一些相关的调整。</p>\n<p>考虑FSA和HSA推出的时间</p>\n<p>FSA是1978年咱改革开放那年出品，而HSA是2003年布什总统在位时出品的二代产品</p>\n<p>这样看起来，咱就把HSA当作iPhone X，把FSA当作iPhone 4吧 🤔</p>\n<p>从另一个角度，FSA也并不是一无事处。注意不是每个公司都有给员工提供HSA的福利，有的公司只有FSA，那也只能矮子里面挑高个了</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>FSA是个有趣的项目，有一些特点。</p>\n<p>比如它的报销范围比较广，可以报销牙医、Child care等项目。</p>\n<p>但它也有些致命的缺点，每年会被清空，且它是跟着雇主走的帐户，一换工作也要清空，因此它并不能有效地帮助我们实现财富独立。</p>\n<p>相比而言，如果你的公司提供HSA，那么你可以用HSA在30年内用复利增长多挣50万美元。具体步骤请读这篇文章：<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">如何用HSA投资且多挣50万美元</a></p>\n<p>本文参考：</p>\n<ul>\n<li><a href=\"https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/\" target=\"_blank\" rel=\"noopener\">https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/</a></li>\n<li><a href=\"https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/\" target=\"_blank\" rel=\"noopener\">https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Flexible_spending_account#History\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Flexible_spending_account#History</a></li>\n<li><a href=\"https://dpath.com/2019-fsa-contribution-limits/\" target=\"_blank\" rel=\"noopener\">https://dpath.com/2019-fsa-contribution-limits/</a></li>\n<li><a href=\"https://www.investopedia.com/insurance/hsa-vs-fsa/\" target=\"_blank\" rel=\"noopener\">https://www.investopedia.com/insurance/hsa-vs-fsa/</a></li>\n<li><a href=\"https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/\" target=\"_blank\" rel=\"noopener\">https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/</a></li>\n</ul>\n<h2 id=\"Dependent-Care-FSA\"><a href=\"#Dependent-Care-FSA\" class=\"headerlink\" title=\"Dependent Care FSA\"></a>Dependent Care FSA</h2><h3 id=\"1、如何使用-Dependent-Care-FSA报账\"><a href=\"#1、如何使用-Dependent-Care-FSA报账\" class=\"headerlink\" title=\"1、如何使用 Dependent Care FSA报账\"></a><strong>1、如何使用 Dependent Care FSA报账</strong></h3><p>首先要说明的一点是，<strong>FSA并不是国家统一管理的，也不是所有公司雇主都提供，提供FSA的雇主各自有自己的管理公司</strong>，你需要在规定的管理公司的网站上注册账号，这样就可以随时检查余额、提交申请了。另外，FSA是在大家每年的福利开放登记（benefit open enrollment）期间登记注册，而且一般每年都要重新登记，不会像医疗保险那样自动保留你上一年的选择。</p>\n<p>FSA登记注册好之后，你选择的缴纳金额按pay schedule进入账户，钱到账之后，你就可以在网上提交你的Daycare费用支付收据。这里要提醒大家注意的是，DCFSA和MFSA不一样，MFSA是你自1月1日起一整年的全部花费都可以获得补偿，而DFSA只有已到帐的余额才能用，而且补偿的必须是已经发生的服务。</p>\n<p>举个很简单的例子，如果你是在3月底交的4月份的学费，无法在3月底得到补偿，而是要等到4月结束后。因此，你的Daycare支付费用收据上最好除了社会保险号之外，还要有提供服务的日期（service period from xxx to xxxx）</p>\n<h3 id=\"2、DCFSA的好处和最高限额\"><a href=\"#2、DCFSA的好处和最高限额\" class=\"headerlink\" title=\"2、DCFSA的好处和最高限额\"></a><strong>2、DCFSA的好处和最高限额</strong></h3><p>FSA 享有很好的免税待遇，FSA的补偿金完全是税前的，不用交SSN、Medicare、Federal and State tax，但是这个免税优惠是有条件的，那就是你的花销得是花在符合资格的个体身上，而且不超过IRS规定的补偿限制。<strong>Dependent Care FSA目前的最高限额是每个家庭5000美元</strong>，夫妻双方任何一人使用都可以，也就是两个人加起来不能超过5000美元的最高限额。</p>\n<p>另外需要注意的是，这里所能享受到的免税额度和夫妻双方的收入是有关系的：如果夫妻双方的收入都多于5000美元，则5000美元都可以免税；如果有一方的收入少于5000美元，比如只有2000美元的话，那么无论你的贡献金额为多少，能免税的都只有那2000美元；如果有一方没有收入，那么你的FSA的贡献金额不管是多少都不能满足免税条件（夫妻中有一方或双方是全职学生或残障人士的情况除外）。</p>\n<h3 id=\"3、享受DCFSA的免税补偿需要满足的条件\"><a href=\"#3、享受DCFSA的免税补偿需要满足的条件\" class=\"headerlink\" title=\"3、享受DCFSA的免税补偿需要满足的条件\"></a><strong>3、享受DCFSA的免税补偿需要满足的条件</strong></h3><p>那么什么才算是有资格的个体呢？除了开头讲到的无生活自理能力的被抚养者之外，对于大多数的妈妈们来说，符合这个资格的就是年龄不超过13岁的孩子（孩子满13岁的这一年要按实际接受的服务来计算价钱）。也就是说，<strong>DCFSA只有在夫妻为双职工或正在找工作（或夫妻一方为全日制学生），且孩子在13岁之下才能获得补偿。</strong>如果夫妻中有一方为全职妈妈或全职爸爸，收入为0，就无法享受这项免税优惠。</p>\n<p>P.S.判定自身或配偶属于全职学生的要求为：必须满足至少五个月的在学校全职上学的条件，这里所指的学校不包括在职培训课程、函授学校或只通过互联网授课的学校。</p>\n<p><strong>与照顾孩子相关的这些费用可以享受DCFSA的免税补偿：</strong></p>\n<p>①Fees for licensed day care（持有牌照经营的Daycare费用。）</p>\n<p>②Amounts paid for services (including babysitters or nursery school) – provided in or outside of your home – for the care of a qualified dependent necessary to allow you and your spouse to work, look for work, or attend school full-time.（付给照顾孩子的保姆或nursery school所产生的费用。）</p>\n<p>③Summer day camp for children under age 13 qualifies if attendance allows you and your spouse to work, look for work, or for your spouse to attend school full-time.（13岁以下孩子参加夏令营所产生的费用。）</p>\n<p>④Before and after school care programs for dependents under age 13.（在上学前、上学后提供照看13岁以下孩子服务所产生的费用。）</p>\n<p>⑤Payment to a relative (age 19 or older who is not your dependent) who cares for your qualified dependent.（请19岁以上的亲戚来照看孩子所产生的费用，这个亲戚不能是你的被抚养者。）</p>\n<p>⑥Payment to a housekeeper whose duties also include dependent day care.（请同样承担照看孩子工作的家庭管家所产生的费用。）</p>\n<p>请参考<a href=\"http://www.irs.com所给出的官方说明：\">www.irs.com所给出的官方说明：</a><br><a href=\"https://www.irs.gov/pub/irs-pdf/i2441.pdf\" target=\"_blank\" rel=\"noopener\">https://www.irs.gov/pub/irs-pdf/i2441.pdf</a><br><a href=\"https://www.irs.gov/pub/irs-pdf/p503.pdf\" target=\"_blank\" rel=\"noopener\">https://www.irs.gov/pub/irs-pdf/p503.pdf</a></p>\n<h2 id=\"HSA\"><a href=\"#HSA\" class=\"headerlink\" title=\"HSA\"></a>HSA</h2><p><strong>本文来源：<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">美元先生</a></strong></p>\n<h3 id=\"到底什么是HSA帐户\"><a href=\"#到底什么是HSA帐户\" class=\"headerlink\" title=\"到底什么是HSA帐户?\"></a>到底什么是HSA帐户?</h3><p>要了解怎么样用HSA省税挣钱，需要先大致对美国税法有一个基本了解：在美国，IRS可能是比FBI更难惹的一个部门</p>\n<p>一来后者关乎犯罪，我等良民不太容易惹得到，而前者则跟每个在美国生活、投资的人息息相关。而美国税制最神奇的一个地方是，你不光需要遵守税法，且你需要对自己不懂税法负责——不情的情况下报税错误？不好意思，也要罚款坐牢</p>\n<p>HSA的全称是Health Savings Account，以下我将会简称其为HSA。顾名思义，这个帐户应该是跟医保储蓄之类的事情相关的。但这个帐户跟你大摇大摆走进一家银行，跟柜员开户的银行帐户完全是两个概念。</p>\n<p>首先，HSA不是一个具体的“银行帐户”概念。相反，它是一种减轻减轻特定人群税务负担的行政手段。</p>\n<p>你可以把HSA理解为，政府为了帮助有医疗需求的人（也即几乎所有在美国生活的人）减轻税务负担而单独开设的减税计划。</p>\n<p>用白话说，就是政府看到有些居民生活困难，而如果碰到医疗开销的话更将会雪上加霜。那么政府决定，由IRS出面，给这些人士一个特殊的“帐户”，这些帐户的唯一作用是，如果往这个帐户里存钱，那么政府将认为这些钱会最终用于你或家人的医疗开销，<strong>而这部分存入的钱是不收税的</strong>。</p>\n<p>举个例子，张二狗同学年收入十万美元，他把7000块存入HSA帐户内。那么他被征税的部分就是93,000美元，存入的7000美元部分免税。</p>\n<h3 id=\"HSA的限制\"><a href=\"#HSA的限制\" class=\"headerlink\" title=\"HSA的限制\"></a>HSA的限制</h3><p>上面的例子听起来很刺激对不对?</p>\n<p>假设你是一位程序写得飞起的Google工程师，每年收25万美元整，那么你可以把25万美元全部存到HSA帐户里喜滋滋把税免了？</p>\n<p>当然不行，IRS这么容易让你钻空子就不是IRS了:)</p>\n<p>通常来说，使用HSA有这么几个限制</p>\n<ol>\n<li>HSA有每年的存入限额</li>\n<li>你，你的公司和IRS三方需要介入整个过程</li>\n<li>多数HSA需要你用的医保是High-deductible的</li>\n</ol>\n<p>我们一条一条来分析</p>\n<p>限制1，HSA有每年的存入限额</p>\n<p>虽然有限额，但是这个限额从历史上来看，是每年严格递增的，也就是说随着时间增加每年你能通过HSA避的税会逐年增加。同时注意HSA的限制对于个人和家庭来说是不一样的，而如果你超过55岁，还可以享受一个“落后生”优惠：每年可以比其它人多存一部分。</p>\n<p>具体年每年IRS允许往HSA帐户里存入的限额如下表（摘自<a href=\"https://en.wikipedia.org/wiki/Health_savings_account\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<p><strong>HSA存入限额（按年）</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">年份</th>\n<th align=\"left\">单身HSA限额</th>\n<th align=\"left\">家庭HSA限额</th>\n<th align=\"left\">55岁以上可补交</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2010<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-26\" target=\"_blank\" rel=\"noopener\">[26]</a></td>\n<td align=\"left\">$3,050</td>\n<td align=\"left\">$6,150</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2011<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-27\" target=\"_blank\" rel=\"noopener\">[27]</a></td>\n<td align=\"left\">$3,050</td>\n<td align=\"left\">$6,150</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2012<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-28\" target=\"_blank\" rel=\"noopener\">[28]</a></td>\n<td align=\"left\">$3,100</td>\n<td align=\"left\">$6,250</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2013<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-29\" target=\"_blank\" rel=\"noopener\">[29]</a></td>\n<td align=\"left\">$3,250</td>\n<td align=\"left\">$6,450</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2014<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-30\" target=\"_blank\" rel=\"noopener\">[30]</a></td>\n<td align=\"left\">$3,300</td>\n<td align=\"left\">$6,550</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2015<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-31\" target=\"_blank\" rel=\"noopener\">[31]</a></td>\n<td align=\"left\">$3,350</td>\n<td align=\"left\">$6,650</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2016<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-32\" target=\"_blank\" rel=\"noopener\">[32]</a></td>\n<td align=\"left\">$3,350</td>\n<td align=\"left\">$6,750</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2017<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-33\" target=\"_blank\" rel=\"noopener\">[33]</a></td>\n<td align=\"left\">$3,400</td>\n<td align=\"left\">$6,750</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2018<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-34\" target=\"_blank\" rel=\"noopener\">[34]</a></td>\n<td align=\"left\">$3,450</td>\n<td align=\"left\">$6,900</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2019<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-35\" target=\"_blank\" rel=\"noopener\">[35]</a></td>\n<td align=\"left\">$3,500</td>\n<td align=\"left\">$7,000</td>\n<td align=\"left\">$1,000</td>\n</tr>\n</tbody></table>\n<p>限制2，你，你的公司和IRS三方需要介入整个过程</p>\n<p>如上文所说，你不能走进一家银行要求”开一个HSA“帐户。到目前为止，你如果需要往HSA帐户里存钱的话，只能通过你的雇主。对于你是自己在创业的同学，你有可能可以搞一个self-employed HSA（相对少见这里不展开讨论了）。而对于IRS在这里的作用则更多是监督你把省的税和投资收益用来买药，而不会把HSA的税务优惠用来买兰博基尼 🙂</p>\n<p>限制3，多数HSA需要你用的医保是High-deductible</p>\n<p>这一条要求搞糊涂了不少人。其实简单点讲，high-deductible plan就是每次去医院的时候需要自己掏腰包的部分稍多一点。但是只要你不是天天去医院，对99%的50岁以下年轻人来说，high-deductible完全够用。同时，比起多出来那一点co-pay和多掏的腰包，HSA能给你带来的收益大得多得多（下文会有具体的计算）</p>\n<h3 id=\"如何理解HSA\"><a href=\"#如何理解HSA\" class=\"headerlink\" title=\"如何理解HSA\"></a>如何理解HSA</h3><p>很多人在理解HSA的时候，包括我自己最初在试图搞清楚它的时候，都被各种概念搞晕。其实要理解HSA，只要脑中简单地有一个概念即可：HSA是一个杯子（容器）</p>\n<p>而你往HSA里放钱的时候，是在把这个杯子换为更大号的杯子。比如说，前三年你往HSA里存入了2万美元，那么你的HSA就是一个容积为2升的杯子。</p>\n<p>而这个杯子的用途就多了，你可以把杯子当作装饰，放在桌上不管它（对应HSA里的钱当作现金）；也可以把杯子里装满茶（对应HSA帐号里的钱用来购买国债）；也可以把杯子里装满咖啡（对应HSA帐号里的钱用来购买mutual fund或者<a href=\"https://usdweekly.com/how-to-invest-etf/\" target=\"_blank\" rel=\"noopener\">购买ETF基金</a>）</p>\n<p>总之，这个杯子里装茶还是咖啡，甚至是一半茶一半咖啡，都是可以的。</p>\n<h3 id=\"如何用HSA帐户进行投资\"><a href=\"#如何用HSA帐户进行投资\" class=\"headerlink\" title=\"如何用HSA帐户进行投资\"></a>如何用HSA帐户进行投资</h3><p>这一节的副标题应该叫：如何用HSA多挣50万美元😍</p>\n<p>到这里为止，你应该大致了解了政府设立HSA的动机是什么，以及HSA的一些限制。那么这一章我就详细讲解一下如何用HSA来帮你多挣50万。</p>\n<p>首先我们做一些简单的假设：</p>\n<ol>\n<li>你每年将会在HSA里放满允许存入的金额。比如2019年你将会放满7000美金</li>\n<li>你还会工作30年直到你退休</li>\n<li>在退休前你不会碰HSA里的钱（千万不要拿出来）</li>\n</ol>\n<p><strong>对于绝大多数HSA帐户，如果你存入超过1000美金，这个帐户就可以用于购买股票、债券或者指数基金。</strong></p>\n<p>而绝大多数HSA提供商（比如我的是HSAbank）都会允许你购买股票、基金或者共同基金</p>\n<p>HSABank的功能界面 – 提供了investments的选项</p>\n<p>那么如何用HSA帐户多挣美元的问题，就转化成了，年定投7000美金30年复利增长可以收益多少的问题。同样，我们用标普500的历史数据来做这个基本分析。我们的基本参数如下：</p>\n<p>年存入: $7000 (2019年家庭限额）</p>\n<p>年限: 30年</p>\n<p>预计年收益：10% (标普500 80年平均）</p>\n<p>复利频率：1年</p>\n<p>用于计算复利的参数</p>\n<p>那么到2048年，我们的总余额将达到126万美元，其中本金仅为21万左右</p>\n<p>当然你可能会说，考虑通货膨胀的话，到2048年这些钱可能就是30年前的万元户手里的一万美元了。其实不然，即使调整了通胀的收益，收益也会是非常可观的数字。本金同样为21万，收益则为50万美元。</p>\n<h3 id=\"HSA如何帮你省税\"><a href=\"#HSA如何帮你省税\" class=\"headerlink\" title=\"HSA如何帮你省税\"></a>HSA如何帮你省税</h3><p>如同乔帮主常说的，just one more thing…</p>\n<p>HSA的超强吸引力，不光在于它可以让你免税开始存钱，更可怕的是，它的收益也可以做到部分免税（医疗报销），而这是401(K)，Traditional IRA, Roth IRA等任何储蓄计划都做不到的。</p>\n<p>具体来说</p>\n<ol>\n<li>你的工资、收入在存入HSA时，是不收税的</li>\n<li>你存入HSA的钱，在收益增值的过程中，是不收税的</li>\n<li>如果你生病了，需要在中途把一部分钱拿出来（不建议，下文讨论如何看病省钱两不误的操作），你可以把钱拿出来且不用交任何税</li>\n<li>如果你到了65岁，你可以把所有的钱一次性拿出来，仅按收入税交税</li>\n</ol>\n<p>举个具体例子，张二狗同学25岁从弟伦比亚大学毕业，到湾区成为了一位光荣的年薪20万美元的初级软件工程师。</p>\n<p>读完这篇文章后张二狗同学决定每年把7000美元拿出来放到HSA中，首先20万美元中的7000美元被划分开，IRS决定对这7000美元免税。即，张二狗同学可能被扣税的收入减少为19万3千美元。</p>\n<p>张二狗同学把HSA中所有的美元全部购买了指数基金。</p>\n<p>到45岁时，张二狗同学的颈椎病发作，但他手里还有一些多余的现金，因此他只把看病时的收据拍照留下了，而在HSA帐户里的基金继续增值。</p>\n<p>到55岁时，张二狗同学决定跟翠花辞职退休，环游世界。30年过去，这时他的HSA帐户中已经有了126万美元，而这30年他仅仅往帐户里存入过21万美元。他需要一些钱来支付环游世界的费用。于是他找出来之前看病时的收据，于55岁这年从HSA帐户里拿出6万美金用于环游世界。</p>\n<p>终于到了65岁，张二狗同学决定把HSA里的钱全拿出来。而此时HSA帐户中已经有了300万美元！这就是复利的力量。这时候二狗同学的身体已经不太好了，累积了50万美元的医疗开销。而张二狗同学在把这300万美元拿出来的过程中，50万美元的部分不必交税，仅余下的250万需要交收入税。</p>\n<p>这就是HSA最大的威力：收入免税+复利增长+部分收益免税</p>\n<h3 id=\"有关HSA的常见问题\"><a href=\"#有关HSA的常见问题\" class=\"headerlink\" title=\"有关HSA的常见问题\"></a>有关HSA的常见问题</h3><p>这里解答一些关于HSA的常见问题</p>\n<h3 id=\"回国了HSA怎么办\"><a href=\"#回国了HSA怎么办\" class=\"headerlink\" title=\"回国了HSA怎么办?\"></a>回国了HSA怎么办?</h3><p>如果你已经决定了在65岁前回国，那么你有两个选择</p>\n<p>选择1，提前把钱退出来（不推荐）</p>\n<p>虽然你可以提前把HSA里的钱拿出来，但是如果不是手头真的紧的话，并不建议。原因是你在把钱放入HSA时，没有交税。那么如果你要提前拿出来，不但你要把拿出来的部分的税补交上，且要加上<a href=\"https://hsastore.com/\" target=\"_blank\" rel=\"noopener\">20%的惩罚</a>。</p>\n<p>举个例子，张二狗同学拿到了假格基金的投资，毅然决然决定2020年启程回国担任CEO走上人生巅峰，而他之前在HSA里的本金和收益总共收益10万美元。在2020年这年，他决定把HSA里的钱全拿出来，那么他的10万美元将需要算作2020年的收入被税，同时需要支付2万美元的罚款。假设张二狗2020年已经辞职且没有其它收入，那么他需要支付的联邦税为29,204 + 20000 = 49,204美元，可以说是非常不划算了。</p>\n<p>当然如果你不着急，有两个办法把税降到最低（但20%的罚款无法避免）</p>\n<p>第一个办法是，尽量降低每年从HSA里拿出来的金额，这样可以让你当年的收入变少，因此可以被税比例降低甚至是免税。</p>\n<p>第二个办法是，尽量在回国之后（这样在美国就不再有收入）再慢慢把钱拿出来，这样你在美国的收入仅有HSA拿出来的部分，你可以选择一年只拿最低征收额以下，比如2019年如果你只拿9,324出来，一分钱税都不用交。</p>\n<p>选择2，把钱放在HSA内增值（推荐）</p>\n<p>如果手里不紧，这是我一贯的主张。在国内几乎没有任何资产配置可以跟美元+美国金融市场匹敌，不着急用钱的话没有任何理由把HSA里大量税收优惠的钱带回国。且实际操作来讲，如果你需要看病的时候，即使是在国内，也可以把看病的花销都记录下来，收据留好，每年报销一次。剩余的部分则在HSA帐户内增值。</p>\n<h3 id=\"如果换了公司HSA帐户怎么办\"><a href=\"#如果换了公司HSA帐户怎么办\" class=\"headerlink\" title=\"如果换了公司HSA帐户怎么办?\"></a>如果换了公司HSA帐户怎么办?</h3><p>这个相对容易，HSA虽然是需要公司参与，但是受益人和操作人是你且只是你。因此如果换了公司，最多是跟给你提供HSA的银行打个电话，告诉他们你换公司了。通常来说你所在公司的HR也会协助你迁移。当然更好的办法是把HSA完全独立出来，所有信息都跟公司分离开来，我就是这么干的。这样即使换了公司，只是换了个每个月向HSA里存钱的帐户而已，相当方便。</p>\n<h3 id=\"HSA可以买什么？\"><a href=\"#HSA可以买什么？\" class=\"headerlink\" title=\"HSA可以买什么？\"></a>HSA可以买什么？</h3><p>理论上HSA里的钱你可以买任何你想买的东西，只是有些东西不免税以及有惩罚而已。</p>\n<p>所以这个问题的问题应该是，HSA帐户可以用于免税购买什么东西？</p>\n<p>根据<a href=\"https://www.irs.gov/publications/p502\" target=\"_blank\" rel=\"noopener\">IRS的指导</a>，你可以用于购买以下东西</p>\n<ul>\n<li>看医生的co-pay</li>\n<li>IRS批准的医药中保险不报销的部分（i.e. out of pocket)</li>\n<li>一些医用的产品，比如baby monitor，温度计之类；比较完整的列表见<a href=\"https://hsastore.com/HSA-Eligibility-List.aspx\" target=\"_blank\" rel=\"noopener\">hsastore.com这个网站</a></li>\n<li><a href=\"https://hsastore.com/Condoms-C78.aspx\" target=\"_blank\" rel=\"noopener\">羞羞的橡胶制品</a></li>\n<li>去看医生的路上的交通，包括巴士，出租，火车或者飞机等</li>\n</ul>\n<p>这里最后一条的解释就很有意思了。IRS的指导是</p>\n<p>如果你的旅行相关的医疗开销对于治疗是必须的，那么这个旅行相关的开销就可以包含在HSA支付的范围。同时，IRS并没有指导医疗开销是不是必须在美国国内。那也就是，如果你觉得北京上海的医生对于你的病的治疗有更多帮助，那么飞到北京或者上海看病是属于合理的HSA可支付范围内。</p>\n<p>当然本文不可能也没必要穷尽所有IRS允许的HSA免税开销，如果有特别需要的话，google一下通常会有相当多人讨论。</p>\n<h3 id=\"HSA可以投资些什么？\"><a href=\"#HSA可以投资些什么？\" class=\"headerlink\" title=\"HSA可以投资些什么？\"></a>HSA可以投资些什么？</h3><p>HSA是一个银行帐户，而通常HSA帐户的提供商都会跟其它证券公司(broker)合作来提供购买投资产品的服务。</p>\n<p>举个例子，美元先生用的HSA帐户提供商是HSABank，而 HSABank与TD-Ameritrade合作提供投资产品。</p>\n<p>在TD-Ameritrade里，我可以选择购买个股，也可以选择购买其它股指基金，房地产基金等等，所以HSA的投资对象并不会受限定，基本是你想投啥都可以。</p>\n<p>但是同时也要注意，如果你在读这篇文章的话，大概率是刚刚开始接触投资，不建议投资个股。如果你不确定投资些什么，优先推荐<a href=\"https://usdweekly.com/how-to-invest-etf/\" target=\"_blank\" rel=\"noopener\">投资ETF基金</a>或共同基金。</p>\n<p>针对这点，我在<a href=\"https://usdweekly.com/should-i-invest-stock-market/\" target=\"_blank\" rel=\"noopener\">我应该投资股票吗一文中有更详细的解释</a>。</p>\n<p>如果你的投资产品里看到Vanguard或者Fidelity, Charles Schwab的股指基金，那恭喜你，这些基金都是品质保障。</p>\n<p>我在<a href=\"https://usdweekly.com/how-to-choose-vanguard-fund/\" target=\"_blank\" rel=\"noopener\">为什么投资这些基金和Vanguard基金如何挑选</a>的文章里详细解释了为什么优先考虑投资Vanguard基金，或者以上提到的几家股指基金/共同基金。</p>\n<h3 id=\"HSA可以给配偶用吗\"><a href=\"#HSA可以给配偶用吗\" class=\"headerlink\" title=\"HSA可以给配偶用吗\"></a>HSA可以给配偶用吗</h3><p>一句话，可以。同时如果你已经结婚的话，HSA的限额会增加，细节见上文“HSA限制”一章</p>\n<h3 id=\"HSA报销麻烦吗？HSA报销需要收据吗？\"><a href=\"#HSA报销麻烦吗？HSA报销需要收据吗？\" class=\"headerlink\" title=\"HSA报销麻烦吗？HSA报销需要收据吗？\"></a>HSA报销麻烦吗？HSA报销需要收据吗？</h3><p>首先HSA报销不麻烦；严格讲这个不叫报销，这个叫向IRS申请使用你的免税额。</p>\n<p>其次IRS不要求你在向你的HSA帐户里取钱时提供收据。需要收据的时候是，IRS抽查到你的时候，你能提供证明你取钱的时候取的部分是用于了医疗。当然了，最容易的证明方式就是把收据给IRS看了。</p>\n<p>这里提供一个不但可以非常方便保存收据，同时可以最大化你的HSA收益的方式，也就是我们的：</p>\n<h3 id=\"用HSA四步多挣50万\"><a href=\"#用HSA四步多挣50万\" class=\"headerlink\" title=\"用HSA四步多挣50万\"></a>用HSA四步多挣50万</h3><h4 id=\"步骤一：\"><a href=\"#步骤一：\" class=\"headerlink\" title=\"步骤一：\"></a>步骤一：</h4><p>在Dropbox/Google Photo或者任何照片同步软件里建一个folder，专门用来保存receipt</p>\n<h4 id=\"步骤二：\"><a href=\"#步骤二：\" class=\"headerlink\" title=\"步骤二：\"></a>步骤二：</h4><p>每次看完病，去看病的路上，把产生的收据照下来，原件不用存</p>\n<h4 id=\"步骤三：\"><a href=\"#步骤三：\" class=\"headerlink\" title=\"步骤三：\"></a>步骤三：</h4><p>不要报销，等到65岁或者过几年再一次性报销。如果你考虑要回国，回国前一次性报销</p>\n<p>步骤四：</p>\n<p>在HSA中选择指数基金或者共同基金，推荐Vanguard的低成本基金。把放到HSA帐户中的钱从脑子中抹去，让它定投和指数增益，不要管它</p>\n<p>步骤一和二非常好理解，不多说</p>\n<p>对于步骤三，逻辑是这样的，对于你所有在HSA里的钱，不要把它考虑为钱，应该把它考虑为equity。什么是equity？equity就是你睡觉时可以继续帮你挣钱的资产。</p>\n<p>在比较早的时间，比如A点取出，和在比较晚的B点取出5万美元，对于资产的增值是有天差地别的区别的。如果在A点取出5万美元，即使考虑了通货膨胀，这部分钱本来也可以增值至B点的5*1.07^10 = 9.8万美元。</p>\n<p>如果你在HSA里的钱全在指数基金或共同基金里，那么你的资产就是这些基金里含有的公司股票的股份，多放一年，平均来讲你HSA里的资产就会增加7%（通胀调整）或者10%（不含通胀调整）。那么要最大化你的收益，显然是让HSA里的资产增值越久越好。而IRS并没有规定医疗费用必须当年申报，因此你完全可以放心大胆把医疗费用的凭证放到一个地方，在你最终需要把钱拿出来时，再拿出来。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>HSA虽然听起来是个跟看病相关的事情，但是其实它是在Roth, 401(K)的基础上，可以极大帮助你省税和提高投资效率的工具。</p>\n<p>如果你之前从来没有听说过的话，也不要感觉自己很悲剧，因为即使美国人知道且在擅于利用HSA的也不多。2008年的数据是，只有8%的在职人员参与了HSA。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p><strong>本文纯属转载</strong></p>\n<p>第一天remote onboarding，benefit的人上来对保险一顿讲解，讲得我头晕眼花。回来仔细查查，才好了解自己到底要买哪个。虽然现在新冠疫情严重，我早已决定把保险拉满（冲</p>\n<h2 id=\"Medical-Insurance\"><a href=\"#Medical-Insurance\" class=\"headerlink\" title=\"Medical Insurance\"></a>Medical Insurance</h2><p>First of all there are some terms that you need to know, because these are the main differences of all the insurances.</p>\n<p><strong>此处部分原文来源<a href=\"https://tigerless.com/how-to-choose-us-health-insurance/\" target=\"_blank\" rel=\"noopener\">虎虎保险</a></strong></p>\n<ul>\n<li><p><strong>1 保险费(Premium)</strong></p>\n<p><strong>不要贪图便宜选保险费(Premium)低的</strong></p>\n<p>保险费 （Premium）。保险费是指你购买健保时，定期要支付给保险公司的费用，一般是每月支付。保险费与受保人年龄、健康状况等相关。一般受保人年龄越高，保险费越贵。一定要先了解公司的保险费（Premium）是多少， 一般每个保险公司都会给出不同(价位的保险选择来迎合不同的受保人需要。但保险费（Premium）不是越低越好？保险费越低意味着赔偿支付也越低，并且限制条件会比较多。</p>\n</li>\n<li><p><strong>2 Out-Of-Pocket</strong></p>\n<p>指自己看病后实际上需要交的钱</p>\n</li>\n<li><p><strong>2 最高限额（Maximum Payment）</strong></p>\n<p><strong>保险公司的 Maximum Payment 额高很重要</strong></p>\n<p>最高保险支付额(Maximum Payment) 是保险公司愿意为你买单的上限。不要天真的以为，看什么病，花多少钱，买了医疗保险，保险公司就都会为你买单。事实上，一般的美国医疗保险都会有一个支付额度的上限。如果你选的保险支付额越低，那么你自己生了大病，要掏腰包的钱就越多。 美国随便做个手术，几万美金小意思~</p>\n</li>\n<li><p><strong>3 自付额(Deductible)</strong></p>\n<p><strong>自付额低很重要</strong></p>\n<p>一般保险公司要求个人支付500美元到5000美元不等的自付款。也就是你一年要先自付一笔钱之后，保险公司才会开始付。总之就是当然是自付额越少越好。有些保险甚至没有自付额，但是每月的Premium就会变高，也就是每月固定支付的钱增加。</p>\n</li>\n<li><p><strong>4 挂号费(Copay)</strong></p>\n<p><strong>挂号费高低因人而异</strong></p>\n<p>定额手续费（copay）是指受保人每次看普通门诊或购买处方药时需当场支付的一笔固定费用。例如，每次看医生门诊个人需支付20美元，购买处方药时需支付15美元。具体的定额手续费金额，看保险合同。一般来说copay从20-50美元都有，也有0的。如果你是医院的“常客”，建议你选择copay低一点的美国医保，但是这样的医疗保险保险费可能相对较高。如果你身体很好，又年轻，不怎么进医院，可以选择保险费相对低的，copay高一点也就无所谓了。</p>\n</li>\n<li><p><strong>5 特殊限制(Special Limits)</strong></p>\n<p><strong>那么医保公司到底可以付多少？需要仔细阅读保险的条款，特别是你有一些疾病，需要长期治疗的。</strong></p>\n<p>对于一些特殊医疗服务，包括住院、手术、麻醉、心理治疗等，不少保险公司规定有一定的支付限额。有些规定一年只报一次Image, 一次体检，需要更多则要自己掏钱。</p>\n</li>\n<li><p><strong>6 排除支付条款(Exclusion)</strong></p>\n<p><strong>每一份保险都会有一个Exclusion list，购买之前一定要仔细阅读哪些医疗项目不在保险支付范围之内。</strong></p>\n<p>在美国看牙，是出了名的贵，牙科/眼科一般都是单门的医保项目。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>HMO(Health Maintenance Organization)</strong></p>\n<p>Cost less, but you have less choice of doctors, when you choose HMO, you have to name a specific doctor who manages all of your cares, often called primary care doctor. You must go to see this specific doctor before you see any other doctors when you are sick or need care. You will have to make a pre-defined payment, known as copay every time you see your primary doctor and any specialists she or he may send you to for care.</p>\n</li>\n<li><p><strong>PPO(Preferred Provider Organization)</strong></p>\n<p>Give you more freedom to choose from a larger pool of doctors, generally cost you more paychecks. You still need to see the doctors “in network” to get the most coverage from the plan. You still need to pay the copay each time you visit the specialist</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>HDHP(High Deductible Health Plan) or CDHP</strong></p>\n<p>Cost the least but have a higher deductible. A health Saving account- or HSA- can be attached to a HDHP to help cover the expenses</p>\n</li>\n</ul>\n<h2 id=\"Flexible-Spending-Account-FSA\"><a href=\"#Flexible-Spending-Account-FSA\" class=\"headerlink\" title=\"Flexible Spending Account (FSA)\"></a>Flexible Spending Account (FSA)</h2><p><strong>本文来源：<a href=\"https://usdweekly.com/what-is-fsa/\" target=\"_blank\" rel=\"noopener\">美元先生</a></strong></p>\n<h3 id=\"FSA是什么？\"><a href=\"#FSA是什么？\" class=\"headerlink\" title=\"FSA是什么？\"></a>FSA是什么？</h3><p>FSA的全称叫Flexible Saving Account，它的主要作用是国税局考虑到贫苦大众们面对生活的摩擦，在生病时总得给点安慰。于是，国税局在1978年开始，正式开始将FSA作为一个福利推出。</p>\n<p>FSA是一个用于给你自己报销医疗花销的储蓄帐户</p>\n<p>最简单的理解是，FSA就是一个银行帐户，在你的工资被扣税前，你可以选择存一部分到这个帐户中。</p>\n<p>存入的这个部分，国税局不会对你征税。</p>\n<p>举个例子，你一年收入是10万美元，而今年你决定把2000美元整放到FSA中，那么你的征税收入计算是98,000而非10万。</p>\n<h3 id=\"FSA报销怎么理解？\"><a href=\"#FSA报销怎么理解？\" class=\"headerlink\" title=\"FSA报销怎么理解？\"></a>FSA报销怎么理解？</h3><p>FSA的报销是指，你自己报销向自己报销花销。这个概念一开始很难理解，哪有人自己找自己报销的？我们用一个例子来说明</p>\n<p>还是继续上面的假设，你今年在FSA里放了2000美元，注意这2000美元IRS没跟你要过一分钱税，而是直接从你工资税前部分存入的。</p>\n<p>然后你很不幸地摔了，看病花了1000美元，这1000美元是你用你自己Chase卡付的。<em>注意，这里的1000美元花的是你税后的钱</em>（不管你用的是Chase信用卡还是借记卡都是你税后的钱）</p>\n<p>现在，你决定去跟自己的FSA报销。你FSA的余额还有2000美元，而你需要报销1000美元出来。你提交了医疗凭证（收据、医生处方），被批准后，FSA往你的银行存入1000美元。这整个过程结果是，你用1000美元税钱的钱看好了病，也即你向自己的FSA成功报销了一次。</p>\n<h3 id=\"怎么用FSA省钱？\"><a href=\"#怎么用FSA省钱？\" class=\"headerlink\" title=\"怎么用FSA省钱？\"></a>怎么用FSA省钱？</h3><p>FSA省钱的策略比HSA简单太多了。</p>\n<p>最基本的理解就是，存入FSA的钱不需要交税，而用这个帐户付钱的时候，只要是付<strong><em>医疗相关</em></strong>的费用（需要证明）就可以被允许（或俗称的，可报销）。</p>\n<p>假设你今年在FSA里存入了2000美元，这2000美元拿去打针吃药是完全没有问题的。最棒的是，FSA还可以报销一些你不太想得到的开销</p>\n<h3 id=\"FSA可以报销哪些开销\"><a href=\"#FSA可以报销哪些开销\" class=\"headerlink\" title=\"FSA可以报销哪些开销\"></a>FSA可以报销哪些开销</h3><p>再次夸一次IRS，或者说瞪一眼美国国税局——由于这个资本主义国家发展的年代已经非常久远，税收的体制已经非常健全，你能想到的漏洞它基本已经帮你想好且堵住了。</p>\n<p>比如说，一个自然的想法就是，FSA里的钱如果可以拿去支付任何开销的话，那不就等于现金了吗？</p>\n<p>非常遗憾的是，IRS不仅对花销的种类有限制，甚至逐条列出来了你可以报销的具体东西，比如</p>\n<ul>\n<li>处方药</li>\n<li>血糖测剂</li>\n<li>计生用品（我的天，这个词我打出来的时候都觉得中文真是博大精深）</li>\n<li>验孕棒（怎么样，IRS心思细不细）</li>\n<li>胰岛素</li>\n<li>绷带</li>\n<li>拐杖（怎么样，再一次，就问你细不细）</li>\n<li>针灸</li>\n<li>理疗</li>\n<li>心理医生费用</li>\n<li>戒烟项目费用</li>\n<li>牙医</li>\n<li><strong>Child care</strong></li>\n</ul>\n<p>写到这里我真的是不禁联想，国内规定的特点是爱用”相关物品“，比如说”医疗相关用品“，这就留下了很多解释的空间。而IRS则相反，把FSA可以报销的东西一件件列出来，如果感兴趣可以看<a href=\"https://www.irs.gov/pub/irs-pdf/p969.pdf#page=16\" target=\"_blank\" rel=\"noopener\">IRS的这个解释</a></p>\n<p>注意上面列表里最后一项，Child care被FSA认为是可以报销的项目。因此，如果你有小朋友需要child care，那么FSA可以用税前的钱来搞定。这也是为什么FSA可能对宝妈们特别有用。</p>\n<h3 id=\"为什么不选FSA\"><a href=\"#为什么不选FSA\" class=\"headerlink\" title=\"为什么不选FSA?\"></a>为什么不选FSA?</h3><p>大转折来了</p>\n<p>尽管有免税的好处，而且报销的范围比HSA广，FSA仍然不是一个非常好的金融工具。原因如下</p>\n<p><strong>原因一：FSA的保持期只有一年</strong></p>\n<p>如果你在一个税务年之前（通常是报税终止之前）FSA里的钱没有用完，那你的FSA帐户非常大的概率会被清空（不被清楚的情况太特殊不讨论）</p>\n<p><strong>原因二：FSA的钱不可以用于投资</strong></p>\n<p>接上条，既然FSA的钱每年会清空，那也就没什么复利增加的意义了。同时，FSA帐户不提供投资的途径，因此断了复利增长这条路。可惜的是，复利增长几乎所有金融工具能帮我们<a href=\"https://usdweekly.com/what-is-financial-independence/\" target=\"_blank\" rel=\"noopener\">实现财富独立</a>的基础</p>\n<p><strong>原因三：FSA只跟着雇主走，换工作清空</strong></p>\n<p>因此，如果你有的是FSA帐户，请确保在换工作前一定把里面的钱花完。可以考虑多看一次牙医，存一些药之类</p>\n<p>正是因为上面三个原因，FSA几乎不应该成为任何人的首选，除非你真的认为用税前的钱来支付Child care之类开销非常重要（HSA不能用于支付Child care）。但是理性来说，如果对比<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">HSA在30年内可以帮你多挣50万美元</a>的能力，FSA这点可怜的好处几乎不值一提</p>\n<h3 id=\"FSA这么没用，为什么它还卑微地存在呢？\"><a href=\"#FSA这么没用，为什么它还卑微地存在呢？\" class=\"headerlink\" title=\"FSA这么没用，为什么它还卑微地存在呢？\"></a>FSA这么没用，为什么它还卑微地存在呢？</h3><p>原因很简单，iPhone是不是一代比一代好？</p>\n<p>FSA/HSA这样的项目也类似，在收集前面的反馈的时候，后续项目会有一些相关的调整。</p>\n<p>考虑FSA和HSA推出的时间</p>\n<p>FSA是1978年咱改革开放那年出品，而HSA是2003年布什总统在位时出品的二代产品</p>\n<p>这样看起来，咱就把HSA当作iPhone X，把FSA当作iPhone 4吧 🤔</p>\n<p>从另一个角度，FSA也并不是一无事处。注意不是每个公司都有给员工提供HSA的福利，有的公司只有FSA，那也只能矮子里面挑高个了</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>FSA是个有趣的项目，有一些特点。</p>\n<p>比如它的报销范围比较广，可以报销牙医、Child care等项目。</p>\n<p>但它也有些致命的缺点，每年会被清空，且它是跟着雇主走的帐户，一换工作也要清空，因此它并不能有效地帮助我们实现财富独立。</p>\n<p>相比而言，如果你的公司提供HSA，那么你可以用HSA在30年内用复利增长多挣50万美元。具体步骤请读这篇文章：<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">如何用HSA投资且多挣50万美元</a></p>\n<p>本文参考：</p>\n<ul>\n<li><a href=\"https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/\" target=\"_blank\" rel=\"noopener\">https://www.healthcare.gov/have-job-based-coverage/flexible-spending-accounts/</a></li>\n<li><a href=\"https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/\" target=\"_blank\" rel=\"noopener\">https://www.nerdwallet.com/blog/health/what-is-flexible-spending-account/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Flexible_spending_account#History\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Flexible_spending_account#History</a></li>\n<li><a href=\"https://dpath.com/2019-fsa-contribution-limits/\" target=\"_blank\" rel=\"noopener\">https://dpath.com/2019-fsa-contribution-limits/</a></li>\n<li><a href=\"https://www.investopedia.com/insurance/hsa-vs-fsa/\" target=\"_blank\" rel=\"noopener\">https://www.investopedia.com/insurance/hsa-vs-fsa/</a></li>\n<li><a href=\"https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/\" target=\"_blank\" rel=\"noopener\">https://www.patriotsoftware.com/payroll/training/blog/fsa-vs-hsa-what-s-the-difference/</a></li>\n</ul>\n<h2 id=\"Dependent-Care-FSA\"><a href=\"#Dependent-Care-FSA\" class=\"headerlink\" title=\"Dependent Care FSA\"></a>Dependent Care FSA</h2><h3 id=\"1、如何使用-Dependent-Care-FSA报账\"><a href=\"#1、如何使用-Dependent-Care-FSA报账\" class=\"headerlink\" title=\"1、如何使用 Dependent Care FSA报账\"></a><strong>1、如何使用 Dependent Care FSA报账</strong></h3><p>首先要说明的一点是，<strong>FSA并不是国家统一管理的，也不是所有公司雇主都提供，提供FSA的雇主各自有自己的管理公司</strong>，你需要在规定的管理公司的网站上注册账号，这样就可以随时检查余额、提交申请了。另外，FSA是在大家每年的福利开放登记（benefit open enrollment）期间登记注册，而且一般每年都要重新登记，不会像医疗保险那样自动保留你上一年的选择。</p>\n<p>FSA登记注册好之后，你选择的缴纳金额按pay schedule进入账户，钱到账之后，你就可以在网上提交你的Daycare费用支付收据。这里要提醒大家注意的是，DCFSA和MFSA不一样，MFSA是你自1月1日起一整年的全部花费都可以获得补偿，而DFSA只有已到帐的余额才能用，而且补偿的必须是已经发生的服务。</p>\n<p>举个很简单的例子，如果你是在3月底交的4月份的学费，无法在3月底得到补偿，而是要等到4月结束后。因此，你的Daycare支付费用收据上最好除了社会保险号之外，还要有提供服务的日期（service period from xxx to xxxx）</p>\n<h3 id=\"2、DCFSA的好处和最高限额\"><a href=\"#2、DCFSA的好处和最高限额\" class=\"headerlink\" title=\"2、DCFSA的好处和最高限额\"></a><strong>2、DCFSA的好处和最高限额</strong></h3><p>FSA 享有很好的免税待遇，FSA的补偿金完全是税前的，不用交SSN、Medicare、Federal and State tax，但是这个免税优惠是有条件的，那就是你的花销得是花在符合资格的个体身上，而且不超过IRS规定的补偿限制。<strong>Dependent Care FSA目前的最高限额是每个家庭5000美元</strong>，夫妻双方任何一人使用都可以，也就是两个人加起来不能超过5000美元的最高限额。</p>\n<p>另外需要注意的是，这里所能享受到的免税额度和夫妻双方的收入是有关系的：如果夫妻双方的收入都多于5000美元，则5000美元都可以免税；如果有一方的收入少于5000美元，比如只有2000美元的话，那么无论你的贡献金额为多少，能免税的都只有那2000美元；如果有一方没有收入，那么你的FSA的贡献金额不管是多少都不能满足免税条件（夫妻中有一方或双方是全职学生或残障人士的情况除外）。</p>\n<h3 id=\"3、享受DCFSA的免税补偿需要满足的条件\"><a href=\"#3、享受DCFSA的免税补偿需要满足的条件\" class=\"headerlink\" title=\"3、享受DCFSA的免税补偿需要满足的条件\"></a><strong>3、享受DCFSA的免税补偿需要满足的条件</strong></h3><p>那么什么才算是有资格的个体呢？除了开头讲到的无生活自理能力的被抚养者之外，对于大多数的妈妈们来说，符合这个资格的就是年龄不超过13岁的孩子（孩子满13岁的这一年要按实际接受的服务来计算价钱）。也就是说，<strong>DCFSA只有在夫妻为双职工或正在找工作（或夫妻一方为全日制学生），且孩子在13岁之下才能获得补偿。</strong>如果夫妻中有一方为全职妈妈或全职爸爸，收入为0，就无法享受这项免税优惠。</p>\n<p>P.S.判定自身或配偶属于全职学生的要求为：必须满足至少五个月的在学校全职上学的条件，这里所指的学校不包括在职培训课程、函授学校或只通过互联网授课的学校。</p>\n<p><strong>与照顾孩子相关的这些费用可以享受DCFSA的免税补偿：</strong></p>\n<p>①Fees for licensed day care（持有牌照经营的Daycare费用。）</p>\n<p>②Amounts paid for services (including babysitters or nursery school) – provided in or outside of your home – for the care of a qualified dependent necessary to allow you and your spouse to work, look for work, or attend school full-time.（付给照顾孩子的保姆或nursery school所产生的费用。）</p>\n<p>③Summer day camp for children under age 13 qualifies if attendance allows you and your spouse to work, look for work, or for your spouse to attend school full-time.（13岁以下孩子参加夏令营所产生的费用。）</p>\n<p>④Before and after school care programs for dependents under age 13.（在上学前、上学后提供照看13岁以下孩子服务所产生的费用。）</p>\n<p>⑤Payment to a relative (age 19 or older who is not your dependent) who cares for your qualified dependent.（请19岁以上的亲戚来照看孩子所产生的费用，这个亲戚不能是你的被抚养者。）</p>\n<p>⑥Payment to a housekeeper whose duties also include dependent day care.（请同样承担照看孩子工作的家庭管家所产生的费用。）</p>\n<p>请参考<a href=\"http://www.irs.com所给出的官方说明：\">www.irs.com所给出的官方说明：</a><br><a href=\"https://www.irs.gov/pub/irs-pdf/i2441.pdf\" target=\"_blank\" rel=\"noopener\">https://www.irs.gov/pub/irs-pdf/i2441.pdf</a><br><a href=\"https://www.irs.gov/pub/irs-pdf/p503.pdf\" target=\"_blank\" rel=\"noopener\">https://www.irs.gov/pub/irs-pdf/p503.pdf</a></p>\n<h2 id=\"HSA\"><a href=\"#HSA\" class=\"headerlink\" title=\"HSA\"></a>HSA</h2><p><strong>本文来源：<a href=\"https://usdweekly.com/hsa-save-investment-tax-saving-guide/\" target=\"_blank\" rel=\"noopener\">美元先生</a></strong></p>\n<h3 id=\"到底什么是HSA帐户\"><a href=\"#到底什么是HSA帐户\" class=\"headerlink\" title=\"到底什么是HSA帐户?\"></a>到底什么是HSA帐户?</h3><p>要了解怎么样用HSA省税挣钱，需要先大致对美国税法有一个基本了解：在美国，IRS可能是比FBI更难惹的一个部门</p>\n<p>一来后者关乎犯罪，我等良民不太容易惹得到，而前者则跟每个在美国生活、投资的人息息相关。而美国税制最神奇的一个地方是，你不光需要遵守税法，且你需要对自己不懂税法负责——不情的情况下报税错误？不好意思，也要罚款坐牢</p>\n<p>HSA的全称是Health Savings Account，以下我将会简称其为HSA。顾名思义，这个帐户应该是跟医保储蓄之类的事情相关的。但这个帐户跟你大摇大摆走进一家银行，跟柜员开户的银行帐户完全是两个概念。</p>\n<p>首先，HSA不是一个具体的“银行帐户”概念。相反，它是一种减轻减轻特定人群税务负担的行政手段。</p>\n<p>你可以把HSA理解为，政府为了帮助有医疗需求的人（也即几乎所有在美国生活的人）减轻税务负担而单独开设的减税计划。</p>\n<p>用白话说，就是政府看到有些居民生活困难，而如果碰到医疗开销的话更将会雪上加霜。那么政府决定，由IRS出面，给这些人士一个特殊的“帐户”，这些帐户的唯一作用是，如果往这个帐户里存钱，那么政府将认为这些钱会最终用于你或家人的医疗开销，<strong>而这部分存入的钱是不收税的</strong>。</p>\n<p>举个例子，张二狗同学年收入十万美元，他把7000块存入HSA帐户内。那么他被征税的部分就是93,000美元，存入的7000美元部分免税。</p>\n<h3 id=\"HSA的限制\"><a href=\"#HSA的限制\" class=\"headerlink\" title=\"HSA的限制\"></a>HSA的限制</h3><p>上面的例子听起来很刺激对不对?</p>\n<p>假设你是一位程序写得飞起的Google工程师，每年收25万美元整，那么你可以把25万美元全部存到HSA帐户里喜滋滋把税免了？</p>\n<p>当然不行，IRS这么容易让你钻空子就不是IRS了:)</p>\n<p>通常来说，使用HSA有这么几个限制</p>\n<ol>\n<li>HSA有每年的存入限额</li>\n<li>你，你的公司和IRS三方需要介入整个过程</li>\n<li>多数HSA需要你用的医保是High-deductible的</li>\n</ol>\n<p>我们一条一条来分析</p>\n<p>限制1，HSA有每年的存入限额</p>\n<p>虽然有限额，但是这个限额从历史上来看，是每年严格递增的，也就是说随着时间增加每年你能通过HSA避的税会逐年增加。同时注意HSA的限制对于个人和家庭来说是不一样的，而如果你超过55岁，还可以享受一个“落后生”优惠：每年可以比其它人多存一部分。</p>\n<p>具体年每年IRS允许往HSA帐户里存入的限额如下表（摘自<a href=\"https://en.wikipedia.org/wiki/Health_savings_account\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<p><strong>HSA存入限额（按年）</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">年份</th>\n<th align=\"left\">单身HSA限额</th>\n<th align=\"left\">家庭HSA限额</th>\n<th align=\"left\">55岁以上可补交</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2010<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-26\" target=\"_blank\" rel=\"noopener\">[26]</a></td>\n<td align=\"left\">$3,050</td>\n<td align=\"left\">$6,150</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2011<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-27\" target=\"_blank\" rel=\"noopener\">[27]</a></td>\n<td align=\"left\">$3,050</td>\n<td align=\"left\">$6,150</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2012<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-28\" target=\"_blank\" rel=\"noopener\">[28]</a></td>\n<td align=\"left\">$3,100</td>\n<td align=\"left\">$6,250</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2013<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-29\" target=\"_blank\" rel=\"noopener\">[29]</a></td>\n<td align=\"left\">$3,250</td>\n<td align=\"left\">$6,450</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2014<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-30\" target=\"_blank\" rel=\"noopener\">[30]</a></td>\n<td align=\"left\">$3,300</td>\n<td align=\"left\">$6,550</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2015<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-31\" target=\"_blank\" rel=\"noopener\">[31]</a></td>\n<td align=\"left\">$3,350</td>\n<td align=\"left\">$6,650</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2016<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-32\" target=\"_blank\" rel=\"noopener\">[32]</a></td>\n<td align=\"left\">$3,350</td>\n<td align=\"left\">$6,750</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2017<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-33\" target=\"_blank\" rel=\"noopener\">[33]</a></td>\n<td align=\"left\">$3,400</td>\n<td align=\"left\">$6,750</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2018<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-34\" target=\"_blank\" rel=\"noopener\">[34]</a></td>\n<td align=\"left\">$3,450</td>\n<td align=\"left\">$6,900</td>\n<td align=\"left\">$1,000</td>\n</tr>\n<tr>\n<td align=\"left\">2019<a href=\"https://en.wikipedia.org/wiki/Health_savings_account#cite_note-35\" target=\"_blank\" rel=\"noopener\">[35]</a></td>\n<td align=\"left\">$3,500</td>\n<td align=\"left\">$7,000</td>\n<td align=\"left\">$1,000</td>\n</tr>\n</tbody></table>\n<p>限制2，你，你的公司和IRS三方需要介入整个过程</p>\n<p>如上文所说，你不能走进一家银行要求”开一个HSA“帐户。到目前为止，你如果需要往HSA帐户里存钱的话，只能通过你的雇主。对于你是自己在创业的同学，你有可能可以搞一个self-employed HSA（相对少见这里不展开讨论了）。而对于IRS在这里的作用则更多是监督你把省的税和投资收益用来买药，而不会把HSA的税务优惠用来买兰博基尼 🙂</p>\n<p>限制3，多数HSA需要你用的医保是High-deductible</p>\n<p>这一条要求搞糊涂了不少人。其实简单点讲，high-deductible plan就是每次去医院的时候需要自己掏腰包的部分稍多一点。但是只要你不是天天去医院，对99%的50岁以下年轻人来说，high-deductible完全够用。同时，比起多出来那一点co-pay和多掏的腰包，HSA能给你带来的收益大得多得多（下文会有具体的计算）</p>\n<h3 id=\"如何理解HSA\"><a href=\"#如何理解HSA\" class=\"headerlink\" title=\"如何理解HSA\"></a>如何理解HSA</h3><p>很多人在理解HSA的时候，包括我自己最初在试图搞清楚它的时候，都被各种概念搞晕。其实要理解HSA，只要脑中简单地有一个概念即可：HSA是一个杯子（容器）</p>\n<p>而你往HSA里放钱的时候，是在把这个杯子换为更大号的杯子。比如说，前三年你往HSA里存入了2万美元，那么你的HSA就是一个容积为2升的杯子。</p>\n<p>而这个杯子的用途就多了，你可以把杯子当作装饰，放在桌上不管它（对应HSA里的钱当作现金）；也可以把杯子里装满茶（对应HSA帐号里的钱用来购买国债）；也可以把杯子里装满咖啡（对应HSA帐号里的钱用来购买mutual fund或者<a href=\"https://usdweekly.com/how-to-invest-etf/\" target=\"_blank\" rel=\"noopener\">购买ETF基金</a>）</p>\n<p>总之，这个杯子里装茶还是咖啡，甚至是一半茶一半咖啡，都是可以的。</p>\n<h3 id=\"如何用HSA帐户进行投资\"><a href=\"#如何用HSA帐户进行投资\" class=\"headerlink\" title=\"如何用HSA帐户进行投资\"></a>如何用HSA帐户进行投资</h3><p>这一节的副标题应该叫：如何用HSA多挣50万美元😍</p>\n<p>到这里为止，你应该大致了解了政府设立HSA的动机是什么，以及HSA的一些限制。那么这一章我就详细讲解一下如何用HSA来帮你多挣50万。</p>\n<p>首先我们做一些简单的假设：</p>\n<ol>\n<li>你每年将会在HSA里放满允许存入的金额。比如2019年你将会放满7000美金</li>\n<li>你还会工作30年直到你退休</li>\n<li>在退休前你不会碰HSA里的钱（千万不要拿出来）</li>\n</ol>\n<p><strong>对于绝大多数HSA帐户，如果你存入超过1000美金，这个帐户就可以用于购买股票、债券或者指数基金。</strong></p>\n<p>而绝大多数HSA提供商（比如我的是HSAbank）都会允许你购买股票、基金或者共同基金</p>\n<p>HSABank的功能界面 – 提供了investments的选项</p>\n<p>那么如何用HSA帐户多挣美元的问题，就转化成了，年定投7000美金30年复利增长可以收益多少的问题。同样，我们用标普500的历史数据来做这个基本分析。我们的基本参数如下：</p>\n<p>年存入: $7000 (2019年家庭限额）</p>\n<p>年限: 30年</p>\n<p>预计年收益：10% (标普500 80年平均）</p>\n<p>复利频率：1年</p>\n<p>用于计算复利的参数</p>\n<p>那么到2048年，我们的总余额将达到126万美元，其中本金仅为21万左右</p>\n<p>当然你可能会说，考虑通货膨胀的话，到2048年这些钱可能就是30年前的万元户手里的一万美元了。其实不然，即使调整了通胀的收益，收益也会是非常可观的数字。本金同样为21万，收益则为50万美元。</p>\n<h3 id=\"HSA如何帮你省税\"><a href=\"#HSA如何帮你省税\" class=\"headerlink\" title=\"HSA如何帮你省税\"></a>HSA如何帮你省税</h3><p>如同乔帮主常说的，just one more thing…</p>\n<p>HSA的超强吸引力，不光在于它可以让你免税开始存钱，更可怕的是，它的收益也可以做到部分免税（医疗报销），而这是401(K)，Traditional IRA, Roth IRA等任何储蓄计划都做不到的。</p>\n<p>具体来说</p>\n<ol>\n<li>你的工资、收入在存入HSA时，是不收税的</li>\n<li>你存入HSA的钱，在收益增值的过程中，是不收税的</li>\n<li>如果你生病了，需要在中途把一部分钱拿出来（不建议，下文讨论如何看病省钱两不误的操作），你可以把钱拿出来且不用交任何税</li>\n<li>如果你到了65岁，你可以把所有的钱一次性拿出来，仅按收入税交税</li>\n</ol>\n<p>举个具体例子，张二狗同学25岁从弟伦比亚大学毕业，到湾区成为了一位光荣的年薪20万美元的初级软件工程师。</p>\n<p>读完这篇文章后张二狗同学决定每年把7000美元拿出来放到HSA中，首先20万美元中的7000美元被划分开，IRS决定对这7000美元免税。即，张二狗同学可能被扣税的收入减少为19万3千美元。</p>\n<p>张二狗同学把HSA中所有的美元全部购买了指数基金。</p>\n<p>到45岁时，张二狗同学的颈椎病发作，但他手里还有一些多余的现金，因此他只把看病时的收据拍照留下了，而在HSA帐户里的基金继续增值。</p>\n<p>到55岁时，张二狗同学决定跟翠花辞职退休，环游世界。30年过去，这时他的HSA帐户中已经有了126万美元，而这30年他仅仅往帐户里存入过21万美元。他需要一些钱来支付环游世界的费用。于是他找出来之前看病时的收据，于55岁这年从HSA帐户里拿出6万美金用于环游世界。</p>\n<p>终于到了65岁，张二狗同学决定把HSA里的钱全拿出来。而此时HSA帐户中已经有了300万美元！这就是复利的力量。这时候二狗同学的身体已经不太好了，累积了50万美元的医疗开销。而张二狗同学在把这300万美元拿出来的过程中，50万美元的部分不必交税，仅余下的250万需要交收入税。</p>\n<p>这就是HSA最大的威力：收入免税+复利增长+部分收益免税</p>\n<h3 id=\"有关HSA的常见问题\"><a href=\"#有关HSA的常见问题\" class=\"headerlink\" title=\"有关HSA的常见问题\"></a>有关HSA的常见问题</h3><p>这里解答一些关于HSA的常见问题</p>\n<h3 id=\"回国了HSA怎么办\"><a href=\"#回国了HSA怎么办\" class=\"headerlink\" title=\"回国了HSA怎么办?\"></a>回国了HSA怎么办?</h3><p>如果你已经决定了在65岁前回国，那么你有两个选择</p>\n<p>选择1，提前把钱退出来（不推荐）</p>\n<p>虽然你可以提前把HSA里的钱拿出来，但是如果不是手头真的紧的话，并不建议。原因是你在把钱放入HSA时，没有交税。那么如果你要提前拿出来，不但你要把拿出来的部分的税补交上，且要加上<a href=\"https://hsastore.com/\" target=\"_blank\" rel=\"noopener\">20%的惩罚</a>。</p>\n<p>举个例子，张二狗同学拿到了假格基金的投资，毅然决然决定2020年启程回国担任CEO走上人生巅峰，而他之前在HSA里的本金和收益总共收益10万美元。在2020年这年，他决定把HSA里的钱全拿出来，那么他的10万美元将需要算作2020年的收入被税，同时需要支付2万美元的罚款。假设张二狗2020年已经辞职且没有其它收入，那么他需要支付的联邦税为29,204 + 20000 = 49,204美元，可以说是非常不划算了。</p>\n<p>当然如果你不着急，有两个办法把税降到最低（但20%的罚款无法避免）</p>\n<p>第一个办法是，尽量降低每年从HSA里拿出来的金额，这样可以让你当年的收入变少，因此可以被税比例降低甚至是免税。</p>\n<p>第二个办法是，尽量在回国之后（这样在美国就不再有收入）再慢慢把钱拿出来，这样你在美国的收入仅有HSA拿出来的部分，你可以选择一年只拿最低征收额以下，比如2019年如果你只拿9,324出来，一分钱税都不用交。</p>\n<p>选择2，把钱放在HSA内增值（推荐）</p>\n<p>如果手里不紧，这是我一贯的主张。在国内几乎没有任何资产配置可以跟美元+美国金融市场匹敌，不着急用钱的话没有任何理由把HSA里大量税收优惠的钱带回国。且实际操作来讲，如果你需要看病的时候，即使是在国内，也可以把看病的花销都记录下来，收据留好，每年报销一次。剩余的部分则在HSA帐户内增值。</p>\n<h3 id=\"如果换了公司HSA帐户怎么办\"><a href=\"#如果换了公司HSA帐户怎么办\" class=\"headerlink\" title=\"如果换了公司HSA帐户怎么办?\"></a>如果换了公司HSA帐户怎么办?</h3><p>这个相对容易，HSA虽然是需要公司参与，但是受益人和操作人是你且只是你。因此如果换了公司，最多是跟给你提供HSA的银行打个电话，告诉他们你换公司了。通常来说你所在公司的HR也会协助你迁移。当然更好的办法是把HSA完全独立出来，所有信息都跟公司分离开来，我就是这么干的。这样即使换了公司，只是换了个每个月向HSA里存钱的帐户而已，相当方便。</p>\n<h3 id=\"HSA可以买什么？\"><a href=\"#HSA可以买什么？\" class=\"headerlink\" title=\"HSA可以买什么？\"></a>HSA可以买什么？</h3><p>理论上HSA里的钱你可以买任何你想买的东西，只是有些东西不免税以及有惩罚而已。</p>\n<p>所以这个问题的问题应该是，HSA帐户可以用于免税购买什么东西？</p>\n<p>根据<a href=\"https://www.irs.gov/publications/p502\" target=\"_blank\" rel=\"noopener\">IRS的指导</a>，你可以用于购买以下东西</p>\n<ul>\n<li>看医生的co-pay</li>\n<li>IRS批准的医药中保险不报销的部分（i.e. out of pocket)</li>\n<li>一些医用的产品，比如baby monitor，温度计之类；比较完整的列表见<a href=\"https://hsastore.com/HSA-Eligibility-List.aspx\" target=\"_blank\" rel=\"noopener\">hsastore.com这个网站</a></li>\n<li><a href=\"https://hsastore.com/Condoms-C78.aspx\" target=\"_blank\" rel=\"noopener\">羞羞的橡胶制品</a></li>\n<li>去看医生的路上的交通，包括巴士，出租，火车或者飞机等</li>\n</ul>\n<p>这里最后一条的解释就很有意思了。IRS的指导是</p>\n<p>如果你的旅行相关的医疗开销对于治疗是必须的，那么这个旅行相关的开销就可以包含在HSA支付的范围。同时，IRS并没有指导医疗开销是不是必须在美国国内。那也就是，如果你觉得北京上海的医生对于你的病的治疗有更多帮助，那么飞到北京或者上海看病是属于合理的HSA可支付范围内。</p>\n<p>当然本文不可能也没必要穷尽所有IRS允许的HSA免税开销，如果有特别需要的话，google一下通常会有相当多人讨论。</p>\n<h3 id=\"HSA可以投资些什么？\"><a href=\"#HSA可以投资些什么？\" class=\"headerlink\" title=\"HSA可以投资些什么？\"></a>HSA可以投资些什么？</h3><p>HSA是一个银行帐户，而通常HSA帐户的提供商都会跟其它证券公司(broker)合作来提供购买投资产品的服务。</p>\n<p>举个例子，美元先生用的HSA帐户提供商是HSABank，而 HSABank与TD-Ameritrade合作提供投资产品。</p>\n<p>在TD-Ameritrade里，我可以选择购买个股，也可以选择购买其它股指基金，房地产基金等等，所以HSA的投资对象并不会受限定，基本是你想投啥都可以。</p>\n<p>但是同时也要注意，如果你在读这篇文章的话，大概率是刚刚开始接触投资，不建议投资个股。如果你不确定投资些什么，优先推荐<a href=\"https://usdweekly.com/how-to-invest-etf/\" target=\"_blank\" rel=\"noopener\">投资ETF基金</a>或共同基金。</p>\n<p>针对这点，我在<a href=\"https://usdweekly.com/should-i-invest-stock-market/\" target=\"_blank\" rel=\"noopener\">我应该投资股票吗一文中有更详细的解释</a>。</p>\n<p>如果你的投资产品里看到Vanguard或者Fidelity, Charles Schwab的股指基金，那恭喜你，这些基金都是品质保障。</p>\n<p>我在<a href=\"https://usdweekly.com/how-to-choose-vanguard-fund/\" target=\"_blank\" rel=\"noopener\">为什么投资这些基金和Vanguard基金如何挑选</a>的文章里详细解释了为什么优先考虑投资Vanguard基金，或者以上提到的几家股指基金/共同基金。</p>\n<h3 id=\"HSA可以给配偶用吗\"><a href=\"#HSA可以给配偶用吗\" class=\"headerlink\" title=\"HSA可以给配偶用吗\"></a>HSA可以给配偶用吗</h3><p>一句话，可以。同时如果你已经结婚的话，HSA的限额会增加，细节见上文“HSA限制”一章</p>\n<h3 id=\"HSA报销麻烦吗？HSA报销需要收据吗？\"><a href=\"#HSA报销麻烦吗？HSA报销需要收据吗？\" class=\"headerlink\" title=\"HSA报销麻烦吗？HSA报销需要收据吗？\"></a>HSA报销麻烦吗？HSA报销需要收据吗？</h3><p>首先HSA报销不麻烦；严格讲这个不叫报销，这个叫向IRS申请使用你的免税额。</p>\n<p>其次IRS不要求你在向你的HSA帐户里取钱时提供收据。需要收据的时候是，IRS抽查到你的时候，你能提供证明你取钱的时候取的部分是用于了医疗。当然了，最容易的证明方式就是把收据给IRS看了。</p>\n<p>这里提供一个不但可以非常方便保存收据，同时可以最大化你的HSA收益的方式，也就是我们的：</p>\n<h3 id=\"用HSA四步多挣50万\"><a href=\"#用HSA四步多挣50万\" class=\"headerlink\" title=\"用HSA四步多挣50万\"></a>用HSA四步多挣50万</h3><h4 id=\"步骤一：\"><a href=\"#步骤一：\" class=\"headerlink\" title=\"步骤一：\"></a>步骤一：</h4><p>在Dropbox/Google Photo或者任何照片同步软件里建一个folder，专门用来保存receipt</p>\n<h4 id=\"步骤二：\"><a href=\"#步骤二：\" class=\"headerlink\" title=\"步骤二：\"></a>步骤二：</h4><p>每次看完病，去看病的路上，把产生的收据照下来，原件不用存</p>\n<h4 id=\"步骤三：\"><a href=\"#步骤三：\" class=\"headerlink\" title=\"步骤三：\"></a>步骤三：</h4><p>不要报销，等到65岁或者过几年再一次性报销。如果你考虑要回国，回国前一次性报销</p>\n<p>步骤四：</p>\n<p>在HSA中选择指数基金或者共同基金，推荐Vanguard的低成本基金。把放到HSA帐户中的钱从脑子中抹去，让它定投和指数增益，不要管它</p>\n<p>步骤一和二非常好理解，不多说</p>\n<p>对于步骤三，逻辑是这样的，对于你所有在HSA里的钱，不要把它考虑为钱，应该把它考虑为equity。什么是equity？equity就是你睡觉时可以继续帮你挣钱的资产。</p>\n<p>在比较早的时间，比如A点取出，和在比较晚的B点取出5万美元，对于资产的增值是有天差地别的区别的。如果在A点取出5万美元，即使考虑了通货膨胀，这部分钱本来也可以增值至B点的5*1.07^10 = 9.8万美元。</p>\n<p>如果你在HSA里的钱全在指数基金或共同基金里，那么你的资产就是这些基金里含有的公司股票的股份，多放一年，平均来讲你HSA里的资产就会增加7%（通胀调整）或者10%（不含通胀调整）。那么要最大化你的收益，显然是让HSA里的资产增值越久越好。而IRS并没有规定医疗费用必须当年申报，因此你完全可以放心大胆把医疗费用的凭证放到一个地方，在你最终需要把钱拿出来时，再拿出来。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>HSA虽然听起来是个跟看病相关的事情，但是其实它是在Roth, 401(K)的基础上，可以极大帮助你省税和提高投资效率的工具。</p>\n<p>如果你之前从来没有听说过的话，也不要感觉自己很悲剧，因为即使美国人知道且在擅于利用HSA的也不多。2008年的数据是，只有8%的在职人员参与了HSA。</p>\n"},{"layout":"post","title":"Make教程","date":"2020-03-18T19:00:00.000Z","description":"知其然也知其所以然，不光会用还要知道它是怎么写的","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321004610.png","optimized_image":null,"author":"tty","_content":"\n## Make，Makefile是什么\n\n在开发一个系统时，一般是将一个系统分成几个模块，这样做提高了系统的可维护性，但由于各个模块间不可避免存在关联，所以当一个模块改动后，其他模块也许会有所更新。\n\n对小系统来说，手工编译连接是没问题，但是如果是一个大系统，存在很多个模块，那么手工编译的方法就不适用了。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件，与手工编译和连接相比，make命令的优点在于他只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文件则置之不理，并且make命令不会漏掉一个需要更新的文件。\n\n文件和文件间或模块或模块间有可能存在倚赖关系，make命令也是依据这种依赖关系来进行维护的，所以我们有必要了解什么是依赖关系；make命令当然不会自己知道这些依赖关系，而需要程序员将这些依赖关系写入一个叫makefile的文件中。Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。\n\n即make和makefile的关系是：make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。\n\nMakefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。\n\n对于很大的项目来说，自己手写Makefile非常麻烦，而标准的GNU软件（如Apacle）都是运行一个configure脚本文件来产生Makefile；GNU软件automake和autoconf就是自动生成configure的工具。开发人员只需要先定义好宏，automake处理后会产生供autoconf使用的Makefine.in，再用autoconf就可以产生configure。\n————————————————\n版权声明：本文为CSDN博主「Jane_小妍」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/yg_2012/article/details/38925161\n\n## 如何写Makefile\n\n以下内容来自于**[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/02/make.html)**\n\n构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。\n\n### 概述\n\nMakefile文件由一系列规则（rules）构成。每条规则的形式如下。\n\n```bash\n<target> : <prerequisites>\n[tab]  <commands>\n```\n\n上面第一行冒号前面的部分，叫做\"目标\"（target），冒号后面的部分叫做\"前置条件\"（prerequisites）；第二行必须由一个tab键起首，后面跟着\"命令\"（commands）。\n\n\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。\n\n每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。\n\n### 目标（target）\n\n一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。\n\n除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。\n\n```bash\nclean:\n      rm *.o\n```\n\n上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于\"伪目标 \"，作用是删除对象文件。\n\n```bash\n$ make  clean\n```\n\n但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n```bash\n.PHONY: clean\nclean:\n        rm *.o temp\n```\n\n声明clean是\"伪目标\"之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看[手册](http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets)。\n\n如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。\n\n```bash\n$ make\n```\n\n上面代码执行Makefile文件的第一个目标。\n\n### 前置条件（prerequisites）\n\n前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。\n\n```bash\nresult.txt: source.txt\n    cp source.txt result.txt\n```\n\n上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么`make result.txt`可以正常运行，否则必须再写一条规则，来生成 source.txt 。\n\n```bash\nsource.txt:\n    echo \"this is the source\" > source.txt\n```\n\n上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用`make source.txt`，它都会生成。\n\n```bash\n$ make result.txt\n$ make result.txt\n```\n\n上面命令连续执行两次`make result.txt`。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。\n\n如果需要生成多个文件，往往采用下面的写法。\n\n```bash\nsource: file1 file2 file3\n```\n\n上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。\n\n```bash\n$ make source\n```\n\n执行`make source`命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。\n\n```bash\n$ make file1\n$ make file2\n$ make file3\n```\n\n### 命令（commands）\n\n命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。\n\n每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。\n\n```bash\n.RECIPEPREFIX = >\nall:\n> echo Hello, world\n```\n\n上面代码用.RECIPEPREFIX指定，大于号（>）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。\n\n需要注意的是，**每行命令在一个单独的shell中执行。这些Shell之间没有继承关系**。\n\n```bash\nvar-lost:\n    export foo=bar\n    echo \"foo=[$$foo]\"\n```\n\n上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。\n\n```bash\nvar-kept:\n    export foo=bar; echo \"foo=[$$foo]\"\n```\n\n另一个解决办法是在换行符前加反斜杠转义。\n\n```bash\nvar-kept:\n    export foo=bar; \\\n    echo \"foo=[$$foo]\"\n```\n\n最后一个方法是加上`.ONESHELL:`命令。\n\n```bash\n.ONESHELL:\nvar-kept:\n    export foo=bar;\n    echo \"foo=[$$foo]\"\n```\n\n## Makefile文件的语法\n\n### 注释\n\n井号（#）在Makefile中表示注释。\n\n```bash\n# 这是注释\nresult.txt: source.txt\n    # 这是注释\n    cp source.txt result.txt # 这也是注释\n```\n\n### 回声（echoing）\n\n正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n```bash\ntest:\n    # 这是测试\n```\n\n执行上面的规则，会得到下面的结果。\n\n```bash\n$ make test\n# 这是测试\n```\n\n在命令的前面加上@，就可以关闭回声。\n\n```bash\ntest:\n    @# 这是测试\n```\n\n现在再执行`make test`，就不会有任何输出。\n\n由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。\n\n```bash\ntest:\n    @# 这是测试\n    @echo TODO\n```\n\n### 通配符\n\n通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为o的文件。\n\n```bash\nclean:\n        rm -f *.o\n```\n\n### 模式匹配\n\nMake命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。\n\n```bash\n%.o: %.c\n```\n\n等同于下面的写法。\n\n```bash\nf1.o: f1.c\nf2.o: f2.c\n```\n\n使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。\n\n### 变量和赋值符\n\nMakefile 允许使用等号自定义变量。\n\n```bash\ntxt = Hello World\ntest:\n    @echo $(txt)\n```\n\n上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。\n\n调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。\n\n```bash\ntest:\n    @echo $$HOME\n```\n\n有时，变量的值可能指向另一个变量。\n\n```bash\nv1 = $(v2)\n```\n\n上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。\n\n为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看[StackOverflow](http://stackoverflow.com/questions/448910/makefile-variable-assignment)。\n\n```bash\nVARIABLE = value\n# 在执行时扩展，允许递归扩展。\n\nVARIABLE := value\n# 在定义时扩展。\n\nVARIABLE ?= value\n# 只有在该变量为空时才设置值。\n\nVARIABLE += value\n# 将值追加到变量的尾端。\n```\n\n### 内置变量（Implicit Variables）\n\nMake命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见[手册](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)。\n\n```bash\noutput:\n    $(CC) -o output input.c\n```\n\n### 自动变量（Automatic Variables）\n\nMake命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。\n\n**（1）$@**\n\n$@指代当前目标，就是Make命令当前构建的那个目标。比如，`make foo`的 $@ 就指代foo。\n\n```bash\na.txt b.txt:\n    touch $@\n```\n\n等同于下面的写法。\n\n```bash\na.txt:\n    touch a.txt\nb.txt:\n    touch b.txt\n```\n\n**（2）$<**\n\n$< 指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1。\n\n```bash\na.txt: b.txt c.txt\n    cp $< $@\n```\n\n等同于下面的写法。\n\n```bash\na.txt: b.txt c.txt\n    cp b.txt a.txt\n```\n\n**（3）$?**\n\n$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。\n\n**（4）$^**\n\n$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。\n\n**（5）$\\***\n\n$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。\n\n**（6）$(@D) 和 $(@F)**\n\n$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。\n\n**（7）$(\n\n$(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n所有的自动变量清单，请看[手册](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)。下面是自动变量的一个例子。\n\n```bash\ndest/%.txt: src/%.txt\n    @[ -d dest ] || mkdir dest\n    cp $< $@\n```\n\n上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$< 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。\n\n### 判断和循环\n\nMakefile使用 Bash 语法，完成判断和循环。\n\n```bash\nifeq ($(CC),gcc)\n  libs=$(libs_for_gcc)\nelse\n  libs=$(normal_libs)\nendif\n```\n\n上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。\n\n```bash\nLIST = one two three\nall:\n    for i in $(LIST); do \\\n        echo $$i; \\\n    done\n\n# 等同于\n\nall:\n    for i in one two three; do \\\n        echo $i; \\\n    done\n```\n\n上面代码的运行结果。\n\n```bash\none\ntwo\nthree\n```\n\n### 函数\n\nMakefile 还可以使用函数，格式如下。\n\n```bash\n$(function arguments)\n# 或者\n${function arguments}\n```\n\nMakefile提供了许多[内置函数](http://www.gnu.org/software/make/manual/html_node/Functions.html)，可供调用。下面是几个常用的内置函数。\n\n**（1）shell 函数**\n\nshell 函数用来执行 shell 命令\n\n```bash\nsrcfiles := $(shell echo src/{00..99}.txt)\n```\n\n**（2）wildcard 函数**\n\nwildcard 函数用来在 Makefile 中，替换 Bash 的通配符。\n\n```bash\nsrcfiles := $(wildcard src/*.txt)\n```\n\n**（3）subst 函数**\n\nsubst 函数用来文本替换，格式如下。\n\n```bash\n$(subst from,to,text)\n```\n\n下面的例子将字符串\"feet on the street\"替换成\"fEEt on the strEEt\"。\n\n```bash\n$(subst ee,EE,feet on the street)\n```\n\n下面是一个稍微复杂的例子。\n\n```bash\ncomma:= ,\nempty:=\n# space变量用两个空变量作为标识符，当中是一个空格\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n# bar is now `a,b,c'.\n```\n\n**（4）patsubst函数**\n\npatsubst 函数用于模式匹配的替换，格式如下。\n\n```bash\n$(patsubst pattern,replacement,text)\n```\n\n下面的例子将文件名\"x.c.c bar.c\"，替换成\"x.c.o bar.o\"。\n\n```bash\n$(patsubst %.c,%.o,x.c.c bar.c)\n```\n\n**（5）替换后缀名**\n\n替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。\n\n```bash\nmin: $(OUTPUT:.js=.min.js)\n```\n\n上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。\n\n## Makefile 的实例\n\n**（1）执行多个目标**\n\n```bash\n.PHONY: cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff\n        rm program\n\ncleanobj :\n        rm *.o\n\ncleandiff :\n        rm *.diff\n```\n\n上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。\n\n**（2）编译C语言项目**\n\n```bash\nedit : main.o kbd.o command.o display.o\n    cc -o edit main.o kbd.o command.o display.o\n\nmain.o : main.c defs.h\n    cc -c main.c\nkbd.o : kbd.c defs.h command.h\n    cc -c kbd.c\ncommand.o : command.c defs.h command.h\n    cc -c command.c\ndisplay.o : display.c defs.h\n    cc -c display.c\n\nclean :\n     rm edit main.o kbd.o command.o display.o\n\n.PHONY: edit clean\n```\n\n## 使用make构建网站\n\n本文来源**[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html)**\n\n### Make的优点\n\n首先解释一下，为什么要用Make。\n\n目前，网站项目（尤其是Node.js项目）有三种构建方案。\n\n> - 方案一：基于Node.js的专用构建工具（[Grunt](http://gruntjs.com/)、[Gulp](http://gulpjs.com/)、[Brunch](http://brunch.io/)、[Broccoli](https://github.com/broccolijs/broccoli)、[Mimosa](http://mimosa.io/)）\n> - 方案二：npm run命令（[教程1](http://substack.net/task_automation_with_npm_run)、[2](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/)、[3](http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/)）\n> - 方案三：make命令\n\n我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。\n\n**（1）插件问题**\n\nGrunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。\n\n**（2）兼容性问题**\n\n插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，[grunt-contrib-jshint插件](https://github.com/gruntjs/grunt-contrib-jshint)现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。\n\n**（3）语法问题**\n\nGrunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。\n\n**（4）功能问题**\n\nmake已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。\n\n基于以上理由，我看好make。\n\n### 常见的构建任务\n\n下面是一些常见的网站构建任务。\n\n> - 检查语法\n> - 编译模板\n> - 转码\n> - 合并\n> - 压缩\n> - 测试\n> - 删除\n\n这些任务用到 [JSHint](http://jshint.com/)、[handlebars](http://handlebarsjs.com/)、[CoffeeScript](http://coffeescript.org/)、[uglifyjs](http://lisperator.net/uglifyjs/)、[mocha](http://mochajs.org/) 等工具。对应的package.json文件如下。\n\n```javascript\n\"devDependencies\": {\n    \"coffee-script\": \"~1.9.1\",\n    \"handlebars\": \"~3.0.0\",\n    \"jshint\": \"^2.6.3\",\n    \"mocha\": \"~2.2.1\",\n    \"uglify-js\": \"~2.4.17\"\n}\n```\n\n我们来看看，Make 命令怎么完成这些构建任务。\n\n### Makefile的通用配置\n\n开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件（参见[《Make 命令教程》](http://www.ruanyifeng.com/blog/2015/02/make.html)）。\n\n首先，写入两行通用配置。\n\n```bash\nPATH  := node_modules/.bin:$(PATH)\nSHELL := /bin/bash\n```\n\n上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。\n\nPATH变量重新赋值为，优先在 node*modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node*modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。\n\nSHELL变量指定构建环境使用BASH。\n\n### 检查语法错误\n\n第一个任务是，检查源码有没有语法错误。\n\n```bash\njs_files = $(shell find ./lib -name '*.js')\n\nlint: $(js_files)\n    jshint $?\n```\n\n上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。\n\n使用时调用下面的命令。\n\n```bash\n$ make lint\n```\n\n### 模板编译\n\n第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。\n\n```bash\nbuild/templates.js: templates/*.handlebars\n    mkdir -p $(dir $@)\n    handlebars templates/*.handlebars > $@\n\ntemplate: build/templates.js\n```\n\n上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。\n\n使用时调用下面的命令。\n\n```bash\n$ make template\n```\n\n### Coffee脚本转码\n\n第三个任务是，将CofferScript脚本转为JavaScript脚本。\n\n```bash\nsource_files := $(wildcard lib/*.coffee)\nbuild_files  := $(source_files:lib/%.coffee=build/%.js)\n\nbuild/%.js: lib/%.coffee\n    coffee -co $(dir $@) $<\n\ncoffee: $(build_files)\n```\n\n上面代码中，首先获取所有的Coffee脚本文件，存放在变量source*files，函数wildcard用来扩展通配符。然后，将变量source*files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。\n\n使用时调用下面的命令。\n\n```bash\n$ make coffee\n```\n\n### 合并文件\n\n使用cat命令，合并多个文件。\n\n```bash\nJS_FILES := $(wildcard build/*.js)\nOUTPUT := build/bundle.js\n\nconcat: $(JS_FILES)\n    cat $^ > $(OUTPUT)\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make concat\n```\n\n### 压缩JavaScript脚本\n\n将所有JavaScript脚本，压缩为build目录下的app.js。\n\n```bash\napp_bundle := build/app.js\n\n$(app_bundle): $(build_files) $(template_js)\n    uglifyjs -cmo $@ $^\n\nmin: $(app_bundle)\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make min\n```\n\n还有另一种写法，可以另行指定压缩工具。\n\n```bash\nUGLIFY ?= uglify\n\n$(app_bundle): $(build_files) $(template_js)\n    $(UGLIFY) -cmo $@ $^\n```\n\n上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。\n\n调用时这样写。\n\n```bash\n$ make UGLIFY=node_modules/.bin/jsmin min\n```\n\n上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。\n\n### 删除临时文件\n\n构建结束前，删除所有临时文件。\n\n```bash\nclean:\n    rm -rf build\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make clean\n```\n\n### 测试\n\n假定测试工具是mocha，所有测试用例放在test目录下。\n\n```bash\ntest: $(app_bundle) $(test_js)\n    mocha\n```\n\n当脚本和测试用例都存在，上面代码就会执行mocha。\n\n使用时调用下面的命令。\n\n```bash\n$ make test\n```\n\n### 多任务执行\n\n构建过程需要一次性执行多个任务，可以指定一个多任务目标。\n\n```bash\nbuild: template concat min clean\n```\n\n上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。\n\n使用时调用下面的命令。\n\n```bash\n$ make build\n```\n\n如果这行规则在Makefile的最前面，执行时可以省略目标名。\n\n```bash\n$ make\n```\n\n通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。\n\n```bash\n$ make -j build\n```\n\n### 声明伪文件\n\n最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。\n\n```bash\n.PHONY: lint template coffee concat min test clean build\n```\n\n### Makefile文件示例\n\n下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。\n\n实例一。\n\n```bash\nPROJECT = \"My Fancy Node.js project\"\n\nall: install test server\n\ntest: ;@echo \"Testing ${PROJECT}.....\"; \\\n    export NODE_PATH=.; \\\n    ./node_modules/mocha/bin/mocha;\n\ninstall: ;@echo \"Installing ${PROJECT}.....\"; \\\n    npm install\n\nupdate: ;@echo \"Updating ${PROJECT}.....\"; \\\n    git pull --rebase; \\\n    npm install\n\nclean : ;\n    rm -rf node_modules\n\n.PHONY: test server install clean update\n```\n\n实例二。\n\n```bash\nall: build-js build-css\n\nbuild-js:\n  browserify -t brfs src/app.js > site/app.js\n\nbuild-css:\n  stylus src/style.styl > site/style.css\n\n.PHONY build-js build-css\n```\n\n参考链接\n\n- Jess Telford, [Example using Makefile for cloverfield](https://github.com/jesstelford/cloverfield-build-make)\n- Oskar Schöldström, [How to use Makefiles in your web projects](http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/)\n- James Coglan, [Building JavaScript projects with Make](https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/)\n- Rob Ashton, [The joy of make](http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html)\n","source":"_posts/2020-03-18-Make教程.md","raw":"---\nlayout: post\ntitle:  Make教程\ndate:   2020-03-18 12:00:00\ndescription: 知其然也知其所以然，不光会用还要知道它是怎么写的\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321004610.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\nauthor: tty\n---\n\n## Make，Makefile是什么\n\n在开发一个系统时，一般是将一个系统分成几个模块，这样做提高了系统的可维护性，但由于各个模块间不可避免存在关联，所以当一个模块改动后，其他模块也许会有所更新。\n\n对小系统来说，手工编译连接是没问题，但是如果是一个大系统，存在很多个模块，那么手工编译的方法就不适用了。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件，与手工编译和连接相比，make命令的优点在于他只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文件则置之不理，并且make命令不会漏掉一个需要更新的文件。\n\n文件和文件间或模块或模块间有可能存在倚赖关系，make命令也是依据这种依赖关系来进行维护的，所以我们有必要了解什么是依赖关系；make命令当然不会自己知道这些依赖关系，而需要程序员将这些依赖关系写入一个叫makefile的文件中。Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。\n\n即make和makefile的关系是：make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。\n\nMakefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。\n\n对于很大的项目来说，自己手写Makefile非常麻烦，而标准的GNU软件（如Apacle）都是运行一个configure脚本文件来产生Makefile；GNU软件automake和autoconf就是自动生成configure的工具。开发人员只需要先定义好宏，automake处理后会产生供autoconf使用的Makefine.in，再用autoconf就可以产生configure。\n————————————————\n版权声明：本文为CSDN博主「Jane_小妍」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/yg_2012/article/details/38925161\n\n## 如何写Makefile\n\n以下内容来自于**[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/02/make.html)**\n\n构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。\n\n### 概述\n\nMakefile文件由一系列规则（rules）构成。每条规则的形式如下。\n\n```bash\n<target> : <prerequisites>\n[tab]  <commands>\n```\n\n上面第一行冒号前面的部分，叫做\"目标\"（target），冒号后面的部分叫做\"前置条件\"（prerequisites）；第二行必须由一个tab键起首，后面跟着\"命令\"（commands）。\n\n\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。\n\n每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。\n\n### 目标（target）\n\n一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。\n\n除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。\n\n```bash\nclean:\n      rm *.o\n```\n\n上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于\"伪目标 \"，作用是删除对象文件。\n\n```bash\n$ make  clean\n```\n\n但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n```bash\n.PHONY: clean\nclean:\n        rm *.o temp\n```\n\n声明clean是\"伪目标\"之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看[手册](http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets)。\n\n如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。\n\n```bash\n$ make\n```\n\n上面代码执行Makefile文件的第一个目标。\n\n### 前置条件（prerequisites）\n\n前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。\n\n```bash\nresult.txt: source.txt\n    cp source.txt result.txt\n```\n\n上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么`make result.txt`可以正常运行，否则必须再写一条规则，来生成 source.txt 。\n\n```bash\nsource.txt:\n    echo \"this is the source\" > source.txt\n```\n\n上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用`make source.txt`，它都会生成。\n\n```bash\n$ make result.txt\n$ make result.txt\n```\n\n上面命令连续执行两次`make result.txt`。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。\n\n如果需要生成多个文件，往往采用下面的写法。\n\n```bash\nsource: file1 file2 file3\n```\n\n上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。\n\n```bash\n$ make source\n```\n\n执行`make source`命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。\n\n```bash\n$ make file1\n$ make file2\n$ make file3\n```\n\n### 命令（commands）\n\n命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。\n\n每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。\n\n```bash\n.RECIPEPREFIX = >\nall:\n> echo Hello, world\n```\n\n上面代码用.RECIPEPREFIX指定，大于号（>）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。\n\n需要注意的是，**每行命令在一个单独的shell中执行。这些Shell之间没有继承关系**。\n\n```bash\nvar-lost:\n    export foo=bar\n    echo \"foo=[$$foo]\"\n```\n\n上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。\n\n```bash\nvar-kept:\n    export foo=bar; echo \"foo=[$$foo]\"\n```\n\n另一个解决办法是在换行符前加反斜杠转义。\n\n```bash\nvar-kept:\n    export foo=bar; \\\n    echo \"foo=[$$foo]\"\n```\n\n最后一个方法是加上`.ONESHELL:`命令。\n\n```bash\n.ONESHELL:\nvar-kept:\n    export foo=bar;\n    echo \"foo=[$$foo]\"\n```\n\n## Makefile文件的语法\n\n### 注释\n\n井号（#）在Makefile中表示注释。\n\n```bash\n# 这是注释\nresult.txt: source.txt\n    # 这是注释\n    cp source.txt result.txt # 这也是注释\n```\n\n### 回声（echoing）\n\n正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n```bash\ntest:\n    # 这是测试\n```\n\n执行上面的规则，会得到下面的结果。\n\n```bash\n$ make test\n# 这是测试\n```\n\n在命令的前面加上@，就可以关闭回声。\n\n```bash\ntest:\n    @# 这是测试\n```\n\n现在再执行`make test`，就不会有任何输出。\n\n由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。\n\n```bash\ntest:\n    @# 这是测试\n    @echo TODO\n```\n\n### 通配符\n\n通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为o的文件。\n\n```bash\nclean:\n        rm -f *.o\n```\n\n### 模式匹配\n\nMake命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。\n\n```bash\n%.o: %.c\n```\n\n等同于下面的写法。\n\n```bash\nf1.o: f1.c\nf2.o: f2.c\n```\n\n使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。\n\n### 变量和赋值符\n\nMakefile 允许使用等号自定义变量。\n\n```bash\ntxt = Hello World\ntest:\n    @echo $(txt)\n```\n\n上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。\n\n调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。\n\n```bash\ntest:\n    @echo $$HOME\n```\n\n有时，变量的值可能指向另一个变量。\n\n```bash\nv1 = $(v2)\n```\n\n上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。\n\n为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看[StackOverflow](http://stackoverflow.com/questions/448910/makefile-variable-assignment)。\n\n```bash\nVARIABLE = value\n# 在执行时扩展，允许递归扩展。\n\nVARIABLE := value\n# 在定义时扩展。\n\nVARIABLE ?= value\n# 只有在该变量为空时才设置值。\n\nVARIABLE += value\n# 将值追加到变量的尾端。\n```\n\n### 内置变量（Implicit Variables）\n\nMake命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见[手册](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)。\n\n```bash\noutput:\n    $(CC) -o output input.c\n```\n\n### 自动变量（Automatic Variables）\n\nMake命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。\n\n**（1）$@**\n\n$@指代当前目标，就是Make命令当前构建的那个目标。比如，`make foo`的 $@ 就指代foo。\n\n```bash\na.txt b.txt:\n    touch $@\n```\n\n等同于下面的写法。\n\n```bash\na.txt:\n    touch a.txt\nb.txt:\n    touch b.txt\n```\n\n**（2）$<**\n\n$< 指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1。\n\n```bash\na.txt: b.txt c.txt\n    cp $< $@\n```\n\n等同于下面的写法。\n\n```bash\na.txt: b.txt c.txt\n    cp b.txt a.txt\n```\n\n**（3）$?**\n\n$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。\n\n**（4）$^**\n\n$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。\n\n**（5）$\\***\n\n$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。\n\n**（6）$(@D) 和 $(@F)**\n\n$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。\n\n**（7）$(\n\n$(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n所有的自动变量清单，请看[手册](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)。下面是自动变量的一个例子。\n\n```bash\ndest/%.txt: src/%.txt\n    @[ -d dest ] || mkdir dest\n    cp $< $@\n```\n\n上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$< 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。\n\n### 判断和循环\n\nMakefile使用 Bash 语法，完成判断和循环。\n\n```bash\nifeq ($(CC),gcc)\n  libs=$(libs_for_gcc)\nelse\n  libs=$(normal_libs)\nendif\n```\n\n上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。\n\n```bash\nLIST = one two three\nall:\n    for i in $(LIST); do \\\n        echo $$i; \\\n    done\n\n# 等同于\n\nall:\n    for i in one two three; do \\\n        echo $i; \\\n    done\n```\n\n上面代码的运行结果。\n\n```bash\none\ntwo\nthree\n```\n\n### 函数\n\nMakefile 还可以使用函数，格式如下。\n\n```bash\n$(function arguments)\n# 或者\n${function arguments}\n```\n\nMakefile提供了许多[内置函数](http://www.gnu.org/software/make/manual/html_node/Functions.html)，可供调用。下面是几个常用的内置函数。\n\n**（1）shell 函数**\n\nshell 函数用来执行 shell 命令\n\n```bash\nsrcfiles := $(shell echo src/{00..99}.txt)\n```\n\n**（2）wildcard 函数**\n\nwildcard 函数用来在 Makefile 中，替换 Bash 的通配符。\n\n```bash\nsrcfiles := $(wildcard src/*.txt)\n```\n\n**（3）subst 函数**\n\nsubst 函数用来文本替换，格式如下。\n\n```bash\n$(subst from,to,text)\n```\n\n下面的例子将字符串\"feet on the street\"替换成\"fEEt on the strEEt\"。\n\n```bash\n$(subst ee,EE,feet on the street)\n```\n\n下面是一个稍微复杂的例子。\n\n```bash\ncomma:= ,\nempty:=\n# space变量用两个空变量作为标识符，当中是一个空格\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n# bar is now `a,b,c'.\n```\n\n**（4）patsubst函数**\n\npatsubst 函数用于模式匹配的替换，格式如下。\n\n```bash\n$(patsubst pattern,replacement,text)\n```\n\n下面的例子将文件名\"x.c.c bar.c\"，替换成\"x.c.o bar.o\"。\n\n```bash\n$(patsubst %.c,%.o,x.c.c bar.c)\n```\n\n**（5）替换后缀名**\n\n替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。\n\n```bash\nmin: $(OUTPUT:.js=.min.js)\n```\n\n上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。\n\n## Makefile 的实例\n\n**（1）执行多个目标**\n\n```bash\n.PHONY: cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff\n        rm program\n\ncleanobj :\n        rm *.o\n\ncleandiff :\n        rm *.diff\n```\n\n上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。\n\n**（2）编译C语言项目**\n\n```bash\nedit : main.o kbd.o command.o display.o\n    cc -o edit main.o kbd.o command.o display.o\n\nmain.o : main.c defs.h\n    cc -c main.c\nkbd.o : kbd.c defs.h command.h\n    cc -c kbd.c\ncommand.o : command.c defs.h command.h\n    cc -c command.c\ndisplay.o : display.c defs.h\n    cc -c display.c\n\nclean :\n     rm edit main.o kbd.o command.o display.o\n\n.PHONY: edit clean\n```\n\n## 使用make构建网站\n\n本文来源**[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html)**\n\n### Make的优点\n\n首先解释一下，为什么要用Make。\n\n目前，网站项目（尤其是Node.js项目）有三种构建方案。\n\n> - 方案一：基于Node.js的专用构建工具（[Grunt](http://gruntjs.com/)、[Gulp](http://gulpjs.com/)、[Brunch](http://brunch.io/)、[Broccoli](https://github.com/broccolijs/broccoli)、[Mimosa](http://mimosa.io/)）\n> - 方案二：npm run命令（[教程1](http://substack.net/task_automation_with_npm_run)、[2](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/)、[3](http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/)）\n> - 方案三：make命令\n\n我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。\n\n**（1）插件问题**\n\nGrunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。\n\n**（2）兼容性问题**\n\n插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，[grunt-contrib-jshint插件](https://github.com/gruntjs/grunt-contrib-jshint)现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。\n\n**（3）语法问题**\n\nGrunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。\n\n**（4）功能问题**\n\nmake已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。\n\n基于以上理由，我看好make。\n\n### 常见的构建任务\n\n下面是一些常见的网站构建任务。\n\n> - 检查语法\n> - 编译模板\n> - 转码\n> - 合并\n> - 压缩\n> - 测试\n> - 删除\n\n这些任务用到 [JSHint](http://jshint.com/)、[handlebars](http://handlebarsjs.com/)、[CoffeeScript](http://coffeescript.org/)、[uglifyjs](http://lisperator.net/uglifyjs/)、[mocha](http://mochajs.org/) 等工具。对应的package.json文件如下。\n\n```javascript\n\"devDependencies\": {\n    \"coffee-script\": \"~1.9.1\",\n    \"handlebars\": \"~3.0.0\",\n    \"jshint\": \"^2.6.3\",\n    \"mocha\": \"~2.2.1\",\n    \"uglify-js\": \"~2.4.17\"\n}\n```\n\n我们来看看，Make 命令怎么完成这些构建任务。\n\n### Makefile的通用配置\n\n开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件（参见[《Make 命令教程》](http://www.ruanyifeng.com/blog/2015/02/make.html)）。\n\n首先，写入两行通用配置。\n\n```bash\nPATH  := node_modules/.bin:$(PATH)\nSHELL := /bin/bash\n```\n\n上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。\n\nPATH变量重新赋值为，优先在 node*modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node*modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。\n\nSHELL变量指定构建环境使用BASH。\n\n### 检查语法错误\n\n第一个任务是，检查源码有没有语法错误。\n\n```bash\njs_files = $(shell find ./lib -name '*.js')\n\nlint: $(js_files)\n    jshint $?\n```\n\n上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。\n\n使用时调用下面的命令。\n\n```bash\n$ make lint\n```\n\n### 模板编译\n\n第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。\n\n```bash\nbuild/templates.js: templates/*.handlebars\n    mkdir -p $(dir $@)\n    handlebars templates/*.handlebars > $@\n\ntemplate: build/templates.js\n```\n\n上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。\n\n使用时调用下面的命令。\n\n```bash\n$ make template\n```\n\n### Coffee脚本转码\n\n第三个任务是，将CofferScript脚本转为JavaScript脚本。\n\n```bash\nsource_files := $(wildcard lib/*.coffee)\nbuild_files  := $(source_files:lib/%.coffee=build/%.js)\n\nbuild/%.js: lib/%.coffee\n    coffee -co $(dir $@) $<\n\ncoffee: $(build_files)\n```\n\n上面代码中，首先获取所有的Coffee脚本文件，存放在变量source*files，函数wildcard用来扩展通配符。然后，将变量source*files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。\n\n使用时调用下面的命令。\n\n```bash\n$ make coffee\n```\n\n### 合并文件\n\n使用cat命令，合并多个文件。\n\n```bash\nJS_FILES := $(wildcard build/*.js)\nOUTPUT := build/bundle.js\n\nconcat: $(JS_FILES)\n    cat $^ > $(OUTPUT)\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make concat\n```\n\n### 压缩JavaScript脚本\n\n将所有JavaScript脚本，压缩为build目录下的app.js。\n\n```bash\napp_bundle := build/app.js\n\n$(app_bundle): $(build_files) $(template_js)\n    uglifyjs -cmo $@ $^\n\nmin: $(app_bundle)\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make min\n```\n\n还有另一种写法，可以另行指定压缩工具。\n\n```bash\nUGLIFY ?= uglify\n\n$(app_bundle): $(build_files) $(template_js)\n    $(UGLIFY) -cmo $@ $^\n```\n\n上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。\n\n调用时这样写。\n\n```bash\n$ make UGLIFY=node_modules/.bin/jsmin min\n```\n\n上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。\n\n### 删除临时文件\n\n构建结束前，删除所有临时文件。\n\n```bash\nclean:\n    rm -rf build\n```\n\n使用时调用下面的命令。\n\n```bash\n$ make clean\n```\n\n### 测试\n\n假定测试工具是mocha，所有测试用例放在test目录下。\n\n```bash\ntest: $(app_bundle) $(test_js)\n    mocha\n```\n\n当脚本和测试用例都存在，上面代码就会执行mocha。\n\n使用时调用下面的命令。\n\n```bash\n$ make test\n```\n\n### 多任务执行\n\n构建过程需要一次性执行多个任务，可以指定一个多任务目标。\n\n```bash\nbuild: template concat min clean\n```\n\n上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。\n\n使用时调用下面的命令。\n\n```bash\n$ make build\n```\n\n如果这行规则在Makefile的最前面，执行时可以省略目标名。\n\n```bash\n$ make\n```\n\n通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。\n\n```bash\n$ make -j build\n```\n\n### 声明伪文件\n\n最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。\n\n```bash\n.PHONY: lint template coffee concat min test clean build\n```\n\n### Makefile文件示例\n\n下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。\n\n实例一。\n\n```bash\nPROJECT = \"My Fancy Node.js project\"\n\nall: install test server\n\ntest: ;@echo \"Testing ${PROJECT}.....\"; \\\n    export NODE_PATH=.; \\\n    ./node_modules/mocha/bin/mocha;\n\ninstall: ;@echo \"Installing ${PROJECT}.....\"; \\\n    npm install\n\nupdate: ;@echo \"Updating ${PROJECT}.....\"; \\\n    git pull --rebase; \\\n    npm install\n\nclean : ;\n    rm -rf node_modules\n\n.PHONY: test server install clean update\n```\n\n实例二。\n\n```bash\nall: build-js build-css\n\nbuild-js:\n  browserify -t brfs src/app.js > site/app.js\n\nbuild-css:\n  stylus src/style.styl > site/style.css\n\n.PHONY build-js build-css\n```\n\n参考链接\n\n- Jess Telford, [Example using Makefile for cloverfield](https://github.com/jesstelford/cloverfield-build-make)\n- Oskar Schöldström, [How to use Makefiles in your web projects](http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/)\n- James Coglan, [Building JavaScript projects with Make](https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/)\n- Rob Ashton, [The joy of make](http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html)\n","slug":"Make教程","published":1,"updated":"2020-03-29T06:59:20.714Z","photos":[],"link":"","_id":"ck8ct7j5q000jgtvi3sgbhx2v","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"Make，Makefile是什么\"><a href=\"#Make，Makefile是什么\" class=\"headerlink\" title=\"Make，Makefile是什么\"></a>Make，Makefile是什么</h2><p>在开发一个系统时，一般是将一个系统分成几个模块，这样做提高了系统的可维护性，但由于各个模块间不可避免存在关联，所以当一个模块改动后，其他模块也许会有所更新。</p>\n<p>对小系统来说，手工编译连接是没问题，但是如果是一个大系统，存在很多个模块，那么手工编译的方法就不适用了。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件，与手工编译和连接相比，make命令的优点在于他只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文件则置之不理，并且make命令不会漏掉一个需要更新的文件。</p>\n<p>文件和文件间或模块或模块间有可能存在倚赖关系，make命令也是依据这种依赖关系来进行维护的，所以我们有必要了解什么是依赖关系；make命令当然不会自己知道这些依赖关系，而需要程序员将这些依赖关系写入一个叫makefile的文件中。Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。</p>\n<p>即make和makefile的关系是：make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p>\n<p>Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>\n<p>对于很大的项目来说，自己手写Makefile非常麻烦，而标准的GNU软件（如Apacle）都是运行一个configure脚本文件来产生Makefile；GNU软件automake和autoconf就是自动生成configure的工具。开发人员只需要先定义好宏，automake处理后会产生供autoconf使用的Makefine.in，再用autoconf就可以产生configure。<br>————————————————<br>版权声明：本文为CSDN博主「Jane_小妍」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/yg_2012/article/details/38925161\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yg_2012/article/details/38925161</a></p>\n<h2 id=\"如何写Makefile\"><a href=\"#如何写Makefile\" class=\"headerlink\" title=\"如何写Makefile\"></a>如何写Makefile</h2><p>以下内容来自于<strong><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></strong></p>\n<p>构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>\n<p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p>\n<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>\n<h3 id=\"目标（target）\"><a href=\"#目标（target）\" class=\"headerlink\" title=\"目标（target）\"></a>目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make  clean</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n\n<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href=\"http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets\" target=\"_blank\" rel=\"noopener\">手册</a>。</p>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行Makefile文件的第一个目标。</p>\n<h3 id=\"前置条件（prerequisites）\"><a href=\"#前置条件（prerequisites）\" class=\"headerlink\" title=\"前置条件（prerequisites）\"></a>前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result.txt: source.txt</span><br><span class=\"line\">    cp source.txt result.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source.txt:</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"this is the source\"</span> &gt; source.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make result.txt</span><br><span class=\"line\">$ make result.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p>\n<p>如果需要生成多个文件，往往采用下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make file1</span><br><span class=\"line\">$ make file2</span><br><span class=\"line\">$ make file3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令（commands）\"><a href=\"#命令（commands）\" class=\"headerlink\" title=\"命令（commands）\"></a>命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p>\n<p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.RECIPEPREFIX = &gt;</span><br><span class=\"line\">all:</span><br><span class=\"line\">&gt; <span class=\"built_in\">echo</span> Hello, world</span><br></pre></td></tr></table></figure>\n\n<p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>\n<p>需要注意的是，<strong>每行命令在一个单独的shell中执行。这些Shell之间没有继承关系</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar; <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另一个解决办法是在换行符前加反斜杠转义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar; \\</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile文件的语法\"><a href=\"#Makefile文件的语法\" class=\"headerlink\" title=\"Makefile文件的语法\"></a>Makefile文件的语法</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>井号（#）在Makefile中表示注释。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是注释</span></span><br><span class=\"line\">result.txt: source.txt</span><br><span class=\"line\">    <span class=\"comment\"># 这是注释</span></span><br><span class=\"line\">    cp source.txt result.txt <span class=\"comment\"># 这也是注释</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"回声（echoing）\"><a href=\"#回声（echoing）\" class=\"headerlink\" title=\"回声（echoing）\"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>执行上面的规则，会得到下面的结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>在命令的前面加上@，就可以关闭回声。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>现在再执行<code>make test</code>，就不会有任何输出。</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"comment\"># 这是测试</span></span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> TODO</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">        rm -f *.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>\n<h3 id=\"变量和赋值符\"><a href=\"#变量和赋值符\" class=\"headerlink\" title=\"变量和赋值符\"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> $(txt)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> $<span class=\"variable\">$HOME</span></span><br></pre></td></tr></table></figure>\n\n<p>有时，变量的值可能指向另一个变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 = $(v2)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p>\n<p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看<a href=\"http://stackoverflow.com/questions/448910/makefile-variable-assignment\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VARIABLE = value</span><br><span class=\"line\"><span class=\"comment\"># 在执行时扩展，允许递归扩展。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE := value</span><br><span class=\"line\"><span class=\"comment\"># 在定义时扩展。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE ?= value</span><br><span class=\"line\"><span class=\"comment\"># 只有在该变量为空时才设置值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE += value</span><br><span class=\"line\"><span class=\"comment\"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置变量（Implicit-Variables）\"><a href=\"#内置变量（Implicit-Variables）\" class=\"headerlink\" title=\"内置变量（Implicit Variables）\"></a>内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href=\"https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html\" target=\"_blank\" rel=\"noopener\">手册</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output:</span><br><span class=\"line\">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动变量（Automatic-Variables）\"><a href=\"#自动变量（Automatic-Variables）\" class=\"headerlink\" title=\"自动变量（Automatic Variables）\"></a>自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p>\n<p><strong>（1）$@</strong></p>\n<p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 $@ 就指代foo。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt b.txt:</span><br><span class=\"line\">    touch <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt:</span><br><span class=\"line\">    touch a.txt</span><br><span class=\"line\">b.txt:</span><br><span class=\"line\">    touch b.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）$&lt;</strong></p>\n<p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt: b.txt c.txt</span><br><span class=\"line\">    cp $&lt; <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt: b.txt c.txt</span><br><span class=\"line\">    cp b.txt a.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）$?</strong></p>\n<p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p>\n<p><strong>（4）$^</strong></p>\n<p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p>\n<p><strong>（5）$*</strong></p>\n<p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p>\n<p><strong>（6）$(@D) 和 $(@F)</strong></p>\n<p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p>\n<p>**（7）$(</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n<p>所有的自动变量清单，请看<a href=\"https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html\" target=\"_blank\" rel=\"noopener\">手册</a>。下面是自动变量的一个例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest/%.txt: src/%.txt</span><br><span class=\"line\">    @[ -d dest ] || mkdir dest</span><br><span class=\"line\">    cp $&lt; <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p>\n<h3 id=\"判断和循环\"><a href=\"#判断和循环\" class=\"headerlink\" title=\"判断和循环\"></a>判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifeq ($(CC),gcc)</span><br><span class=\"line\">  libs=$(libs_for_gcc)</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  libs=$(normal_libs)</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n<p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIST = one two three</span><br><span class=\"line\">all:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(LIST); <span class=\"keyword\">do</span> \\</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> $<span class=\"variable\">$i</span>; \\</span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\">all:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> one two three; <span class=\"keyword\">do</span> \\</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span>; \\</span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的运行结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one</span><br><span class=\"line\">two</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>Makefile 还可以使用函数，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"keyword\">function</span> arguments)</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>Makefile提供了许多<a href=\"http://www.gnu.org/software/make/manual/html_node/Functions.html\" target=\"_blank\" rel=\"noopener\">内置函数</a>，可供调用。下面是几个常用的内置函数。</p>\n<p><strong>（1）shell 函数</strong></p>\n<p>shell 函数用来执行 shell 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srcfiles := $(shell <span class=\"built_in\">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）wildcard 函数</strong></p>\n<p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）subst 函数</strong></p>\n<p>subst 函数用来文本替换，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(subst from,to,text)</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个稍微复杂的例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comma:= ,</span><br><span class=\"line\">empty:=</span><br><span class=\"line\"><span class=\"comment\"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class=\"line\">space:= $(empty) $(empty)</span><br><span class=\"line\">foo:= a b c</span><br><span class=\"line\">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class=\"line\"><span class=\"comment\"># bar is now `a,b,c'.</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）patsubst函数</strong></p>\n<p>patsubst 函数用于模式匹配的替换，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）替换后缀名</strong></p>\n<p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p>\n<h2 id=\"Makefile-的实例\"><a href=\"#Makefile-的实例\" class=\"headerlink\" title=\"Makefile 的实例\"></a>Makefile 的实例</h2><p><strong>（1）执行多个目标</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: cleanall cleanobj cleandiff</span><br><span class=\"line\"></span><br><span class=\"line\">cleanall : cleanobj cleandiff</span><br><span class=\"line\">        rm program</span><br><span class=\"line\"></span><br><span class=\"line\">cleanobj :</span><br><span class=\"line\">        rm *.o</span><br><span class=\"line\"></span><br><span class=\"line\">cleandiff :</span><br><span class=\"line\">        rm *.diff</span><br></pre></td></tr></table></figure>\n\n<p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p>\n<p><strong>（2）编译C语言项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o</span><br><span class=\"line\">    cc -o edit main.o kbd.o command.o display.o</span><br><span class=\"line\"></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">    cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">    cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">    cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h</span><br><span class=\"line\">    cc -c display.c</span><br><span class=\"line\"></span><br><span class=\"line\">clean :</span><br><span class=\"line\">     rm edit main.o kbd.o command.o display.o</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: edit clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用make构建网站\"><a href=\"#使用make构建网站\" class=\"headerlink\" title=\"使用make构建网站\"></a>使用make构建网站</h2><p>本文来源<strong><a href=\"http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></strong></p>\n<h3 id=\"Make的优点\"><a href=\"#Make的优点\" class=\"headerlink\" title=\"Make的优点\"></a>Make的优点</h3><p>首先解释一下，为什么要用Make。</p>\n<p>目前，网站项目（尤其是Node.js项目）有三种构建方案。</p>\n<blockquote>\n<ul>\n<li>方案一：基于Node.js的专用构建工具（<a href=\"http://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">Grunt</a>、<a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">Gulp</a>、<a href=\"http://brunch.io/\" target=\"_blank\" rel=\"noopener\">Brunch</a>、<a href=\"https://github.com/broccolijs/broccoli\" target=\"_blank\" rel=\"noopener\">Broccoli</a>、<a href=\"http://mimosa.io/\" target=\"_blank\" rel=\"noopener\">Mimosa</a>）</li>\n<li>方案二：npm run命令（<a href=\"http://substack.net/task_automation_with_npm_run\" target=\"_blank\" rel=\"noopener\">教程1</a>、<a href=\"http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/\" target=\"_blank\" rel=\"noopener\">2</a>、<a href=\"http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/\" target=\"_blank\" rel=\"noopener\">3</a>）</li>\n<li>方案三：make命令</li>\n</ul>\n</blockquote>\n<p>我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。</p>\n<p><strong>（1）插件问题</strong></p>\n<p>Grunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。</p>\n<p><strong>（2）兼容性问题</strong></p>\n<p>插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，<a href=\"https://github.com/gruntjs/grunt-contrib-jshint\" target=\"_blank\" rel=\"noopener\">grunt-contrib-jshint插件</a>现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。</p>\n<p><strong>（3）语法问题</strong></p>\n<p>Grunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。</p>\n<p><strong>（4）功能问题</strong></p>\n<p>make已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。</p>\n<p>基于以上理由，我看好make。</p>\n<h3 id=\"常见的构建任务\"><a href=\"#常见的构建任务\" class=\"headerlink\" title=\"常见的构建任务\"></a>常见的构建任务</h3><p>下面是一些常见的网站构建任务。</p>\n<blockquote>\n<ul>\n<li>检查语法</li>\n<li>编译模板</li>\n<li>转码</li>\n<li>合并</li>\n<li>压缩</li>\n<li>测试</li>\n<li>删除</li>\n</ul>\n</blockquote>\n<p>这些任务用到 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a>、<a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">handlebars</a>、<a href=\"http://coffeescript.org/\" target=\"_blank\" rel=\"noopener\">CoffeeScript</a>、<a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"noopener\">uglifyjs</a>、<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">mocha</a> 等工具。对应的package.json文件如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"coffee-script\"</span>: <span class=\"string\">\"~1.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"handlebars\"</span>: <span class=\"string\">\"~3.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"jshint\"</span>: <span class=\"string\">\"^2.6.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mocha\"</span>: <span class=\"string\">\"~2.2.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"uglify-js\"</span>: <span class=\"string\">\"~2.4.17\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看，Make 命令怎么完成这些构建任务。</p>\n<h3 id=\"Makefile的通用配置\"><a href=\"#Makefile的通用配置\" class=\"headerlink\" title=\"Makefile的通用配置\"></a>Makefile的通用配置</h3><p>开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件（参见<a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">《Make 命令教程》</a>）。</p>\n<p>首先，写入两行通用配置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH  := node_modules/.bin:$(PATH)</span><br><span class=\"line\">SHELL := /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。</p>\n<p>PATH变量重新赋值为，优先在 node<em>modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node</em>modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。</p>\n<p>SHELL变量指定构建环境使用BASH。</p>\n<h3 id=\"检查语法错误\"><a href=\"#检查语法错误\" class=\"headerlink\" title=\"检查语法错误\"></a>检查语法错误</h3><p>第一个任务是，检查源码有没有语法错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">js_files = $(shell find ./lib -name <span class=\"string\">'*.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">lint: $(js_files)</span><br><span class=\"line\">    jshint $?</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make lint</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h3><p>第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/templates.js: templates/*.handlebars</span><br><span class=\"line\">    mkdir -p $(dir <span class=\"variable\">$@</span>)</span><br><span class=\"line\">    handlebars templates/*.handlebars &gt; <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\">template: build/templates.js</span><br></pre></td></tr></table></figure>\n\n<p>上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make template</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Coffee脚本转码\"><a href=\"#Coffee脚本转码\" class=\"headerlink\" title=\"Coffee脚本转码\"></a>Coffee脚本转码</h3><p>第三个任务是，将CofferScript脚本转为JavaScript脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source_files := $(wildcard lib/*.coffee)</span><br><span class=\"line\">build_files  := $(source_files:lib/%.coffee=build/%.js)</span><br><span class=\"line\"></span><br><span class=\"line\">build/%.js: lib/%.coffee</span><br><span class=\"line\">    coffee -co $(dir <span class=\"variable\">$@</span>) $&lt;</span><br><span class=\"line\"></span><br><span class=\"line\">coffee: $(build_files)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，首先获取所有的Coffee脚本文件，存放在变量source<em>files，函数wildcard用来扩展通配符。然后，将变量source</em>files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make coffee</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并文件\"><a href=\"#合并文件\" class=\"headerlink\" title=\"合并文件\"></a>合并文件</h3><p>使用cat命令，合并多个文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS_FILES := $(wildcard build/*.js)</span><br><span class=\"line\">OUTPUT := build/bundle.js</span><br><span class=\"line\"></span><br><span class=\"line\">concat: $(JS_FILES)</span><br><span class=\"line\">    cat $^ &gt; $(OUTPUT)</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make concat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"压缩JavaScript脚本\"><a href=\"#压缩JavaScript脚本\" class=\"headerlink\" title=\"压缩JavaScript脚本\"></a>压缩JavaScript脚本</h3><p>将所有JavaScript脚本，压缩为build目录下的app.js。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app_bundle := build/app.js</span><br><span class=\"line\"></span><br><span class=\"line\">$(app_bundle): $(build_files) $(template_js)</span><br><span class=\"line\">    uglifyjs -cmo <span class=\"variable\">$@</span> $^</span><br><span class=\"line\"></span><br><span class=\"line\">min: $(app_bundle)</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make min</span><br></pre></td></tr></table></figure>\n\n<p>还有另一种写法，可以另行指定压缩工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UGLIFY ?= uglify</span><br><span class=\"line\"></span><br><span class=\"line\">$(app_bundle): $(build_files) $(template_js)</span><br><span class=\"line\">    $(UGLIFY) -cmo <span class=\"variable\">$@</span> $^</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。</p>\n<p>调用时这样写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make UGLIFY=node_modules/.bin/jsmin min</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。</p>\n<h3 id=\"删除临时文件\"><a href=\"#删除临时文件\" class=\"headerlink\" title=\"删除临时文件\"></a>删除临时文件</h3><p>构建结束前，删除所有临时文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">    rm -rf build</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make clean</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>假定测试工具是mocha，所有测试用例放在test目录下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>: $(app_bundle) $(test_js)</span><br><span class=\"line\">    mocha</span><br></pre></td></tr></table></figure>\n\n<p>当脚本和测试用例都存在，上面代码就会执行mocha。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多任务执行\"><a href=\"#多任务执行\" class=\"headerlink\" title=\"多任务执行\"></a>多任务执行</h3><p>构建过程需要一次性执行多个任务，可以指定一个多任务目标。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build: template concat min clean</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make build</span><br></pre></td></tr></table></figure>\n\n<p>如果这行规则在Makefile的最前面，执行时可以省略目标名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -j build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明伪文件\"><a href=\"#声明伪文件\" class=\"headerlink\" title=\"声明伪文件\"></a>声明伪文件</h3><p>最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: lint template coffee concat min <span class=\"built_in\">test</span> clean build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Makefile文件示例\"><a href=\"#Makefile文件示例\" class=\"headerlink\" title=\"Makefile文件示例\"></a>Makefile文件示例</h3><p>下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。</p>\n<p>实例一。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT = <span class=\"string\">\"My Fancy Node.js project\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">all: install <span class=\"built_in\">test</span> server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">test</span>: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Testing <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_PATH=.; \\</span><br><span class=\"line\">    ./node_modules/mocha/bin/mocha;</span><br><span class=\"line\"></span><br><span class=\"line\">install: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Installing <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    npm install</span><br><span class=\"line\"></span><br><span class=\"line\">update: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Updating <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    git pull --rebase; \\</span><br><span class=\"line\">    npm install</span><br><span class=\"line\"></span><br><span class=\"line\">clean : ;</span><br><span class=\"line\">    rm -rf node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: <span class=\"built_in\">test</span> server install clean update</span><br></pre></td></tr></table></figure>\n\n<p>实例二。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all: build-js build-css</span><br><span class=\"line\"></span><br><span class=\"line\">build-js:</span><br><span class=\"line\">  browserify -t brfs src/app.js &gt; site/app.js</span><br><span class=\"line\"></span><br><span class=\"line\">build-css:</span><br><span class=\"line\">  stylus src/style.styl &gt; site/style.css</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY build-js build-css</span><br></pre></td></tr></table></figure>\n\n<p>参考链接</p>\n<ul>\n<li>Jess Telford, <a href=\"https://github.com/jesstelford/cloverfield-build-make\" target=\"_blank\" rel=\"noopener\">Example using Makefile for cloverfield</a></li>\n<li>Oskar Schöldström, <a href=\"http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/\" target=\"_blank\" rel=\"noopener\">How to use Makefiles in your web projects</a></li>\n<li>James Coglan, <a href=\"https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/\" target=\"_blank\" rel=\"noopener\">Building JavaScript projects with Make</a></li>\n<li>Rob Ashton, <a href=\"http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html\" target=\"_blank\" rel=\"noopener\">The joy of make</a></li>\n</ul>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<h2 id=\"Make，Makefile是什么\"><a href=\"#Make，Makefile是什么\" class=\"headerlink\" title=\"Make，Makefile是什么\"></a>Make，Makefile是什么</h2><p>在开发一个系统时，一般是将一个系统分成几个模块，这样做提高了系统的可维护性，但由于各个模块间不可避免存在关联，所以当一个模块改动后，其他模块也许会有所更新。</p>\n<p>对小系统来说，手工编译连接是没问题，但是如果是一个大系统，存在很多个模块，那么手工编译的方法就不适用了。为此，在Linux系统中，专门提供了一个make命令来自动维护目标文件，与手工编译和连接相比，make命令的优点在于他只更新修改过的文件（在Linux中，一个文件被创建或更新后有一个最后修改时间，make命令就是通过这个最后修改时间来判断此文件是否被修改），而对没修改的文件则置之不理，并且make命令不会漏掉一个需要更新的文件。</p>\n<p>文件和文件间或模块或模块间有可能存在倚赖关系，make命令也是依据这种依赖关系来进行维护的，所以我们有必要了解什么是依赖关系；make命令当然不会自己知道这些依赖关系，而需要程序员将这些依赖关系写入一个叫makefile的文件中。Makefile文件中包含着一些目标，通常目标就是文件名，对每一个目标，提供了实现这个目标的一组命令以及和这个目标有依赖关系的其他目标或文件名。</p>\n<p>即make和makefile的关系是：make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p>\n<p>Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>\n<p>对于很大的项目来说，自己手写Makefile非常麻烦，而标准的GNU软件（如Apacle）都是运行一个configure脚本文件来产生Makefile；GNU软件automake和autoconf就是自动生成configure的工具。开发人员只需要先定义好宏，automake处理后会产生供autoconf使用的Makefine.in，再用autoconf就可以产生configure。<br>————————————————<br>版权声明：本文为CSDN博主「Jane_小妍」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/yg_2012/article/details/38925161\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yg_2012/article/details/38925161</a></p>\n<h2 id=\"如何写Makefile\"><a href=\"#如何写Makefile\" class=\"headerlink\" title=\"如何写Makefile\"></a>如何写Makefile</h2><p>以下内容来自于<strong><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></strong></p>\n<p>构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>\n<p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p>\n<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>\n<h3 id=\"目标（target）\"><a href=\"#目标（target）\" class=\"headerlink\" title=\"目标（target）\"></a>目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make  clean</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n\n<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href=\"http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets\" target=\"_blank\" rel=\"noopener\">手册</a>。</p>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行Makefile文件的第一个目标。</p>\n<h3 id=\"前置条件（prerequisites）\"><a href=\"#前置条件（prerequisites）\" class=\"headerlink\" title=\"前置条件（prerequisites）\"></a>前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result.txt: source.txt</span><br><span class=\"line\">    cp source.txt result.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source.txt:</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"this is the source\"</span> &gt; source.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make result.txt</span><br><span class=\"line\">$ make result.txt</span><br></pre></td></tr></table></figure>\n\n<p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p>\n<p>如果需要生成多个文件，往往采用下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make file1</span><br><span class=\"line\">$ make file2</span><br><span class=\"line\">$ make file3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令（commands）\"><a href=\"#命令（commands）\" class=\"headerlink\" title=\"命令（commands）\"></a>命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p>\n<p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.RECIPEPREFIX = &gt;</span><br><span class=\"line\">all:</span><br><span class=\"line\">&gt; <span class=\"built_in\">echo</span> Hello, world</span><br></pre></td></tr></table></figure>\n\n<p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>\n<p>需要注意的是，<strong>每行命令在一个单独的shell中执行。这些Shell之间没有继承关系</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar; <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另一个解决办法是在换行符前加反斜杠转义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar; \\</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    <span class=\"built_in\">export</span> foo=bar;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"foo=[$<span class=\"variable\">$foo</span>]\"</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile文件的语法\"><a href=\"#Makefile文件的语法\" class=\"headerlink\" title=\"Makefile文件的语法\"></a>Makefile文件的语法</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>井号（#）在Makefile中表示注释。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是注释</span></span><br><span class=\"line\">result.txt: source.txt</span><br><span class=\"line\">    <span class=\"comment\"># 这是注释</span></span><br><span class=\"line\">    cp source.txt result.txt <span class=\"comment\"># 这也是注释</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"回声（echoing）\"><a href=\"#回声（echoing）\" class=\"headerlink\" title=\"回声（echoing）\"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>执行上面的规则，会得到下面的结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>在命令的前面加上@，就可以关闭回声。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"comment\"># 这是测试</span></span><br></pre></td></tr></table></figure>\n\n<p>现在再执行<code>make test</code>，就不会有任何输出。</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"comment\"># 这是测试</span></span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> TODO</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">        rm -f *.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>\n<h3 id=\"变量和赋值符\"><a href=\"#变量和赋值符\" class=\"headerlink\" title=\"变量和赋值符\"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> $(txt)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>:</span><br><span class=\"line\">    @<span class=\"built_in\">echo</span> $<span class=\"variable\">$HOME</span></span><br></pre></td></tr></table></figure>\n\n<p>有时，变量的值可能指向另一个变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 = $(v2)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p>\n<p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看<a href=\"http://stackoverflow.com/questions/448910/makefile-variable-assignment\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VARIABLE = value</span><br><span class=\"line\"><span class=\"comment\"># 在执行时扩展，允许递归扩展。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE := value</span><br><span class=\"line\"><span class=\"comment\"># 在定义时扩展。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE ?= value</span><br><span class=\"line\"><span class=\"comment\"># 只有在该变量为空时才设置值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">VARIABLE += value</span><br><span class=\"line\"><span class=\"comment\"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置变量（Implicit-Variables）\"><a href=\"#内置变量（Implicit-Variables）\" class=\"headerlink\" title=\"内置变量（Implicit Variables）\"></a>内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href=\"https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html\" target=\"_blank\" rel=\"noopener\">手册</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output:</span><br><span class=\"line\">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动变量（Automatic-Variables）\"><a href=\"#自动变量（Automatic-Variables）\" class=\"headerlink\" title=\"自动变量（Automatic Variables）\"></a>自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p>\n<p><strong>（1）$@</strong></p>\n<p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 $@ 就指代foo。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt b.txt:</span><br><span class=\"line\">    touch <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt:</span><br><span class=\"line\">    touch a.txt</span><br><span class=\"line\">b.txt:</span><br><span class=\"line\">    touch b.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）$&lt;</strong></p>\n<p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt: b.txt c.txt</span><br><span class=\"line\">    cp $&lt; <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>等同于下面的写法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.txt: b.txt c.txt</span><br><span class=\"line\">    cp b.txt a.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）$?</strong></p>\n<p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p>\n<p><strong>（4）$^</strong></p>\n<p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p>\n<p><strong>（5）$*</strong></p>\n<p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p>\n<p><strong>（6）$(@D) 和 $(@F)</strong></p>\n<p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p>\n<p>**（7）$(</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n<p>所有的自动变量清单，请看<a href=\"https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html\" target=\"_blank\" rel=\"noopener\">手册</a>。下面是自动变量的一个例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest/%.txt: src/%.txt</span><br><span class=\"line\">    @[ -d dest ] || mkdir dest</span><br><span class=\"line\">    cp $&lt; <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p>\n<h3 id=\"判断和循环\"><a href=\"#判断和循环\" class=\"headerlink\" title=\"判断和循环\"></a>判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifeq ($(CC),gcc)</span><br><span class=\"line\">  libs=$(libs_for_gcc)</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  libs=$(normal_libs)</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n<p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIST = one two three</span><br><span class=\"line\">all:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(LIST); <span class=\"keyword\">do</span> \\</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> $<span class=\"variable\">$i</span>; \\</span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\">all:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> one two three; <span class=\"keyword\">do</span> \\</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span>; \\</span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的运行结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one</span><br><span class=\"line\">two</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>Makefile 还可以使用函数，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"keyword\">function</span> arguments)</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>Makefile提供了许多<a href=\"http://www.gnu.org/software/make/manual/html_node/Functions.html\" target=\"_blank\" rel=\"noopener\">内置函数</a>，可供调用。下面是几个常用的内置函数。</p>\n<p><strong>（1）shell 函数</strong></p>\n<p>shell 函数用来执行 shell 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srcfiles := $(shell <span class=\"built_in\">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）wildcard 函数</strong></p>\n<p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）subst 函数</strong></p>\n<p>subst 函数用来文本替换，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(subst from,to,text)</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个稍微复杂的例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comma:= ,</span><br><span class=\"line\">empty:=</span><br><span class=\"line\"><span class=\"comment\"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class=\"line\">space:= $(empty) $(empty)</span><br><span class=\"line\">foo:= a b c</span><br><span class=\"line\">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class=\"line\"><span class=\"comment\"># bar is now `a,b,c'.</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）patsubst函数</strong></p>\n<p>patsubst 函数用于模式匹配的替换，格式如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）替换后缀名</strong></p>\n<p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p>\n<h2 id=\"Makefile-的实例\"><a href=\"#Makefile-的实例\" class=\"headerlink\" title=\"Makefile 的实例\"></a>Makefile 的实例</h2><p><strong>（1）执行多个目标</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: cleanall cleanobj cleandiff</span><br><span class=\"line\"></span><br><span class=\"line\">cleanall : cleanobj cleandiff</span><br><span class=\"line\">        rm program</span><br><span class=\"line\"></span><br><span class=\"line\">cleanobj :</span><br><span class=\"line\">        rm *.o</span><br><span class=\"line\"></span><br><span class=\"line\">cleandiff :</span><br><span class=\"line\">        rm *.diff</span><br></pre></td></tr></table></figure>\n\n<p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p>\n<p><strong>（2）编译C语言项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o</span><br><span class=\"line\">    cc -o edit main.o kbd.o command.o display.o</span><br><span class=\"line\"></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">    cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">    cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">    cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h</span><br><span class=\"line\">    cc -c display.c</span><br><span class=\"line\"></span><br><span class=\"line\">clean :</span><br><span class=\"line\">     rm edit main.o kbd.o command.o display.o</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: edit clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用make构建网站\"><a href=\"#使用make构建网站\" class=\"headerlink\" title=\"使用make构建网站\"></a>使用make构建网站</h2><p>本文来源<strong><a href=\"http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></strong></p>\n<h3 id=\"Make的优点\"><a href=\"#Make的优点\" class=\"headerlink\" title=\"Make的优点\"></a>Make的优点</h3><p>首先解释一下，为什么要用Make。</p>\n<p>目前，网站项目（尤其是Node.js项目）有三种构建方案。</p>\n<blockquote>\n<ul>\n<li>方案一：基于Node.js的专用构建工具（<a href=\"http://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">Grunt</a>、<a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">Gulp</a>、<a href=\"http://brunch.io/\" target=\"_blank\" rel=\"noopener\">Brunch</a>、<a href=\"https://github.com/broccolijs/broccoli\" target=\"_blank\" rel=\"noopener\">Broccoli</a>、<a href=\"http://mimosa.io/\" target=\"_blank\" rel=\"noopener\">Mimosa</a>）</li>\n<li>方案二：npm run命令（<a href=\"http://substack.net/task_automation_with_npm_run\" target=\"_blank\" rel=\"noopener\">教程1</a>、<a href=\"http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/\" target=\"_blank\" rel=\"noopener\">2</a>、<a href=\"http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/\" target=\"_blank\" rel=\"noopener\">3</a>）</li>\n<li>方案三：make命令</li>\n</ul>\n</blockquote>\n<p>我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。</p>\n<p><strong>（1）插件问题</strong></p>\n<p>Grunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。</p>\n<p><strong>（2）兼容性问题</strong></p>\n<p>插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，<a href=\"https://github.com/gruntjs/grunt-contrib-jshint\" target=\"_blank\" rel=\"noopener\">grunt-contrib-jshint插件</a>现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。</p>\n<p><strong>（3）语法问题</strong></p>\n<p>Grunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。</p>\n<p><strong>（4）功能问题</strong></p>\n<p>make已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。</p>\n<p>基于以上理由，我看好make。</p>\n<h3 id=\"常见的构建任务\"><a href=\"#常见的构建任务\" class=\"headerlink\" title=\"常见的构建任务\"></a>常见的构建任务</h3><p>下面是一些常见的网站构建任务。</p>\n<blockquote>\n<ul>\n<li>检查语法</li>\n<li>编译模板</li>\n<li>转码</li>\n<li>合并</li>\n<li>压缩</li>\n<li>测试</li>\n<li>删除</li>\n</ul>\n</blockquote>\n<p>这些任务用到 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a>、<a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">handlebars</a>、<a href=\"http://coffeescript.org/\" target=\"_blank\" rel=\"noopener\">CoffeeScript</a>、<a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"noopener\">uglifyjs</a>、<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">mocha</a> 等工具。对应的package.json文件如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"coffee-script\"</span>: <span class=\"string\">\"~1.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"handlebars\"</span>: <span class=\"string\">\"~3.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"jshint\"</span>: <span class=\"string\">\"^2.6.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mocha\"</span>: <span class=\"string\">\"~2.2.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"uglify-js\"</span>: <span class=\"string\">\"~2.4.17\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看，Make 命令怎么完成这些构建任务。</p>\n<h3 id=\"Makefile的通用配置\"><a href=\"#Makefile的通用配置\" class=\"headerlink\" title=\"Makefile的通用配置\"></a>Makefile的通用配置</h3><p>开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件（参见<a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">《Make 命令教程》</a>）。</p>\n<p>首先，写入两行通用配置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH  := node_modules/.bin:$(PATH)</span><br><span class=\"line\">SHELL := /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。</p>\n<p>PATH变量重新赋值为，优先在 node<em>modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node</em>modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。</p>\n<p>SHELL变量指定构建环境使用BASH。</p>\n<h3 id=\"检查语法错误\"><a href=\"#检查语法错误\" class=\"headerlink\" title=\"检查语法错误\"></a>检查语法错误</h3><p>第一个任务是，检查源码有没有语法错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">js_files = $(shell find ./lib -name <span class=\"string\">'*.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">lint: $(js_files)</span><br><span class=\"line\">    jshint $?</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make lint</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h3><p>第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/templates.js: templates/*.handlebars</span><br><span class=\"line\">    mkdir -p $(dir <span class=\"variable\">$@</span>)</span><br><span class=\"line\">    handlebars templates/*.handlebars &gt; <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\">template: build/templates.js</span><br></pre></td></tr></table></figure>\n\n<p>上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make template</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Coffee脚本转码\"><a href=\"#Coffee脚本转码\" class=\"headerlink\" title=\"Coffee脚本转码\"></a>Coffee脚本转码</h3><p>第三个任务是，将CofferScript脚本转为JavaScript脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source_files := $(wildcard lib/*.coffee)</span><br><span class=\"line\">build_files  := $(source_files:lib/%.coffee=build/%.js)</span><br><span class=\"line\"></span><br><span class=\"line\">build/%.js: lib/%.coffee</span><br><span class=\"line\">    coffee -co $(dir <span class=\"variable\">$@</span>) $&lt;</span><br><span class=\"line\"></span><br><span class=\"line\">coffee: $(build_files)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，首先获取所有的Coffee脚本文件，存放在变量source<em>files，函数wildcard用来扩展通配符。然后，将变量source</em>files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make coffee</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并文件\"><a href=\"#合并文件\" class=\"headerlink\" title=\"合并文件\"></a>合并文件</h3><p>使用cat命令，合并多个文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS_FILES := $(wildcard build/*.js)</span><br><span class=\"line\">OUTPUT := build/bundle.js</span><br><span class=\"line\"></span><br><span class=\"line\">concat: $(JS_FILES)</span><br><span class=\"line\">    cat $^ &gt; $(OUTPUT)</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make concat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"压缩JavaScript脚本\"><a href=\"#压缩JavaScript脚本\" class=\"headerlink\" title=\"压缩JavaScript脚本\"></a>压缩JavaScript脚本</h3><p>将所有JavaScript脚本，压缩为build目录下的app.js。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app_bundle := build/app.js</span><br><span class=\"line\"></span><br><span class=\"line\">$(app_bundle): $(build_files) $(template_js)</span><br><span class=\"line\">    uglifyjs -cmo <span class=\"variable\">$@</span> $^</span><br><span class=\"line\"></span><br><span class=\"line\">min: $(app_bundle)</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make min</span><br></pre></td></tr></table></figure>\n\n<p>还有另一种写法，可以另行指定压缩工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UGLIFY ?= uglify</span><br><span class=\"line\"></span><br><span class=\"line\">$(app_bundle): $(build_files) $(template_js)</span><br><span class=\"line\">    $(UGLIFY) -cmo <span class=\"variable\">$@</span> $^</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。</p>\n<p>调用时这样写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make UGLIFY=node_modules/.bin/jsmin min</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。</p>\n<h3 id=\"删除临时文件\"><a href=\"#删除临时文件\" class=\"headerlink\" title=\"删除临时文件\"></a>删除临时文件</h3><p>构建结束前，删除所有临时文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">    rm -rf build</span><br></pre></td></tr></table></figure>\n\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make clean</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>假定测试工具是mocha，所有测试用例放在test目录下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span>: $(app_bundle) $(test_js)</span><br><span class=\"line\">    mocha</span><br></pre></td></tr></table></figure>\n\n<p>当脚本和测试用例都存在，上面代码就会执行mocha。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多任务执行\"><a href=\"#多任务执行\" class=\"headerlink\" title=\"多任务执行\"></a>多任务执行</h3><p>构建过程需要一次性执行多个任务，可以指定一个多任务目标。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build: template concat min clean</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。</p>\n<p>使用时调用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make build</span><br></pre></td></tr></table></figure>\n\n<p>如果这行规则在Makefile的最前面，执行时可以省略目标名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -j build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明伪文件\"><a href=\"#声明伪文件\" class=\"headerlink\" title=\"声明伪文件\"></a>声明伪文件</h3><p>最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: lint template coffee concat min <span class=\"built_in\">test</span> clean build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Makefile文件示例\"><a href=\"#Makefile文件示例\" class=\"headerlink\" title=\"Makefile文件示例\"></a>Makefile文件示例</h3><p>下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。</p>\n<p>实例一。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT = <span class=\"string\">\"My Fancy Node.js project\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">all: install <span class=\"built_in\">test</span> server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">test</span>: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Testing <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_PATH=.; \\</span><br><span class=\"line\">    ./node_modules/mocha/bin/mocha;</span><br><span class=\"line\"></span><br><span class=\"line\">install: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Installing <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    npm install</span><br><span class=\"line\"></span><br><span class=\"line\">update: ;@<span class=\"built_in\">echo</span> <span class=\"string\">\"Updating <span class=\"variable\">$&#123;PROJECT&#125;</span>.....\"</span>; \\</span><br><span class=\"line\">    git pull --rebase; \\</span><br><span class=\"line\">    npm install</span><br><span class=\"line\"></span><br><span class=\"line\">clean : ;</span><br><span class=\"line\">    rm -rf node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: <span class=\"built_in\">test</span> server install clean update</span><br></pre></td></tr></table></figure>\n\n<p>实例二。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all: build-js build-css</span><br><span class=\"line\"></span><br><span class=\"line\">build-js:</span><br><span class=\"line\">  browserify -t brfs src/app.js &gt; site/app.js</span><br><span class=\"line\"></span><br><span class=\"line\">build-css:</span><br><span class=\"line\">  stylus src/style.styl &gt; site/style.css</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY build-js build-css</span><br></pre></td></tr></table></figure>\n\n<p>参考链接</p>\n<ul>\n<li>Jess Telford, <a href=\"https://github.com/jesstelford/cloverfield-build-make\" target=\"_blank\" rel=\"noopener\">Example using Makefile for cloverfield</a></li>\n<li>Oskar Schöldström, <a href=\"http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/\" target=\"_blank\" rel=\"noopener\">How to use Makefiles in your web projects</a></li>\n<li>James Coglan, <a href=\"https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/\" target=\"_blank\" rel=\"noopener\">Building JavaScript projects with Make</a></li>\n<li>Rob Ashton, <a href=\"http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html\" target=\"_blank\" rel=\"noopener\">The joy of make</a></li>\n</ul>\n"},{"layout":"post","title":"正则表达式教程","date":"2020-03-18T19:00:00.000Z","description":"优秀的程序员需要良好的基础","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321004350.png","optimized_image":null,"author":"deerchao","_content":"\n**本文来源[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)** 原作者：deerchao\n\n相关链接：\n\n- [常用正则表达式](https://deerchao.cn/tutorials/regex/common.htm)\n- [JavaScript 在线正则测试器](https://deerchao.cn/tools/wegester/)\n- [.Net 正则表达式测试工具](https://deerchao.cn/tools/regester/)\n- [正则表达式引擎特性对比](https://deerchao.cn/tutorials/regex/diffs.html)\n\n## 本文目标\n\n30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n\n## 如何使用本教程\n\n别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。\n\n除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？\n\n[清除格式](https://deerchao.cn/tutorials/regex/regex.htm) 文本格式约定：**专业术语** 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) *对其进行匹配的源字符串* 对正则表达式或其中一部分的说明\n\n[隐藏边注](https://deerchao.cn/tutorials/regex/regex.htm) 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。\n\n本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看[正则表达式引擎特性对比](https://deerchao.cn/tutorials/regex/diffs.html)。\n\n最重要的是——请给我*30分钟*，如果你没有使用正则表达式的经验，请不要试图在30*秒*内入门——除非你是超人 :)\n\n## 正则表达式到底是什么东西？\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n很可能你使用过Windows/Dos下用于文件查找的**通配符(wildcard)**，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n**字符**是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。**字符串**是0个或更多个字符的序列。**文本**也就是文字，字符串。说某个字符串**匹配**某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。\n\n## 入门\n\n学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。\n\n假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。\n\n这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*hi*,*HI*,*Hi*,*hI*这四种情况中的任意一种。\n\n不幸的是，很多单词里包含*hi*这两个连续的字符，比如*him*,*history*,*high*等等。用hi来查找的话，这里边的*hi*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。\n\n\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**。\n\n如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。\n\n假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。\n\n这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.*\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\n\n换行符就是'\\n',ASCII编码为10(十六进制0x0A)的字符。\n\n如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：\n\n0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。\n\n这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。\n\n为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。\n\n## 测试正则表达式\n\n如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。\n\n不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 [Regester](https://deerchao.cn/tools/regester/)。请参考该页面的说明来安装和运行该软件。\n\n你也可以试试这个在线测试工具：[Wegester, JavaScript正则表达式测试器。](https://deerchao.cn/tools/wegester/)\n\n## 元字符\n\n现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。\n\n对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。\n\n下面来看看更多的例子：\n\n\\ba\\w*\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。\n\n\\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\n\n\\b\\w{6}\\b 匹配刚好6个字符的单词。\n\n好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)\n\n| 代码 | 说明                         |\n| ---- | ---------------------------- |\n| .    | 匹配除换行符以外的任意字符   |\n| \\w   | 匹配字母或数字或下划线或汉字 |\n| \\s   | 匹配任意的空白符             |\n| \\d   | 匹配数字                     |\n| \\b   | 匹配单词的开始或结束         |\n| ^    | 匹配字符串的开始             |\n| $    | 匹配字符串的结束             |\n\n元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。\n\n这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。\n\n因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。\n\n和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。\n\n正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。\n\n## 字符转义\n\n如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用\\.和\\*。当然，要查找\\本身，你也得用\\\\.\n\n例如：deerchao\\.cn匹配deerchao.cn，C:\\\\Windows匹配C:\\Windows。\n\n## 重复\n\n你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：\n\n| 代码/语法 | 说明             |\n| --------- | ---------------- |\n| *         | 重复零次或更多次 |\n| +         | 重复一次或更多次 |\n| ?         | 重复零次或一次   |\n| {n}       | 重复n次          |\n| {n,}      | 重复n次或更多次  |\n| {n,m}     | 重复n到m次       |\n\n下面是一些使用重复的例子：\n\nWindows\\d+匹配Windows后面跟1个或更多数字\n\n^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n\n很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。\n\n我们也可以轻松地指定一个字符**范围**，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。\n\n下面是一个更复杂的表达式：\\(?0\\d{2}[) -]?\\d{8}。\n\n这个表达式可以匹配几种格式的电话号码，像*(010)88886666*，或*022-22334455*，或*02912345678*等。我们对它进行一些分析吧：首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n\n“(”和“)”也是元字符，后面的[分组节](https://deerchao.cn/tutorials/regex/regex.htm#grouping)里会提到，所以在这里需要使用[转义](https://deerchao.cn/tutorials/regex/regex.htm#escape)。\n\n## 分枝条件\n\n不幸的是，刚才那个表达式也能匹配*010)12345678*或*(022-87654321*这样的“不正确”的格式。要解决这个问题，我们需要用到**分枝条件**。正则表达式里的**分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：\n\n0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\n\n\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n\n\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n\n## 分组\n\n我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定**子表达式**(也叫做**分组**)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。\n\n(\\d{1,3}\\.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\n\n不幸的是，它也将匹配*256.300.888.999*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。\n\n理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。\n\nIP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：\n\n| 代码/语法 | 说明                                       |\n| --------- | ------------------------------------------ |\n| \\W        | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S        | 匹配任意不是空白符的字符                   |\n| \\D        | 匹配任意非数字的字符                       |\n| \\B        | 匹配不是单词开头或结束的位置               |\n| [^x]      | 匹配除了x以外的任意字符                    |\n| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |\n\n例子：\\S+匹配不包含空白符的字符串。\n\n<a[^>]+>匹配用尖括号括起来的以a开头的字符串。\n\n## 后向引用\n\n使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n\n呃……其实,组号分配还不像我刚说得那么简单：\n\n- 分组0对应整个正则表达式\n- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号\n- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．\n\n**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：\n\n\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。\n\n你也可以自己指定子表达式的**组名**。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\\w+)(或者把尖括号换成'也行：(?'Word'\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b。\n\n使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：\n\n| 分类         | 代码/语法                                                    | 说明                                                         |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 捕获         | (exp)                                                        | 匹配exp,并捕获文本到自动命名的组里                           |\n| (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |                                                              |\n| (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |                                                              |\n| 零宽断言     | (?=exp)                                                      | 匹配exp前面的位置                                            |\n| (?<=exp)     | 匹配exp后面的位置                                            |                                                              |\n| (?!exp)      | 匹配后面跟的不是exp的位置                                    |                                                              |\n| (?<!exp)     | 匹配前面不是exp的位置                                        |                                                              |\n| 注释         | (?#comment)                                                  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |\n\n我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？\n\n## 零宽断言\n\n接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为**零宽断言**。最好还是拿例子来说明吧：\n\n断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。\n\n(?=exp)也叫**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找*I'm singing while you're dancing.*时，它会匹配sing和danc。\n\n(?<=exp)也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找*reading a book*时，它匹配ading。\n\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\\d)\\d{3})+\\b，用它对*1234567890*进行查找时结果是234567890。\n\n下面这个例子同时使用了这两种断言：(?<=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。\n\n## 负向零宽断言\n\n前面我们提到过怎么查找**不是某个字符或不在某个字符类里**的字符的方法(反义)。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n\n\\b\\w*q[^u]\\w*\\b匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq**,**Benq**，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w*q[^u]\\w*\\b就能匹配整个*Iraq fighting*。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\\b\\w*q(?!u)\\w*\\b。\n\n**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。\n\n同理，我们可以用(?<!exp),**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：(?<![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n\n一个更复杂的例子：(?<=<(\\w+)>).*(?=<\\/\\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\\w+)>)指定了这样的**前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个**后缀**(?=<\\/\\1>)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。\n\n## 注释\n\n小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)。\n\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n\n```\n      (?<=    # 断言要匹配的文本的前缀\n      <(\\w+)> # 查找尖括号括起来的内容\n              # (即HTML/XML标签)\n      )       # 前缀结束\n      .*      # 匹配任意文本\n      (?=     # 断言要匹配的文本的后缀\n      <\\/\\1>  # 查找尖括号括起来的内容\n              # 查找尖括号括起来的内容\n      )       # 后缀结束\n```\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索*aabab*的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：\n\na.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n\n为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。\n\n| 代码/语法 | 说明                            |\n| --------- | ------------------------------- |\n| *?        | 重复任意次，但尽可能少重复      |\n| +?        | 重复1次或更多次，但尽可能少重复 |\n| ??        | 重复0次或1次，但尽可能少重复    |\n| {n,m}?    | 重复n到m次，但尽可能少重复      |\n| {n,}?     | 重复n次以上，但尽可能少重复     |\n\n## 处理选项\n\n上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：\n\n| 名称                              | 说明                                                         |\n| --------------------------------- | ------------------------------------------------------------ |\n| IgnoreCase(忽略大小写)            | 匹配时不区分大小写。                                         |\n| Multiline(多行模式)               | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) |\n| Singleline(单行模式)              | 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。          |\n| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。                |\n| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                                     |\n\n在C#中，你可以使用[Regex(String, RegexOptions)构造函数](http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx)来设置正则表达式的处理选项。如：Regex regex = new Regex(@\"\\ba\\w{6}\\b\", RegexOptions.IgnoreCase);\n\n一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.\n\n目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。\n\n## 平衡组/递归匹配\n\n有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\\(.+\\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如*( 5 / ( 3 + 2 ) ) )*，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？\n\n这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。\n\n为了避免(和\\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把*xx   aa> yy*这样的字符串里，最长的配对的尖括号内的内容捕获出来？\n\n这里需要用到以下的语法构造：\n\n- (?'group') 把捕获的内容命名为group,并压入**堆栈(Stack)**\n- (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败\n- (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分\n- (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败\n\n我们需要做的是每碰到了左括号，就在压入一个\"Open\",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。\n\n```\n<                   #最外层的左括号\n  [^<>]*            #它后面非括号的内容\n  (\n      (\n        (?'Open'<)  #左括号，压入\"Open\"\n        [^<>]*      #左括号后面的内容\n      )+\n      (\n        (?'-Open'>) #右括号，弹出一个\"Open\"\n        [^<>]*      #右括号后面的内容\n      )+\n  )*\n  (?(Open)(?!))     #最外层的右括号前检查\n                    #若还有未弹出的\"Open\"\n                    #则匹配失败\n\n>                #最外层的右括号\n```\n\n平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.\n\n如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个\"group\"，第二个就是从黑板上擦掉一个\"group\"，第三个就是看黑板上写的还有没有\"group\"，如果有就继续匹配yes部分，否则就匹配no部分。\n\n## 还有些什么东西没提到\n\n上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们--当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看[关于正则表达式语言元素的MSDN在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)。\n\n| 代码/语法        | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| \\a               | 报警字符(打印它的效果是电脑嘀一声)                           |\n| \\b               | 通常是单词分界位置，但如果在字符类里使用代表退格             |\n| \\t               | 制表符，Tab                                                  |\n| \\r               | 回车                                                         |\n| \\v               | 竖向制表符                                                   |\n| \\f               | 换页符                                                       |\n| \\n               | 换行符                                                       |\n| \\e               | Escape                                                       |\n| \\0nn             | ASCII代码中八进制代码为nn的字符                              |\n| \\xnn             | ASCII代码中十六进制代码为nn的字符                            |\n| \\unnnn           | Unicode代码中十六进制代码为nnnn的字符                        |\n| \\cN              | ASCII控制字符。比如\\cC代表Ctrl+C                             |\n| \\A               | 字符串开头(类似^，但不受处理多行选项的影响)                  |\n| \\Z               | 字符串结尾或行尾(不受处理多行选项的影响)                     |\n| \\z               | 字符串结尾(类似$，但不受处理多行选项的影响)                  |\n| \\G               | 当前搜索的开头                                               |\n| \\p{name}         | Unicode中命名为name的字符类，例如\\p{IsGreek}                 |\n| (?>exp)          | 贪婪子表达式                                                 |\n| (?<x>-<y>exp)    | 平衡组                                                       |\n| (?im-nsx:exp)    | 在子表达式exp中改变处理选项                                  |\n| (?im-nsx)        | 为表达式后面的部分改变处理选项                               |\n| (?(exp)yes\\|no)  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |\n| (?(exp)yes)      | 同上，只是使用空表达式作为no                                 |\n| (?(name)yes\\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |\n| (?(name)yes)     | 同上，只是使用空表达式作为no                                 |\n\n## 联系作者\n\n好吧，我承认，我骗了你，读到这里你肯定花了不止30分钟。相信我，这是我的错，而不是因为你太笨。我之所以说\"30分钟\"，是为了让你有信心，有耐心继续下去。既然你看到了这里，那证明我的阴谋成功了。被忽悠的感觉很爽吧？\n\n要投诉我，或者觉得我其实可以忽悠得更高明，或者有关于正则表达式的问题, 可以发邮件到 deerchao#qq#com。如果本文给了你帮助，你可以使用支付宝或微信支付向我打赏。点击本页右上方的“打赏”即可看到支付二维码，可能你得先[回到页面最顶端](https://deerchao.cn/tutorials/regex/regex.htm#top)。\n\n## 网上的资源及本文参考文献\n\n- [精通正则表达式(第3版)](https://u.jd.com/0yfKdc)\n- [微软的正则表达式教程](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions)\n- [Regex类(微软文档)](https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex)\n- [专业的正则表达式教学网站(英文)](http://www.regular-expressions.info/)\n- [关于.Net下的平衡组的详细讨论（英文）](http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx)","source":"_posts/2020-03-18-正则表达式教程.md","raw":"---\nlayout: post\ntitle:  正则表达式教程\ndate:   2020-03-18 12:00:00\ndescription: 优秀的程序员需要良好的基础\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321004350.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\nauthor: deerchao\n---\n\n**本文来源[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)** 原作者：deerchao\n\n相关链接：\n\n- [常用正则表达式](https://deerchao.cn/tutorials/regex/common.htm)\n- [JavaScript 在线正则测试器](https://deerchao.cn/tools/wegester/)\n- [.Net 正则表达式测试工具](https://deerchao.cn/tools/regester/)\n- [正则表达式引擎特性对比](https://deerchao.cn/tutorials/regex/diffs.html)\n\n## 本文目标\n\n30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n\n## 如何使用本教程\n\n别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。\n\n除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？\n\n[清除格式](https://deerchao.cn/tutorials/regex/regex.htm) 文本格式约定：**专业术语** 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) *对其进行匹配的源字符串* 对正则表达式或其中一部分的说明\n\n[隐藏边注](https://deerchao.cn/tutorials/regex/regex.htm) 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。\n\n本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看[正则表达式引擎特性对比](https://deerchao.cn/tutorials/regex/diffs.html)。\n\n最重要的是——请给我*30分钟*，如果你没有使用正则表达式的经验，请不要试图在30*秒*内入门——除非你是超人 :)\n\n## 正则表达式到底是什么东西？\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n很可能你使用过Windows/Dos下用于文件查找的**通配符(wildcard)**，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n**字符**是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。**字符串**是0个或更多个字符的序列。**文本**也就是文字，字符串。说某个字符串**匹配**某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。\n\n## 入门\n\n学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。\n\n假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。\n\n这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*hi*,*HI*,*Hi*,*hI*这四种情况中的任意一种。\n\n不幸的是，很多单词里包含*hi*这两个连续的字符，比如*him*,*history*,*high*等等。用hi来查找的话，这里边的*hi*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。\n\n\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**。\n\n如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。\n\n假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。\n\n这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.*\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\n\n换行符就是'\\n',ASCII编码为10(十六进制0x0A)的字符。\n\n如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：\n\n0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。\n\n这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。\n\n为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。\n\n## 测试正则表达式\n\n如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。\n\n不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 [Regester](https://deerchao.cn/tools/regester/)。请参考该页面的说明来安装和运行该软件。\n\n你也可以试试这个在线测试工具：[Wegester, JavaScript正则表达式测试器。](https://deerchao.cn/tools/wegester/)\n\n## 元字符\n\n现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。\n\n对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。\n\n下面来看看更多的例子：\n\n\\ba\\w*\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。\n\n\\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\n\n\\b\\w{6}\\b 匹配刚好6个字符的单词。\n\n好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)\n\n| 代码 | 说明                         |\n| ---- | ---------------------------- |\n| .    | 匹配除换行符以外的任意字符   |\n| \\w   | 匹配字母或数字或下划线或汉字 |\n| \\s   | 匹配任意的空白符             |\n| \\d   | 匹配数字                     |\n| \\b   | 匹配单词的开始或结束         |\n| ^    | 匹配字符串的开始             |\n| $    | 匹配字符串的结束             |\n\n元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。\n\n这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。\n\n因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。\n\n和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。\n\n正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。\n\n## 字符转义\n\n如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用\\.和\\*。当然，要查找\\本身，你也得用\\\\.\n\n例如：deerchao\\.cn匹配deerchao.cn，C:\\\\Windows匹配C:\\Windows。\n\n## 重复\n\n你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：\n\n| 代码/语法 | 说明             |\n| --------- | ---------------- |\n| *         | 重复零次或更多次 |\n| +         | 重复一次或更多次 |\n| ?         | 重复零次或一次   |\n| {n}       | 重复n次          |\n| {n,}      | 重复n次或更多次  |\n| {n,m}     | 重复n到m次       |\n\n下面是一些使用重复的例子：\n\nWindows\\d+匹配Windows后面跟1个或更多数字\n\n^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n\n很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。\n\n我们也可以轻松地指定一个字符**范围**，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。\n\n下面是一个更复杂的表达式：\\(?0\\d{2}[) -]?\\d{8}。\n\n这个表达式可以匹配几种格式的电话号码，像*(010)88886666*，或*022-22334455*，或*02912345678*等。我们对它进行一些分析吧：首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n\n“(”和“)”也是元字符，后面的[分组节](https://deerchao.cn/tutorials/regex/regex.htm#grouping)里会提到，所以在这里需要使用[转义](https://deerchao.cn/tutorials/regex/regex.htm#escape)。\n\n## 分枝条件\n\n不幸的是，刚才那个表达式也能匹配*010)12345678*或*(022-87654321*这样的“不正确”的格式。要解决这个问题，我们需要用到**分枝条件**。正则表达式里的**分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：\n\n0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\n\n\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n\n\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n\n## 分组\n\n我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定**子表达式**(也叫做**分组**)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。\n\n(\\d{1,3}\\.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\n\n不幸的是，它也将匹配*256.300.888.999*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。\n\n理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。\n\nIP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：\n\n| 代码/语法 | 说明                                       |\n| --------- | ------------------------------------------ |\n| \\W        | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S        | 匹配任意不是空白符的字符                   |\n| \\D        | 匹配任意非数字的字符                       |\n| \\B        | 匹配不是单词开头或结束的位置               |\n| [^x]      | 匹配除了x以外的任意字符                    |\n| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |\n\n例子：\\S+匹配不包含空白符的字符串。\n\n<a[^>]+>匹配用尖括号括起来的以a开头的字符串。\n\n## 后向引用\n\n使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n\n呃……其实,组号分配还不像我刚说得那么简单：\n\n- 分组0对应整个正则表达式\n- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号\n- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．\n\n**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：\n\n\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。\n\n你也可以自己指定子表达式的**组名**。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\\w+)(或者把尖括号换成'也行：(?'Word'\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b。\n\n使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：\n\n| 分类         | 代码/语法                                                    | 说明                                                         |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 捕获         | (exp)                                                        | 匹配exp,并捕获文本到自动命名的组里                           |\n| (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |                                                              |\n| (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |                                                              |\n| 零宽断言     | (?=exp)                                                      | 匹配exp前面的位置                                            |\n| (?<=exp)     | 匹配exp后面的位置                                            |                                                              |\n| (?!exp)      | 匹配后面跟的不是exp的位置                                    |                                                              |\n| (?<!exp)     | 匹配前面不是exp的位置                                        |                                                              |\n| 注释         | (?#comment)                                                  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |\n\n我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？\n\n## 零宽断言\n\n接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为**零宽断言**。最好还是拿例子来说明吧：\n\n断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。\n\n(?=exp)也叫**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找*I'm singing while you're dancing.*时，它会匹配sing和danc。\n\n(?<=exp)也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找*reading a book*时，它匹配ading。\n\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\\d)\\d{3})+\\b，用它对*1234567890*进行查找时结果是234567890。\n\n下面这个例子同时使用了这两种断言：(?<=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。\n\n## 负向零宽断言\n\n前面我们提到过怎么查找**不是某个字符或不在某个字符类里**的字符的方法(反义)。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n\n\\b\\w*q[^u]\\w*\\b匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq**,**Benq**，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w*q[^u]\\w*\\b就能匹配整个*Iraq fighting*。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\\b\\w*q(?!u)\\w*\\b。\n\n**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。\n\n同理，我们可以用(?<!exp),**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：(?<![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n\n一个更复杂的例子：(?<=<(\\w+)>).*(?=<\\/\\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\\w+)>)指定了这样的**前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个**后缀**(?=<\\/\\1>)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。\n\n## 注释\n\n小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)。\n\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n\n```\n      (?<=    # 断言要匹配的文本的前缀\n      <(\\w+)> # 查找尖括号括起来的内容\n              # (即HTML/XML标签)\n      )       # 前缀结束\n      .*      # 匹配任意文本\n      (?=     # 断言要匹配的文本的后缀\n      <\\/\\1>  # 查找尖括号括起来的内容\n              # 查找尖括号括起来的内容\n      )       # 后缀结束\n```\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索*aabab*的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：\n\na.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n\n为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。\n\n| 代码/语法 | 说明                            |\n| --------- | ------------------------------- |\n| *?        | 重复任意次，但尽可能少重复      |\n| +?        | 重复1次或更多次，但尽可能少重复 |\n| ??        | 重复0次或1次，但尽可能少重复    |\n| {n,m}?    | 重复n到m次，但尽可能少重复      |\n| {n,}?     | 重复n次以上，但尽可能少重复     |\n\n## 处理选项\n\n上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：\n\n| 名称                              | 说明                                                         |\n| --------------------------------- | ------------------------------------------------------------ |\n| IgnoreCase(忽略大小写)            | 匹配时不区分大小写。                                         |\n| Multiline(多行模式)               | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) |\n| Singleline(单行模式)              | 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。          |\n| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。                |\n| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                                     |\n\n在C#中，你可以使用[Regex(String, RegexOptions)构造函数](http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx)来设置正则表达式的处理选项。如：Regex regex = new Regex(@\"\\ba\\w{6}\\b\", RegexOptions.IgnoreCase);\n\n一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.\n\n目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。\n\n## 平衡组/递归匹配\n\n有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\\(.+\\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如*( 5 / ( 3 + 2 ) ) )*，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？\n\n这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。\n\n为了避免(和\\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把*xx   aa> yy*这样的字符串里，最长的配对的尖括号内的内容捕获出来？\n\n这里需要用到以下的语法构造：\n\n- (?'group') 把捕获的内容命名为group,并压入**堆栈(Stack)**\n- (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败\n- (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分\n- (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败\n\n我们需要做的是每碰到了左括号，就在压入一个\"Open\",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。\n\n```\n<                   #最外层的左括号\n  [^<>]*            #它后面非括号的内容\n  (\n      (\n        (?'Open'<)  #左括号，压入\"Open\"\n        [^<>]*      #左括号后面的内容\n      )+\n      (\n        (?'-Open'>) #右括号，弹出一个\"Open\"\n        [^<>]*      #右括号后面的内容\n      )+\n  )*\n  (?(Open)(?!))     #最外层的右括号前检查\n                    #若还有未弹出的\"Open\"\n                    #则匹配失败\n\n>                #最外层的右括号\n```\n\n平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.\n\n如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个\"group\"，第二个就是从黑板上擦掉一个\"group\"，第三个就是看黑板上写的还有没有\"group\"，如果有就继续匹配yes部分，否则就匹配no部分。\n\n## 还有些什么东西没提到\n\n上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们--当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看[关于正则表达式语言元素的MSDN在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)。\n\n| 代码/语法        | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| \\a               | 报警字符(打印它的效果是电脑嘀一声)                           |\n| \\b               | 通常是单词分界位置，但如果在字符类里使用代表退格             |\n| \\t               | 制表符，Tab                                                  |\n| \\r               | 回车                                                         |\n| \\v               | 竖向制表符                                                   |\n| \\f               | 换页符                                                       |\n| \\n               | 换行符                                                       |\n| \\e               | Escape                                                       |\n| \\0nn             | ASCII代码中八进制代码为nn的字符                              |\n| \\xnn             | ASCII代码中十六进制代码为nn的字符                            |\n| \\unnnn           | Unicode代码中十六进制代码为nnnn的字符                        |\n| \\cN              | ASCII控制字符。比如\\cC代表Ctrl+C                             |\n| \\A               | 字符串开头(类似^，但不受处理多行选项的影响)                  |\n| \\Z               | 字符串结尾或行尾(不受处理多行选项的影响)                     |\n| \\z               | 字符串结尾(类似$，但不受处理多行选项的影响)                  |\n| \\G               | 当前搜索的开头                                               |\n| \\p{name}         | Unicode中命名为name的字符类，例如\\p{IsGreek}                 |\n| (?>exp)          | 贪婪子表达式                                                 |\n| (?<x>-<y>exp)    | 平衡组                                                       |\n| (?im-nsx:exp)    | 在子表达式exp中改变处理选项                                  |\n| (?im-nsx)        | 为表达式后面的部分改变处理选项                               |\n| (?(exp)yes\\|no)  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |\n| (?(exp)yes)      | 同上，只是使用空表达式作为no                                 |\n| (?(name)yes\\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |\n| (?(name)yes)     | 同上，只是使用空表达式作为no                                 |\n\n## 联系作者\n\n好吧，我承认，我骗了你，读到这里你肯定花了不止30分钟。相信我，这是我的错，而不是因为你太笨。我之所以说\"30分钟\"，是为了让你有信心，有耐心继续下去。既然你看到了这里，那证明我的阴谋成功了。被忽悠的感觉很爽吧？\n\n要投诉我，或者觉得我其实可以忽悠得更高明，或者有关于正则表达式的问题, 可以发邮件到 deerchao#qq#com。如果本文给了你帮助，你可以使用支付宝或微信支付向我打赏。点击本页右上方的“打赏”即可看到支付二维码，可能你得先[回到页面最顶端](https://deerchao.cn/tutorials/regex/regex.htm#top)。\n\n## 网上的资源及本文参考文献\n\n- [精通正则表达式(第3版)](https://u.jd.com/0yfKdc)\n- [微软的正则表达式教程](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions)\n- [Regex类(微软文档)](https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex)\n- [专业的正则表达式教学网站(英文)](http://www.regular-expressions.info/)\n- [关于.Net下的平衡组的详细讨论（英文）](http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx)","slug":"正则表达式教程","published":1,"updated":"2020-03-29T06:59:20.714Z","photos":[],"link":"","_id":"ck8ct7j5r000mgtviatsyal1r","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>本文来源<a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">正则表达式30分钟入门教程</a></strong> 原作者：deerchao</p>\n<p>相关链接：</p>\n<ul>\n<li><a href=\"https://deerchao.cn/tutorials/regex/common.htm\" target=\"_blank\" rel=\"noopener\">常用正则表达式</a></li>\n<li><a href=\"https://deerchao.cn/tools/wegester/\" target=\"_blank\" rel=\"noopener\">JavaScript 在线正则测试器</a></li>\n<li><a href=\"https://deerchao.cn/tools/regester/\" target=\"_blank\" rel=\"noopener\">.Net 正则表达式测试工具</a></li>\n<li><a href=\"https://deerchao.cn/tutorials/regex/diffs.html\" target=\"_blank\" rel=\"noopener\">正则表达式引擎特性对比</a></li>\n</ul>\n<h2 id=\"本文目标\"><a href=\"#本文目标\" class=\"headerlink\" title=\"本文目标\"></a>本文目标</h2><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>\n<h2 id=\"如何使用本教程\"><a href=\"#如何使用本教程\" class=\"headerlink\" title=\"如何使用本教程\"></a>如何使用本教程</h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p>\n<p>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？</p>\n<p><a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">清除格式</a> 文本格式约定：<strong>专业术语</strong> 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) <em>对其进行匹配的源字符串</em> 对正则表达式或其中一部分的说明</p>\n<p><a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">隐藏边注</a> 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。</p>\n<p>本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看<a href=\"https://deerchao.cn/tutorials/regex/diffs.html\" target=\"_blank\" rel=\"noopener\">正则表达式引擎特性对比</a>。</p>\n<p>最重要的是——请给我<em>30分钟</em>，如果你没有使用正则表达式的经验，请不要试图在30<em>秒</em>内入门——除非你是超人 :)</p>\n<h2 id=\"正则表达式到底是什么东西？\"><a href=\"#正则表达式到底是什么东西？\" class=\"headerlink\" title=\"正则表达式到底是什么东西？\"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p>很可能你使用过Windows/Dos下用于文件查找的<strong>通配符(wildcard)</strong>，也就是<em>和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索</em>.doc。在这里，<em>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或*0376-7654321</em>)。</p>\n<p><strong>字符</strong>是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。<strong>字符串</strong>是0个或更多个字符的序列。<strong>文本</strong>也就是文字，字符串。说某个字符串<strong>匹配</strong>某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。</p>\n<p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p>\n<p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<em>hi</em>,<em>HI</em>,<em>Hi</em>,<em>hI</em>这四种情况中的任意一种。</p>\n<p>不幸的是，很多单词里包含<em>hi<em>这两个连续的字符，比如</em>him</em>,<em>history</em>,<em>high</em>等等。用hi来查找的话，这里边的<em>hi</em>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。</p>\n<p>\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p>\n<p>如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。</p>\n<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。</p>\n<p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.<em>连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.</em>\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p>\n<p>换行符就是’\\n’,ASCII编码为10(十六进制0x0A)的字符。</p>\n<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p>\n<p>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>\n<p>这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p>\n<p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。</p>\n<h2 id=\"测试正则表达式\"><a href=\"#测试正则表达式\" class=\"headerlink\" title=\"测试正则表达式\"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p>\n<p>不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 <a href=\"https://deerchao.cn/tools/regester/\" target=\"_blank\" rel=\"noopener\">Regester</a>。请参考该页面的说明来安装和运行该软件。</p>\n<p>你也可以试试这个在线测试工具：<a href=\"https://deerchao.cn/tools/wegester/\" target=\"_blank\" rel=\"noopener\">Wegester, JavaScript正则表达式测试器。</a></p>\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。</p>\n<p>对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</p>\n<p>下面来看看更多的例子：</p>\n<p>\\ba\\w<em>\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w</em>)，最后是单词结束处(\\b)。</p>\n<p>\\d+匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p>\n<p>\\b\\w{6}\\b 匹配刚好6个字符的单词。</p>\n<p>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。</p>\n<p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p>\n<p>因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>\n<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>\n<p>正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\</em>。当然，要查找\\本身，你也得用\\.</p>\n<p>例如：deerchao.cn匹配deerchao.cn，C:\\Windows匹配C:\\Windows。</p>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><p>你已经看过了前面的<em>,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如</em>,{5,12}等)：</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<p>下面是一些使用重复的例子：</p>\n<p>Windows\\d+匹配Windows后面跟1个或更多数字</p>\n<p>^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>\n<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>\n<p>我们也可以轻松地指定一个字符<strong>范围</strong>，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。</p>\n<p>下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。</p>\n<p>这个表达式可以匹配几种格式的电话号码，像<em>(010)88886666</em>，或<em>022-22334455</em>，或<em>02912345678</em>等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n<p>“(”和“)”也是元字符，后面的<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#grouping\" target=\"_blank\" rel=\"noopener\">分组节</a>里会提到，所以在这里需要使用<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#escape\" target=\"_blank\" rel=\"noopener\">转义</a>。</p>\n<h2 id=\"分枝条件\"><a href=\"#分枝条件\" class=\"headerlink\" title=\"分枝条件\"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配<em>010)12345678*或</em>(022-87654321<em>这样的“不正确”的格式。要解决这个问题，我们需要用到*</em>分枝条件<strong>。正则表达式里的</strong>分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>\n<p>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>\n<p>(0\\d{2})[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>\n<p>\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>\n<p>(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。</p>\n<p>不幸的是，它也将匹配<em>256.300.888.999</em>这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。</p>\n<p>理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>\n<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：\\S+匹配不包含空白符的字符串。</p>\n<p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"后向引用\"><a href=\"#后向引用\" class=\"headerlink\" title=\"后向引用\"></a>后向引用</h2><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>\n<p>呃……其实,组号分配还不像我刚说得那么简单：</p>\n<ul>\n<li>分组0对应整个正则表达式</li>\n<li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li>\n<li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li>\n</ul>\n<p><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：</p>\n<p>\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。</p>\n<p>你也可以自己指定子表达式的<strong>组名</strong>。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组<strong>捕获</strong>的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b。</p>\n<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>捕获</td>\n<td>(exp)</td>\n<td>匹配exp,并捕获文本到自动命名的组里</td>\n</tr>\n<tr>\n<td>(?<name>exp)</td>\n<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>\n<td></td>\n</tr>\n<tr>\n<td>(?:exp)</td>\n<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>\n<td></td>\n</tr>\n<tr>\n<td>零宽断言</td>\n<td>(?=exp)</td>\n<td>匹配exp前面的位置</td>\n</tr>\n<tr>\n<td>(?&lt;=exp)</td>\n<td>匹配exp后面的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>(?!exp)</td>\n<td>匹配后面跟的不是exp的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>(?&lt;!exp)</td>\n<td>匹配前面不是exp的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>注释</td>\n<td>(?#comment)</td>\n<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>\n</tr>\n</tbody></table>\n<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>\n<h2 id=\"零宽断言\"><a href=\"#零宽断言\" class=\"headerlink\" title=\"零宽断言\"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。最好还是拿例子来说明吧：</p>\n<p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p>\n<p>(?=exp)也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<em>I’m singing while you’re dancing.</em>时，它会匹配sing和danc。</p>\n<p>(?&lt;=exp)也叫<strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<em>reading a book</em>时，它匹配ading。</p>\n<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})+\\b，用它对<em>1234567890</em>进行查找时结果是234567890。</p>\n<p>下面这个例子同时使用了这两种断言：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>\n<h2 id=\"负向零宽断言\"><a href=\"#负向零宽断言\" class=\"headerlink\" title=\"负向零宽断言\"></a>负向零宽断言</h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p>\n<p>\\b\\w<em>q[^u]\\w</em>\\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w<em>\\b将会匹配下一个单词，于是\\b\\w</em>q[^u]\\w<em>\\b就能匹配整个</em>Iraq fighting<em>。*</em>负向零宽断言<strong>能解决这样的问题，因为它只匹配一个位置，并不</strong>消费*<em>任何字符。现在，我们可以这样来解决这个问题：\\b\\w</em>q(?!u)\\w*\\b。</p>\n<p><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。</p>\n<p>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言</strong>来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。</p>\n<p>一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).<em>(?=&lt;/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的<strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是.</em>(任意的字符串),最后是一个<strong>后缀</strong>(?=&lt;/\\1&gt;)。注意后缀里的/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25<a href=\"?#250-255\">0-5</a>|[01]?\\d\\d?(?#0-199)。</p>\n<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;&#x3D;    # 断言要匹配的文本的前缀</span><br><span class=\"line\">&lt;(\\w+)&gt; # 查找尖括号括起来的内容</span><br><span class=\"line\">        # (即HTML&#x2F;XML标签)</span><br><span class=\"line\">)       # 前缀结束</span><br><span class=\"line\">.*      # 匹配任意文本</span><br><span class=\"line\">(?&#x3D;     # 断言要匹配的文本的后缀</span><br><span class=\"line\">&lt;\\&#x2F;\\1&gt;  # 查找尖括号括起来的内容</span><br><span class=\"line\">        # 查找尖括号括起来的内容</span><br><span class=\"line\">)       # 后缀结束</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索</em>aabab<em>的话，它会匹配整个字符串aabab。这被称为*</em>贪婪**匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>\n<p>a.<em>?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于</em>aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>\n<p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IgnoreCase(忽略大小写)</td>\n<td>匹配时不区分大小写。</td>\n</tr>\n<tr>\n<td>Multiline(多行模式)</td>\n<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.)</td>\n</tr>\n<tr>\n<td>Singleline(单行模式)</td>\n<td>更改.的含义，使它与每一个字符匹配（包括换行符\\n）。</td>\n</tr>\n<tr>\n<td>IgnorePatternWhitespace(忽略空白)</td>\n<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>\n</tr>\n<tr>\n<td>ExplicitCapture(显式捕获)</td>\n<td>仅捕获已被显式命名的组。</td>\n</tr>\n</tbody></table>\n<p>在C#中，你可以使用<a href=\"http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx\" target=\"_blank\" rel=\"noopener\">Regex(String, RegexOptions)构造函数</a>来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\\ba\\w{6}\\b”, RegexOptions.IgnoreCase);</p>\n<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.</p>\n<p>目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。</p>\n<h2 id=\"平衡组-递归匹配\"><a href=\"#平衡组-递归匹配\" class=\"headerlink\" title=\"平衡组/递归匹配\"></a>平衡组/递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如<em>( 5 / ( 3 + 2 ) ) )</em>，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p>\n<p>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p>\n<p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<em>xx   aa&gt; yy</em>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p>\n<p>这里需要用到以下的语法构造：</p>\n<ul>\n<li>(?’group’) 把捕获的内容命名为group,并压入<strong>堆栈(Stack)</strong></li>\n<li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>\n<li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>\n<li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>\n</ul>\n<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;                   #最外层的左括号</span><br><span class=\"line\">  [^&lt;&gt;]*            #它后面非括号的内容</span><br><span class=\"line\">  (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        (?&#39;Open&#39;&lt;)  #左括号，压入&quot;Open&quot;</span><br><span class=\"line\">        [^&lt;&gt;]*      #左括号后面的内容</span><br><span class=\"line\">      )+</span><br><span class=\"line\">      (</span><br><span class=\"line\">        (?&#39;-Open&#39;&gt;) #右括号，弹出一个&quot;Open&quot;</span><br><span class=\"line\">        [^&lt;&gt;]*      #右括号后面的内容</span><br><span class=\"line\">      )+</span><br><span class=\"line\">  )*</span><br><span class=\"line\">  (?(Open)(?!))     #最外层的右括号前检查</span><br><span class=\"line\">                    #若还有未弹出的&quot;Open&quot;</span><br><span class=\"line\">                    #则匹配失败</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;                #最外层的右括号</span><br></pre></td></tr></table></figure>\n\n<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：&lt;div[^&gt;]<em>&gt;[^&lt;&gt;]</em>(((?’Open’&lt;div[^&gt;]<em>&gt;)[^&lt;&gt;]</em>)+((?’-Open’</div>)[^&lt;&gt;]<em>)+)</em>(?(Open)(?!))</div>.</p>\n<p>如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p>\n<h2 id=\"还有些什么东西没提到\"><a href=\"#还有些什么东西没提到\" class=\"headerlink\" title=\"还有些什么东西没提到\"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href=\"http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx\" target=\"_blank\" rel=\"noopener\">关于正则表达式语言元素的MSDN在线文档</a>。</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\a</td>\n<td>报警字符(打印它的效果是电脑嘀一声)</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符，Tab</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>竖向制表符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\e</td>\n<td>Escape</td>\n</tr>\n<tr>\n<td>\\0nn</td>\n<td>ASCII代码中八进制代码为nn的字符</td>\n</tr>\n<tr>\n<td>\\xnn</td>\n<td>ASCII代码中十六进制代码为nn的字符</td>\n</tr>\n<tr>\n<td>\\unnnn</td>\n<td>Unicode代码中十六进制代码为nnnn的字符</td>\n</tr>\n<tr>\n<td>\\cN</td>\n<td>ASCII控制字符。比如\\cC代表Ctrl+C</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>字符串开头(类似^，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\Z</td>\n<td>字符串结尾或行尾(不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\z</td>\n<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>当前搜索的开头</td>\n</tr>\n<tr>\n<td>\\p{name}</td>\n<td>Unicode中命名为name的字符类，例如\\p{IsGreek}</td>\n</tr>\n<tr>\n<td>(?&gt;exp)</td>\n<td>贪婪子表达式</td>\n</tr>\n<tr>\n<td>(?<x>-<y>exp)</td>\n<td>平衡组</td>\n</tr>\n<tr>\n<td>(?im-nsx:exp)</td>\n<td>在子表达式exp中改变处理选项</td>\n</tr>\n<tr>\n<td>(?im-nsx)</td>\n<td>为表达式后面的部分改变处理选项</td>\n</tr>\n<tr>\n<td>(?(exp)yes|no)</td>\n<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>\n</tr>\n<tr>\n<td>(?(exp)yes)</td>\n<td>同上，只是使用空表达式作为no</td>\n</tr>\n<tr>\n<td>(?(name)yes|no)</td>\n<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>\n</tr>\n<tr>\n<td>(?(name)yes)</td>\n<td>同上，只是使用空表达式作为no</td>\n</tr>\n</tbody></table>\n<h2 id=\"联系作者\"><a href=\"#联系作者\" class=\"headerlink\" title=\"联系作者\"></a>联系作者</h2><p>好吧，我承认，我骗了你，读到这里你肯定花了不止30分钟。相信我，这是我的错，而不是因为你太笨。我之所以说”30分钟”，是为了让你有信心，有耐心继续下去。既然你看到了这里，那证明我的阴谋成功了。被忽悠的感觉很爽吧？</p>\n<p>要投诉我，或者觉得我其实可以忽悠得更高明，或者有关于正则表达式的问题, 可以发邮件到 deerchao#qq#com。如果本文给了你帮助，你可以使用支付宝或微信支付向我打赏。点击本页右上方的“打赏”即可看到支付二维码，可能你得先<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#top\" target=\"_blank\" rel=\"noopener\">回到页面最顶端</a>。</p>\n<h2 id=\"网上的资源及本文参考文献\"><a href=\"#网上的资源及本文参考文献\" class=\"headerlink\" title=\"网上的资源及本文参考文献\"></a>网上的资源及本文参考文献</h2><ul>\n<li><a href=\"https://u.jd.com/0yfKdc\" target=\"_blank\" rel=\"noopener\">精通正则表达式(第3版)</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions\" target=\"_blank\" rel=\"noopener\">微软的正则表达式教程</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex\" target=\"_blank\" rel=\"noopener\">Regex类(微软文档)</a></li>\n<li><a href=\"http://www.regular-expressions.info/\" target=\"_blank\" rel=\"noopener\">专业的正则表达式教学网站(英文)</a></li>\n<li><a href=\"http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx\" target=\"_blank\" rel=\"noopener\">关于.Net下的平衡组的详细讨论（英文）</a></li>\n</ul>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p><strong>本文来源<a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">正则表达式30分钟入门教程</a></strong> 原作者：deerchao</p>\n<p>相关链接：</p>\n<ul>\n<li><a href=\"https://deerchao.cn/tutorials/regex/common.htm\" target=\"_blank\" rel=\"noopener\">常用正则表达式</a></li>\n<li><a href=\"https://deerchao.cn/tools/wegester/\" target=\"_blank\" rel=\"noopener\">JavaScript 在线正则测试器</a></li>\n<li><a href=\"https://deerchao.cn/tools/regester/\" target=\"_blank\" rel=\"noopener\">.Net 正则表达式测试工具</a></li>\n<li><a href=\"https://deerchao.cn/tutorials/regex/diffs.html\" target=\"_blank\" rel=\"noopener\">正则表达式引擎特性对比</a></li>\n</ul>\n<h2 id=\"本文目标\"><a href=\"#本文目标\" class=\"headerlink\" title=\"本文目标\"></a>本文目标</h2><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>\n<h2 id=\"如何使用本教程\"><a href=\"#如何使用本教程\" class=\"headerlink\" title=\"如何使用本教程\"></a>如何使用本教程</h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p>\n<p>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？</p>\n<p><a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">清除格式</a> 文本格式约定：<strong>专业术语</strong> 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) <em>对其进行匹配的源字符串</em> 对正则表达式或其中一部分的说明</p>\n<p><a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">隐藏边注</a> 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。</p>\n<p>本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看<a href=\"https://deerchao.cn/tutorials/regex/diffs.html\" target=\"_blank\" rel=\"noopener\">正则表达式引擎特性对比</a>。</p>\n<p>最重要的是——请给我<em>30分钟</em>，如果你没有使用正则表达式的经验，请不要试图在30<em>秒</em>内入门——除非你是超人 :)</p>\n<h2 id=\"正则表达式到底是什么东西？\"><a href=\"#正则表达式到底是什么东西？\" class=\"headerlink\" title=\"正则表达式到底是什么东西？\"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p>很可能你使用过Windows/Dos下用于文件查找的<strong>通配符(wildcard)</strong>，也就是<em>和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索</em>.doc。在这里，<em>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或*0376-7654321</em>)。</p>\n<p><strong>字符</strong>是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。<strong>字符串</strong>是0个或更多个字符的序列。<strong>文本</strong>也就是文字，字符串。说某个字符串<strong>匹配</strong>某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。</p>\n<p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p>\n<p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<em>hi</em>,<em>HI</em>,<em>Hi</em>,<em>hI</em>这四种情况中的任意一种。</p>\n<p>不幸的是，很多单词里包含<em>hi<em>这两个连续的字符，比如</em>him</em>,<em>history</em>,<em>high</em>等等。用hi来查找的话，这里边的<em>hi</em>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。</p>\n<p>\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p>\n<p>如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。</p>\n<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。</p>\n<p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.<em>连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.</em>\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p>\n<p>换行符就是’\\n’,ASCII编码为10(十六进制0x0A)的字符。</p>\n<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p>\n<p>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>\n<p>这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p>\n<p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。</p>\n<h2 id=\"测试正则表达式\"><a href=\"#测试正则表达式\" class=\"headerlink\" title=\"测试正则表达式\"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p>\n<p>不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 <a href=\"https://deerchao.cn/tools/regester/\" target=\"_blank\" rel=\"noopener\">Regester</a>。请参考该页面的说明来安装和运行该软件。</p>\n<p>你也可以试试这个在线测试工具：<a href=\"https://deerchao.cn/tools/wegester/\" target=\"_blank\" rel=\"noopener\">Wegester, JavaScript正则表达式测试器。</a></p>\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。</p>\n<p>对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</p>\n<p>下面来看看更多的例子：</p>\n<p>\\ba\\w<em>\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w</em>)，最后是单词结束处(\\b)。</p>\n<p>\\d+匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p>\n<p>\\b\\w{6}\\b 匹配刚好6个字符的单词。</p>\n<p>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。</p>\n<p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p>\n<p>因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>\n<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>\n<p>正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\</em>。当然，要查找\\本身，你也得用\\.</p>\n<p>例如：deerchao.cn匹配deerchao.cn，C:\\Windows匹配C:\\Windows。</p>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><p>你已经看过了前面的<em>,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如</em>,{5,12}等)：</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<p>下面是一些使用重复的例子：</p>\n<p>Windows\\d+匹配Windows后面跟1个或更多数字</p>\n<p>^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>\n<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>\n<p>我们也可以轻松地指定一个字符<strong>范围</strong>，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。</p>\n<p>下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。</p>\n<p>这个表达式可以匹配几种格式的电话号码，像<em>(010)88886666</em>，或<em>022-22334455</em>，或<em>02912345678</em>等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n<p>“(”和“)”也是元字符，后面的<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#grouping\" target=\"_blank\" rel=\"noopener\">分组节</a>里会提到，所以在这里需要使用<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#escape\" target=\"_blank\" rel=\"noopener\">转义</a>。</p>\n<h2 id=\"分枝条件\"><a href=\"#分枝条件\" class=\"headerlink\" title=\"分枝条件\"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配<em>010)12345678*或</em>(022-87654321<em>这样的“不正确”的格式。要解决这个问题，我们需要用到*</em>分枝条件<strong>。正则表达式里的</strong>分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>\n<p>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>\n<p>(0\\d{2})[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>\n<p>\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>\n<p>(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。</p>\n<p>不幸的是，它也将匹配<em>256.300.888.999</em>这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。</p>\n<p>理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>\n<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：\\S+匹配不包含空白符的字符串。</p>\n<p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"后向引用\"><a href=\"#后向引用\" class=\"headerlink\" title=\"后向引用\"></a>后向引用</h2><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>\n<p>呃……其实,组号分配还不像我刚说得那么简单：</p>\n<ul>\n<li>分组0对应整个正则表达式</li>\n<li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li>\n<li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li>\n</ul>\n<p><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：</p>\n<p>\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。</p>\n<p>你也可以自己指定子表达式的<strong>组名</strong>。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组<strong>捕获</strong>的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b。</p>\n<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>捕获</td>\n<td>(exp)</td>\n<td>匹配exp,并捕获文本到自动命名的组里</td>\n</tr>\n<tr>\n<td>(?<name>exp)</td>\n<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>\n<td></td>\n</tr>\n<tr>\n<td>(?:exp)</td>\n<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>\n<td></td>\n</tr>\n<tr>\n<td>零宽断言</td>\n<td>(?=exp)</td>\n<td>匹配exp前面的位置</td>\n</tr>\n<tr>\n<td>(?&lt;=exp)</td>\n<td>匹配exp后面的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>(?!exp)</td>\n<td>匹配后面跟的不是exp的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>(?&lt;!exp)</td>\n<td>匹配前面不是exp的位置</td>\n<td></td>\n</tr>\n<tr>\n<td>注释</td>\n<td>(?#comment)</td>\n<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>\n</tr>\n</tbody></table>\n<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>\n<h2 id=\"零宽断言\"><a href=\"#零宽断言\" class=\"headerlink\" title=\"零宽断言\"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。最好还是拿例子来说明吧：</p>\n<p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p>\n<p>(?=exp)也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<em>I’m singing while you’re dancing.</em>时，它会匹配sing和danc。</p>\n<p>(?&lt;=exp)也叫<strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<em>reading a book</em>时，它匹配ading。</p>\n<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})+\\b，用它对<em>1234567890</em>进行查找时结果是234567890。</p>\n<p>下面这个例子同时使用了这两种断言：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>\n<h2 id=\"负向零宽断言\"><a href=\"#负向零宽断言\" class=\"headerlink\" title=\"负向零宽断言\"></a>负向零宽断言</h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p>\n<p>\\b\\w<em>q[^u]\\w</em>\\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w<em>\\b将会匹配下一个单词，于是\\b\\w</em>q[^u]\\w<em>\\b就能匹配整个</em>Iraq fighting<em>。*</em>负向零宽断言<strong>能解决这样的问题，因为它只匹配一个位置，并不</strong>消费*<em>任何字符。现在，我们可以这样来解决这个问题：\\b\\w</em>q(?!u)\\w*\\b。</p>\n<p><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。</p>\n<p>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言</strong>来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。</p>\n<p>一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).<em>(?=&lt;/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的<strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是.</em>(任意的字符串),最后是一个<strong>后缀</strong>(?=&lt;/\\1&gt;)。注意后缀里的/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25<a href=\"?#250-255\">0-5</a>|[01]?\\d\\d?(?#0-199)。</p>\n<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;&#x3D;    # 断言要匹配的文本的前缀</span><br><span class=\"line\">&lt;(\\w+)&gt; # 查找尖括号括起来的内容</span><br><span class=\"line\">        # (即HTML&#x2F;XML标签)</span><br><span class=\"line\">)       # 前缀结束</span><br><span class=\"line\">.*      # 匹配任意文本</span><br><span class=\"line\">(?&#x3D;     # 断言要匹配的文本的后缀</span><br><span class=\"line\">&lt;\\&#x2F;\\1&gt;  # 查找尖括号括起来的内容</span><br><span class=\"line\">        # 查找尖括号括起来的内容</span><br><span class=\"line\">)       # 后缀结束</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索</em>aabab<em>的话，它会匹配整个字符串aabab。这被称为*</em>贪婪**匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>\n<p>a.<em>?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于</em>aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>\n<p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IgnoreCase(忽略大小写)</td>\n<td>匹配时不区分大小写。</td>\n</tr>\n<tr>\n<td>Multiline(多行模式)</td>\n<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.)</td>\n</tr>\n<tr>\n<td>Singleline(单行模式)</td>\n<td>更改.的含义，使它与每一个字符匹配（包括换行符\\n）。</td>\n</tr>\n<tr>\n<td>IgnorePatternWhitespace(忽略空白)</td>\n<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>\n</tr>\n<tr>\n<td>ExplicitCapture(显式捕获)</td>\n<td>仅捕获已被显式命名的组。</td>\n</tr>\n</tbody></table>\n<p>在C#中，你可以使用<a href=\"http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx\" target=\"_blank\" rel=\"noopener\">Regex(String, RegexOptions)构造函数</a>来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\\ba\\w{6}\\b”, RegexOptions.IgnoreCase);</p>\n<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.</p>\n<p>目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。</p>\n<h2 id=\"平衡组-递归匹配\"><a href=\"#平衡组-递归匹配\" class=\"headerlink\" title=\"平衡组/递归匹配\"></a>平衡组/递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如<em>( 5 / ( 3 + 2 ) ) )</em>，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p>\n<p>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p>\n<p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<em>xx   aa&gt; yy</em>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p>\n<p>这里需要用到以下的语法构造：</p>\n<ul>\n<li>(?’group’) 把捕获的内容命名为group,并压入<strong>堆栈(Stack)</strong></li>\n<li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>\n<li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>\n<li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>\n</ul>\n<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;                   #最外层的左括号</span><br><span class=\"line\">  [^&lt;&gt;]*            #它后面非括号的内容</span><br><span class=\"line\">  (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        (?&#39;Open&#39;&lt;)  #左括号，压入&quot;Open&quot;</span><br><span class=\"line\">        [^&lt;&gt;]*      #左括号后面的内容</span><br><span class=\"line\">      )+</span><br><span class=\"line\">      (</span><br><span class=\"line\">        (?&#39;-Open&#39;&gt;) #右括号，弹出一个&quot;Open&quot;</span><br><span class=\"line\">        [^&lt;&gt;]*      #右括号后面的内容</span><br><span class=\"line\">      )+</span><br><span class=\"line\">  )*</span><br><span class=\"line\">  (?(Open)(?!))     #最外层的右括号前检查</span><br><span class=\"line\">                    #若还有未弹出的&quot;Open&quot;</span><br><span class=\"line\">                    #则匹配失败</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;                #最外层的右括号</span><br></pre></td></tr></table></figure>\n\n<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：&lt;div[^&gt;]<em>&gt;[^&lt;&gt;]</em>(((?’Open’&lt;div[^&gt;]<em>&gt;)[^&lt;&gt;]</em>)+((?’-Open’</div>)[^&lt;&gt;]<em>)+)</em>(?(Open)(?!))</div>.</p>\n<p>如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p>\n<h2 id=\"还有些什么东西没提到\"><a href=\"#还有些什么东西没提到\" class=\"headerlink\" title=\"还有些什么东西没提到\"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href=\"http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx\" target=\"_blank\" rel=\"noopener\">关于正则表达式语言元素的MSDN在线文档</a>。</p>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\a</td>\n<td>报警字符(打印它的效果是电脑嘀一声)</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符，Tab</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>竖向制表符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\e</td>\n<td>Escape</td>\n</tr>\n<tr>\n<td>\\0nn</td>\n<td>ASCII代码中八进制代码为nn的字符</td>\n</tr>\n<tr>\n<td>\\xnn</td>\n<td>ASCII代码中十六进制代码为nn的字符</td>\n</tr>\n<tr>\n<td>\\unnnn</td>\n<td>Unicode代码中十六进制代码为nnnn的字符</td>\n</tr>\n<tr>\n<td>\\cN</td>\n<td>ASCII控制字符。比如\\cC代表Ctrl+C</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>字符串开头(类似^，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\Z</td>\n<td>字符串结尾或行尾(不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\z</td>\n<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>当前搜索的开头</td>\n</tr>\n<tr>\n<td>\\p{name}</td>\n<td>Unicode中命名为name的字符类，例如\\p{IsGreek}</td>\n</tr>\n<tr>\n<td>(?&gt;exp)</td>\n<td>贪婪子表达式</td>\n</tr>\n<tr>\n<td>(?<x>-<y>exp)</td>\n<td>平衡组</td>\n</tr>\n<tr>\n<td>(?im-nsx:exp)</td>\n<td>在子表达式exp中改变处理选项</td>\n</tr>\n<tr>\n<td>(?im-nsx)</td>\n<td>为表达式后面的部分改变处理选项</td>\n</tr>\n<tr>\n<td>(?(exp)yes|no)</td>\n<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>\n</tr>\n<tr>\n<td>(?(exp)yes)</td>\n<td>同上，只是使用空表达式作为no</td>\n</tr>\n<tr>\n<td>(?(name)yes|no)</td>\n<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>\n</tr>\n<tr>\n<td>(?(name)yes)</td>\n<td>同上，只是使用空表达式作为no</td>\n</tr>\n</tbody></table>\n<h2 id=\"联系作者\"><a href=\"#联系作者\" class=\"headerlink\" title=\"联系作者\"></a>联系作者</h2><p>好吧，我承认，我骗了你，读到这里你肯定花了不止30分钟。相信我，这是我的错，而不是因为你太笨。我之所以说”30分钟”，是为了让你有信心，有耐心继续下去。既然你看到了这里，那证明我的阴谋成功了。被忽悠的感觉很爽吧？</p>\n<p>要投诉我，或者觉得我其实可以忽悠得更高明，或者有关于正则表达式的问题, 可以发邮件到 deerchao#qq#com。如果本文给了你帮助，你可以使用支付宝或微信支付向我打赏。点击本页右上方的“打赏”即可看到支付二维码，可能你得先<a href=\"https://deerchao.cn/tutorials/regex/regex.htm#top\" target=\"_blank\" rel=\"noopener\">回到页面最顶端</a>。</p>\n<h2 id=\"网上的资源及本文参考文献\"><a href=\"#网上的资源及本文参考文献\" class=\"headerlink\" title=\"网上的资源及本文参考文献\"></a>网上的资源及本文参考文献</h2><ul>\n<li><a href=\"https://u.jd.com/0yfKdc\" target=\"_blank\" rel=\"noopener\">精通正则表达式(第3版)</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions\" target=\"_blank\" rel=\"noopener\">微软的正则表达式教程</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex\" target=\"_blank\" rel=\"noopener\">Regex类(微软文档)</a></li>\n<li><a href=\"http://www.regular-expressions.info/\" target=\"_blank\" rel=\"noopener\">专业的正则表达式教学网站(英文)</a></li>\n<li><a href=\"http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx\" target=\"_blank\" rel=\"noopener\">关于.Net下的平衡组的详细讨论（英文）</a></li>\n</ul>\n"},{"layout":"post","title":"Virtualenv简明教程","date":"2020-03-19T19:00:00.000Z","description":"不同的项目需要不同版本的依赖怎么办","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321003905.png","optimized_image":null,"author":"Andrew_liu","_content":"\n---\n\n**作者：Andrew_liu**\n\n**链接：https://www.jianshu.com/p/08c657bd34f1**\n\n**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**\n\n\n\n`virtualenv`创建一个拥有自己安装目录的环境, 这个环境不与其他虚拟环境共享库, 能够方便的管理python版本和管理python库\n\n## 1. 安装Virtualenv\n\n使用`pip`安装Virtualenv, 使用过python的都应该知道`pip`包管理神器吧, 即使不知道, 网站也有大把的教程, 不过推荐查看[官方安装指南](https://link.jianshu.com?t=https://pip.pypa.io/en/latest/installing.html)\n\n```bash\n$ pip install virtualenv\n//或者由于权限问题使用sudo临时提升权限\n$ sudo pip install virtualenv\n```\n\n## 2. virtualenv基本使用\n\n现在开始使用virtualenv管理python环境\n\n```bash\n➜  Test git:(master)$ virtualenv ENV  #创建一个名为ENV的目录, 并且安装了ENV/bin/python, 创建了lib,include,bin目录,安装了pip\nNew python executable in \nInstalling setuptools, pip...done.\n  \n➜  Test git:(master)$ cd ENV\n➜  ENV git:(master)$ ll\ndrwxr-xr-x  14 andrew_liu  staff  476 12  8 08:49 bin\ndrwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 include\ndrwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 lib\n```\n\n- `lib`,所有安装的python库都会放在这个目录中的`lib/pythonx.x/site-packages/`下\n- `bin`,`bin/python`是在当前环境是使用的python解释器\n\n> 如果在命令行中运行`virtualenv --system-site-packages ENV`, 会继承`/usr/lib/python2.7/site-packages`下的所有库, 最新版本virtualenv把把访问全局`site-packages`作为默认行为\n>  default behavior.\n\n### 2.1. 激活virtualenv\n\n\n\n```bash\n#ENV目录下使用如下命令\n➜  ENV git:(master)$ source ./bin/activate  #激活当前virtualenv\n(ENV)➜  ENV git:(master)$ #注意终端发生了变化\n```\n\n\n\n```css\n#使用pip查看当前库\n(ENV)➜  ENV git:(master)$ pip list\npip (1.5.6)\nsetuptools (3.6)\nwsgiref (0.1.2) #发现在只有这三个\n\npip freeze  #显示所有依赖\npip freeze > requirement.txt  #生成requirement.txt文件\npip install -r requirement.txt  #根据requirement.txt生成相同的环境\n```\n\n### 2.2. 关闭virtualenv\n\n使用下面命令\n\n```bash\n$ deactivate\n```\n\n### 2.3. 指定python版本\n\n可以使用`-p PYTHON_EXE`选项在创建虚拟环境的时候指定python版本\n\n```bash\n#创建python2.7虚拟环境\n➜  Test git:(master) $ virtualenv -p /usr/bin/python2.7 ENV2.7\nRunning virtualenv with interpreter /usr/bin/python2.7\nNew python executable in ENV2.7/bin/python\nInstalling setuptools, pip...done.\n```\n\n\n\n```bash\n#创建python3.4虚拟环境\n➜  Test git:(master) $ virtualenv -p /usr/local/bin/python3.4 ENV3.4\nRunning virtualenv with interpreter /usr/local/bin/python3.4\nUsing base prefix '/Library/Frameworks/Python.framework/Versions/3.4'\nNew python executable in ENV3.4/bin/python3.4\nAlso creating executable in ENV3.4/bin/python\nInstalling setuptools, pip...done.\n```\n\n> 到此已经可以解决python版本冲突问题和python库不同版本的问题\n\n## 3. 其他\n\n### 3.1. 生成可打包环境\n\n某些特殊需求下,可能没有网络, 我们期望直接打包一个ENV, 可以解压后直接使用, 这时候可以使用`virtualenv -relocatable`指令将ENV修改为可更改位置的ENV\n\n\n\n```bash\n#对当前已经创建的虚拟环境更改为可迁移\n➜  ENV3.4 git:(master) ✗ virtualenv --relocatable ./\nMaking script ./bin/easy_install relative\nMaking script ./bin/easy_install-3.4 relative\nMaking script ./bin/pip relative\nMaking script ./bin/pip3 relative\nMaking script ./bin/pip3.4 relative\n```\n\n### 3.2. 获得帮助\n\n\n\n```ruby\n$ virtualenv -h\n```\n\n当前的ENV都被修改为相对路径, 可以打包当前目录, 上传到其他位置使用\n\n> 这并不能使虚拟环境跨平台使用\n\n## 4. 参考链接\n\n[virtualenv官方文档](https://link.jianshu.com?t=http://virtualenv.readthedocs.org/en/latest/virtualenv.html)\n\n\n\n","source":"_posts/2020-03-19-Virtualenv教程.md","raw":"---\nlayout: post\ntitle:  Virtualenv简明教程\ndate:   2020-03-19 12:00:00\ndescription: 不同的项目需要不同版本的依赖怎么办\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321003905.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\nauthor: Andrew_liu\n---\n\n---\n\n**作者：Andrew_liu**\n\n**链接：https://www.jianshu.com/p/08c657bd34f1**\n\n**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**\n\n\n\n`virtualenv`创建一个拥有自己安装目录的环境, 这个环境不与其他虚拟环境共享库, 能够方便的管理python版本和管理python库\n\n## 1. 安装Virtualenv\n\n使用`pip`安装Virtualenv, 使用过python的都应该知道`pip`包管理神器吧, 即使不知道, 网站也有大把的教程, 不过推荐查看[官方安装指南](https://link.jianshu.com?t=https://pip.pypa.io/en/latest/installing.html)\n\n```bash\n$ pip install virtualenv\n//或者由于权限问题使用sudo临时提升权限\n$ sudo pip install virtualenv\n```\n\n## 2. virtualenv基本使用\n\n现在开始使用virtualenv管理python环境\n\n```bash\n➜  Test git:(master)$ virtualenv ENV  #创建一个名为ENV的目录, 并且安装了ENV/bin/python, 创建了lib,include,bin目录,安装了pip\nNew python executable in \nInstalling setuptools, pip...done.\n  \n➜  Test git:(master)$ cd ENV\n➜  ENV git:(master)$ ll\ndrwxr-xr-x  14 andrew_liu  staff  476 12  8 08:49 bin\ndrwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 include\ndrwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 lib\n```\n\n- `lib`,所有安装的python库都会放在这个目录中的`lib/pythonx.x/site-packages/`下\n- `bin`,`bin/python`是在当前环境是使用的python解释器\n\n> 如果在命令行中运行`virtualenv --system-site-packages ENV`, 会继承`/usr/lib/python2.7/site-packages`下的所有库, 最新版本virtualenv把把访问全局`site-packages`作为默认行为\n>  default behavior.\n\n### 2.1. 激活virtualenv\n\n\n\n```bash\n#ENV目录下使用如下命令\n➜  ENV git:(master)$ source ./bin/activate  #激活当前virtualenv\n(ENV)➜  ENV git:(master)$ #注意终端发生了变化\n```\n\n\n\n```css\n#使用pip查看当前库\n(ENV)➜  ENV git:(master)$ pip list\npip (1.5.6)\nsetuptools (3.6)\nwsgiref (0.1.2) #发现在只有这三个\n\npip freeze  #显示所有依赖\npip freeze > requirement.txt  #生成requirement.txt文件\npip install -r requirement.txt  #根据requirement.txt生成相同的环境\n```\n\n### 2.2. 关闭virtualenv\n\n使用下面命令\n\n```bash\n$ deactivate\n```\n\n### 2.3. 指定python版本\n\n可以使用`-p PYTHON_EXE`选项在创建虚拟环境的时候指定python版本\n\n```bash\n#创建python2.7虚拟环境\n➜  Test git:(master) $ virtualenv -p /usr/bin/python2.7 ENV2.7\nRunning virtualenv with interpreter /usr/bin/python2.7\nNew python executable in ENV2.7/bin/python\nInstalling setuptools, pip...done.\n```\n\n\n\n```bash\n#创建python3.4虚拟环境\n➜  Test git:(master) $ virtualenv -p /usr/local/bin/python3.4 ENV3.4\nRunning virtualenv with interpreter /usr/local/bin/python3.4\nUsing base prefix '/Library/Frameworks/Python.framework/Versions/3.4'\nNew python executable in ENV3.4/bin/python3.4\nAlso creating executable in ENV3.4/bin/python\nInstalling setuptools, pip...done.\n```\n\n> 到此已经可以解决python版本冲突问题和python库不同版本的问题\n\n## 3. 其他\n\n### 3.1. 生成可打包环境\n\n某些特殊需求下,可能没有网络, 我们期望直接打包一个ENV, 可以解压后直接使用, 这时候可以使用`virtualenv -relocatable`指令将ENV修改为可更改位置的ENV\n\n\n\n```bash\n#对当前已经创建的虚拟环境更改为可迁移\n➜  ENV3.4 git:(master) ✗ virtualenv --relocatable ./\nMaking script ./bin/easy_install relative\nMaking script ./bin/easy_install-3.4 relative\nMaking script ./bin/pip relative\nMaking script ./bin/pip3 relative\nMaking script ./bin/pip3.4 relative\n```\n\n### 3.2. 获得帮助\n\n\n\n```ruby\n$ virtualenv -h\n```\n\n当前的ENV都被修改为相对路径, 可以打包当前目录, 上传到其他位置使用\n\n> 这并不能使虚拟环境跨平台使用\n\n## 4. 参考链接\n\n[virtualenv官方文档](https://link.jianshu.com?t=http://virtualenv.readthedocs.org/en/latest/virtualenv.html)\n\n\n\n","slug":"Virtualenv教程","published":1,"updated":"2020-03-29T06:59:20.715Z","photos":[],"link":"","_id":"ck8ct7j5t000rgtviegtp24vq","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<p><strong>作者：Andrew_liu</strong></p>\n<p><strong>链接：<a href=\"https://www.jianshu.com/p/08c657bd34f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08c657bd34f1</a></strong></p>\n<p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p>\n<p><code>virtualenv</code>创建一个拥有自己安装目录的环境, 这个环境不与其他虚拟环境共享库, 能够方便的管理python版本和管理python库</p>\n<h2 id=\"1-安装Virtualenv\"><a href=\"#1-安装Virtualenv\" class=\"headerlink\" title=\"1. 安装Virtualenv\"></a>1. 安装Virtualenv</h2><p>使用<code>pip</code>安装Virtualenv, 使用过python的都应该知道<code>pip</code>包管理神器吧, 即使不知道, 网站也有大把的教程, 不过推荐查看<a href=\"https://link.jianshu.com?t=https://pip.pypa.io/en/latest/installing.html\" target=\"_blank\" rel=\"noopener\">官方安装指南</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install virtualenv</span><br><span class=\"line\">//或者由于权限问题使用sudo临时提升权限</span><br><span class=\"line\">$ sudo pip install virtualenv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-virtualenv基本使用\"><a href=\"#2-virtualenv基本使用\" class=\"headerlink\" title=\"2. virtualenv基本使用\"></a>2. virtualenv基本使用</h2><p>现在开始使用virtualenv管理python环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  Test git:(master)$ virtualenv ENV  <span class=\"comment\">#创建一个名为ENV的目录, 并且安装了ENV/bin/python, 创建了lib,include,bin目录,安装了pip</span></span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> </span><br><span class=\"line\">Installing setuptools, pip...done.</span><br><span class=\"line\">  </span><br><span class=\"line\">➜  Test git:(master)$ <span class=\"built_in\">cd</span> ENV</span><br><span class=\"line\">➜  ENV git:(master)$ ll</span><br><span class=\"line\">drwxr-xr-x  14 andrew_liu  staff  476 12  8 08:49 bin</span><br><span class=\"line\">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 include</span><br><span class=\"line\">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 lib</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>lib</code>,所有安装的python库都会放在这个目录中的<code>lib/pythonx.x/site-packages/</code>下</li>\n<li><code>bin</code>,<code>bin/python</code>是在当前环境是使用的python解释器</li>\n</ul>\n<blockquote>\n<p>如果在命令行中运行<code>virtualenv --system-site-packages ENV</code>, 会继承<code>/usr/lib/python2.7/site-packages</code>下的所有库, 最新版本virtualenv把把访问全局<code>site-packages</code>作为默认行为<br> default behavior.</p>\n</blockquote>\n<h3 id=\"2-1-激活virtualenv\"><a href=\"#2-1-激活virtualenv\" class=\"headerlink\" title=\"2.1. 激活virtualenv\"></a>2.1. 激活virtualenv</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ENV目录下使用如下命令</span></span><br><span class=\"line\">➜  ENV git:(master)$ <span class=\"built_in\">source</span> ./bin/activate  <span class=\"comment\">#激活当前virtualenv</span></span><br><span class=\"line\">(ENV)➜  ENV git:(master)$ <span class=\"comment\">#注意终端发生了变化</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用<span class=\"selector-tag\">pip</span>查看当前库</span><br><span class=\"line\">(ENV)➜  ENV git:(master)$ pip list</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> (1<span class=\"selector-class\">.5</span><span class=\"selector-class\">.6</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">setuptools</span> (3<span class=\"selector-class\">.6</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">wsgiref</span> (0<span class=\"selector-class\">.1</span><span class=\"selector-class\">.2</span>) #发现在只有这三个</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">freeze</span>  #显示所有依赖</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">freeze</span> &gt; <span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>  #生成<span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>文件</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">-r</span> <span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>  #根据<span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>生成相同的环境</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-关闭virtualenv\"><a href=\"#2-2-关闭virtualenv\" class=\"headerlink\" title=\"2.2. 关闭virtualenv\"></a>2.2. 关闭virtualenv</h3><p>使用下面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ deactivate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-指定python版本\"><a href=\"#2-3-指定python版本\" class=\"headerlink\" title=\"2.3. 指定python版本\"></a>2.3. 指定python版本</h3><p>可以使用<code>-p PYTHON_EXE</code>选项在创建虚拟环境的时候指定python版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建python2.7虚拟环境</span></span><br><span class=\"line\">➜  Test git:(master) $ virtualenv -p /usr/bin/python2.7 ENV2.7</span><br><span class=\"line\">Running virtualenv with interpreter /usr/bin/python2.7</span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> ENV2.7/bin/python</span><br><span class=\"line\">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建python3.4虚拟环境</span></span><br><span class=\"line\">➜  Test git:(master) $ virtualenv -p /usr/<span class=\"built_in\">local</span>/bin/python3.4 ENV3.4</span><br><span class=\"line\">Running virtualenv with interpreter /usr/<span class=\"built_in\">local</span>/bin/python3.4</span><br><span class=\"line\">Using base prefix <span class=\"string\">'/Library/Frameworks/Python.framework/Versions/3.4'</span></span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> ENV3.4/bin/python3.4</span><br><span class=\"line\">Also creating executable <span class=\"keyword\">in</span> ENV3.4/bin/python</span><br><span class=\"line\">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>到此已经可以解决python版本冲突问题和python库不同版本的问题</p>\n</blockquote>\n<h2 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3. 其他\"></a>3. 其他</h2><h3 id=\"3-1-生成可打包环境\"><a href=\"#3-1-生成可打包环境\" class=\"headerlink\" title=\"3.1. 生成可打包环境\"></a>3.1. 生成可打包环境</h3><p>某些特殊需求下,可能没有网络, 我们期望直接打包一个ENV, 可以解压后直接使用, 这时候可以使用<code>virtualenv -relocatable</code>指令将ENV修改为可更改位置的ENV</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#对当前已经创建的虚拟环境更改为可迁移</span></span><br><span class=\"line\">➜  ENV3.4 git:(master) ✗ virtualenv --relocatable ./</span><br><span class=\"line\">Making script ./bin/easy_install relative</span><br><span class=\"line\">Making script ./bin/easy_install-3.4 relative</span><br><span class=\"line\">Making script ./bin/pip relative</span><br><span class=\"line\">Making script ./bin/pip3 relative</span><br><span class=\"line\">Making script ./bin/pip3.4 relative</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-获得帮助\"><a href=\"#3-2-获得帮助\" class=\"headerlink\" title=\"3.2. 获得帮助\"></a>3.2. 获得帮助</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv -h</span><br></pre></td></tr></table></figure>\n\n<p>当前的ENV都被修改为相对路径, 可以打包当前目录, 上传到其他位置使用</p>\n<blockquote>\n<p>这并不能使虚拟环境跨平台使用</p>\n</blockquote>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4. 参考链接\"></a>4. 参考链接</h2><p><a href=\"https://link.jianshu.com?t=http://virtualenv.readthedocs.org/en/latest/virtualenv.html\" target=\"_blank\" rel=\"noopener\">virtualenv官方文档</a></p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<hr>\n<p><strong>作者：Andrew_liu</strong></p>\n<p><strong>链接：<a href=\"https://www.jianshu.com/p/08c657bd34f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08c657bd34f1</a></strong></p>\n<p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p>\n<p><code>virtualenv</code>创建一个拥有自己安装目录的环境, 这个环境不与其他虚拟环境共享库, 能够方便的管理python版本和管理python库</p>\n<h2 id=\"1-安装Virtualenv\"><a href=\"#1-安装Virtualenv\" class=\"headerlink\" title=\"1. 安装Virtualenv\"></a>1. 安装Virtualenv</h2><p>使用<code>pip</code>安装Virtualenv, 使用过python的都应该知道<code>pip</code>包管理神器吧, 即使不知道, 网站也有大把的教程, 不过推荐查看<a href=\"https://link.jianshu.com?t=https://pip.pypa.io/en/latest/installing.html\" target=\"_blank\" rel=\"noopener\">官方安装指南</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install virtualenv</span><br><span class=\"line\">//或者由于权限问题使用sudo临时提升权限</span><br><span class=\"line\">$ sudo pip install virtualenv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-virtualenv基本使用\"><a href=\"#2-virtualenv基本使用\" class=\"headerlink\" title=\"2. virtualenv基本使用\"></a>2. virtualenv基本使用</h2><p>现在开始使用virtualenv管理python环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  Test git:(master)$ virtualenv ENV  <span class=\"comment\">#创建一个名为ENV的目录, 并且安装了ENV/bin/python, 创建了lib,include,bin目录,安装了pip</span></span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> </span><br><span class=\"line\">Installing setuptools, pip...done.</span><br><span class=\"line\">  </span><br><span class=\"line\">➜  Test git:(master)$ <span class=\"built_in\">cd</span> ENV</span><br><span class=\"line\">➜  ENV git:(master)$ ll</span><br><span class=\"line\">drwxr-xr-x  14 andrew_liu  staff  476 12  8 08:49 bin</span><br><span class=\"line\">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 include</span><br><span class=\"line\">drwxr-xr-x   3 andrew_liu  staff  102 12  8 08:49 lib</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>lib</code>,所有安装的python库都会放在这个目录中的<code>lib/pythonx.x/site-packages/</code>下</li>\n<li><code>bin</code>,<code>bin/python</code>是在当前环境是使用的python解释器</li>\n</ul>\n<blockquote>\n<p>如果在命令行中运行<code>virtualenv --system-site-packages ENV</code>, 会继承<code>/usr/lib/python2.7/site-packages</code>下的所有库, 最新版本virtualenv把把访问全局<code>site-packages</code>作为默认行为<br> default behavior.</p>\n</blockquote>\n<h3 id=\"2-1-激活virtualenv\"><a href=\"#2-1-激活virtualenv\" class=\"headerlink\" title=\"2.1. 激活virtualenv\"></a>2.1. 激活virtualenv</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ENV目录下使用如下命令</span></span><br><span class=\"line\">➜  ENV git:(master)$ <span class=\"built_in\">source</span> ./bin/activate  <span class=\"comment\">#激活当前virtualenv</span></span><br><span class=\"line\">(ENV)➜  ENV git:(master)$ <span class=\"comment\">#注意终端发生了变化</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用<span class=\"selector-tag\">pip</span>查看当前库</span><br><span class=\"line\">(ENV)➜  ENV git:(master)$ pip list</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> (1<span class=\"selector-class\">.5</span><span class=\"selector-class\">.6</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">setuptools</span> (3<span class=\"selector-class\">.6</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">wsgiref</span> (0<span class=\"selector-class\">.1</span><span class=\"selector-class\">.2</span>) #发现在只有这三个</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">freeze</span>  #显示所有依赖</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">freeze</span> &gt; <span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>  #生成<span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>文件</span><br><span class=\"line\"><span class=\"selector-tag\">pip</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">-r</span> <span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>  #根据<span class=\"selector-tag\">requirement</span><span class=\"selector-class\">.txt</span>生成相同的环境</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-关闭virtualenv\"><a href=\"#2-2-关闭virtualenv\" class=\"headerlink\" title=\"2.2. 关闭virtualenv\"></a>2.2. 关闭virtualenv</h3><p>使用下面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ deactivate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-指定python版本\"><a href=\"#2-3-指定python版本\" class=\"headerlink\" title=\"2.3. 指定python版本\"></a>2.3. 指定python版本</h3><p>可以使用<code>-p PYTHON_EXE</code>选项在创建虚拟环境的时候指定python版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建python2.7虚拟环境</span></span><br><span class=\"line\">➜  Test git:(master) $ virtualenv -p /usr/bin/python2.7 ENV2.7</span><br><span class=\"line\">Running virtualenv with interpreter /usr/bin/python2.7</span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> ENV2.7/bin/python</span><br><span class=\"line\">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建python3.4虚拟环境</span></span><br><span class=\"line\">➜  Test git:(master) $ virtualenv -p /usr/<span class=\"built_in\">local</span>/bin/python3.4 ENV3.4</span><br><span class=\"line\">Running virtualenv with interpreter /usr/<span class=\"built_in\">local</span>/bin/python3.4</span><br><span class=\"line\">Using base prefix <span class=\"string\">'/Library/Frameworks/Python.framework/Versions/3.4'</span></span><br><span class=\"line\">New python executable <span class=\"keyword\">in</span> ENV3.4/bin/python3.4</span><br><span class=\"line\">Also creating executable <span class=\"keyword\">in</span> ENV3.4/bin/python</span><br><span class=\"line\">Installing setuptools, pip...done.</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>到此已经可以解决python版本冲突问题和python库不同版本的问题</p>\n</blockquote>\n<h2 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3. 其他\"></a>3. 其他</h2><h3 id=\"3-1-生成可打包环境\"><a href=\"#3-1-生成可打包环境\" class=\"headerlink\" title=\"3.1. 生成可打包环境\"></a>3.1. 生成可打包环境</h3><p>某些特殊需求下,可能没有网络, 我们期望直接打包一个ENV, 可以解压后直接使用, 这时候可以使用<code>virtualenv -relocatable</code>指令将ENV修改为可更改位置的ENV</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#对当前已经创建的虚拟环境更改为可迁移</span></span><br><span class=\"line\">➜  ENV3.4 git:(master) ✗ virtualenv --relocatable ./</span><br><span class=\"line\">Making script ./bin/easy_install relative</span><br><span class=\"line\">Making script ./bin/easy_install-3.4 relative</span><br><span class=\"line\">Making script ./bin/pip relative</span><br><span class=\"line\">Making script ./bin/pip3 relative</span><br><span class=\"line\">Making script ./bin/pip3.4 relative</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-获得帮助\"><a href=\"#3-2-获得帮助\" class=\"headerlink\" title=\"3.2. 获得帮助\"></a>3.2. 获得帮助</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv -h</span><br></pre></td></tr></table></figure>\n\n<p>当前的ENV都被修改为相对路径, 可以打包当前目录, 上传到其他位置使用</p>\n<blockquote>\n<p>这并不能使虚拟环境跨平台使用</p>\n</blockquote>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4. 参考链接\"></a>4. 参考链接</h2><p><a href=\"https://link.jianshu.com?t=http://virtualenv.readthedocs.org/en/latest/virtualenv.html\" target=\"_blank\" rel=\"noopener\">virtualenv官方文档</a></p>\n"},{"layout":"post","title":"Bash Shell编程入门","date":"2020-03-19T19:00:00.000Z","description":"程序员必备基础知识，不会的不配找到工作","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321004047.png","optimized_image":null,"author":"echoworlding","_content":"\n**作者：echoworlding**\n\n**链接：https://www.jianshu.com/p/e1c8e5bfa45e**\n\n**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**\n\n## Shell是什么？\n\nshell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。\n\n### Shell语言的流派\n\n目前，shell主要有两大流派：\n\n- sh:\n  - burne shell (sh)\n  - burne again shell (bash)\n- csh:\n  - c shell (csh)\n  - tc shell (tcsh)\n  - korn shell (ksh)\n\n目前，大部分Linux系统预设的shell都是bash。\n\n> Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：\n\n```bash\nslot@slot-ubt:~$ cat /etc/shells \n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\nslot@slot-ubt:~$ \n```\n\n> Mac OS提供的shell环境：\n\n```bash\n$ cat /etc/shells\n# List of acceptable shells for chpass(1).\n# Ftpd will not allow users to connect who are not using\n# one of these shells.\n>\n/bin/bash\n/bin/csh\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh  # zsh系本文作者自己安装 \n```\n\n> 注意：\n>\n> 在Catalina之后mac就不是使用bash的了，而是使用zsh的\n\n### 一个极简的bash demo: hello_world.sh\n\n```bash\n    #!/bin/bash\n    \n    # Here is comment \n    echo \"Hello World!\"\n```\n\n**执行**  \n\n方法1: 直接使用bash解释器来解释执行：\n\n```bash\n    bash hello_world.sh\n```\n\n或者：\n\n```bash\n    sh hello_world.sh\n```\n\n方法2: 先将文件属性改为可执行状态：\n\n\n\n```bash\n    chmod +x hello_world.sh\n```\n\n或者：\n\n\n\n```bash\n    chmod 777 hello_world.sh  \n```\n\n再直接执行：\n\n\n\n```bash\n    ./hello_world.sh\n```\n\n**输出**\n\n\n\n```bash\n    Hello World!\n```\n\n**解释**\n\n\n\n#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。\n\n#开头的是注释行(#!除外)，shell中只有单行注释。  \n\n```bash\n    echo \"Hello World!\" 即用echo命令输出字符串\"Hello World!\"到终端显示器。\n```\n\n> **补充知识: 文件的属性**\n>  通过`ls -l`命令可以查看文件的属性，例如查看新建文件test.sh的属性：\n\n```ruby\nslot@slot-ubt:~$ touch test.sh\nslot@slot-ubt:~$ ls -l test.sh \n-rw-rw-r-- 1 slot slot 0 12月 21 15:40 test.sh\n```\n\n> 可以看到，一般新建文件的默认属性是`-rw-rw-r--`，即644，不具有可执行属性`x`，可使用`chmod`命令来改变文件属性（修改默认属性则使用`umask`命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：\n\n```ruby\nslot@slot-ubt:~$ chmod 777 test.sh \nslot@slot-ubt:~$ ls -l test.sh \n-rwxrwxrwx 1 slot slot 0 12月 21 15:40 test.sh\n```\n\n## Bash中的变量\n\n### 变量的定义与赋值\n\n不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：\n\n```bash\nmy_bash_var=\"this is my bash var\"\n```\n\n**注意**:\n\n- **`＝`两边不能有空格！**否则就是语法错误了。\n- Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。\n\n### 变量的引用\n\n使用已定义的变量时，只要在变量名前面加`$`符号即可:\n\n```bash\necho $my_bash_var\n```\n\n或者使用`${var_name}`的形式，`{}`是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：\n\n```bash\necho ${my_bash_var}\n```\n\n注意`''`和`\"\"`的区别：\n\n- `''` ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；\n- `\"\"`：双引号里可以引用变量，可以出现转义字符。\n\n实例：\n\n```bash\na=\"hello\"\necho 'a is : $a'\necho \"a is : $a\"\n```\n\nOutput:\n\n```csharp\na is : $a\na is : hello\n```\n\n#### 只读变量\n\n使用 **`readonly`** 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.\n\n```bash\na_var=\"hello\"\nreadonly a_var\na_var=\"world\"  # Output: bash: read-only variable: a_var\n```\n\n#### 删除变量\n\n使用 **`unset`** 命令可以删除变量，但是不能删除只读变量。\n 变量被删除后不能再次使用。\n\n```bash\nmy_var=\"haha\"\nunset my_var\necho ${my_var} # 变量my_var已被删除，没有任何输出\n```\n\n### 变量的类型\n\n诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分**类型**。\n\n本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是**变量中的值是否只有数字**，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。\n\n另外，注意Bash中的数字默认的是十进制，八进制需要以`0`开头，十六进制以`0x`开头。\n\n纯数字变量是“数字变量”：\n\n```bash\na=1234\nlet \"a+=1\"\necho ${a}  # Output: 1235\n```\n\n数字＋字符串：字符串变量，字符串变量不能进行数学运算\n\n```bash\nb=${a/12/BB} # 将12替换为BB\necho ${b}    # Output: BB35\n\nlet \"b+=1\"\necho ${b}    # Output:1\n```\n\n将变量中的非数字字符替换为数字，得到数字变量\n\n```bash\nc=BB34\necho ${c}     # Output: BB34\n\nd=${c/BB/12}  # 将BB替换为12\necho ${d}     # Output: 1234\n\nlet \"d+=1\"\necho ${d}     # Output: 1235\n```\n\n空变量+数字：数字变量\n\n```bash\n# 变量e定义为空值\ne=\"\"\necho ${e}  # Output: 没有任何输出\n\nlet \"e+=1\" # 空值 + 1\necho ${e}  # Output: 1\n```\n\n未定义的变量+数字：数字变量\n\n```bash\n# 变量f未定义\necho \"f = $f\"   # Output: f =\n\nlet \"f+=1\" \necho \"f = ${f}\" # Output: f = 1\n```\n\n### 变量的作用域\n\n- 局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用`local`声明；\n- 全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；\n- 环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。\n   如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。\n\n> 更多关于环境变量的知识可以参考以下文章：\n>\n> - [Linux环境变量总结](https://www.jianshu.com/p/ac2bc0ad3d74)\n> - [linux入门之环境变量与文件查找](https://www.jianshu.com/p/f7d4a821d292)\n\n## Bash中的运算符\n\nBash支持的运算符有：\n\n- 数学运算符\n- 关系运算符\n- 布尔运算符\n- 逻辑运算符\n- 字符串运算符\n- 文件测试运算符\n\n### 数学运算符\n\n| 数学运算符 | 说明                         |\n| ---------- | ---------------------------- |\n| +          | 加法                         |\n| -          | 减法                         |\n| *          | 乘法                         |\n| /          | 除法                         |\n| %          | 取余                         |\n| =          | 赋值                         |\n| ==         | 相等测试，相等则返回true     |\n| !=         | 不相等测试，不相等则返回true |\n\n**注意：**  乘号`*`前边必须加反斜杠 \\ 才能实现乘法运算\n\n### 关系运算符\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字\n\n| 关系运算符 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| -eq        | (equal)    检测两个数是否相等，相等则返回 true               |\n| -ne        | (not equal）检测两个数是否相等，不相等则返回 true            |\n| -gt        | (greater than）检测左边的数是否大于右边的，如果是，则返回 true |\n| -lt        | (lower than) 检测左边的数是否小于右边的，如果是，则返回 true |\n| -ge        | (greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true |\n| -le        | (lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true |\n\n### 布尔运算符\n\n| 布尔运算符 | 说明                                              |\n| ---------- | ------------------------------------------------- |\n| -a         | 与运算，两个表达式都为 true 才返回 true           |\n| -o         | 或运算，有一个表达式为 true 则返回 true           |\n| !          | 非运算，表达式为 true 则返回 false，否则返回 true |\n\n### 逻辑运算符\n\n| 逻辑运算符 | 说明   |\n| ---------- | ------ |\n| &&         | 逻辑与 |\n| II         | 逻辑或 |\n\n### 字符串运算符\n\n| 字符串运算符 | 说明                                    | 举例  (a=\"abc\" b=\"def\") |\n| ------------ | --------------------------------------- | ----------------------- |\n| =            | 检测两个字符串是否相等，相等返回 true   | [ $a = $b ] 返回 false  |\n| !=           | 检测两个字符串是否相等，不相等返回 true | [ $a != $b ] 返回 true  |\n| -z           | 检测字符串长度是否为0，为0返回 true     | [ -z $a ] 返回 false    |\n| -n           | 检测字符串长度是否为0，不为0返回 true   | [ -n $a ] 返回 true     |\n| str_name     | 检测字符串是否为空，不为空返回 true     | [ $a ] 返回 true        |\n\n### 文件测试运算符\n\n文件测试运算符用于检测 Unix 文件的各种属性\n\n| 文件测试运算符 | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| -b file        | 检测文件是否是块设备文件，如果是，则返回 true                |\n| -c file        | 检测文件是否是字符设备文件，如果是，则返回 true              |\n| -d file        | 检测文件是否是目录，如果是，则返回 true                      |\n| -f file        | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true |\n| -g file        | 检测文件是否设置了 SGID 位，如果是，则返回 true              |\n| -k file        | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true    |\n| -p fill        | 检测文件是否是命名管道，如果是，则返回 true                  |\n| -u file        | 检测文件是否设置了 SUID 位，如果是，则返回 true              |\n| -r file        | 检测文件是否可读，如果是，则返回 true                        |\n| -w file        | 检测文件是否可写，如果是，则返回 true                        |\n| -x file        | 检测文件是否可执行，如果是，则返回 true                      |\n| -s file        | 检测文件是否为空（文件大小是否大于0），不为空返回 true       |\n| -e file        | 检测文件（包括目录）是否存在，如果是，则返回 true            |\n\n## Bash的控制流\n\n### 条件语句\n\n#### if语句\n\n- if\n\n```bash\nif [ condition ]\nthen\n    command\nfi\n```\n\n- if-else\n\n```bash\nif [ condition ]\nthen\n    command\nelse\n    command\nfi\n```\n\n- if-elif-else\n\n```bash\nif [ condition1 ]\nthen\n    command1\nelif [ condition2 ]\n    command2\nelse\n    commandN\nfi\n```\n\n**注意：**\n 勿忘最后的`fi`（`if`的反向拼写）!\n\n#### case语句\n\n```bash\ncase \"${var}\" in\n    \"$condition1\" )\n        command1\n    ;;\n\n    \"$condition2\" )\n        command2\n    ;;\n\n    * )  # 这里相当于C中case语句的default \nesac\n```\n\n**注意：**\n\n- 对变量使用`\"\"`并不是强制的，因为不会发生单词分离;\n- 每句测试行,都以右小括号`)`结尾;\n- 每个条件块都以两个分号`;;`结尾（作用类似C中的break）;\n- case 块的结束以 `esac`(case 的反向拼写)结尾.\n\n### 循环语句\n\n#### for语句\n\n```bash\nfor var in item1 item2 ... itemN\ndo\n    command1\n    command2\n    ...\n    commandN\ndone\n```\n\n**注意：**  \n 在循环的每次执行中，var将顺序的存取 list （i.e. item1 ... itemN）中列出的变量。\n\nC风格的for循环:\n\n```bash\nfor (( EXP1; EXP2; EXP3 ))\ndo\n    command1\n    command2\n    command3\ndone\n```\n\n**注意:**  `(())`中对变量的引用可以不加`$`\n\n#### while语句\n\n```bash\nwhile [ condition ]\ndo\n    command\ndone\n```\n\nC风格的while循环:\n\n```bash\nwhile (( condition ))\ndo\n    command\ndone\n```\n\n**注意:**  `(())`中对变量的引用同样可以不加`$`\n\n#### until语句\n\n```bash\nuntil [ condition-is-true ]\ndo\n    command\ndone\n```\n\n**注意：**  \n util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。\n\n## Bash支持的编程模型\n\nBash只支持**过程式**的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。\n\n## Bash的传参机制\n\nshell通过**位置参数**（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,$0, $1, $2, $3...  其中：\n\n- $0 是该脚本文件的名字\n- $1 是第一个参数, $2 是第 2 个参数...\n\n**注意：**\n\n- $9 以后就需要大括号了,如 ${10}, ${11}, ${12}...\n\n另外，还有几个特殊字符用来处理参数：\n\n| 参数处理 | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数。                     |\n| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同                   |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n`$*` 与 `$@` 区别:\n\n- 相同点：都表示引用所有的位置参数;\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n\n## Bash函数\n\n### 函数的定义\n\n```php\nfunction func_name()\n{\n    # 函数体\n}\n```\n\n**注意：**\n\n- 关键字function是可选的;\n- 函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;\n- 在一个函数内嵌套另一个函数也是可以的，但是不常用.\n\n### 函数的参数传递\n\n函数以**位置**来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, ...\n\n### 函数的调用\n\n函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。\n\n#### 无参函数的调用\n\n\n\n```php\nfunction func1()\n{\n    echo \"Hello World!\"\n    echo \"This is func1\"\n}\n\n# Calling func1\nfunc1\n```\n\n输出：\n\n\n\n```swift\nHello World!\nThis is func1\n```\n\n#### 有参函数的调用\n\n\n\n```bash\nfunction func2()\n{\n    echo \"This is func2\"\n    \n    a=$1\n    b=$2\n    echo \"a is : $a\"\n    echo \"b is : $b\"\n}\n\n# Calling func2,and pass two parameters\nfunc2 \"aaa\" \"bbb\"\n```\n\n输出：\n\n\n\n```csharp\nThis is func2\na is : aaa\nb is : bbb\n```\n\n### 函数中参数的作用域\n\n在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。\n\n如果变量用`local` 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部\"范围\"。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。\n\n\n\n```bash\n  1 #!/bin/bash\n  2\n  3 func()\n  4 {\n  5     global_var=\"I am global_var difined in function func.\"\n  6     echo $global_var\n  7\n  8     local loc_var=\"I am local_var defined in function func\"\n  9     echo $loc_var\n 10 }\n 11\n 12 func\n 13 echo\n 14 echo $global_var\n 15 echo $loc_var\n 16\n 17 exit\n```\n\n输出：\n\n\n\n```go\nI am global_var difined in function func.\nI am local_var defined in function func\n\nI am global_var difined in function func.\n```\n\n## Bash数组\n\nBash 只支持一维数组，用圆括号`()`来表示，数组元素之间用\"空格\"符号来分割（不同于C、C++、Java等语言中用逗号分割）。\n\n### 数组的定义与初始化\n\n初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从`0`开始。\n\n### 初始化方式1：直接初始化\n\n\n\n```undefined\narr_name=(value1 value2 ... valueN) \n```\n\n### 初始化方式2: 用下标初始化\n\n\n\n```bash\narr_name[0]=value1\narr_name[1]=value2\narr_name[223]=value3 # 不连续初始化\n```\n\n**注意：**\n\n- 数组成员不必一定要连续，空缺元素是允许的;\n- 数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;\n\n### 访问数组元素\n\n访问数组元素的一般格式：\n\n\n\n```bash\n${arr_name[index]}\n```\n\n### 遍历数组\n\n使用`*` 或`@` 可以获取数组中的所有元素\n 实例：\n\n\n\n```bash\nmy_arr=(A B C \"ddd\")\n\n# 遍历数组格式1\necho \"my_arr: ${my_arr[*]}\n\n# 遍历数组格式2\necho \"my_arr: ${my_arr[@]}\n```\n\n输出：\n\n\n\n```undefined\nmy_arr: A B C ddd\nmy_arr: A B C ddd\n```\n\n### 获取数组长度\n\n获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了`#`符号，格式：\n\n\n\n```ruby\n${#arr_name[*]}\n```\n\n或者\n\n\n\n```ruby\n${#my_arr[@]}\n```\n\n实例：\n\n\n\n```bash\n# 获取数组my_arr的长度（元素个数）\necho \"my_arr length: ${#my_arr[*]}\n\n# 获取数组my_arr的长度,\necho \"my_arr length: ${#my_arr[@]}\n```\n\n输出：\n\n\n\n```undefined\nmy_arr length: 4\nmy_arr length: 4\n```\n\n## Bash字符串操作\n\n在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。\n 定义字符串实例：\n\n\n\n```bash\nstr1=hello\nstr2='hello'\nstr3=\"hello\"\n\necho $str1\necho $str2\necho $str3\n```\n\n输出：\n\n\n\n```undefined\nhello\nhello\nhello\n```\n\n### 获取字符串长度\n\n格式：\n\n\n\n```ruby\n${#string_name}\n```\n\n实例：\n\n\n\n```bash\nmy_str=\"hello world\"\necho \"my_str length: ${#my_str}\n```\n\n输出：\n\n\n\n```undefined\nmy_str length: 11\n```\n\n### 字符串拼接\n\n和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。\n 实例：\n\n\n\n```bash\nstr1=\"hello\"\nstr2=\"world\"\n\nstr3=${str1}\" \"${str2}\necho ${str3}\n```\n\n输出：\n\n\n\n```undefined\nhello world\n```\n\n### 提取子串\n\n| 表达式                    | 含义                                                 |\n| ------------------------- | ---------------------------------------------------- |\n| ${string:position}        | 在string中, 从位置position开始提取子串               |\n| ${string:position:length} | 在string中, 从位置position开始提取长度为length的子串 |\n\n实例1：从位置1开始提取子串\n\n\n\n```bash\nstr=\"hello world\"\n\nsub_str=${str:1}\necho \"sub_str: ${sub_str}\"\n```\n\n输出：\n\n\n\n```undefined\nsub_str: ello world\n```\n\n实例2：从位置1开始提取长度为3的子串\n\n\n\n```bash\nstr=\"hello world\"\n\nsub_str=${str:1:3}\necho \"sub_str: ${sub_str}\"\n```\n\n输出：\n\n\n\n```undefined\nsub_str: ell\n```\n\n### 删除子串\n\n| 表达式               | 含义                                        |\n| -------------------- | ------------------------------------------- |\n| ${string#substring}  | 从string的开头, 删除最短匹配substring的子串 |\n| ${string##substring} | 从string的开头, 删除最长匹配substring的子串 |\n| ${string%substring}  | 从string的结尾, 删除最短匹配substring的子串 |\n| ${string%%substring} | 从string的结尾, 删除最长匹配substring的子串 |\n\n记忆：\n\n- `#`表示从头匹配，`%`表示从尾匹配\n- 一个符号（`#`或者`%`）表示最短匹配，两个符号（`##`或者`%%`）表示最长匹配\n\n**注意：**substring可以是正则表达式。\n\n实例：\n\n\n\n```bash\nstr=\"abcabcdefabcabc\"\n\n# 从str的开头,删除最短匹配的以a开头c结尾的子串\n# 将删除最左端的abc\n# 输出：abcdefabcabc\necho \"${str#a*c}\"  \n\n# 从str的开头,删除最长匹配以a开头b结尾的子串\n# 将删除abcabcdefabcab\n# 输出：c\necho \"${str##a*b}\" \n\n# 从str的结尾,删除最短匹配以a开头c结尾的子串\n# 将删除最右端的abc\n# 输出：abcabcdefabc\necho \"${str%a*c}\"  \n\n# 从str的结尾,删除最长匹配以a开头c结尾的子串\n# 将删除整个字符串\n# 输出：空\necho \"${str%%a*b}\" \n```\n\n### 替换子串\n\n| 表达式                           | 含义                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| ${string/substring/replacement}  | 使用$replacement 来代替**第一个**匹配的$substring            |\n| ${string//substring/replacement} | 使用$replacement 代替**所有**匹配的$substring                |\n| ${string/#substring/replacement} | 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring |\n| ${string/%substring/replacement} | 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring |\n\n实例：\n\n\n\n```ruby\nstr=\"abcdefabc\"\n\n# 用hello替换第一个abc\necho ${str/\"abc\"/\"hello\"}    # 输出：hellodefabc\n\n# 用hello替换第一个abc\necho ${str//\"abc\"/\"hello\"}   # 输出：hellodefhello\n\n# 前缀匹配替换\necho ${str/#\"abc\"/\"world\"}   # 输出：worlddefabc\n\n# 后缀匹配替换\necho ${str/％\"abc\"/\"world\"}   # 输出：abcdefworld\n```\n\n## References\n\n[Advanced Bash-Scripting Guide](https://link.jianshu.com?t=http://tldp.org/LDP/abs/html/)\n 这本书内容翔实，实例丰富，既可做精钻细研的教材，又可作为手册时时查阅，真是居家旅行必备良品;-)\n\n另外，感兴趣的同学也可翻阅《Linux Shell Scripting Cookbook》(中文译名《Linux Shell脚本攻略》)，里面介绍了很多Shell编程的奇技淫巧，甚是有用有趣。","source":"_posts/2020-03-19-Bash-Shell编程入门.md","raw":"---\nlayout: post\ntitle:  Bash Shell编程入门\ndate:   2020-03-19 12:00:00\ndescription: 程序员必备基础知识，不会的不配找到工作\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321004047.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\nauthor: echoworlding\n---\n\n**作者：echoworlding**\n\n**链接：https://www.jianshu.com/p/e1c8e5bfa45e**\n\n**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**\n\n## Shell是什么？\n\nshell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。\n\n### Shell语言的流派\n\n目前，shell主要有两大流派：\n\n- sh:\n  - burne shell (sh)\n  - burne again shell (bash)\n- csh:\n  - c shell (csh)\n  - tc shell (tcsh)\n  - korn shell (ksh)\n\n目前，大部分Linux系统预设的shell都是bash。\n\n> Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：\n\n```bash\nslot@slot-ubt:~$ cat /etc/shells \n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\nslot@slot-ubt:~$ \n```\n\n> Mac OS提供的shell环境：\n\n```bash\n$ cat /etc/shells\n# List of acceptable shells for chpass(1).\n# Ftpd will not allow users to connect who are not using\n# one of these shells.\n>\n/bin/bash\n/bin/csh\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh  # zsh系本文作者自己安装 \n```\n\n> 注意：\n>\n> 在Catalina之后mac就不是使用bash的了，而是使用zsh的\n\n### 一个极简的bash demo: hello_world.sh\n\n```bash\n    #!/bin/bash\n    \n    # Here is comment \n    echo \"Hello World!\"\n```\n\n**执行**  \n\n方法1: 直接使用bash解释器来解释执行：\n\n```bash\n    bash hello_world.sh\n```\n\n或者：\n\n```bash\n    sh hello_world.sh\n```\n\n方法2: 先将文件属性改为可执行状态：\n\n\n\n```bash\n    chmod +x hello_world.sh\n```\n\n或者：\n\n\n\n```bash\n    chmod 777 hello_world.sh  \n```\n\n再直接执行：\n\n\n\n```bash\n    ./hello_world.sh\n```\n\n**输出**\n\n\n\n```bash\n    Hello World!\n```\n\n**解释**\n\n\n\n#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。\n\n#开头的是注释行(#!除外)，shell中只有单行注释。  \n\n```bash\n    echo \"Hello World!\" 即用echo命令输出字符串\"Hello World!\"到终端显示器。\n```\n\n> **补充知识: 文件的属性**\n>  通过`ls -l`命令可以查看文件的属性，例如查看新建文件test.sh的属性：\n\n```ruby\nslot@slot-ubt:~$ touch test.sh\nslot@slot-ubt:~$ ls -l test.sh \n-rw-rw-r-- 1 slot slot 0 12月 21 15:40 test.sh\n```\n\n> 可以看到，一般新建文件的默认属性是`-rw-rw-r--`，即644，不具有可执行属性`x`，可使用`chmod`命令来改变文件属性（修改默认属性则使用`umask`命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：\n\n```ruby\nslot@slot-ubt:~$ chmod 777 test.sh \nslot@slot-ubt:~$ ls -l test.sh \n-rwxrwxrwx 1 slot slot 0 12月 21 15:40 test.sh\n```\n\n## Bash中的变量\n\n### 变量的定义与赋值\n\n不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：\n\n```bash\nmy_bash_var=\"this is my bash var\"\n```\n\n**注意**:\n\n- **`＝`两边不能有空格！**否则就是语法错误了。\n- Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。\n\n### 变量的引用\n\n使用已定义的变量时，只要在变量名前面加`$`符号即可:\n\n```bash\necho $my_bash_var\n```\n\n或者使用`${var_name}`的形式，`{}`是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：\n\n```bash\necho ${my_bash_var}\n```\n\n注意`''`和`\"\"`的区别：\n\n- `''` ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；\n- `\"\"`：双引号里可以引用变量，可以出现转义字符。\n\n实例：\n\n```bash\na=\"hello\"\necho 'a is : $a'\necho \"a is : $a\"\n```\n\nOutput:\n\n```csharp\na is : $a\na is : hello\n```\n\n#### 只读变量\n\n使用 **`readonly`** 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.\n\n```bash\na_var=\"hello\"\nreadonly a_var\na_var=\"world\"  # Output: bash: read-only variable: a_var\n```\n\n#### 删除变量\n\n使用 **`unset`** 命令可以删除变量，但是不能删除只读变量。\n 变量被删除后不能再次使用。\n\n```bash\nmy_var=\"haha\"\nunset my_var\necho ${my_var} # 变量my_var已被删除，没有任何输出\n```\n\n### 变量的类型\n\n诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分**类型**。\n\n本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是**变量中的值是否只有数字**，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。\n\n另外，注意Bash中的数字默认的是十进制，八进制需要以`0`开头，十六进制以`0x`开头。\n\n纯数字变量是“数字变量”：\n\n```bash\na=1234\nlet \"a+=1\"\necho ${a}  # Output: 1235\n```\n\n数字＋字符串：字符串变量，字符串变量不能进行数学运算\n\n```bash\nb=${a/12/BB} # 将12替换为BB\necho ${b}    # Output: BB35\n\nlet \"b+=1\"\necho ${b}    # Output:1\n```\n\n将变量中的非数字字符替换为数字，得到数字变量\n\n```bash\nc=BB34\necho ${c}     # Output: BB34\n\nd=${c/BB/12}  # 将BB替换为12\necho ${d}     # Output: 1234\n\nlet \"d+=1\"\necho ${d}     # Output: 1235\n```\n\n空变量+数字：数字变量\n\n```bash\n# 变量e定义为空值\ne=\"\"\necho ${e}  # Output: 没有任何输出\n\nlet \"e+=1\" # 空值 + 1\necho ${e}  # Output: 1\n```\n\n未定义的变量+数字：数字变量\n\n```bash\n# 变量f未定义\necho \"f = $f\"   # Output: f =\n\nlet \"f+=1\" \necho \"f = ${f}\" # Output: f = 1\n```\n\n### 变量的作用域\n\n- 局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用`local`声明；\n- 全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；\n- 环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。\n   如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。\n\n> 更多关于环境变量的知识可以参考以下文章：\n>\n> - [Linux环境变量总结](https://www.jianshu.com/p/ac2bc0ad3d74)\n> - [linux入门之环境变量与文件查找](https://www.jianshu.com/p/f7d4a821d292)\n\n## Bash中的运算符\n\nBash支持的运算符有：\n\n- 数学运算符\n- 关系运算符\n- 布尔运算符\n- 逻辑运算符\n- 字符串运算符\n- 文件测试运算符\n\n### 数学运算符\n\n| 数学运算符 | 说明                         |\n| ---------- | ---------------------------- |\n| +          | 加法                         |\n| -          | 减法                         |\n| *          | 乘法                         |\n| /          | 除法                         |\n| %          | 取余                         |\n| =          | 赋值                         |\n| ==         | 相等测试，相等则返回true     |\n| !=         | 不相等测试，不相等则返回true |\n\n**注意：**  乘号`*`前边必须加反斜杠 \\ 才能实现乘法运算\n\n### 关系运算符\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字\n\n| 关系运算符 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| -eq        | (equal)    检测两个数是否相等，相等则返回 true               |\n| -ne        | (not equal）检测两个数是否相等，不相等则返回 true            |\n| -gt        | (greater than）检测左边的数是否大于右边的，如果是，则返回 true |\n| -lt        | (lower than) 检测左边的数是否小于右边的，如果是，则返回 true |\n| -ge        | (greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true |\n| -le        | (lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true |\n\n### 布尔运算符\n\n| 布尔运算符 | 说明                                              |\n| ---------- | ------------------------------------------------- |\n| -a         | 与运算，两个表达式都为 true 才返回 true           |\n| -o         | 或运算，有一个表达式为 true 则返回 true           |\n| !          | 非运算，表达式为 true 则返回 false，否则返回 true |\n\n### 逻辑运算符\n\n| 逻辑运算符 | 说明   |\n| ---------- | ------ |\n| &&         | 逻辑与 |\n| II         | 逻辑或 |\n\n### 字符串运算符\n\n| 字符串运算符 | 说明                                    | 举例  (a=\"abc\" b=\"def\") |\n| ------------ | --------------------------------------- | ----------------------- |\n| =            | 检测两个字符串是否相等，相等返回 true   | [ $a = $b ] 返回 false  |\n| !=           | 检测两个字符串是否相等，不相等返回 true | [ $a != $b ] 返回 true  |\n| -z           | 检测字符串长度是否为0，为0返回 true     | [ -z $a ] 返回 false    |\n| -n           | 检测字符串长度是否为0，不为0返回 true   | [ -n $a ] 返回 true     |\n| str_name     | 检测字符串是否为空，不为空返回 true     | [ $a ] 返回 true        |\n\n### 文件测试运算符\n\n文件测试运算符用于检测 Unix 文件的各种属性\n\n| 文件测试运算符 | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| -b file        | 检测文件是否是块设备文件，如果是，则返回 true                |\n| -c file        | 检测文件是否是字符设备文件，如果是，则返回 true              |\n| -d file        | 检测文件是否是目录，如果是，则返回 true                      |\n| -f file        | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true |\n| -g file        | 检测文件是否设置了 SGID 位，如果是，则返回 true              |\n| -k file        | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true    |\n| -p fill        | 检测文件是否是命名管道，如果是，则返回 true                  |\n| -u file        | 检测文件是否设置了 SUID 位，如果是，则返回 true              |\n| -r file        | 检测文件是否可读，如果是，则返回 true                        |\n| -w file        | 检测文件是否可写，如果是，则返回 true                        |\n| -x file        | 检测文件是否可执行，如果是，则返回 true                      |\n| -s file        | 检测文件是否为空（文件大小是否大于0），不为空返回 true       |\n| -e file        | 检测文件（包括目录）是否存在，如果是，则返回 true            |\n\n## Bash的控制流\n\n### 条件语句\n\n#### if语句\n\n- if\n\n```bash\nif [ condition ]\nthen\n    command\nfi\n```\n\n- if-else\n\n```bash\nif [ condition ]\nthen\n    command\nelse\n    command\nfi\n```\n\n- if-elif-else\n\n```bash\nif [ condition1 ]\nthen\n    command1\nelif [ condition2 ]\n    command2\nelse\n    commandN\nfi\n```\n\n**注意：**\n 勿忘最后的`fi`（`if`的反向拼写）!\n\n#### case语句\n\n```bash\ncase \"${var}\" in\n    \"$condition1\" )\n        command1\n    ;;\n\n    \"$condition2\" )\n        command2\n    ;;\n\n    * )  # 这里相当于C中case语句的default \nesac\n```\n\n**注意：**\n\n- 对变量使用`\"\"`并不是强制的，因为不会发生单词分离;\n- 每句测试行,都以右小括号`)`结尾;\n- 每个条件块都以两个分号`;;`结尾（作用类似C中的break）;\n- case 块的结束以 `esac`(case 的反向拼写)结尾.\n\n### 循环语句\n\n#### for语句\n\n```bash\nfor var in item1 item2 ... itemN\ndo\n    command1\n    command2\n    ...\n    commandN\ndone\n```\n\n**注意：**  \n 在循环的每次执行中，var将顺序的存取 list （i.e. item1 ... itemN）中列出的变量。\n\nC风格的for循环:\n\n```bash\nfor (( EXP1; EXP2; EXP3 ))\ndo\n    command1\n    command2\n    command3\ndone\n```\n\n**注意:**  `(())`中对变量的引用可以不加`$`\n\n#### while语句\n\n```bash\nwhile [ condition ]\ndo\n    command\ndone\n```\n\nC风格的while循环:\n\n```bash\nwhile (( condition ))\ndo\n    command\ndone\n```\n\n**注意:**  `(())`中对变量的引用同样可以不加`$`\n\n#### until语句\n\n```bash\nuntil [ condition-is-true ]\ndo\n    command\ndone\n```\n\n**注意：**  \n util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。\n\n## Bash支持的编程模型\n\nBash只支持**过程式**的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。\n\n## Bash的传参机制\n\nshell通过**位置参数**（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,$0, $1, $2, $3...  其中：\n\n- $0 是该脚本文件的名字\n- $1 是第一个参数, $2 是第 2 个参数...\n\n**注意：**\n\n- $9 以后就需要大括号了,如 ${10}, ${11}, ${12}...\n\n另外，还有几个特殊字符用来处理参数：\n\n| 参数处理 | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数。                     |\n| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同                   |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n`$*` 与 `$@` 区别:\n\n- 相同点：都表示引用所有的位置参数;\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n\n## Bash函数\n\n### 函数的定义\n\n```php\nfunction func_name()\n{\n    # 函数体\n}\n```\n\n**注意：**\n\n- 关键字function是可选的;\n- 函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;\n- 在一个函数内嵌套另一个函数也是可以的，但是不常用.\n\n### 函数的参数传递\n\n函数以**位置**来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, ...\n\n### 函数的调用\n\n函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。\n\n#### 无参函数的调用\n\n\n\n```php\nfunction func1()\n{\n    echo \"Hello World!\"\n    echo \"This is func1\"\n}\n\n# Calling func1\nfunc1\n```\n\n输出：\n\n\n\n```swift\nHello World!\nThis is func1\n```\n\n#### 有参函数的调用\n\n\n\n```bash\nfunction func2()\n{\n    echo \"This is func2\"\n    \n    a=$1\n    b=$2\n    echo \"a is : $a\"\n    echo \"b is : $b\"\n}\n\n# Calling func2,and pass two parameters\nfunc2 \"aaa\" \"bbb\"\n```\n\n输出：\n\n\n\n```csharp\nThis is func2\na is : aaa\nb is : bbb\n```\n\n### 函数中参数的作用域\n\n在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。\n\n如果变量用`local` 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部\"范围\"。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。\n\n\n\n```bash\n  1 #!/bin/bash\n  2\n  3 func()\n  4 {\n  5     global_var=\"I am global_var difined in function func.\"\n  6     echo $global_var\n  7\n  8     local loc_var=\"I am local_var defined in function func\"\n  9     echo $loc_var\n 10 }\n 11\n 12 func\n 13 echo\n 14 echo $global_var\n 15 echo $loc_var\n 16\n 17 exit\n```\n\n输出：\n\n\n\n```go\nI am global_var difined in function func.\nI am local_var defined in function func\n\nI am global_var difined in function func.\n```\n\n## Bash数组\n\nBash 只支持一维数组，用圆括号`()`来表示，数组元素之间用\"空格\"符号来分割（不同于C、C++、Java等语言中用逗号分割）。\n\n### 数组的定义与初始化\n\n初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从`0`开始。\n\n### 初始化方式1：直接初始化\n\n\n\n```undefined\narr_name=(value1 value2 ... valueN) \n```\n\n### 初始化方式2: 用下标初始化\n\n\n\n```bash\narr_name[0]=value1\narr_name[1]=value2\narr_name[223]=value3 # 不连续初始化\n```\n\n**注意：**\n\n- 数组成员不必一定要连续，空缺元素是允许的;\n- 数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;\n\n### 访问数组元素\n\n访问数组元素的一般格式：\n\n\n\n```bash\n${arr_name[index]}\n```\n\n### 遍历数组\n\n使用`*` 或`@` 可以获取数组中的所有元素\n 实例：\n\n\n\n```bash\nmy_arr=(A B C \"ddd\")\n\n# 遍历数组格式1\necho \"my_arr: ${my_arr[*]}\n\n# 遍历数组格式2\necho \"my_arr: ${my_arr[@]}\n```\n\n输出：\n\n\n\n```undefined\nmy_arr: A B C ddd\nmy_arr: A B C ddd\n```\n\n### 获取数组长度\n\n获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了`#`符号，格式：\n\n\n\n```ruby\n${#arr_name[*]}\n```\n\n或者\n\n\n\n```ruby\n${#my_arr[@]}\n```\n\n实例：\n\n\n\n```bash\n# 获取数组my_arr的长度（元素个数）\necho \"my_arr length: ${#my_arr[*]}\n\n# 获取数组my_arr的长度,\necho \"my_arr length: ${#my_arr[@]}\n```\n\n输出：\n\n\n\n```undefined\nmy_arr length: 4\nmy_arr length: 4\n```\n\n## Bash字符串操作\n\n在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。\n 定义字符串实例：\n\n\n\n```bash\nstr1=hello\nstr2='hello'\nstr3=\"hello\"\n\necho $str1\necho $str2\necho $str3\n```\n\n输出：\n\n\n\n```undefined\nhello\nhello\nhello\n```\n\n### 获取字符串长度\n\n格式：\n\n\n\n```ruby\n${#string_name}\n```\n\n实例：\n\n\n\n```bash\nmy_str=\"hello world\"\necho \"my_str length: ${#my_str}\n```\n\n输出：\n\n\n\n```undefined\nmy_str length: 11\n```\n\n### 字符串拼接\n\n和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。\n 实例：\n\n\n\n```bash\nstr1=\"hello\"\nstr2=\"world\"\n\nstr3=${str1}\" \"${str2}\necho ${str3}\n```\n\n输出：\n\n\n\n```undefined\nhello world\n```\n\n### 提取子串\n\n| 表达式                    | 含义                                                 |\n| ------------------------- | ---------------------------------------------------- |\n| ${string:position}        | 在string中, 从位置position开始提取子串               |\n| ${string:position:length} | 在string中, 从位置position开始提取长度为length的子串 |\n\n实例1：从位置1开始提取子串\n\n\n\n```bash\nstr=\"hello world\"\n\nsub_str=${str:1}\necho \"sub_str: ${sub_str}\"\n```\n\n输出：\n\n\n\n```undefined\nsub_str: ello world\n```\n\n实例2：从位置1开始提取长度为3的子串\n\n\n\n```bash\nstr=\"hello world\"\n\nsub_str=${str:1:3}\necho \"sub_str: ${sub_str}\"\n```\n\n输出：\n\n\n\n```undefined\nsub_str: ell\n```\n\n### 删除子串\n\n| 表达式               | 含义                                        |\n| -------------------- | ------------------------------------------- |\n| ${string#substring}  | 从string的开头, 删除最短匹配substring的子串 |\n| ${string##substring} | 从string的开头, 删除最长匹配substring的子串 |\n| ${string%substring}  | 从string的结尾, 删除最短匹配substring的子串 |\n| ${string%%substring} | 从string的结尾, 删除最长匹配substring的子串 |\n\n记忆：\n\n- `#`表示从头匹配，`%`表示从尾匹配\n- 一个符号（`#`或者`%`）表示最短匹配，两个符号（`##`或者`%%`）表示最长匹配\n\n**注意：**substring可以是正则表达式。\n\n实例：\n\n\n\n```bash\nstr=\"abcabcdefabcabc\"\n\n# 从str的开头,删除最短匹配的以a开头c结尾的子串\n# 将删除最左端的abc\n# 输出：abcdefabcabc\necho \"${str#a*c}\"  \n\n# 从str的开头,删除最长匹配以a开头b结尾的子串\n# 将删除abcabcdefabcab\n# 输出：c\necho \"${str##a*b}\" \n\n# 从str的结尾,删除最短匹配以a开头c结尾的子串\n# 将删除最右端的abc\n# 输出：abcabcdefabc\necho \"${str%a*c}\"  \n\n# 从str的结尾,删除最长匹配以a开头c结尾的子串\n# 将删除整个字符串\n# 输出：空\necho \"${str%%a*b}\" \n```\n\n### 替换子串\n\n| 表达式                           | 含义                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| ${string/substring/replacement}  | 使用$replacement 来代替**第一个**匹配的$substring            |\n| ${string//substring/replacement} | 使用$replacement 代替**所有**匹配的$substring                |\n| ${string/#substring/replacement} | 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring |\n| ${string/%substring/replacement} | 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring |\n\n实例：\n\n\n\n```ruby\nstr=\"abcdefabc\"\n\n# 用hello替换第一个abc\necho ${str/\"abc\"/\"hello\"}    # 输出：hellodefabc\n\n# 用hello替换第一个abc\necho ${str//\"abc\"/\"hello\"}   # 输出：hellodefhello\n\n# 前缀匹配替换\necho ${str/#\"abc\"/\"world\"}   # 输出：worlddefabc\n\n# 后缀匹配替换\necho ${str/％\"abc\"/\"world\"}   # 输出：abcdefworld\n```\n\n## References\n\n[Advanced Bash-Scripting Guide](https://link.jianshu.com?t=http://tldp.org/LDP/abs/html/)\n 这本书内容翔实，实例丰富，既可做精钻细研的教材，又可作为手册时时查阅，真是居家旅行必备良品;-)\n\n另外，感兴趣的同学也可翻阅《Linux Shell Scripting Cookbook》(中文译名《Linux Shell脚本攻略》)，里面介绍了很多Shell编程的奇技淫巧，甚是有用有趣。","slug":"Bash-Shell编程入门","published":1,"updated":"2020-03-29T06:59:20.715Z","photos":[],"link":"","_id":"ck8ct7j5u000ugtvibfvdgidv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>作者：echoworlding</strong></p>\n<p><strong>链接：<a href=\"https://www.jianshu.com/p/e1c8e5bfa45e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e1c8e5bfa45e</a></strong></p>\n<p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p>\n<h2 id=\"Shell是什么？\"><a href=\"#Shell是什么？\" class=\"headerlink\" title=\"Shell是什么？\"></a>Shell是什么？</h2><p>shell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。</p>\n<h3 id=\"Shell语言的流派\"><a href=\"#Shell语言的流派\" class=\"headerlink\" title=\"Shell语言的流派\"></a>Shell语言的流派</h3><p>目前，shell主要有两大流派：</p>\n<ul>\n<li>sh:<ul>\n<li>burne shell (sh)</li>\n<li>burne again shell (bash)</li>\n</ul>\n</li>\n<li>csh:<ul>\n<li>c shell (csh)</li>\n<li>tc shell (tcsh)</li>\n<li>korn shell (ksh)</li>\n</ul>\n</li>\n</ul>\n<p>目前，大部分Linux系统预设的shell都是bash。</p>\n<blockquote>\n<p>Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-ubt:~$ cat /etc/shells </span><br><span class=\"line\"><span class=\"comment\"># /etc/shells: valid login shells</span></span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/rbash</span><br><span class=\"line\">slot@slot-ubt:~$</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Mac OS提供的shell环境：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/shells</span><br><span class=\"line\"><span class=\"comment\"># List of acceptable shells for chpass(1).</span></span><br><span class=\"line\"><span class=\"comment\"># Ftpd will not allow users to connect who are not using</span></span><br><span class=\"line\"><span class=\"comment\"># one of these shells.</span></span><br><span class=\"line\">&gt;</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/csh</span><br><span class=\"line\">/bin/ksh</span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/zsh  <span class=\"comment\"># zsh系本文作者自己安装</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<p>在Catalina之后mac就不是使用bash的了，而是使用zsh的</p>\n</blockquote>\n<h3 id=\"一个极简的bash-demo-hello-world-sh\"><a href=\"#一个极简的bash-demo-hello-world-sh\" class=\"headerlink\" title=\"一个极简的bash demo: hello_world.sh\"></a>一个极简的bash demo: hello_world.sh</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Here is comment </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>执行</strong>  </p>\n<p>方法1: 直接使用bash解释器来解释执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>方法2: 先将文件属性改为可执行状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>再直接执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。</p>\n<p>#开头的是注释行(#!除外)，shell中只有单行注释。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Hello World!\"</span> 即用<span class=\"built_in\">echo</span>命令输出字符串<span class=\"string\">\"Hello World!\"</span>到终端显示器。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>补充知识: 文件的属性</strong><br> 通过<code>ls -l</code>命令可以查看文件的属性，例如查看新建文件test.sh的属性：</p>\n</blockquote>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ touch test.sh</span><br><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ ls -l test.sh </span><br><span class=\"line\">-rw-rw-r-- <span class=\"number\">1</span> slot slot <span class=\"number\">0</span> <span class=\"number\">12</span>月 <span class=\"number\">21</span> <span class=\"number\">15</span><span class=\"symbol\">:</span><span class=\"number\">40</span> test.sh</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看到，一般新建文件的默认属性是<code>-rw-rw-r--</code>，即644，不具有可执行属性<code>x</code>，可使用<code>chmod</code>命令来改变文件属性（修改默认属性则使用<code>umask</code>命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：</p>\n</blockquote>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ chmod <span class=\"number\">777</span> test.sh </span><br><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ ls -l test.sh </span><br><span class=\"line\">-rwxrwxrwx <span class=\"number\">1</span> slot slot <span class=\"number\">0</span> <span class=\"number\">12</span>月 <span class=\"number\">21</span> <span class=\"number\">15</span><span class=\"symbol\">:</span><span class=\"number\">40</span> test.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash中的变量\"><a href=\"#Bash中的变量\" class=\"headerlink\" title=\"Bash中的变量\"></a>Bash中的变量</h2><h3 id=\"变量的定义与赋值\"><a href=\"#变量的定义与赋值\" class=\"headerlink\" title=\"变量的定义与赋值\"></a>变量的定义与赋值</h3><p>不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_bash_var=<span class=\"string\">\"this is my bash var\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>:</p>\n<ul>\n<li><strong><code>＝</code>两边不能有空格！</strong>否则就是语法错误了。</li>\n<li>Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。</li>\n</ul>\n<h3 id=\"变量的引用\"><a href=\"#变量的引用\" class=\"headerlink\" title=\"变量的引用\"></a>变量的引用</h3><p>使用已定义的变量时，只要在变量名前面加<code>$</code>符号即可:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$my_bash_var</span></span><br></pre></td></tr></table></figure>\n\n<p>或者使用<code>${var_name}</code>的形式，<code>{}</code>是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;my_bash_var&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意<code>&#39;&#39;</code>和<code>&quot;&quot;</code>的区别：</p>\n<ul>\n<li><code>&#39;&#39;</code> ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；</li>\n<li><code>&quot;&quot;</code>：双引号里可以引用变量，可以出现转义字符。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'a is : $a'</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"a is : <span class=\"variable\">$a</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>Output:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"keyword\">is</span> : $a</span><br><span class=\"line\">a <span class=\"keyword\">is</span> : hello</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h4><p>使用 <strong><code>readonly</code></strong> 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_var=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">readonly</span> a_var</span><br><span class=\"line\">a_var=<span class=\"string\">\"world\"</span>  <span class=\"comment\"># Output: bash: read-only variable: a_var</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除变量\"><a href=\"#删除变量\" class=\"headerlink\" title=\"删除变量\"></a>删除变量</h4><p>使用 <strong><code>unset</code></strong> 命令可以删除变量，但是不能删除只读变量。<br> 变量被删除后不能再次使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_var=<span class=\"string\">\"haha\"</span></span><br><span class=\"line\"><span class=\"built_in\">unset</span> my_var</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;my_var&#125;</span> <span class=\"comment\"># 变量my_var已被删除，没有任何输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h3><p>诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分<strong>类型</strong>。</p>\n<p>本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是<strong>变量中的值是否只有数字</strong>，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。</p>\n<p>另外，注意Bash中的数字默认的是十进制，八进制需要以<code>0</code>开头，十六进制以<code>0x</code>开头。</p>\n<p>纯数字变量是“数字变量”：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1234</span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"a+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a&#125;</span>  <span class=\"comment\"># Output: 1235</span></span><br></pre></td></tr></table></figure>\n\n<p>数字＋字符串：字符串变量，字符串变量不能进行数学运算</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b=<span class=\"variable\">$&#123;a/12/BB&#125;</span> <span class=\"comment\"># 将12替换为BB</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;b&#125;</span>    <span class=\"comment\"># Output: BB35</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"b+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;b&#125;</span>    <span class=\"comment\"># Output:1</span></span><br></pre></td></tr></table></figure>\n\n<p>将变量中的非数字字符替换为数字，得到数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c=BB34</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;c&#125;</span>     <span class=\"comment\"># Output: BB34</span></span><br><span class=\"line\"></span><br><span class=\"line\">d=<span class=\"variable\">$&#123;c/BB/12&#125;</span>  <span class=\"comment\"># 将BB替换为12</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;d&#125;</span>     <span class=\"comment\"># Output: 1234</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"d+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;d&#125;</span>     <span class=\"comment\"># Output: 1235</span></span><br></pre></td></tr></table></figure>\n\n<p>空变量+数字：数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 变量e定义为空值</span></span><br><span class=\"line\">e=<span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;e&#125;</span>  <span class=\"comment\"># Output: 没有任何输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"e+=1\"</span> <span class=\"comment\"># 空值 + 1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;e&#125;</span>  <span class=\"comment\"># Output: 1</span></span><br></pre></td></tr></table></figure>\n\n<p>未定义的变量+数字：数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 变量f未定义</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"f = <span class=\"variable\">$f</span>\"</span>   <span class=\"comment\"># Output: f =</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"f+=1\"</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"f = <span class=\"variable\">$&#123;f&#125;</span>\"</span> <span class=\"comment\"># Output: f = 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的作用域\"><a href=\"#变量的作用域\" class=\"headerlink\" title=\"变量的作用域\"></a>变量的作用域</h3><ul>\n<li>局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用<code>local</code>声明；</li>\n<li>全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；</li>\n<li>环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。<br> 如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。</li>\n</ul>\n<blockquote>\n<p>更多关于环境变量的知识可以参考以下文章：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/ac2bc0ad3d74\" target=\"_blank\" rel=\"noopener\">Linux环境变量总结</a></li>\n<li><a href=\"https://www.jianshu.com/p/f7d4a821d292\" target=\"_blank\" rel=\"noopener\">linux入门之环境变量与文件查找</a></li>\n</ul>\n</blockquote>\n<h2 id=\"Bash中的运算符\"><a href=\"#Bash中的运算符\" class=\"headerlink\" title=\"Bash中的运算符\"></a>Bash中的运算符</h2><p>Bash支持的运算符有：</p>\n<ul>\n<li>数学运算符</li>\n<li>关系运算符</li>\n<li>布尔运算符</li>\n<li>逻辑运算符</li>\n<li>字符串运算符</li>\n<li>文件测试运算符</li>\n</ul>\n<h3 id=\"数学运算符\"><a href=\"#数学运算符\" class=\"headerlink\" title=\"数学运算符\"></a>数学运算符</h3><table>\n<thead>\n<tr>\n<th>数学运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等测试，相等则返回true</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等测试，不相等则返回true</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong>  乘号<code>*</code>前边必须加反斜杠 \\ 才能实现乘法运算</p>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p>\n<table>\n<thead>\n<tr>\n<th>关系运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-eq</td>\n<td>(equal)    检测两个数是否相等，相等则返回 true</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>(not equal）检测两个数是否相等，不相等则返回 true</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>(greater than）检测左边的数是否大于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>(lower than) 检测左边的数是否小于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>(greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>(lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"布尔运算符\"><a href=\"#布尔运算符\" class=\"headerlink\" title=\"布尔运算符\"></a>布尔运算符</h3><table>\n<thead>\n<tr>\n<th>布尔运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><table>\n<thead>\n<tr>\n<th>逻辑运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>II</td>\n<td>逻辑或</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h3><table>\n<thead>\n<tr>\n<th>字符串运算符</th>\n<th>说明</th>\n<th>举例  (a=”abc” b=”def”)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>检测两个字符串是否相等，相等返回 true</td>\n<td>[ $a = $b ] 返回 false</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检测两个字符串是否相等，不相等返回 true</td>\n<td>[ $a != $b ] 返回 true</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>检测字符串长度是否为0，为0返回 true</td>\n<td>[ -z $a ] 返回 false</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>检测字符串长度是否为0，不为0返回 true</td>\n<td>[ -n $a ] 返回 true</td>\n</tr>\n<tr>\n<td>str_name</td>\n<td>检测字符串是否为空，不为空返回 true</td>\n<td>[ $a ] 返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性</p>\n<table>\n<thead>\n<tr>\n<th>文件测试运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-b file</td>\n<td>检测文件是否是块设备文件，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-c file</td>\n<td>检测文件是否是字符设备文件，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-d file</td>\n<td>检测文件是否是目录，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-g file</td>\n<td>检测文件是否设置了 SGID 位，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-k file</td>\n<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-p fill</td>\n<td>检测文件是否是命名管道，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-u file</td>\n<td>检测文件是否设置了 SUID 位，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>检测文件是否可读，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>检测文件是否可写，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检测文件是否可执行，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>检测文件（包括目录）是否存在，如果是，则返回 true</td>\n</tr>\n</tbody></table>\n<h2 id=\"Bash的控制流\"><a href=\"#Bash的控制流\" class=\"headerlink\" title=\"Bash的控制流\"></a>Bash的控制流</h2><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><h4 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h4><ul>\n<li>if</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if-else</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if-elif-else</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition1 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ condition2 ]</span><br><span class=\"line\">    command2</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    commandN</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> 勿忘最后的<code>fi</code>（<code>if</code>的反向拼写）!</p>\n<h4 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$&#123;var&#125;</span>\"</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"string\">\"<span class=\"variable\">$condition1</span>\"</span> )</span><br><span class=\"line\">        command1</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"<span class=\"variable\">$condition2</span>\"</span> )</span><br><span class=\"line\">        command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">    * )  <span class=\"comment\"># 这里相当于C中case语句的default </span></span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>对变量使用<code>&quot;&quot;</code>并不是强制的，因为不会发生单词分离;</li>\n<li>每句测试行,都以右小括号<code>)</code>结尾;</li>\n<li>每个条件块都以两个分号<code>;;</code>结尾（作用类似C中的break）;</li>\n<li>case 块的结束以 <code>esac</code>(case 的反向拼写)结尾.</li>\n</ul>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><h4 id=\"for语句\"><a href=\"#for语句\" class=\"headerlink\" title=\"for语句\"></a>for语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> var <span class=\"keyword\">in</span> item1 item2 ... itemN</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> 在循环的每次执行中，var将顺序的存取 list （i.e. item1 … itemN）中列出的变量。</p>\n<p>C风格的for循环:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (( EXP1; EXP2; EXP3 ))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    command3</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong>  <code>(())</code>中对变量的引用可以不加<code>$</code></p>\n<h4 id=\"while语句\"><a href=\"#while语句\" class=\"headerlink\" title=\"while语句\"></a>while语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>C风格的while循环:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (( condition ))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong>  <code>(())</code>中对变量的引用同样可以不加<code>$</code></p>\n<h4 id=\"until语句\"><a href=\"#until语句\" class=\"headerlink\" title=\"until语句\"></a>until语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until [ condition-is-true ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。</p>\n<h2 id=\"Bash支持的编程模型\"><a href=\"#Bash支持的编程模型\" class=\"headerlink\" title=\"Bash支持的编程模型\"></a>Bash支持的编程模型</h2><p>Bash只支持<strong>过程式</strong>的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。</p>\n<h2 id=\"Bash的传参机制\"><a href=\"#Bash的传参机制\" class=\"headerlink\" title=\"Bash的传参机制\"></a>Bash的传参机制</h2><p>shell通过<strong>位置参数</strong>（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,$0, $1, $2, $3…  其中：</p>\n<ul>\n<li>$0 是该脚本文件的名字</li>\n<li>$1 是第一个参数, $2 是第 2 个参数…</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>$9 以后就需要大括号了,如 ${10}, ${11}, ${12}…</li>\n</ul>\n<p>另外，还有几个特殊字符用来处理参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数处理</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$#</td>\n<td>传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>以一个单字符串显示所有向脚本传递的参数。</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td>$-</td>\n<td>显示Shell使用的当前选项，与set命令功能相同</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody></table>\n<p><code>$*</code> 与 <code>$@</code> 区别:</p>\n<ul>\n<li>相同点：都表示引用所有的位置参数;</li>\n<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>\n</ul>\n<h2 id=\"Bash函数\"><a href=\"#Bash函数\" class=\"headerlink\" title=\"Bash函数\"></a>Bash函数</h2><h3 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func_name</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\"># 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>关键字function是可选的;</li>\n<li>函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;</li>\n<li>在一个函数内嵌套另一个函数也是可以的，但是不常用.</li>\n</ul>\n<h3 id=\"函数的参数传递\"><a href=\"#函数的参数传递\" class=\"headerlink\" title=\"函数的参数传递\"></a>函数的参数传递</h3><p>函数以<strong>位置</strong>来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, …</p>\n<h3 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h3><p>函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。</p>\n<h4 id=\"无参函数的调用\"><a href=\"#无参函数的调用\" class=\"headerlink\" title=\"无参函数的调用\"></a>无参函数的调用</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"Hello World!\"</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"This is func1\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Calling func1</span></span><br><span class=\"line\">func1</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Hello</span> <span class=\"type\">World!</span></span><br><span class=\"line\"><span class=\"type\">This</span> <span class=\"keyword\">is</span> func1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"有参函数的调用\"><a href=\"#有参函数的调用\" class=\"headerlink\" title=\"有参函数的调用\"></a>有参函数的调用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> func2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"This is func2\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    a=<span class=\"variable\">$1</span></span><br><span class=\"line\">    b=<span class=\"variable\">$2</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"a is : <span class=\"variable\">$a</span>\"</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"b is : <span class=\"variable\">$b</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Calling func2,and pass two parameters</span></span><br><span class=\"line\">func2 <span class=\"string\">\"aaa\"</span> <span class=\"string\">\"bbb\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This <span class=\"keyword\">is</span> func2</span><br><span class=\"line\">a <span class=\"keyword\">is</span> : aaa</span><br><span class=\"line\">b <span class=\"keyword\">is</span> : bbb</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数中参数的作用域\"><a href=\"#函数中参数的作用域\" class=\"headerlink\" title=\"函数中参数的作用域\"></a>函数中参数的作用域</h3><p>在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。</p>\n<p>如果变量用<code>local</code> 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部”范围”。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 <span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"> 2</span><br><span class=\"line\"> 3 func()</span><br><span class=\"line\"> 4 &#123;</span><br><span class=\"line\"> 5     global_var=<span class=\"string\">\"I am global_var difined in function func.\"</span></span><br><span class=\"line\"> 6     <span class=\"built_in\">echo</span> <span class=\"variable\">$global_var</span></span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8     <span class=\"built_in\">local</span> loc_var=<span class=\"string\">\"I am local_var defined in function func\"</span></span><br><span class=\"line\"> 9     <span class=\"built_in\">echo</span> <span class=\"variable\">$loc_var</span></span><br><span class=\"line\">10 &#125;</span><br><span class=\"line\">11</span><br><span class=\"line\">12 func</span><br><span class=\"line\">13 <span class=\"built_in\">echo</span></span><br><span class=\"line\">14 <span class=\"built_in\">echo</span> <span class=\"variable\">$global_var</span></span><br><span class=\"line\">15 <span class=\"built_in\">echo</span> <span class=\"variable\">$loc_var</span></span><br><span class=\"line\">16</span><br><span class=\"line\">17 <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I am global_var difined in function <span class=\"function\"><span class=\"keyword\">func</span>.</span></span><br><span class=\"line\">I am local_var defined in function <span class=\"function\"><span class=\"keyword\">func</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">I am global_var difined in function <span class=\"function\"><span class=\"keyword\">func</span>.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash数组\"><a href=\"#Bash数组\" class=\"headerlink\" title=\"Bash数组\"></a>Bash数组</h2><p>Bash 只支持一维数组，用圆括号<code>()</code>来表示，数组元素之间用”空格”符号来分割（不同于C、C++、Java等语言中用逗号分割）。</p>\n<h3 id=\"数组的定义与初始化\"><a href=\"#数组的定义与初始化\" class=\"headerlink\" title=\"数组的定义与初始化\"></a>数组的定义与初始化</h3><p>初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从<code>0</code>开始。</p>\n<h3 id=\"初始化方式1：直接初始化\"><a href=\"#初始化方式1：直接初始化\" class=\"headerlink\" title=\"初始化方式1：直接初始化\"></a>初始化方式1：直接初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr_name&#x3D;(value1 value2 ... valueN)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化方式2-用下标初始化\"><a href=\"#初始化方式2-用下标初始化\" class=\"headerlink\" title=\"初始化方式2: 用下标初始化\"></a>初始化方式2: 用下标初始化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr_name[0]=value1</span><br><span class=\"line\">arr_name[1]=value2</span><br><span class=\"line\">arr_name[223]=value3 <span class=\"comment\"># 不连续初始化</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>数组成员不必一定要连续，空缺元素是允许的;</li>\n<li>数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;</li>\n</ul>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>访问数组元素的一般格式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$&#123;arr_name[index]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h3><p>使用<code>*</code> 或<code>@</code> 可以获取数组中的所有元素<br> 实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr=(A B C <span class=\"string\">\"ddd\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历数组格式1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_arr: <span class=\"variable\">$&#123;my_arr[*]&#125;</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 遍历数组格式2</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>my_arr: <span class=\"variable\">$&#123;my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr: A B C ddd</span><br><span class=\"line\">my_arr: A B C ddd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取数组长度\"><a href=\"#获取数组长度\" class=\"headerlink\" title=\"获取数组长度\"></a>获取数组长度</h3><p>获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了<code>#</code>符号，格式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#arr_name[*]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取数组my_arr的长度（元素个数）</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_arr length: <span class=\"variable\">$&#123;#my_arr[*]&#125;</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 获取数组my_arr的长度,</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>my_arr length: <span class=\"variable\">$&#123;#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr length: 4</span><br><span class=\"line\">my_arr length: 4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash字符串操作\"><a href=\"#Bash字符串操作\" class=\"headerlink\" title=\"Bash字符串操作\"></a>Bash字符串操作</h2><p>在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。<br> 定义字符串实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=hello</span><br><span class=\"line\">str2=<span class=\"string\">'hello'</span></span><br><span class=\"line\">str3=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str2</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str3</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h3><p>格式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#string_name&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_str length: <span class=\"variable\">$&#123;#my_str&#125;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_str length: 11</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><p>和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。<br> 实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\">str2=<span class=\"string\">\"world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">str3=<span class=\"variable\">$&#123;str1&#125;</span><span class=\"string\">\" \"</span><span class=\"variable\">$&#123;str2&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str3&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提取子串\"><a href=\"#提取子串\" class=\"headerlink\" title=\"提取子串\"></a>提取子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string:position}</td>\n<td>在string中, 从位置position开始提取子串</td>\n</tr>\n<tr>\n<td>${string:position:length}</td>\n<td>在string中, 从位置position开始提取长度为length的子串</td>\n</tr>\n</tbody></table>\n<p>实例1：从位置1开始提取子串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">sub_str=<span class=\"variable\">$&#123;str:1&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"sub_str: <span class=\"variable\">$&#123;sub_str&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub_str: ello world</span><br></pre></td></tr></table></figure>\n\n<p>实例2：从位置1开始提取长度为3的子串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">sub_str=<span class=\"variable\">$&#123;str:1:3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"sub_str: <span class=\"variable\">$&#123;sub_str&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub_str: ell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除子串\"><a href=\"#删除子串\" class=\"headerlink\" title=\"删除子串\"></a>删除子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string#substring}</td>\n<td>从string的开头, 删除最短匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string##substring}</td>\n<td>从string的开头, 删除最长匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string%substring}</td>\n<td>从string的结尾, 删除最短匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string%%substring}</td>\n<td>从string的结尾, 删除最长匹配substring的子串</td>\n</tr>\n</tbody></table>\n<p>记忆：</p>\n<ul>\n<li><code>#</code>表示从头匹配，<code>%</code>表示从尾匹配</li>\n<li>一个符号（<code>#</code>或者<code>%</code>）表示最短匹配，两个符号（<code>##</code>或者<code>%%</code>）表示最长匹配</li>\n</ul>\n<p><strong>注意：</strong>substring可以是正则表达式。</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"abcabcdefabcabc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的开头,删除最短匹配的以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除最左端的abc</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：abcdefabcabc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str#a*c&#125;</span>\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的开头,删除最长匹配以a开头b结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除abcabcdefabcab</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：c</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str##a*b&#125;</span>\"</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的结尾,删除最短匹配以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除最右端的abc</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：abcabcdefabc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str%a*c&#125;</span>\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的结尾,删除最长匹配以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除整个字符串</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：空</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str%%a*b&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换子串\"><a href=\"#替换子串\" class=\"headerlink\" title=\"替换子串\"></a>替换子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string/substring/replacement}</td>\n<td>使用$replacement 来代替<strong>第一个</strong>匹配的$substring</td>\n</tr>\n<tr>\n<td>${string//substring/replacement}</td>\n<td>使用$replacement 代替<strong>所有</strong>匹配的$substring</td>\n</tr>\n<tr>\n<td>${string/#substring/replacement}</td>\n<td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>\n</tr>\n<tr>\n<td>${string/%substring/replacement}</td>\n<td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>\n</tr>\n</tbody></table>\n<p>实例：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"abcdefabc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用hello替换第一个abc</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"string\">\"abc\"</span>/<span class=\"string\">\"hello\"</span>&#125;    <span class=\"comment\"># 输出：hellodefabc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用hello替换第一个abc</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"regexp\">/\"abc\"/</span><span class=\"string\">\"hello\"</span>&#125;   <span class=\"comment\"># 输出：hellodefhello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 前缀匹配替换</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"comment\">#\"abc\"/\"world\"&#125;   # 输出：worlddefabc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后缀匹配替换</span></span><br><span class=\"line\">echo $&#123;str/％<span class=\"string\">\"abc\"</span>/<span class=\"string\">\"world\"</span>&#125;   <span class=\"comment\"># 输出：abcdefworld</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://link.jianshu.com?t=http://tldp.org/LDP/abs/html/\" target=\"_blank\" rel=\"noopener\">Advanced Bash-Scripting Guide</a><br> 这本书内容翔实，实例丰富，既可做精钻细研的教材，又可作为手册时时查阅，真是居家旅行必备良品;-)</p>\n<p>另外，感兴趣的同学也可翻阅《Linux Shell Scripting Cookbook》(中文译名《Linux Shell脚本攻略》)，里面介绍了很多Shell编程的奇技淫巧，甚是有用有趣。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p><strong>作者：echoworlding</strong></p>\n<p><strong>链接：<a href=\"https://www.jianshu.com/p/e1c8e5bfa45e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e1c8e5bfa45e</a></strong></p>\n<p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p>\n<h2 id=\"Shell是什么？\"><a href=\"#Shell是什么？\" class=\"headerlink\" title=\"Shell是什么？\"></a>Shell是什么？</h2><p>shell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。</p>\n<h3 id=\"Shell语言的流派\"><a href=\"#Shell语言的流派\" class=\"headerlink\" title=\"Shell语言的流派\"></a>Shell语言的流派</h3><p>目前，shell主要有两大流派：</p>\n<ul>\n<li>sh:<ul>\n<li>burne shell (sh)</li>\n<li>burne again shell (bash)</li>\n</ul>\n</li>\n<li>csh:<ul>\n<li>c shell (csh)</li>\n<li>tc shell (tcsh)</li>\n<li>korn shell (ksh)</li>\n</ul>\n</li>\n</ul>\n<p>目前，大部分Linux系统预设的shell都是bash。</p>\n<blockquote>\n<p>Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-ubt:~$ cat /etc/shells </span><br><span class=\"line\"><span class=\"comment\"># /etc/shells: valid login shells</span></span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/rbash</span><br><span class=\"line\">slot@slot-ubt:~$</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Mac OS提供的shell环境：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/shells</span><br><span class=\"line\"><span class=\"comment\"># List of acceptable shells for chpass(1).</span></span><br><span class=\"line\"><span class=\"comment\"># Ftpd will not allow users to connect who are not using</span></span><br><span class=\"line\"><span class=\"comment\"># one of these shells.</span></span><br><span class=\"line\">&gt;</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/csh</span><br><span class=\"line\">/bin/ksh</span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/zsh  <span class=\"comment\"># zsh系本文作者自己安装</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<p>在Catalina之后mac就不是使用bash的了，而是使用zsh的</p>\n</blockquote>\n<h3 id=\"一个极简的bash-demo-hello-world-sh\"><a href=\"#一个极简的bash-demo-hello-world-sh\" class=\"headerlink\" title=\"一个极简的bash demo: hello_world.sh\"></a>一个极简的bash demo: hello_world.sh</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Here is comment </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>执行</strong>  </p>\n<p>方法1: 直接使用bash解释器来解释执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>方法2: 先将文件属性改为可执行状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p>再直接执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./hello_world.sh</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。</p>\n<p>#开头的是注释行(#!除外)，shell中只有单行注释。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Hello World!\"</span> 即用<span class=\"built_in\">echo</span>命令输出字符串<span class=\"string\">\"Hello World!\"</span>到终端显示器。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>补充知识: 文件的属性</strong><br> 通过<code>ls -l</code>命令可以查看文件的属性，例如查看新建文件test.sh的属性：</p>\n</blockquote>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ touch test.sh</span><br><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ ls -l test.sh </span><br><span class=\"line\">-rw-rw-r-- <span class=\"number\">1</span> slot slot <span class=\"number\">0</span> <span class=\"number\">12</span>月 <span class=\"number\">21</span> <span class=\"number\">15</span><span class=\"symbol\">:</span><span class=\"number\">40</span> test.sh</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看到，一般新建文件的默认属性是<code>-rw-rw-r--</code>，即644，不具有可执行属性<code>x</code>，可使用<code>chmod</code>命令来改变文件属性（修改默认属性则使用<code>umask</code>命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：</p>\n</blockquote>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ chmod <span class=\"number\">777</span> test.sh </span><br><span class=\"line\">slot@slot-<span class=\"symbol\">ubt:</span>~$ ls -l test.sh </span><br><span class=\"line\">-rwxrwxrwx <span class=\"number\">1</span> slot slot <span class=\"number\">0</span> <span class=\"number\">12</span>月 <span class=\"number\">21</span> <span class=\"number\">15</span><span class=\"symbol\">:</span><span class=\"number\">40</span> test.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash中的变量\"><a href=\"#Bash中的变量\" class=\"headerlink\" title=\"Bash中的变量\"></a>Bash中的变量</h2><h3 id=\"变量的定义与赋值\"><a href=\"#变量的定义与赋值\" class=\"headerlink\" title=\"变量的定义与赋值\"></a>变量的定义与赋值</h3><p>不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_bash_var=<span class=\"string\">\"this is my bash var\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>:</p>\n<ul>\n<li><strong><code>＝</code>两边不能有空格！</strong>否则就是语法错误了。</li>\n<li>Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。</li>\n</ul>\n<h3 id=\"变量的引用\"><a href=\"#变量的引用\" class=\"headerlink\" title=\"变量的引用\"></a>变量的引用</h3><p>使用已定义的变量时，只要在变量名前面加<code>$</code>符号即可:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$my_bash_var</span></span><br></pre></td></tr></table></figure>\n\n<p>或者使用<code>${var_name}</code>的形式，<code>{}</code>是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;my_bash_var&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意<code>&#39;&#39;</code>和<code>&quot;&quot;</code>的区别：</p>\n<ul>\n<li><code>&#39;&#39;</code> ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；</li>\n<li><code>&quot;&quot;</code>：双引号里可以引用变量，可以出现转义字符。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'a is : $a'</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"a is : <span class=\"variable\">$a</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>Output:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"keyword\">is</span> : $a</span><br><span class=\"line\">a <span class=\"keyword\">is</span> : hello</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h4><p>使用 <strong><code>readonly</code></strong> 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_var=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">readonly</span> a_var</span><br><span class=\"line\">a_var=<span class=\"string\">\"world\"</span>  <span class=\"comment\"># Output: bash: read-only variable: a_var</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除变量\"><a href=\"#删除变量\" class=\"headerlink\" title=\"删除变量\"></a>删除变量</h4><p>使用 <strong><code>unset</code></strong> 命令可以删除变量，但是不能删除只读变量。<br> 变量被删除后不能再次使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_var=<span class=\"string\">\"haha\"</span></span><br><span class=\"line\"><span class=\"built_in\">unset</span> my_var</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;my_var&#125;</span> <span class=\"comment\"># 变量my_var已被删除，没有任何输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h3><p>诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分<strong>类型</strong>。</p>\n<p>本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是<strong>变量中的值是否只有数字</strong>，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。</p>\n<p>另外，注意Bash中的数字默认的是十进制，八进制需要以<code>0</code>开头，十六进制以<code>0x</code>开头。</p>\n<p>纯数字变量是“数字变量”：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1234</span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"a+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a&#125;</span>  <span class=\"comment\"># Output: 1235</span></span><br></pre></td></tr></table></figure>\n\n<p>数字＋字符串：字符串变量，字符串变量不能进行数学运算</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b=<span class=\"variable\">$&#123;a/12/BB&#125;</span> <span class=\"comment\"># 将12替换为BB</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;b&#125;</span>    <span class=\"comment\"># Output: BB35</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"b+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;b&#125;</span>    <span class=\"comment\"># Output:1</span></span><br></pre></td></tr></table></figure>\n\n<p>将变量中的非数字字符替换为数字，得到数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c=BB34</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;c&#125;</span>     <span class=\"comment\"># Output: BB34</span></span><br><span class=\"line\"></span><br><span class=\"line\">d=<span class=\"variable\">$&#123;c/BB/12&#125;</span>  <span class=\"comment\"># 将BB替换为12</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;d&#125;</span>     <span class=\"comment\"># Output: 1234</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"d+=1\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;d&#125;</span>     <span class=\"comment\"># Output: 1235</span></span><br></pre></td></tr></table></figure>\n\n<p>空变量+数字：数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 变量e定义为空值</span></span><br><span class=\"line\">e=<span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;e&#125;</span>  <span class=\"comment\"># Output: 没有任何输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"e+=1\"</span> <span class=\"comment\"># 空值 + 1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;e&#125;</span>  <span class=\"comment\"># Output: 1</span></span><br></pre></td></tr></table></figure>\n\n<p>未定义的变量+数字：数字变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 变量f未定义</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"f = <span class=\"variable\">$f</span>\"</span>   <span class=\"comment\"># Output: f =</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"f+=1\"</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"f = <span class=\"variable\">$&#123;f&#125;</span>\"</span> <span class=\"comment\"># Output: f = 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的作用域\"><a href=\"#变量的作用域\" class=\"headerlink\" title=\"变量的作用域\"></a>变量的作用域</h3><ul>\n<li>局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用<code>local</code>声明；</li>\n<li>全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；</li>\n<li>环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。<br> 如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。</li>\n</ul>\n<blockquote>\n<p>更多关于环境变量的知识可以参考以下文章：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/ac2bc0ad3d74\" target=\"_blank\" rel=\"noopener\">Linux环境变量总结</a></li>\n<li><a href=\"https://www.jianshu.com/p/f7d4a821d292\" target=\"_blank\" rel=\"noopener\">linux入门之环境变量与文件查找</a></li>\n</ul>\n</blockquote>\n<h2 id=\"Bash中的运算符\"><a href=\"#Bash中的运算符\" class=\"headerlink\" title=\"Bash中的运算符\"></a>Bash中的运算符</h2><p>Bash支持的运算符有：</p>\n<ul>\n<li>数学运算符</li>\n<li>关系运算符</li>\n<li>布尔运算符</li>\n<li>逻辑运算符</li>\n<li>字符串运算符</li>\n<li>文件测试运算符</li>\n</ul>\n<h3 id=\"数学运算符\"><a href=\"#数学运算符\" class=\"headerlink\" title=\"数学运算符\"></a>数学运算符</h3><table>\n<thead>\n<tr>\n<th>数学运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等测试，相等则返回true</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等测试，不相等则返回true</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong>  乘号<code>*</code>前边必须加反斜杠 \\ 才能实现乘法运算</p>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p>\n<table>\n<thead>\n<tr>\n<th>关系运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-eq</td>\n<td>(equal)    检测两个数是否相等，相等则返回 true</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>(not equal）检测两个数是否相等，不相等则返回 true</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>(greater than）检测左边的数是否大于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>(lower than) 检测左边的数是否小于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>(greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>(lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"布尔运算符\"><a href=\"#布尔运算符\" class=\"headerlink\" title=\"布尔运算符\"></a>布尔运算符</h3><table>\n<thead>\n<tr>\n<th>布尔运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><table>\n<thead>\n<tr>\n<th>逻辑运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>II</td>\n<td>逻辑或</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h3><table>\n<thead>\n<tr>\n<th>字符串运算符</th>\n<th>说明</th>\n<th>举例  (a=”abc” b=”def”)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>检测两个字符串是否相等，相等返回 true</td>\n<td>[ $a = $b ] 返回 false</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检测两个字符串是否相等，不相等返回 true</td>\n<td>[ $a != $b ] 返回 true</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>检测字符串长度是否为0，为0返回 true</td>\n<td>[ -z $a ] 返回 false</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>检测字符串长度是否为0，不为0返回 true</td>\n<td>[ -n $a ] 返回 true</td>\n</tr>\n<tr>\n<td>str_name</td>\n<td>检测字符串是否为空，不为空返回 true</td>\n<td>[ $a ] 返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性</p>\n<table>\n<thead>\n<tr>\n<th>文件测试运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-b file</td>\n<td>检测文件是否是块设备文件，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-c file</td>\n<td>检测文件是否是字符设备文件，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-d file</td>\n<td>检测文件是否是目录，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-g file</td>\n<td>检测文件是否设置了 SGID 位，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-k file</td>\n<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-p fill</td>\n<td>检测文件是否是命名管道，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-u file</td>\n<td>检测文件是否设置了 SUID 位，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>检测文件是否可读，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>检测文件是否可写，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检测文件是否可执行，如果是，则返回 true</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>检测文件（包括目录）是否存在，如果是，则返回 true</td>\n</tr>\n</tbody></table>\n<h2 id=\"Bash的控制流\"><a href=\"#Bash的控制流\" class=\"headerlink\" title=\"Bash的控制流\"></a>Bash的控制流</h2><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><h4 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h4><ul>\n<li>if</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if-else</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if-elif-else</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition1 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ condition2 ]</span><br><span class=\"line\">    command2</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    commandN</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> 勿忘最后的<code>fi</code>（<code>if</code>的反向拼写）!</p>\n<h4 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$&#123;var&#125;</span>\"</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"string\">\"<span class=\"variable\">$condition1</span>\"</span> )</span><br><span class=\"line\">        command1</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"<span class=\"variable\">$condition2</span>\"</span> )</span><br><span class=\"line\">        command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">    * )  <span class=\"comment\"># 这里相当于C中case语句的default </span></span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>对变量使用<code>&quot;&quot;</code>并不是强制的，因为不会发生单词分离;</li>\n<li>每句测试行,都以右小括号<code>)</code>结尾;</li>\n<li>每个条件块都以两个分号<code>;;</code>结尾（作用类似C中的break）;</li>\n<li>case 块的结束以 <code>esac</code>(case 的反向拼写)结尾.</li>\n</ul>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><h4 id=\"for语句\"><a href=\"#for语句\" class=\"headerlink\" title=\"for语句\"></a>for语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> var <span class=\"keyword\">in</span> item1 item2 ... itemN</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> 在循环的每次执行中，var将顺序的存取 list （i.e. item1 … itemN）中列出的变量。</p>\n<p>C风格的for循环:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (( EXP1; EXP2; EXP3 ))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    command3</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong>  <code>(())</code>中对变量的引用可以不加<code>$</code></p>\n<h4 id=\"while语句\"><a href=\"#while语句\" class=\"headerlink\" title=\"while语句\"></a>while语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>C风格的while循环:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (( condition ))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong>  <code>(())</code>中对变量的引用同样可以不加<code>$</code></p>\n<h4 id=\"until语句\"><a href=\"#until语句\" class=\"headerlink\" title=\"until语句\"></a>until语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until [ condition-is-true ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong><br> util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。</p>\n<h2 id=\"Bash支持的编程模型\"><a href=\"#Bash支持的编程模型\" class=\"headerlink\" title=\"Bash支持的编程模型\"></a>Bash支持的编程模型</h2><p>Bash只支持<strong>过程式</strong>的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。</p>\n<h2 id=\"Bash的传参机制\"><a href=\"#Bash的传参机制\" class=\"headerlink\" title=\"Bash的传参机制\"></a>Bash的传参机制</h2><p>shell通过<strong>位置参数</strong>（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,$0, $1, $2, $3…  其中：</p>\n<ul>\n<li>$0 是该脚本文件的名字</li>\n<li>$1 是第一个参数, $2 是第 2 个参数…</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>$9 以后就需要大括号了,如 ${10}, ${11}, ${12}…</li>\n</ul>\n<p>另外，还有几个特殊字符用来处理参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数处理</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$#</td>\n<td>传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>以一个单字符串显示所有向脚本传递的参数。</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td>$-</td>\n<td>显示Shell使用的当前选项，与set命令功能相同</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody></table>\n<p><code>$*</code> 与 <code>$@</code> 区别:</p>\n<ul>\n<li>相同点：都表示引用所有的位置参数;</li>\n<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>\n</ul>\n<h2 id=\"Bash函数\"><a href=\"#Bash函数\" class=\"headerlink\" title=\"Bash函数\"></a>Bash函数</h2><h3 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func_name</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\"># 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>关键字function是可选的;</li>\n<li>函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;</li>\n<li>在一个函数内嵌套另一个函数也是可以的，但是不常用.</li>\n</ul>\n<h3 id=\"函数的参数传递\"><a href=\"#函数的参数传递\" class=\"headerlink\" title=\"函数的参数传递\"></a>函数的参数传递</h3><p>函数以<strong>位置</strong>来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, …</p>\n<h3 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h3><p>函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。</p>\n<h4 id=\"无参函数的调用\"><a href=\"#无参函数的调用\" class=\"headerlink\" title=\"无参函数的调用\"></a>无参函数的调用</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"Hello World!\"</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"This is func1\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Calling func1</span></span><br><span class=\"line\">func1</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Hello</span> <span class=\"type\">World!</span></span><br><span class=\"line\"><span class=\"type\">This</span> <span class=\"keyword\">is</span> func1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"有参函数的调用\"><a href=\"#有参函数的调用\" class=\"headerlink\" title=\"有参函数的调用\"></a>有参函数的调用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> func2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"This is func2\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    a=<span class=\"variable\">$1</span></span><br><span class=\"line\">    b=<span class=\"variable\">$2</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"a is : <span class=\"variable\">$a</span>\"</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"b is : <span class=\"variable\">$b</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Calling func2,and pass two parameters</span></span><br><span class=\"line\">func2 <span class=\"string\">\"aaa\"</span> <span class=\"string\">\"bbb\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This <span class=\"keyword\">is</span> func2</span><br><span class=\"line\">a <span class=\"keyword\">is</span> : aaa</span><br><span class=\"line\">b <span class=\"keyword\">is</span> : bbb</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数中参数的作用域\"><a href=\"#函数中参数的作用域\" class=\"headerlink\" title=\"函数中参数的作用域\"></a>函数中参数的作用域</h3><p>在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。</p>\n<p>如果变量用<code>local</code> 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部”范围”。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 <span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"> 2</span><br><span class=\"line\"> 3 func()</span><br><span class=\"line\"> 4 &#123;</span><br><span class=\"line\"> 5     global_var=<span class=\"string\">\"I am global_var difined in function func.\"</span></span><br><span class=\"line\"> 6     <span class=\"built_in\">echo</span> <span class=\"variable\">$global_var</span></span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8     <span class=\"built_in\">local</span> loc_var=<span class=\"string\">\"I am local_var defined in function func\"</span></span><br><span class=\"line\"> 9     <span class=\"built_in\">echo</span> <span class=\"variable\">$loc_var</span></span><br><span class=\"line\">10 &#125;</span><br><span class=\"line\">11</span><br><span class=\"line\">12 func</span><br><span class=\"line\">13 <span class=\"built_in\">echo</span></span><br><span class=\"line\">14 <span class=\"built_in\">echo</span> <span class=\"variable\">$global_var</span></span><br><span class=\"line\">15 <span class=\"built_in\">echo</span> <span class=\"variable\">$loc_var</span></span><br><span class=\"line\">16</span><br><span class=\"line\">17 <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I am global_var difined in function <span class=\"function\"><span class=\"keyword\">func</span>.</span></span><br><span class=\"line\">I am local_var defined in function <span class=\"function\"><span class=\"keyword\">func</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">I am global_var difined in function <span class=\"function\"><span class=\"keyword\">func</span>.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash数组\"><a href=\"#Bash数组\" class=\"headerlink\" title=\"Bash数组\"></a>Bash数组</h2><p>Bash 只支持一维数组，用圆括号<code>()</code>来表示，数组元素之间用”空格”符号来分割（不同于C、C++、Java等语言中用逗号分割）。</p>\n<h3 id=\"数组的定义与初始化\"><a href=\"#数组的定义与初始化\" class=\"headerlink\" title=\"数组的定义与初始化\"></a>数组的定义与初始化</h3><p>初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从<code>0</code>开始。</p>\n<h3 id=\"初始化方式1：直接初始化\"><a href=\"#初始化方式1：直接初始化\" class=\"headerlink\" title=\"初始化方式1：直接初始化\"></a>初始化方式1：直接初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr_name&#x3D;(value1 value2 ... valueN)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化方式2-用下标初始化\"><a href=\"#初始化方式2-用下标初始化\" class=\"headerlink\" title=\"初始化方式2: 用下标初始化\"></a>初始化方式2: 用下标初始化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr_name[0]=value1</span><br><span class=\"line\">arr_name[1]=value2</span><br><span class=\"line\">arr_name[223]=value3 <span class=\"comment\"># 不连续初始化</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>数组成员不必一定要连续，空缺元素是允许的;</li>\n<li>数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;</li>\n</ul>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>访问数组元素的一般格式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$&#123;arr_name[index]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h3><p>使用<code>*</code> 或<code>@</code> 可以获取数组中的所有元素<br> 实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr=(A B C <span class=\"string\">\"ddd\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历数组格式1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_arr: <span class=\"variable\">$&#123;my_arr[*]&#125;</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 遍历数组格式2</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>my_arr: <span class=\"variable\">$&#123;my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr: A B C ddd</span><br><span class=\"line\">my_arr: A B C ddd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取数组长度\"><a href=\"#获取数组长度\" class=\"headerlink\" title=\"获取数组长度\"></a>获取数组长度</h3><p>获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了<code>#</code>符号，格式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#arr_name[*]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取数组my_arr的长度（元素个数）</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_arr length: <span class=\"variable\">$&#123;#my_arr[*]&#125;</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 获取数组my_arr的长度,</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>my_arr length: <span class=\"variable\">$&#123;#my_arr[@]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_arr length: 4</span><br><span class=\"line\">my_arr length: 4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bash字符串操作\"><a href=\"#Bash字符串操作\" class=\"headerlink\" title=\"Bash字符串操作\"></a>Bash字符串操作</h2><p>在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。<br> 定义字符串实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=hello</span><br><span class=\"line\">str2=<span class=\"string\">'hello'</span></span><br><span class=\"line\">str3=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str2</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$str3</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h3><p>格式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;<span class=\"comment\">#string_name&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"my_str length: <span class=\"variable\">$&#123;#my_str&#125;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_str length: 11</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><p>和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。<br> 实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1=<span class=\"string\">\"hello\"</span></span><br><span class=\"line\">str2=<span class=\"string\">\"world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">str3=<span class=\"variable\">$&#123;str1&#125;</span><span class=\"string\">\" \"</span><span class=\"variable\">$&#123;str2&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str3&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提取子串\"><a href=\"#提取子串\" class=\"headerlink\" title=\"提取子串\"></a>提取子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string:position}</td>\n<td>在string中, 从位置position开始提取子串</td>\n</tr>\n<tr>\n<td>${string:position:length}</td>\n<td>在string中, 从位置position开始提取长度为length的子串</td>\n</tr>\n</tbody></table>\n<p>实例1：从位置1开始提取子串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">sub_str=<span class=\"variable\">$&#123;str:1&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"sub_str: <span class=\"variable\">$&#123;sub_str&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub_str: ello world</span><br></pre></td></tr></table></figure>\n\n<p>实例2：从位置1开始提取长度为3的子串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">sub_str=<span class=\"variable\">$&#123;str:1:3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"sub_str: <span class=\"variable\">$&#123;sub_str&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub_str: ell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除子串\"><a href=\"#删除子串\" class=\"headerlink\" title=\"删除子串\"></a>删除子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string#substring}</td>\n<td>从string的开头, 删除最短匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string##substring}</td>\n<td>从string的开头, 删除最长匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string%substring}</td>\n<td>从string的结尾, 删除最短匹配substring的子串</td>\n</tr>\n<tr>\n<td>${string%%substring}</td>\n<td>从string的结尾, 删除最长匹配substring的子串</td>\n</tr>\n</tbody></table>\n<p>记忆：</p>\n<ul>\n<li><code>#</code>表示从头匹配，<code>%</code>表示从尾匹配</li>\n<li>一个符号（<code>#</code>或者<code>%</code>）表示最短匹配，两个符号（<code>##</code>或者<code>%%</code>）表示最长匹配</li>\n</ul>\n<p><strong>注意：</strong>substring可以是正则表达式。</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"abcabcdefabcabc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的开头,删除最短匹配的以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除最左端的abc</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：abcdefabcabc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str#a*c&#125;</span>\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的开头,删除最长匹配以a开头b结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除abcabcdefabcab</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：c</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str##a*b&#125;</span>\"</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的结尾,删除最短匹配以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除最右端的abc</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：abcabcdefabc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str%a*c&#125;</span>\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从str的结尾,删除最长匹配以a开头c结尾的子串</span></span><br><span class=\"line\"><span class=\"comment\"># 将删除整个字符串</span></span><br><span class=\"line\"><span class=\"comment\"># 输出：空</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;str%%a*b&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换子串\"><a href=\"#替换子串\" class=\"headerlink\" title=\"替换子串\"></a>替换子串</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${string/substring/replacement}</td>\n<td>使用$replacement 来代替<strong>第一个</strong>匹配的$substring</td>\n</tr>\n<tr>\n<td>${string//substring/replacement}</td>\n<td>使用$replacement 代替<strong>所有</strong>匹配的$substring</td>\n</tr>\n<tr>\n<td>${string/#substring/replacement}</td>\n<td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>\n</tr>\n<tr>\n<td>${string/%substring/replacement}</td>\n<td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>\n</tr>\n</tbody></table>\n<p>实例：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">\"abcdefabc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用hello替换第一个abc</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"string\">\"abc\"</span>/<span class=\"string\">\"hello\"</span>&#125;    <span class=\"comment\"># 输出：hellodefabc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用hello替换第一个abc</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"regexp\">/\"abc\"/</span><span class=\"string\">\"hello\"</span>&#125;   <span class=\"comment\"># 输出：hellodefhello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 前缀匹配替换</span></span><br><span class=\"line\">echo $&#123;str/<span class=\"comment\">#\"abc\"/\"world\"&#125;   # 输出：worlddefabc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后缀匹配替换</span></span><br><span class=\"line\">echo $&#123;str/％<span class=\"string\">\"abc\"</span>/<span class=\"string\">\"world\"</span>&#125;   <span class=\"comment\"># 输出：abcdefworld</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://link.jianshu.com?t=http://tldp.org/LDP/abs/html/\" target=\"_blank\" rel=\"noopener\">Advanced Bash-Scripting Guide</a><br> 这本书内容翔实，实例丰富，既可做精钻细研的教材，又可作为手册时时查阅，真是居家旅行必备良品;-)</p>\n<p>另外，感兴趣的同学也可翻阅《Linux Shell Scripting Cookbook》(中文译名《Linux Shell脚本攻略》)，里面介绍了很多Shell编程的奇技淫巧，甚是有用有趣。</p>\n"},{"layout":"post","title":"markdown教程","date":"2020-03-20T08:00:00.000Z","subtitle":null,"description":"表格怎么画？引用怎么写？","comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321023014.png","optimized_image":null,"author":"欧阳锋","_content":"\nTip: 强烈建议使用typora作为您的markdown工具\n\n> 提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 [ JOHN GRUBER](https://daringfireball.net/) 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看...\n\n# 基础语法\n\n### 标题\n\nMarkdown支持6种级别的标题，对应html标签 **h1 ~ h6**\n\n```\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n复制代码\n```\n\n以上标记效果如下：\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n\n##### h5\n\n###### h6\n\n除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 [Setext](http://docutils.sourceforge.net/mirror/setext.html) 标记语言的表现形式，使用下划线进行文本大小的控制\n\n```\n这是一级标题\n===\n这是二级标题\n---\n复制代码\n```\n\n使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181200.png)\n\n这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。\n\n\n\n### 段落及区块引用\n\n需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。\n\n而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号>用于段首进行强调，被强调的文字部分将会高亮显示\n\n```\n> 这段文字将被高亮显示...\n复制代码\n```\n\n以上标记显示效果如下：\n\n> 这段文字将被高亮显示...\n\n### 插入链接或图片\n\nMarkdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记\n\n```\n[点击跳转至百度](http://www.baidu.com)\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png)\n```\n\n以上标记显示效果如下：\n\n[点击跳转至百度](http://www.baidu.com)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png)\n\n注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。\n\n### 列表\n\nMarkdown支持有序列表和无序列表两种形式：\n\n- 无序列表使用*或+或-标识\n- 有序列表使用数字加.标识，例如：1.\n\n```\n* 黄瓜\n* 玉米\n* 茄子\n\n+ 黄瓜\n+ 玉米\n+ 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n1. 黄瓜\n2. 玉米\n3. 茄子\n复制代码\n```\n\n以上标记显示效果如下：\n\n- 黄瓜\n- 玉米\n- 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n1. 黄瓜\n2. 玉米\n3. 茄子\n\n注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。\n\n### 使用列表的一些注意事项\n\n如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格\n\n```\n*    段落一\n\n     小段一\n*    段落二\n\n     小段二\n复制代码\n```\n\n以上标记显示效果如下：\n\n- 段落一\n\n  小段一\n\n- 段落二\n\n  小段二\n\n另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格\n\n```\n* 段落一\n    > 区块标记一\n* 段落二\n    > 区块标记二\n复制代码\n```\n\n- 段落一\n\n  > 区块标记一\n\n- 段落二\n\n  > 区块标记二\n\n注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。\n\n### 分隔线\n\n有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以\n\n```\n***\n---\n复制代码\n```\n\n------\n\n------\n\n产生分隔线的语法要求比较松，符号之间添加空格也可以。\n\n### 强调\n\n有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗\n\n```\n*这里是斜体*\n_这里是斜体_\n\n**这里是加粗**\n__这里是加粗__\n复制代码\n```\n\n*这里是斜体* *这里是斜体*\n\n**这里是加粗** **这里是加粗**\n\n# 高级用法\n\n### 插入代码块\n\nMarkdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。\n\n方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹\n\n这是一段`var x = 3`行内代码\n\n如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果：\n\n```\nfun (x: Int, y: Int): Int {\n  return x + y\n}\n复制代码\n```\n\n注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。\n\n### 插入表格\n\n表格是Markdown语法中比较复杂的一个，其语法如下：\n\n```\n表头|条目一|条目二\n:---:|:---:|:---:\n项目|项目一|项目二\n复制代码\n```\n\n以上标记显示效果如下：\n\n| 表头 | 条目一 | 条目二 |\n| :--: | :----: | :----: |\n| 项目 | 项目一 | 项目二 |\n\n注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。\n\n# 其它\n\n### 特殊符号处理\n\nMarkdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理：\n\n```\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n复制代码\n```\n\n例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\\\ => \\ 。\n\n注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。\n\n### 如何给文字上色\n\n使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：\n\n1. 先用Markdown编辑完成\n2. 导出为html，在需要上色的部分手动添加标签<font color='#ff0000'></font>保存即可。\n\n### Markdown软件推荐\n\n强烈建议你使用typora\n\n如果你是一个Mac用户，也可以使用开源的 [MacDown](http://macdown.uranusjr.com/)：\n\n![Macdown](https://user-gold-cdn.xitu.io/2018/4/18/162d75d95959514c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n# 简单总结\n\nMarkdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。\n\n不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！\n\n\n作者：欧阳锋\n链接：https://juejin.im/post/5ad6e09e518825557b4d451c\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","source":"_posts/2020-03-20-Markdown教程.md","raw":"---\nlayout: post\ntitle:  markdown教程\ndate:   2020-03-20 1:00:00\nsubtitle: \ndescription: 表格怎么画？引用怎么写？\ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321023014.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - tips\nauthor: 欧阳锋\n---\n\nTip: 强烈建议使用typora作为您的markdown工具\n\n> 提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 [ JOHN GRUBER](https://daringfireball.net/) 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看...\n\n# 基础语法\n\n### 标题\n\nMarkdown支持6种级别的标题，对应html标签 **h1 ~ h6**\n\n```\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n复制代码\n```\n\n以上标记效果如下：\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n\n##### h5\n\n###### h6\n\n除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 [Setext](http://docutils.sourceforge.net/mirror/setext.html) 标记语言的表现形式，使用下划线进行文本大小的控制\n\n```\n这是一级标题\n===\n这是二级标题\n---\n复制代码\n```\n\n使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181200.png)\n\n这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。\n\n\n\n### 段落及区块引用\n\n需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。\n\n而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号>用于段首进行强调，被强调的文字部分将会高亮显示\n\n```\n> 这段文字将被高亮显示...\n复制代码\n```\n\n以上标记显示效果如下：\n\n> 这段文字将被高亮显示...\n\n### 插入链接或图片\n\nMarkdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记\n\n```\n[点击跳转至百度](http://www.baidu.com)\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png)\n```\n\n以上标记显示效果如下：\n\n[点击跳转至百度](http://www.baidu.com)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png)\n\n注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。\n\n### 列表\n\nMarkdown支持有序列表和无序列表两种形式：\n\n- 无序列表使用*或+或-标识\n- 有序列表使用数字加.标识，例如：1.\n\n```\n* 黄瓜\n* 玉米\n* 茄子\n\n+ 黄瓜\n+ 玉米\n+ 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n1. 黄瓜\n2. 玉米\n3. 茄子\n复制代码\n```\n\n以上标记显示效果如下：\n\n- 黄瓜\n- 玉米\n- 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n- 黄瓜\n- 玉米\n- 茄子\n\n1. 黄瓜\n2. 玉米\n3. 茄子\n\n注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。\n\n### 使用列表的一些注意事项\n\n如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格\n\n```\n*    段落一\n\n     小段一\n*    段落二\n\n     小段二\n复制代码\n```\n\n以上标记显示效果如下：\n\n- 段落一\n\n  小段一\n\n- 段落二\n\n  小段二\n\n另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格\n\n```\n* 段落一\n    > 区块标记一\n* 段落二\n    > 区块标记二\n复制代码\n```\n\n- 段落一\n\n  > 区块标记一\n\n- 段落二\n\n  > 区块标记二\n\n注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。\n\n### 分隔线\n\n有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以\n\n```\n***\n---\n复制代码\n```\n\n------\n\n------\n\n产生分隔线的语法要求比较松，符号之间添加空格也可以。\n\n### 强调\n\n有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗\n\n```\n*这里是斜体*\n_这里是斜体_\n\n**这里是加粗**\n__这里是加粗__\n复制代码\n```\n\n*这里是斜体* *这里是斜体*\n\n**这里是加粗** **这里是加粗**\n\n# 高级用法\n\n### 插入代码块\n\nMarkdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。\n\n方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹\n\n这是一段`var x = 3`行内代码\n\n如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果：\n\n```\nfun (x: Int, y: Int): Int {\n  return x + y\n}\n复制代码\n```\n\n注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。\n\n### 插入表格\n\n表格是Markdown语法中比较复杂的一个，其语法如下：\n\n```\n表头|条目一|条目二\n:---:|:---:|:---:\n项目|项目一|项目二\n复制代码\n```\n\n以上标记显示效果如下：\n\n| 表头 | 条目一 | 条目二 |\n| :--: | :----: | :----: |\n| 项目 | 项目一 | 项目二 |\n\n注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。\n\n# 其它\n\n### 特殊符号处理\n\nMarkdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理：\n\n```\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n复制代码\n```\n\n例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\\\ => \\ 。\n\n注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。\n\n### 如何给文字上色\n\n使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：\n\n1. 先用Markdown编辑完成\n2. 导出为html，在需要上色的部分手动添加标签<font color='#ff0000'></font>保存即可。\n\n### Markdown软件推荐\n\n强烈建议你使用typora\n\n如果你是一个Mac用户，也可以使用开源的 [MacDown](http://macdown.uranusjr.com/)：\n\n![Macdown](https://user-gold-cdn.xitu.io/2018/4/18/162d75d95959514c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n# 简单总结\n\nMarkdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。\n\n不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！\n\n\n作者：欧阳锋\n链接：https://juejin.im/post/5ad6e09e518825557b4d451c\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","slug":"Markdown教程","published":1,"updated":"2020-03-29T06:59:20.716Z","photos":[],"link":"","_id":"ck8ct7j5v000ygtvi9j9w0hzs","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Tip: 强烈建议使用typora作为您的markdown工具</p>\n<blockquote>\n<p>提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 <a href=\"https://daringfireball.net/\" target=\"_blank\" rel=\"noopener\"> JOHN GRUBER</a> 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看…</p>\n</blockquote>\n<h1 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h1><h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>Markdown支持6种级别的标题，对应html标签 <strong>h1 ~ h6</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># h1</span><br><span class=\"line\">## h2</span><br><span class=\"line\">### h3</span><br><span class=\"line\">#### h4</span><br><span class=\"line\">##### h5</span><br><span class=\"line\">###### h6</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记效果如下：</p>\n<h1 id=\"h1\"><a href=\"#h1\" class=\"headerlink\" title=\"h1\"></a>h1</h1><h2 id=\"h2\"><a href=\"#h2\" class=\"headerlink\" title=\"h2\"></a>h2</h2><h3 id=\"h3\"><a href=\"#h3\" class=\"headerlink\" title=\"h3\"></a>h3</h3><h4 id=\"h4\"><a href=\"#h4\" class=\"headerlink\" title=\"h4\"></a>h4</h4><h5 id=\"h5\"><a href=\"#h5\" class=\"headerlink\" title=\"h5\"></a>h5</h5><h6 id=\"h6\"><a href=\"#h6\" class=\"headerlink\" title=\"h6\"></a>h6</h6><p>除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 <a href=\"http://docutils.sourceforge.net/mirror/setext.html\" target=\"_blank\" rel=\"noopener\">Setext</a> 标记语言的表现形式，使用下划线进行文本大小的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一级标题</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">这是二级标题</span><br><span class=\"line\">---</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200320181200.png\"  alt=\"\"></p>\n<p>这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。</p>\n<h3 id=\"段落及区块引用\"><a href=\"#段落及区块引用\" class=\"headerlink\" title=\"段落及区块引用\"></a>段落及区块引用</h3><p>需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。</p>\n<p>而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 这段文字将被高亮显示...</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<blockquote>\n<p>这段文字将被高亮显示…</p>\n</blockquote>\n<h3 id=\"插入链接或图片\"><a href=\"#插入链接或图片\" class=\"headerlink\" title=\"插入链接或图片\"></a>插入链接或图片</h3><p>Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[点击跳转至百度](http:&#x2F;&#x2F;www.baidu.com)</span><br><span class=\"line\">![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;8128&#x2F;PicGo&#x2F;master&#x2F;20200320181301.png)</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">点击跳转至百度</a></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png\"  alt=\"\"></p>\n<p>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>Markdown支持有序列表和无序列表两种形式：</p>\n<ul>\n<li>无序列表使用*或+或-标识</li>\n<li>有序列表使用数字加.标识，例如：1.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 黄瓜</span><br><span class=\"line\">* 玉米</span><br><span class=\"line\">* 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">+ 黄瓜</span><br><span class=\"line\">+ 玉米</span><br><span class=\"line\">+ 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">- 黄瓜</span><br><span class=\"line\">- 玉米</span><br><span class=\"line\">- 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">1. 黄瓜</span><br><span class=\"line\">2. 玉米</span><br><span class=\"line\">3. 茄子</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<ul>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n</ul>\n<ol>\n<li>黄瓜</li>\n<li>玉米</li>\n<li>茄子</li>\n</ol>\n<p>注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。</p>\n<h3 id=\"使用列表的一些注意事项\"><a href=\"#使用列表的一些注意事项\" class=\"headerlink\" title=\"使用列表的一些注意事项\"></a>使用列表的一些注意事项</h3><p>如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*    段落一</span><br><span class=\"line\"></span><br><span class=\"line\">     小段一</span><br><span class=\"line\">*    段落二</span><br><span class=\"line\"></span><br><span class=\"line\">     小段二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<ul>\n<li><p>段落一</p>\n<p>小段一</p>\n</li>\n<li><p>段落二</p>\n<p>小段二</p>\n</li>\n</ul>\n<p>另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 段落一</span><br><span class=\"line\">    &gt; 区块标记一</span><br><span class=\"line\">* 段落二</span><br><span class=\"line\">    &gt; 区块标记二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>段落一</p>\n<blockquote>\n<p>区块标记一</p>\n</blockquote>\n</li>\n<li><p>段落二</p>\n<blockquote>\n<p>区块标记二</p>\n</blockquote>\n</li>\n</ul>\n<p>注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。</p>\n<h3 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h3><p>有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\">---</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<hr>\n<hr>\n<p>产生分隔线的语法要求比较松，符号之间添加空格也可以。</p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这里是斜体*</span><br><span class=\"line\">_这里是斜体_</span><br><span class=\"line\"></span><br><span class=\"line\">**这里是加粗**</span><br><span class=\"line\">__这里是加粗__</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p><em>这里是斜体</em> <em>这里是斜体</em></p>\n<p><strong>这里是加粗</strong> <strong>这里是加粗</strong></p>\n<h1 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h1><h3 id=\"插入代码块\"><a href=\"#插入代码块\" class=\"headerlink\" title=\"插入代码块\"></a>插入代码块</h3><p>Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。</p>\n<p>方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹</p>\n<p>这是一段<code>var x = 3</code>行内代码</p>\n<p>如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun (x: Int, y: Int): Int &#123;</span><br><span class=\"line\">  return x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。</p>\n<h3 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h3><p>表格是Markdown语法中比较复杂的一个，其语法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表头|条目一|条目二</span><br><span class=\"line\">:---:|:---:|:---:</span><br><span class=\"line\">项目|项目一|项目二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表头</th>\n<th align=\"center\">条目一</th>\n<th align=\"center\">条目二</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目</td>\n<td align=\"center\">项目一</td>\n<td align=\"center\">项目二</td>\n</tr>\n</tbody></table>\n<p>注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h3 id=\"特殊符号处理\"><a href=\"#特殊符号处理\" class=\"headerlink\" title=\"特殊符号处理\"></a>特殊符号处理</h3><p>Markdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">&#96;   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\">#   井字号</span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\ =&gt; \\ 。</p>\n<p>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p>\n<h3 id=\"如何给文字上色\"><a href=\"#如何给文字上色\" class=\"headerlink\" title=\"如何给文字上色\"></a>如何给文字上色</h3><p>使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：</p>\n<ol>\n<li>先用Markdown编辑完成</li>\n<li>导出为html，在需要上色的部分手动添加标签<font color='#ff0000'></font>保存即可。</li>\n</ol>\n<h3 id=\"Markdown软件推荐\"><a href=\"#Markdown软件推荐\" class=\"headerlink\" title=\"Markdown软件推荐\"></a>Markdown软件推荐</h3><p>强烈建议你使用typora</p>\n<p>如果你是一个Mac用户，也可以使用开源的 <a href=\"http://macdown.uranusjr.com/\" target=\"_blank\" rel=\"noopener\">MacDown</a>：</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d75d95959514c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"  alt=\"Macdown\"></p>\n<h1 id=\"简单总结\"><a href=\"#简单总结\" class=\"headerlink\" title=\"简单总结\"></a>简单总结</h1><p>Markdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。</p>\n<p>不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！</p>\n<p>作者：欧阳锋<br>链接：<a href=\"https://juejin.im/post/5ad6e09e518825557b4d451c\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ad6e09e518825557b4d451c</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>Tip: 强烈建议使用typora作为您的markdown工具</p>\n<blockquote>\n<p>提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 <a href=\"https://daringfireball.net/\" target=\"_blank\" rel=\"noopener\"> JOHN GRUBER</a> 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看…</p>\n</blockquote>\n<h1 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h1><h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>Markdown支持6种级别的标题，对应html标签 <strong>h1 ~ h6</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># h1</span><br><span class=\"line\">## h2</span><br><span class=\"line\">### h3</span><br><span class=\"line\">#### h4</span><br><span class=\"line\">##### h5</span><br><span class=\"line\">###### h6</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记效果如下：</p>\n<h1 id=\"h1\"><a href=\"#h1\" class=\"headerlink\" title=\"h1\"></a>h1</h1><h2 id=\"h2\"><a href=\"#h2\" class=\"headerlink\" title=\"h2\"></a>h2</h2><h3 id=\"h3\"><a href=\"#h3\" class=\"headerlink\" title=\"h3\"></a>h3</h3><h4 id=\"h4\"><a href=\"#h4\" class=\"headerlink\" title=\"h4\"></a>h4</h4><h5 id=\"h5\"><a href=\"#h5\" class=\"headerlink\" title=\"h5\"></a>h5</h5><h6 id=\"h6\"><a href=\"#h6\" class=\"headerlink\" title=\"h6\"></a>h6</h6><p>除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 <a href=\"http://docutils.sourceforge.net/mirror/setext.html\" target=\"_blank\" rel=\"noopener\">Setext</a> 标记语言的表现形式，使用下划线进行文本大小的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一级标题</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">这是二级标题</span><br><span class=\"line\">---</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200320181200.png\" alt=\"\"></p>\n<p>这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。</p>\n<h3 id=\"段落及区块引用\"><a href=\"#段落及区块引用\" class=\"headerlink\" title=\"段落及区块引用\"></a>段落及区块引用</h3><p>需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。</p>\n<p>而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 这段文字将被高亮显示...</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<blockquote>\n<p>这段文字将被高亮显示…</p>\n</blockquote>\n<h3 id=\"插入链接或图片\"><a href=\"#插入链接或图片\" class=\"headerlink\" title=\"插入链接或图片\"></a>插入链接或图片</h3><p>Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[点击跳转至百度](http:&#x2F;&#x2F;www.baidu.com)</span><br><span class=\"line\">![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;8128&#x2F;PicGo&#x2F;master&#x2F;20200320181301.png)</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">点击跳转至百度</a></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200320181301.png\" alt=\"\"></p>\n<p>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>Markdown支持有序列表和无序列表两种形式：</p>\n<ul>\n<li>无序列表使用*或+或-标识</li>\n<li>有序列表使用数字加.标识，例如：1.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 黄瓜</span><br><span class=\"line\">* 玉米</span><br><span class=\"line\">* 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">+ 黄瓜</span><br><span class=\"line\">+ 玉米</span><br><span class=\"line\">+ 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">- 黄瓜</span><br><span class=\"line\">- 玉米</span><br><span class=\"line\">- 茄子</span><br><span class=\"line\"></span><br><span class=\"line\">1. 黄瓜</span><br><span class=\"line\">2. 玉米</span><br><span class=\"line\">3. 茄子</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<ul>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n<li><p>黄瓜</p>\n</li>\n<li><p>玉米</p>\n</li>\n<li><p>茄子</p>\n</li>\n</ul>\n<ol>\n<li>黄瓜</li>\n<li>玉米</li>\n<li>茄子</li>\n</ol>\n<p>注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。</p>\n<h3 id=\"使用列表的一些注意事项\"><a href=\"#使用列表的一些注意事项\" class=\"headerlink\" title=\"使用列表的一些注意事项\"></a>使用列表的一些注意事项</h3><p>如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*    段落一</span><br><span class=\"line\"></span><br><span class=\"line\">     小段一</span><br><span class=\"line\">*    段落二</span><br><span class=\"line\"></span><br><span class=\"line\">     小段二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<ul>\n<li><p>段落一</p>\n<p>小段一</p>\n</li>\n<li><p>段落二</p>\n<p>小段二</p>\n</li>\n</ul>\n<p>另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 段落一</span><br><span class=\"line\">    &gt; 区块标记一</span><br><span class=\"line\">* 段落二</span><br><span class=\"line\">    &gt; 区块标记二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>段落一</p>\n<blockquote>\n<p>区块标记一</p>\n</blockquote>\n</li>\n<li><p>段落二</p>\n<blockquote>\n<p>区块标记二</p>\n</blockquote>\n</li>\n</ul>\n<p>注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。</p>\n<h3 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h3><p>有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\">---</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<hr>\n<hr>\n<p>产生分隔线的语法要求比较松，符号之间添加空格也可以。</p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这里是斜体*</span><br><span class=\"line\">_这里是斜体_</span><br><span class=\"line\"></span><br><span class=\"line\">**这里是加粗**</span><br><span class=\"line\">__这里是加粗__</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p><em>这里是斜体</em> <em>这里是斜体</em></p>\n<p><strong>这里是加粗</strong> <strong>这里是加粗</strong></p>\n<h1 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h1><h3 id=\"插入代码块\"><a href=\"#插入代码块\" class=\"headerlink\" title=\"插入代码块\"></a>插入代码块</h3><p>Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。</p>\n<p>方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹</p>\n<p>这是一段<code>var x = 3</code>行内代码</p>\n<p>如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun (x: Int, y: Int): Int &#123;</span><br><span class=\"line\">  return x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。</p>\n<h3 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h3><p>表格是Markdown语法中比较复杂的一个，其语法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表头|条目一|条目二</span><br><span class=\"line\">:---:|:---:|:---:</span><br><span class=\"line\">项目|项目一|项目二</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>以上标记显示效果如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表头</th>\n<th align=\"center\">条目一</th>\n<th align=\"center\">条目二</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目</td>\n<td align=\"center\">项目一</td>\n<td align=\"center\">项目二</td>\n</tr>\n</tbody></table>\n<p>注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h3 id=\"特殊符号处理\"><a href=\"#特殊符号处理\" class=\"headerlink\" title=\"特殊符号处理\"></a>特殊符号处理</h3><p>Markdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">&#96;   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\">#   井字号</span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\ =&gt; \\ 。</p>\n<p>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p>\n<h3 id=\"如何给文字上色\"><a href=\"#如何给文字上色\" class=\"headerlink\" title=\"如何给文字上色\"></a>如何给文字上色</h3><p>使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：</p>\n<ol>\n<li>先用Markdown编辑完成</li>\n<li>导出为html，在需要上色的部分手动添加标签<font color='#ff0000'></font>保存即可。</li>\n</ol>\n<h3 id=\"Markdown软件推荐\"><a href=\"#Markdown软件推荐\" class=\"headerlink\" title=\"Markdown软件推荐\"></a>Markdown软件推荐</h3><p>强烈建议你使用typora</p>\n<p>如果你是一个Mac用户，也可以使用开源的 <a href=\"http://macdown.uranusjr.com/\" target=\"_blank\" rel=\"noopener\">MacDown</a>：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d75d95959514c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"Macdown\"></p>\n<h1 id=\"简单总结\"><a href=\"#简单总结\" class=\"headerlink\" title=\"简单总结\"></a>简单总结</h1><p>Markdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。</p>\n<p>不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！</p>\n<p>作者：欧阳锋<br>链接：<a href=\"https://juejin.im/post/5ad6e09e518825557b4d451c\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ad6e09e518825557b4d451c</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"layout":"post","title":"南疆游记","date":"2020-03-21T09:47:00.000Z","description":"横穿塔克拉玛干沙漠，飞跃海拔五千米的边境公路","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/0427C6ED-4414-40A7-80D6-62B86DF0C8DA_1_105_c.jpeg","optimized_image":null,"author":"tty","top":true,"_content":"\n**照片都是手机直出的，没有任何调色等修改**\n\n在19年的南疆之旅之前，我已去过新疆，不过前往的都是北疆景点，未曾踏足天山以南的土地。上次游玩之后，同行的人发来邀请，问是否明年想改换航线，前往南疆旅行一次。\n\n在北疆旅游的时候，但凡见到当地的汉人，他们都会说：北边都是汉化的地儿，兵团驻扎，你们要想感受感受风土人情，那还是得去南疆看看。想起夏尔西里的景色和烤羊的诱惑，假如南疆比这北疆还能更好玩，那便绝对值得一去。我们想也没想就答应了。\n\n所谓南疆北疆，是按天山划分的。这天山几乎横切了整个新疆，按我爸的话说，“抬头看到高山，得嘞，那就是天山”。我们虽然计划去南疆，但因为有朋友在北疆等我们，于是还是降落在了乌鲁木齐。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ED5408C8-72EC-4110-953E-6FF33F88229C_1_105_c.jpeg)\n\n乌鲁木齐这座城市汉化很严重，管理也很严格。在我18年来的时候，全国各地都在用4G了，而且都整上好几年了，到了乌鲁木齐一打开手机，诶嘿，还是3G网（周边城市有4G，就乌鲁木齐没有），速度慢得跟没有一样，妻管严的兄弟来这里玩估计随随便便就漏掉好多老婆的微信，回家的时候只能当光棍了。当时据说是只有申请才能用上4G（我们同行的人中有当地人能上），我们这些外来物种那就只能乖乖3G了。\n\n严格管理当然不只是网络管理，有一位部队里的兄弟在吃饭的时候直接吹牛，说在新疆11点后你四人大声打牌都要给你逮起来，新疆现在就是全国最安全的地方。\n\n18年的环境，他说这句话，我举双手赞成。我们当时就是在乌鲁木齐坐个车，一路上但凡到了十字路口就会有一个关卡，有的关卡甚至会有水泥铸的碉堡（和谐一点，叫保安亭好了）。大伙可都拿的是真枪实弹，哪有人能在这环境下整活？你到了十字路口，警察叔叔就过来了，让你把窗户摇下来——他一瞥，哟，是个汉人，走走走吧，没你事了，该干嘛干嘛去。但假如你是个维族人，兄弟，请你出示一下你的身份证！\n\n也亏得我们是汉人，这维族人简直就是寸步难行。其实我们汉人也一样，没了身份证你哪都跑不了，到处都有可能要检查身份证，加油站这种门口摆着巨大战时路障的更不用说了，你还得过安检。只是你被查到的概率远远低于维族人而已。你被查一次，他们大概已经被查20次了。\n\n在这样的环境下，大巴扎在18年的时候，关门关得特别早。大巴扎在维语中就是大集市的意思。出事以前，大巴扎半夜三更都特别热闹，当然今非昔比了。\n\n我19年再去的时候，环境改善了不少。不仅有4G了，大巴扎竟然开到晚上了。于是我们就进去恰了一顿夜宵。虽然游客不少，但是其中维族人比例属实不低。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/6BDA8F68-B75E-4DD3-847E-95088A5BBF21_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/282348A7-709B-415E-9735-18820A7EAE54_1_105_c.jpeg)\n\n你问我在大巴扎中印象最深的是什么？害，我会告诉你我吃夜宵的时候，~~在我前面的维族志愿者小姐姐好看到爆表我完全忘不掉吗？~~ 不，是啤酒！人头大的啤酒你喝过吗！~~很难喝~~\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/D329EC50-6258-4D2A-8A1F-790E0F54CA0E_1_105_c.jpeg)\n\n隔天我们就直接飞向了阿克苏。阿克苏这名字是不是很耳熟？是不是脑子里蹦出来一个红苹果？\n\n因为坐飞机到阿克苏已经花了一早上，我们在阿克苏我们就去了一个景点：刀郎部落。且不说这个景点疯狂蹭刀郎（没错就是2002年第一场雪的刀郎）热度，这个景点本身做工低劣极其弟弟……他们企图把这个村包装成一个人文景观，但是实际上只有自然景观还算凑合，坐马车跑跑路还算惬意。那几个部落里跳舞的小兄弟看起来无精打采的，小姐姐也莫得只剩大姐姐了，建议别去浪费钱了\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/4DCEDA5E-01F8-47C4-A07C-F64D6651A90E_1_105_c.jpeg)\n\n次日终于来到了本次旅途重头戏之一——沙漠公路。话说我自上次北疆之旅就对沙漠公路念念不忘，没办法，听起来实在是太酷了。但是上次时间有些不足，多半时间都花在独库公路上了。这次终于能见识到什么叫做沙漠公路了。\n\n说起来我也未曾去大沙漠中好好玩一圈，此前去过的也顶多就是陕甘宁那片区的小沙漠，它们跟塔克拉玛干比起来自然是不值一提。\n\n我们行过的路段是阿克苏到和田的部分。去之前司机小哥对沙漠公路是一顿胡夸海吹，跟我说到了沙漠之中，你就能感受到大漠孤烟直，长河落日圆的气氛！公路在沙漠中笔直穿过看不到边际，两边是一望无际的旷野……\n\n因为他这几句话，我刚上路的时候是满怀期待的。但是为了保护这条沙漠公路，公路两旁都有防护带，或是摆成方格状的干草，或是生存力顽强的草皮。其中有一个片区还种植了各式植物，据司机小哥说，这里是在做对照试验，看哪种方法防砂效果最佳。\n\n防砂固然要紧，但这沙漠公路看起来就没有那么酷了。本来我以为两侧是一望无尽的沙漠丘陵，你给我上面种些花里胡哨的植物，我总觉得破坏了其中的艺术气息。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/DC5C4B3D-A795-4672-8D13-62191E7E19A4_1_105_c.jpeg)\n\n为了看看沙漠的真面目，我们找了几个地方停了车。翻过丘陵之后，却发现之后的沙漠也没想象中的那么广阔壮观。靠北，多半是之前看到的沙漠宣传照都被调了色！PS害人呐！真正的沙漠就这？\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/2C124614-02BC-4703-B640-F48C0FA77690_1_105_c.jpeg)\n\n不过沙漠最终还是没让我们失望，行车不久后，我们便看到小哥口中的“大漠孤烟直”了。一开始我还不确定那是什么，以为前面失火了，寻思着大沙漠里难不成有人的车自燃了，谁知道靠近了一看，竟然是道通天高的龙卷风。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-5124d97939f8.gif)\n\n我不知道你们有没有见过龙卷风，反正我是从来没见过。我只是小时候在百科全书上见过，之后就是各种灾难片。没想到在这大沙漠中竟然能看到龙卷风的真身。令人咋舌的是沙漠中远远不止这一阵龙卷风，随着我们深入，龙卷风变得随处可见！\n\n不过之前看新闻的时候我记得美国曾发生过一次龙卷风把人卷到空中的事件。这里的龙卷风威力并没有那么大。我不太清楚它们是如何形成的，但是有些小龙卷风在踏上这条公路之后便快速消失了。车从这些龙卷风中穿过并不会遭到太大的阻碍。不过有一次我企图开车窗拍张风哥近照，风哥突然加快了步伐，冲过来就喂了我一嘴沙。想到这我都觉得嘴里有点异样。\n\n在我们快到和田之前，司机一个拐弯拐进了沙漠里，原来有座热瓦克古佛寺藏在这沙漠之中。在这小道中我们一路颠簸，到了一个只有游客中心的地方。这游客中心可算是空无一人，门口与写着全国重点文物保护单位，却只有个大爷坐在门口阴凉处打瞌睡。我们上去前往交流，却发现这看管景点的大爷并不会汉语。司机小哥用几句蹩脚的维语问大爷入口是不是在这，大爷好像点了点头。我们也不管，就这么进去了。看来新疆的文物保护着实还是需要加大力度。\n\n这座古佛寺据说建于南北朝时期，还是被一个英国探险家发现的。谈到这就难受，过去大家对文物都不怎么当回事，不知道被别人拐了多少家产走。说起来作为一个历史麻瓜，我当时一瞬间脑子卡壳，这怎么在伊斯兰的地盘会有佛寺？原来新疆以前一度是佛国地区，要不是被伊斯兰国攻打，可能他们现在跟我们一样信教主要信佛教呢！不得不说，对付宗教还得靠宗教。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/D780C6BF-A6BC-409E-9C50-4CD2DBDA824E_1_105_c.jpeg)\n\n下午到了和田之后我们一行人稍作休息，晚上跑到和田夜市恰了一顿饭。不得不说，现在回来看和田夜市的照片，真的，卫生环境不知道比武汉海鲜市场高到哪里去了（武汉海鲜市场的视频在YouTube上满天飞，很多老外说什么中国人还不如病毒，能吃得下这肮脏海鲜市场里东西的家伙根本不能算人。当然了，说出这种话的人根本不能算人，但是我们总得反省下吧，尼玛的2020年了菜市场还这样呢？）亏得你们还是生活条件不错的内地人！这里有几样菜比较有意思，牛羊肉就不必说了（新疆的羊肉串!=其他地方的羊肉串，新疆羊肉独一档，内蒙古羊肉在新疆羊肉面前就是乐色），酸奶（是什么奶我忘了）冰淇淋和烤蛋都挺好吃。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-8e0a5126f1fc.gif)\n\n<!--split-->\n\n第二天一早起来，我们就去参观了一个植物园一样的地方。那里种植了树龄有足足1300年的核桃树，占地上百平米的无花果王，还有些葫芦，葡萄，西瓜之类的水果。估计是休息时间实在太长，有一位葫芦先生屁股都坐扁了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/0BF6261B-93FE-477F-9C22-20F137C19894_1_105_c.jpeg)\n\n这位是无花果王，怎么说呢，你看到的围起来的地方都是这株无花果的领地……\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/CA8A3D8B-E44A-4686-87D6-CA0405A5327F_1_105_c.jpeg)\n\n这天的中饭非常有意思，我们跑到了墨玉县去吃当地的特色菜。一个叫西瓜烧肉，一个叫肚烧肉。所谓西瓜烧肉，就是用西瓜当锅，然后将乳鸽和羊肉放在其中炖汤，炖出来的汤带有西瓜汁的味道，怪好喝的，不过西瓜炖得都发黑了，属实不太好看。肚烧肉也是一个意思，用猪肚还不知道是牛肚烤羊肉。不过我总觉得那羊肉没烤透，便没怎么吃。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/232B41AE-DE56-4DDD-83BE-6C46146710A2_1_201_a.jpeg)\n\n吃完饭之后我们直接开车前往喀什。喀什据说是以前东突分子们的首都，假如搞什么独立，好像喀什会成为他们东突首府，具体是个什么情况我不清楚，反正独立我是不赞成的。\n\n在这去喀什的路上还有一段小插曲，就是我们想要上高速的时候，被警察拦住了。警察告诉我们说这段路不能走了，路那边好像有什么领导要过来，只能换小路走。我纳闷呢，咋能有人这么威风直接拦高速自己走。\n\n不过当时那段高速也没彻底修好，路上还有不少施工的人和车，要是有什么交通厅的领导来视察之类的，也是可以理解。警察说你们往边上绕吧，绕也能去喀什的。于是我们两辆车就从侧边的一条小路走去。\n\n结果走着走着发现这路在GPS上没了，大概是地图信息有段时间没更新了，或者是这路本来就没在地图上过。但我们隐隐约约看到不远处有一个上高速的入口，不由得欣喜若狂，一脚油门就继续在这砂石小径上继续走了，一同跟来的商务车便也踩着油门往前冲。我们是山地SUV，这都是小case，噌噌噌就过去了，跑回到了高速路上。\n\n其实我是不赞成回到这高速的，因为两边不是有交警拦着么，虽然我们这条小路上没人拦，但总觉得开上来好像不是很合法。交警叫我们绕道，应该是绕道走普通道路，不是绕道上高速啊。果不其然，开到一半就出事了，不久后我们看到一辆逆向的军车朝我们打着双闪冲过来了。我们立刻将车靠边停了，也没做什么后续动作。军车也没有理会我们，呼啸着从我们身旁开过去了。\n\n“这军车是开道的，后面应该有什么车队。”司机小哥说。\n\n不一时果真有车队到来。这是由几辆军车护航的大巴车队，我们依稀能见到这些大巴车上有隔开司机的铁栅栏。一共四十多量大巴，一路开过，根本没有人来打理我们一下，估计以为我们是来修高速的工人。随着最后一辆护卫车驶过，我们发动了引擎。\n\n“是监狱的车吧，要不就是……”\n\n我们也没有多想，继续往前开，突然想起我们后面那辆车来。这我们上了高速也有一阵了，虽然这高速还在修路况有些问题，但这商务车也不至于那么慢吧？十分应景的是电话这时候就响了，原来是后面的人来求助来了。\n\n“我们的商务车卡沙子里了！你们找根绳子来帮我们拉出来。”\n\n我们真的满头问号，我们这都开出来40分钟了快到叶城了，你们咋才告诉我们你们陷沙子里了啊？而且我们车上也没绳子啊。我们一边告诉他们我们会尽力去找，另一方面叫他们去找墨玉县的人帮帮忙。于是我们开车就去找路边的修路老伯。司机小哥掏了包烟带上钱就过去了，问维族老伯有绳子没有。\n\n老伯不会汉语，但总算听明白了我们的意思。他摆了摆手表示不要烟和钱，而且跟我们说没有绳子，但是会带我们去找绳子，说完就开了十分钟车带我们去他的小屋拿了根绳子。我们不停地谢谢，然后便往回走了。\n\n谁知开到一半，另外一头又打电话告诉我们不必来了。说是遇到了几个开车的维族小伙子，看到需要帮忙，直接热心肠帮忙给他们把车给揪出来了。\n\n大家都不由得感叹维族人的热心善良，这要是汉族人指不定要收你多少钱。最后我们把绳子还给老伯，老伯还是什么都不肯收。\n\n说道这里就不得不再提一句维族人的善良真诚了，真的，一路遇到的维族人无一不是热心善良的，小孩子也是天真可爱，看到你过来会睁大眼睛不停地摆手打招呼，跟内地印象中的新疆人完全不相符。按队里小哥的话说，外面都是善良的人，可能是因为但凡你有一点不善良的动机，你已经被拉去再教育了。从这点来看，我觉得大部分的维族人都太可怜了。假如说Trump说Chinese virus是歧视，那我们因为一次暴恐事件把所有维族人都严加管理，这又算是什么呢？（我没说Trump说Chinese virus是正确的行为）\n\n喀什玩的地方很多，有古城，艾提尕尔清真寺，大巴扎等等。你到了喀什会有种来到了中东的错觉，这里的很多建筑就跟中东战争电影里的一模一样。喀什古城就是其中一种跟中东风哥相仿的建筑区，这个建筑群建在一个大概两三层楼高的一个高台上，据说只有过去的权贵（天龙人）才能住在这里。你想象下我们中原的城墙，他们就住在那个高度上。那当真应该是意气奋发，抬头向窗外一看，嗨你们这些屁民，只能住在地面上。当然现在住的已经都是些朴实无华的人，你走过路过路边摊或者民宿的时候，还会有不少维族小姐姐来打招呼，~~哎哟小哥进来玩呀，完全免费哦💕~~。可别信了她们的邪，进去参观是免费的，可你跟她们互动来扭捏去过会说不定一会就挂不下面子疯狂消费了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/B8B5E8B5-C134-49A8-B3D8-759E5A930B20_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/6FCB8EA6-767C-4286-BA48-02F5368186E6_1_105_c.jpeg)\n\n同样，这里的维族人也很友好。我们跟维族阿姨说买馕的钱不用找了的时候，感觉她把一年的快乐都笑出来了。路边还有带着孩子让他给我们打招呼的可爱小姐姐，善良的人们呐祝你们一生幸福。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/21F3F998-E734-4E8B-9D39-2D2C63BADD67_1_105_c.jpeg)\n\n接着我们去了那个亚洲最大的清真寺艾提尕尔清真寺和大巴扎。这儿的大巴扎不得不说还是比乌鲁木齐的有趣多了，东西多而广，衣食住行应有尽有。我们买了一堆坚果葡萄干之类的产品直接寄回家了，然后在市场里面闲逛。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7F926F8D-6CED-478E-B45A-4ECA78AD3CE2_1_105_c.jpeg)\n\n期间一个老伯先是问我们要不要买帽子（戴起来像皇军的那种），我们谢绝了之后，他突然压低声音问我们要不要狼牙。这倒是引起了我们的兴趣，我们跟着他走进屋里看了看，但也不能确定是不是真的狼牙，便还是走了出来。狼是保护动物，你猎杀不得，但是假如它攻击你的话，那你就可以反击。老A说了个故事，说他在西藏海拔五千多米的地方驾车时遇到过狼群，怎么甩也甩不掉，头狼深蓝色的眼睛就透过车窗死死地盯着自己。他当时差点就想去撞死那狼，但最后还是作罢。“狼真的有灵性，带着狼牙可以辟邪。这400块钱的狼牙，假如是真的肯定值，但是我看起来不像是真的。”他这么说。\n\n中午我们吃了一顿饭，天啊现在想起来我还馋得不行，那架烤羊肉！那大盘鸡！那羊肉抓饭！那蜂蜜藏红花！简直就是极致美味。什么烤全羊都是弟中弟，当你吃过那架子上金黄色肥而不腻的架烤羊肉，你就不知道其他羊肉还算不算羊肉了！\n\n羊肉手抓饭也是当之无愧的新疆必吃美味，在新疆这辽阔的地方当你开了八小时的车累得快死了，你想到下一顿是羊肉手抓饭，你就能继续开下去，说不定你还能再开八小时。\n\n饭桌上老C说阿尔泰的羊肉就是最好的羊肉，我们吃的就是阿尔泰羊肉。阿尔泰羊肉最好，其次才是伊犁的羊肉。别的地方小羊养到15kg才开涮，伊犁他们12kg就开始了。RIP小羊，我是爱（吃）你们的。\n\n<!--split-->\n\n吃完饭后我们也没歇着，直接向阿图什天门开去。据说这座天门被发现还是因为有飞行员在此地飞行，看到山中间竟有一个大洞，这才发现的。这个景点较新，并没有很多人去过，我们决定过去探探险。\n\n一路上都是一望无际的戈壁滩，在行车的过程中尤为壮观。可用手机一拍，好像又不是那么一回事了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/42708B60-13F2-466F-9E85-A656CE9CFAF6_1_105_c.jpeg)\n\n来到天门我们几人买了门票，就徒步向里走去。这个景点在丰水期间好像会关门，而我们徒步进入的地方也似是一条河道。刚踏入这个景区我们便被壮观的风化山石镇住了。随行的小D还时不时的看看岩壁，按他的话说，搞不好这些岩壁上有化石。“以前这些地方都是沉在水里的，这里有化石丝毫不奇怪，我以前就捡到过化石。”他这么说。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3D89B5ED-62C5-45D4-A685-36A65594A525_1_105_c.jpeg)\n\n山间大风严重，有一座山直接被经年累月的风凿除了一个巨洞，宛如被一记重拳打中。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3D115670-CBA0-4D0C-B2C9-1C5787DB8D66_1_105_c.jpeg)\n\n走到后段，队内的中老年选手已经不太行了，少说走了有几公里路了。不过眼前出现了天门的光点，让大家都有了希望。所有人都顺着溪石向上攀登，不一时有了台阶，离山顶还有几百级。然而在到山顶之前，你都不会知道结局有多波澜壮阔！\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/8B758FEB-ED8D-4A45-BC67-9D80658F6A41_1_105_c.jpeg)\n\n这是一扇高达百米的门！我们在山下只能看见门的上半部分，殊不知其后还有深不见底的裂谷。远方的那座高山在烈日下被染成金色，队里一阵“我操”声。\n\n“消耗了我一年的运动量，真没算白来！”老A瞪大了眼，半天才“我操”出来。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E3F7C8EE-EE71-40C3-A411-2E0932B007CB_1_105_c.jpeg)\n\n这时候再看看我们之前上来的路……GG，上山容易下山难，怕是又要忙活好久一阵了……\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/C15F7849-E970-477E-B4C0-184B784F14F4_1_105_c.jpeg)\n\n下山之后的戈壁滩（这是我的微信profile图，假如你有看到过），新疆这地方，随手一拍都是美景啊\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/AB51348C-E5D9-4EA5-BDF4-4A56F1F1AB7F_1_105_c.jpeg)\n\n倒数第二日我们走G314国道前往了塔县。塔县的全名是塔什库尔干塔吉克自治县，在帕米尔高原之上。喀什库尔干意思就是石头城，里面还有石头城遗迹，同时这里还有中国唯一的白人种族，塔吉克族。据老D所说，塔吉克族虽然是白人，但是异常爱国，他们很多人从小的梦想就是成为军人守护边疆。\n\n前往塔县之路是一条边境之路。你想去塔县，你得有边防证才能走这条边境之路。在这里就能看出中国基建狂魔之名号不是浪得虚名，有几个路段，在巨山之中，几十米高的桥就这么突兀地架过去了。这条路还尤为惊险，左右都能看到不少的山体滑坡，想来泥石流在这也不是什么怪事，毕竟山顶都是积雪。还有些路段被积水淹没了。\n\n在新疆的荒野中开车，突然遇到堵车，那是很正常的事情。之前我们在独库公路上就因为前方路面坍塌而不得不绕道，这次我们也好几次遇到了施工队，等待他们解决问题。好笑的是有时候路边会有巴扎，然后堵车的时候有的维族人就跑巴扎里去了，出来的时候抱着一只羊。羊还超级乖，可可爱爱地坐他怀里一动不动，我们都笑晕了。\n\n我们在这危险路段开了一段时间，海拔也是越开越高，车上大家逐渐困顿，一个个睡去。一段时间后终于拨开云雾，来到一片巨大的湖泊前。此湖名为白沙湖，如你所见，湖边的山全是由白沙构成的。湖呈现不真实的碧蓝色。我不知道怎么形容它，我只能说在这海拔3300+米的地方看到它，unreal。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/9FFFC562-FF06-4E01-B63B-C6BF05980592_1_105_c.jpeg)\n\n首先声明下这图里俩人一车不是我们的人和车……然后我也不知道为什么这张的湖水颜色不一样。不过说实话两张照片中湖水的颜色都跟真实颜色有一定差距，真实的颜色更接近淡淡的青色。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7CD71221-68BC-4F4C-8F73-522D0F5D0E8D_1_105_c.jpeg)\n\n在这里我们喝了几碗羊汤就上路了。假如你爱干净的话可能你不会很喜欢这里，因为这里只有旱厕。但是羊汤很便宜，十块钱一碗，在这3300+的海拔上，属实不能算贵了。\n\n慕士塔格峰在就在白沙湖的边上，海拔有7500+，极其壮观。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/840FCE17-6E74-45B8-B504-EA4FE6AE0385_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3B0484FD-E6AB-4D2C-9067-01728C23CEA9_1_105_c.jpeg)\n\n之后还有个葱岭圣湖。然而大家都刚刚看过白沙湖，直接贤者模式了，这葱岭圣湖便没怎么看直接路过了\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/C611EDD8-116D-488D-90F7-9A522D1362DC_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7A0389B7-3B0B-487F-AFFB-0362D2A1E762_1_105_c.jpeg)\n\n到了塔县后我们休息了一晚，吃了吃高原牦牛火锅，去了趟高原湿地公园（我们那天大雾，拍照片拍不清楚。但是远方的山都被雾所阻隔了，我当时以为湿地大到离谱，第二天才发现四野是有山的）\n\n第二日我们就去了红其拉甫口岸，这是我们此行去的最后一个地方。这是跟巴基斯坦交接的口岸，海拔有5000米之高，人没缺氧，车缺氧了，燃油有些烧不动，动力变弱了。上面还得过个哨所，得有通行证才能过。边防兵脾气也不好，可能直接上来骂娘，得小心点，毕竟人身上带着枪呢。上去之后还特别冷，老C老D裹着棉被冲出去拍照，给爷逗笑了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/040807D0-7DC7-4806-811D-3DCED01F7815_1_201_a.jpeg)\n\n去了口岸之后，我们回到塔县吃了一顿冷水鱼。塔县并不是个吃冷水鱼的好地方，老板也做得不怎么样，导致这顿冷水鱼吃着感觉还不如吃鲫鱼。晚上我们便回了喀什，飞回了家。\n\n下次若还有机会，我倒是很想走走新藏公路，见识见识昆仑的魅力。","source":"_posts/2020-03-21-南疆游记.md","raw":"---\nlayout: post\ntitle:  南疆游记\ndate:   2020-03-21 2:47:00\ndescription: 横穿塔克拉玛干沙漠，飞跃海拔五千米的边境公路\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/0427C6ED-4414-40A7-80D6-62B86DF0C8DA_1_105_c.jpeg\noptimized_image: \ncategory: travel\ntags:\n  - travel\n  - life\n  - blog\nauthor: tty\ntop: true\n---\n\n**照片都是手机直出的，没有任何调色等修改**\n\n在19年的南疆之旅之前，我已去过新疆，不过前往的都是北疆景点，未曾踏足天山以南的土地。上次游玩之后，同行的人发来邀请，问是否明年想改换航线，前往南疆旅行一次。\n\n在北疆旅游的时候，但凡见到当地的汉人，他们都会说：北边都是汉化的地儿，兵团驻扎，你们要想感受感受风土人情，那还是得去南疆看看。想起夏尔西里的景色和烤羊的诱惑，假如南疆比这北疆还能更好玩，那便绝对值得一去。我们想也没想就答应了。\n\n所谓南疆北疆，是按天山划分的。这天山几乎横切了整个新疆，按我爸的话说，“抬头看到高山，得嘞，那就是天山”。我们虽然计划去南疆，但因为有朋友在北疆等我们，于是还是降落在了乌鲁木齐。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ED5408C8-72EC-4110-953E-6FF33F88229C_1_105_c.jpeg)\n\n乌鲁木齐这座城市汉化很严重，管理也很严格。在我18年来的时候，全国各地都在用4G了，而且都整上好几年了，到了乌鲁木齐一打开手机，诶嘿，还是3G网（周边城市有4G，就乌鲁木齐没有），速度慢得跟没有一样，妻管严的兄弟来这里玩估计随随便便就漏掉好多老婆的微信，回家的时候只能当光棍了。当时据说是只有申请才能用上4G（我们同行的人中有当地人能上），我们这些外来物种那就只能乖乖3G了。\n\n严格管理当然不只是网络管理，有一位部队里的兄弟在吃饭的时候直接吹牛，说在新疆11点后你四人大声打牌都要给你逮起来，新疆现在就是全国最安全的地方。\n\n18年的环境，他说这句话，我举双手赞成。我们当时就是在乌鲁木齐坐个车，一路上但凡到了十字路口就会有一个关卡，有的关卡甚至会有水泥铸的碉堡（和谐一点，叫保安亭好了）。大伙可都拿的是真枪实弹，哪有人能在这环境下整活？你到了十字路口，警察叔叔就过来了，让你把窗户摇下来——他一瞥，哟，是个汉人，走走走吧，没你事了，该干嘛干嘛去。但假如你是个维族人，兄弟，请你出示一下你的身份证！\n\n也亏得我们是汉人，这维族人简直就是寸步难行。其实我们汉人也一样，没了身份证你哪都跑不了，到处都有可能要检查身份证，加油站这种门口摆着巨大战时路障的更不用说了，你还得过安检。只是你被查到的概率远远低于维族人而已。你被查一次，他们大概已经被查20次了。\n\n在这样的环境下，大巴扎在18年的时候，关门关得特别早。大巴扎在维语中就是大集市的意思。出事以前，大巴扎半夜三更都特别热闹，当然今非昔比了。\n\n我19年再去的时候，环境改善了不少。不仅有4G了，大巴扎竟然开到晚上了。于是我们就进去恰了一顿夜宵。虽然游客不少，但是其中维族人比例属实不低。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/6BDA8F68-B75E-4DD3-847E-95088A5BBF21_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/282348A7-709B-415E-9735-18820A7EAE54_1_105_c.jpeg)\n\n你问我在大巴扎中印象最深的是什么？害，我会告诉你我吃夜宵的时候，~~在我前面的维族志愿者小姐姐好看到爆表我完全忘不掉吗？~~ 不，是啤酒！人头大的啤酒你喝过吗！~~很难喝~~\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/D329EC50-6258-4D2A-8A1F-790E0F54CA0E_1_105_c.jpeg)\n\n隔天我们就直接飞向了阿克苏。阿克苏这名字是不是很耳熟？是不是脑子里蹦出来一个红苹果？\n\n因为坐飞机到阿克苏已经花了一早上，我们在阿克苏我们就去了一个景点：刀郎部落。且不说这个景点疯狂蹭刀郎（没错就是2002年第一场雪的刀郎）热度，这个景点本身做工低劣极其弟弟……他们企图把这个村包装成一个人文景观，但是实际上只有自然景观还算凑合，坐马车跑跑路还算惬意。那几个部落里跳舞的小兄弟看起来无精打采的，小姐姐也莫得只剩大姐姐了，建议别去浪费钱了\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/4DCEDA5E-01F8-47C4-A07C-F64D6651A90E_1_105_c.jpeg)\n\n次日终于来到了本次旅途重头戏之一——沙漠公路。话说我自上次北疆之旅就对沙漠公路念念不忘，没办法，听起来实在是太酷了。但是上次时间有些不足，多半时间都花在独库公路上了。这次终于能见识到什么叫做沙漠公路了。\n\n说起来我也未曾去大沙漠中好好玩一圈，此前去过的也顶多就是陕甘宁那片区的小沙漠，它们跟塔克拉玛干比起来自然是不值一提。\n\n我们行过的路段是阿克苏到和田的部分。去之前司机小哥对沙漠公路是一顿胡夸海吹，跟我说到了沙漠之中，你就能感受到大漠孤烟直，长河落日圆的气氛！公路在沙漠中笔直穿过看不到边际，两边是一望无际的旷野……\n\n因为他这几句话，我刚上路的时候是满怀期待的。但是为了保护这条沙漠公路，公路两旁都有防护带，或是摆成方格状的干草，或是生存力顽强的草皮。其中有一个片区还种植了各式植物，据司机小哥说，这里是在做对照试验，看哪种方法防砂效果最佳。\n\n防砂固然要紧，但这沙漠公路看起来就没有那么酷了。本来我以为两侧是一望无尽的沙漠丘陵，你给我上面种些花里胡哨的植物，我总觉得破坏了其中的艺术气息。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/DC5C4B3D-A795-4672-8D13-62191E7E19A4_1_105_c.jpeg)\n\n为了看看沙漠的真面目，我们找了几个地方停了车。翻过丘陵之后，却发现之后的沙漠也没想象中的那么广阔壮观。靠北，多半是之前看到的沙漠宣传照都被调了色！PS害人呐！真正的沙漠就这？\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/2C124614-02BC-4703-B640-F48C0FA77690_1_105_c.jpeg)\n\n不过沙漠最终还是没让我们失望，行车不久后，我们便看到小哥口中的“大漠孤烟直”了。一开始我还不确定那是什么，以为前面失火了，寻思着大沙漠里难不成有人的车自燃了，谁知道靠近了一看，竟然是道通天高的龙卷风。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-5124d97939f8.gif)\n\n我不知道你们有没有见过龙卷风，反正我是从来没见过。我只是小时候在百科全书上见过，之后就是各种灾难片。没想到在这大沙漠中竟然能看到龙卷风的真身。令人咋舌的是沙漠中远远不止这一阵龙卷风，随着我们深入，龙卷风变得随处可见！\n\n不过之前看新闻的时候我记得美国曾发生过一次龙卷风把人卷到空中的事件。这里的龙卷风威力并没有那么大。我不太清楚它们是如何形成的，但是有些小龙卷风在踏上这条公路之后便快速消失了。车从这些龙卷风中穿过并不会遭到太大的阻碍。不过有一次我企图开车窗拍张风哥近照，风哥突然加快了步伐，冲过来就喂了我一嘴沙。想到这我都觉得嘴里有点异样。\n\n在我们快到和田之前，司机一个拐弯拐进了沙漠里，原来有座热瓦克古佛寺藏在这沙漠之中。在这小道中我们一路颠簸，到了一个只有游客中心的地方。这游客中心可算是空无一人，门口与写着全国重点文物保护单位，却只有个大爷坐在门口阴凉处打瞌睡。我们上去前往交流，却发现这看管景点的大爷并不会汉语。司机小哥用几句蹩脚的维语问大爷入口是不是在这，大爷好像点了点头。我们也不管，就这么进去了。看来新疆的文物保护着实还是需要加大力度。\n\n这座古佛寺据说建于南北朝时期，还是被一个英国探险家发现的。谈到这就难受，过去大家对文物都不怎么当回事，不知道被别人拐了多少家产走。说起来作为一个历史麻瓜，我当时一瞬间脑子卡壳，这怎么在伊斯兰的地盘会有佛寺？原来新疆以前一度是佛国地区，要不是被伊斯兰国攻打，可能他们现在跟我们一样信教主要信佛教呢！不得不说，对付宗教还得靠宗教。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/D780C6BF-A6BC-409E-9C50-4CD2DBDA824E_1_105_c.jpeg)\n\n下午到了和田之后我们一行人稍作休息，晚上跑到和田夜市恰了一顿饭。不得不说，现在回来看和田夜市的照片，真的，卫生环境不知道比武汉海鲜市场高到哪里去了（武汉海鲜市场的视频在YouTube上满天飞，很多老外说什么中国人还不如病毒，能吃得下这肮脏海鲜市场里东西的家伙根本不能算人。当然了，说出这种话的人根本不能算人，但是我们总得反省下吧，尼玛的2020年了菜市场还这样呢？）亏得你们还是生活条件不错的内地人！这里有几样菜比较有意思，牛羊肉就不必说了（新疆的羊肉串!=其他地方的羊肉串，新疆羊肉独一档，内蒙古羊肉在新疆羊肉面前就是乐色），酸奶（是什么奶我忘了）冰淇淋和烤蛋都挺好吃。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-8e0a5126f1fc.gif)\n\n<!--split-->\n\n第二天一早起来，我们就去参观了一个植物园一样的地方。那里种植了树龄有足足1300年的核桃树，占地上百平米的无花果王，还有些葫芦，葡萄，西瓜之类的水果。估计是休息时间实在太长，有一位葫芦先生屁股都坐扁了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/0BF6261B-93FE-477F-9C22-20F137C19894_1_105_c.jpeg)\n\n这位是无花果王，怎么说呢，你看到的围起来的地方都是这株无花果的领地……\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/CA8A3D8B-E44A-4686-87D6-CA0405A5327F_1_105_c.jpeg)\n\n这天的中饭非常有意思，我们跑到了墨玉县去吃当地的特色菜。一个叫西瓜烧肉，一个叫肚烧肉。所谓西瓜烧肉，就是用西瓜当锅，然后将乳鸽和羊肉放在其中炖汤，炖出来的汤带有西瓜汁的味道，怪好喝的，不过西瓜炖得都发黑了，属实不太好看。肚烧肉也是一个意思，用猪肚还不知道是牛肚烤羊肉。不过我总觉得那羊肉没烤透，便没怎么吃。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/232B41AE-DE56-4DDD-83BE-6C46146710A2_1_201_a.jpeg)\n\n吃完饭之后我们直接开车前往喀什。喀什据说是以前东突分子们的首都，假如搞什么独立，好像喀什会成为他们东突首府，具体是个什么情况我不清楚，反正独立我是不赞成的。\n\n在这去喀什的路上还有一段小插曲，就是我们想要上高速的时候，被警察拦住了。警察告诉我们说这段路不能走了，路那边好像有什么领导要过来，只能换小路走。我纳闷呢，咋能有人这么威风直接拦高速自己走。\n\n不过当时那段高速也没彻底修好，路上还有不少施工的人和车，要是有什么交通厅的领导来视察之类的，也是可以理解。警察说你们往边上绕吧，绕也能去喀什的。于是我们两辆车就从侧边的一条小路走去。\n\n结果走着走着发现这路在GPS上没了，大概是地图信息有段时间没更新了，或者是这路本来就没在地图上过。但我们隐隐约约看到不远处有一个上高速的入口，不由得欣喜若狂，一脚油门就继续在这砂石小径上继续走了，一同跟来的商务车便也踩着油门往前冲。我们是山地SUV，这都是小case，噌噌噌就过去了，跑回到了高速路上。\n\n其实我是不赞成回到这高速的，因为两边不是有交警拦着么，虽然我们这条小路上没人拦，但总觉得开上来好像不是很合法。交警叫我们绕道，应该是绕道走普通道路，不是绕道上高速啊。果不其然，开到一半就出事了，不久后我们看到一辆逆向的军车朝我们打着双闪冲过来了。我们立刻将车靠边停了，也没做什么后续动作。军车也没有理会我们，呼啸着从我们身旁开过去了。\n\n“这军车是开道的，后面应该有什么车队。”司机小哥说。\n\n不一时果真有车队到来。这是由几辆军车护航的大巴车队，我们依稀能见到这些大巴车上有隔开司机的铁栅栏。一共四十多量大巴，一路开过，根本没有人来打理我们一下，估计以为我们是来修高速的工人。随着最后一辆护卫车驶过，我们发动了引擎。\n\n“是监狱的车吧，要不就是……”\n\n我们也没有多想，继续往前开，突然想起我们后面那辆车来。这我们上了高速也有一阵了，虽然这高速还在修路况有些问题，但这商务车也不至于那么慢吧？十分应景的是电话这时候就响了，原来是后面的人来求助来了。\n\n“我们的商务车卡沙子里了！你们找根绳子来帮我们拉出来。”\n\n我们真的满头问号，我们这都开出来40分钟了快到叶城了，你们咋才告诉我们你们陷沙子里了啊？而且我们车上也没绳子啊。我们一边告诉他们我们会尽力去找，另一方面叫他们去找墨玉县的人帮帮忙。于是我们开车就去找路边的修路老伯。司机小哥掏了包烟带上钱就过去了，问维族老伯有绳子没有。\n\n老伯不会汉语，但总算听明白了我们的意思。他摆了摆手表示不要烟和钱，而且跟我们说没有绳子，但是会带我们去找绳子，说完就开了十分钟车带我们去他的小屋拿了根绳子。我们不停地谢谢，然后便往回走了。\n\n谁知开到一半，另外一头又打电话告诉我们不必来了。说是遇到了几个开车的维族小伙子，看到需要帮忙，直接热心肠帮忙给他们把车给揪出来了。\n\n大家都不由得感叹维族人的热心善良，这要是汉族人指不定要收你多少钱。最后我们把绳子还给老伯，老伯还是什么都不肯收。\n\n说道这里就不得不再提一句维族人的善良真诚了，真的，一路遇到的维族人无一不是热心善良的，小孩子也是天真可爱，看到你过来会睁大眼睛不停地摆手打招呼，跟内地印象中的新疆人完全不相符。按队里小哥的话说，外面都是善良的人，可能是因为但凡你有一点不善良的动机，你已经被拉去再教育了。从这点来看，我觉得大部分的维族人都太可怜了。假如说Trump说Chinese virus是歧视，那我们因为一次暴恐事件把所有维族人都严加管理，这又算是什么呢？（我没说Trump说Chinese virus是正确的行为）\n\n喀什玩的地方很多，有古城，艾提尕尔清真寺，大巴扎等等。你到了喀什会有种来到了中东的错觉，这里的很多建筑就跟中东战争电影里的一模一样。喀什古城就是其中一种跟中东风哥相仿的建筑区，这个建筑群建在一个大概两三层楼高的一个高台上，据说只有过去的权贵（天龙人）才能住在这里。你想象下我们中原的城墙，他们就住在那个高度上。那当真应该是意气奋发，抬头向窗外一看，嗨你们这些屁民，只能住在地面上。当然现在住的已经都是些朴实无华的人，你走过路过路边摊或者民宿的时候，还会有不少维族小姐姐来打招呼，~~哎哟小哥进来玩呀，完全免费哦💕~~。可别信了她们的邪，进去参观是免费的，可你跟她们互动来扭捏去过会说不定一会就挂不下面子疯狂消费了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/B8B5E8B5-C134-49A8-B3D8-759E5A930B20_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/6FCB8EA6-767C-4286-BA48-02F5368186E6_1_105_c.jpeg)\n\n同样，这里的维族人也很友好。我们跟维族阿姨说买馕的钱不用找了的时候，感觉她把一年的快乐都笑出来了。路边还有带着孩子让他给我们打招呼的可爱小姐姐，善良的人们呐祝你们一生幸福。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/21F3F998-E734-4E8B-9D39-2D2C63BADD67_1_105_c.jpeg)\n\n接着我们去了那个亚洲最大的清真寺艾提尕尔清真寺和大巴扎。这儿的大巴扎不得不说还是比乌鲁木齐的有趣多了，东西多而广，衣食住行应有尽有。我们买了一堆坚果葡萄干之类的产品直接寄回家了，然后在市场里面闲逛。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7F926F8D-6CED-478E-B45A-4ECA78AD3CE2_1_105_c.jpeg)\n\n期间一个老伯先是问我们要不要买帽子（戴起来像皇军的那种），我们谢绝了之后，他突然压低声音问我们要不要狼牙。这倒是引起了我们的兴趣，我们跟着他走进屋里看了看，但也不能确定是不是真的狼牙，便还是走了出来。狼是保护动物，你猎杀不得，但是假如它攻击你的话，那你就可以反击。老A说了个故事，说他在西藏海拔五千多米的地方驾车时遇到过狼群，怎么甩也甩不掉，头狼深蓝色的眼睛就透过车窗死死地盯着自己。他当时差点就想去撞死那狼，但最后还是作罢。“狼真的有灵性，带着狼牙可以辟邪。这400块钱的狼牙，假如是真的肯定值，但是我看起来不像是真的。”他这么说。\n\n中午我们吃了一顿饭，天啊现在想起来我还馋得不行，那架烤羊肉！那大盘鸡！那羊肉抓饭！那蜂蜜藏红花！简直就是极致美味。什么烤全羊都是弟中弟，当你吃过那架子上金黄色肥而不腻的架烤羊肉，你就不知道其他羊肉还算不算羊肉了！\n\n羊肉手抓饭也是当之无愧的新疆必吃美味，在新疆这辽阔的地方当你开了八小时的车累得快死了，你想到下一顿是羊肉手抓饭，你就能继续开下去，说不定你还能再开八小时。\n\n饭桌上老C说阿尔泰的羊肉就是最好的羊肉，我们吃的就是阿尔泰羊肉。阿尔泰羊肉最好，其次才是伊犁的羊肉。别的地方小羊养到15kg才开涮，伊犁他们12kg就开始了。RIP小羊，我是爱（吃）你们的。\n\n<!--split-->\n\n吃完饭后我们也没歇着，直接向阿图什天门开去。据说这座天门被发现还是因为有飞行员在此地飞行，看到山中间竟有一个大洞，这才发现的。这个景点较新，并没有很多人去过，我们决定过去探探险。\n\n一路上都是一望无际的戈壁滩，在行车的过程中尤为壮观。可用手机一拍，好像又不是那么一回事了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/42708B60-13F2-466F-9E85-A656CE9CFAF6_1_105_c.jpeg)\n\n来到天门我们几人买了门票，就徒步向里走去。这个景点在丰水期间好像会关门，而我们徒步进入的地方也似是一条河道。刚踏入这个景区我们便被壮观的风化山石镇住了。随行的小D还时不时的看看岩壁，按他的话说，搞不好这些岩壁上有化石。“以前这些地方都是沉在水里的，这里有化石丝毫不奇怪，我以前就捡到过化石。”他这么说。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3D89B5ED-62C5-45D4-A685-36A65594A525_1_105_c.jpeg)\n\n山间大风严重，有一座山直接被经年累月的风凿除了一个巨洞，宛如被一记重拳打中。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3D115670-CBA0-4D0C-B2C9-1C5787DB8D66_1_105_c.jpeg)\n\n走到后段，队内的中老年选手已经不太行了，少说走了有几公里路了。不过眼前出现了天门的光点，让大家都有了希望。所有人都顺着溪石向上攀登，不一时有了台阶，离山顶还有几百级。然而在到山顶之前，你都不会知道结局有多波澜壮阔！\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/8B758FEB-ED8D-4A45-BC67-9D80658F6A41_1_105_c.jpeg)\n\n这是一扇高达百米的门！我们在山下只能看见门的上半部分，殊不知其后还有深不见底的裂谷。远方的那座高山在烈日下被染成金色，队里一阵“我操”声。\n\n“消耗了我一年的运动量，真没算白来！”老A瞪大了眼，半天才“我操”出来。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E3F7C8EE-EE71-40C3-A411-2E0932B007CB_1_105_c.jpeg)\n\n这时候再看看我们之前上来的路……GG，上山容易下山难，怕是又要忙活好久一阵了……\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/C15F7849-E970-477E-B4C0-184B784F14F4_1_105_c.jpeg)\n\n下山之后的戈壁滩（这是我的微信profile图，假如你有看到过），新疆这地方，随手一拍都是美景啊\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/AB51348C-E5D9-4EA5-BDF4-4A56F1F1AB7F_1_105_c.jpeg)\n\n倒数第二日我们走G314国道前往了塔县。塔县的全名是塔什库尔干塔吉克自治县，在帕米尔高原之上。喀什库尔干意思就是石头城，里面还有石头城遗迹，同时这里还有中国唯一的白人种族，塔吉克族。据老D所说，塔吉克族虽然是白人，但是异常爱国，他们很多人从小的梦想就是成为军人守护边疆。\n\n前往塔县之路是一条边境之路。你想去塔县，你得有边防证才能走这条边境之路。在这里就能看出中国基建狂魔之名号不是浪得虚名，有几个路段，在巨山之中，几十米高的桥就这么突兀地架过去了。这条路还尤为惊险，左右都能看到不少的山体滑坡，想来泥石流在这也不是什么怪事，毕竟山顶都是积雪。还有些路段被积水淹没了。\n\n在新疆的荒野中开车，突然遇到堵车，那是很正常的事情。之前我们在独库公路上就因为前方路面坍塌而不得不绕道，这次我们也好几次遇到了施工队，等待他们解决问题。好笑的是有时候路边会有巴扎，然后堵车的时候有的维族人就跑巴扎里去了，出来的时候抱着一只羊。羊还超级乖，可可爱爱地坐他怀里一动不动，我们都笑晕了。\n\n我们在这危险路段开了一段时间，海拔也是越开越高，车上大家逐渐困顿，一个个睡去。一段时间后终于拨开云雾，来到一片巨大的湖泊前。此湖名为白沙湖，如你所见，湖边的山全是由白沙构成的。湖呈现不真实的碧蓝色。我不知道怎么形容它，我只能说在这海拔3300+米的地方看到它，unreal。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/9FFFC562-FF06-4E01-B63B-C6BF05980592_1_105_c.jpeg)\n\n首先声明下这图里俩人一车不是我们的人和车……然后我也不知道为什么这张的湖水颜色不一样。不过说实话两张照片中湖水的颜色都跟真实颜色有一定差距，真实的颜色更接近淡淡的青色。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7CD71221-68BC-4F4C-8F73-522D0F5D0E8D_1_105_c.jpeg)\n\n在这里我们喝了几碗羊汤就上路了。假如你爱干净的话可能你不会很喜欢这里，因为这里只有旱厕。但是羊汤很便宜，十块钱一碗，在这3300+的海拔上，属实不能算贵了。\n\n慕士塔格峰在就在白沙湖的边上，海拔有7500+，极其壮观。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/840FCE17-6E74-45B8-B504-EA4FE6AE0385_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3B0484FD-E6AB-4D2C-9067-01728C23CEA9_1_105_c.jpeg)\n\n之后还有个葱岭圣湖。然而大家都刚刚看过白沙湖，直接贤者模式了，这葱岭圣湖便没怎么看直接路过了\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/C611EDD8-116D-488D-90F7-9A522D1362DC_1_105_c.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/7A0389B7-3B0B-487F-AFFB-0362D2A1E762_1_105_c.jpeg)\n\n到了塔县后我们休息了一晚，吃了吃高原牦牛火锅，去了趟高原湿地公园（我们那天大雾，拍照片拍不清楚。但是远方的山都被雾所阻隔了，我当时以为湿地大到离谱，第二天才发现四野是有山的）\n\n第二日我们就去了红其拉甫口岸，这是我们此行去的最后一个地方。这是跟巴基斯坦交接的口岸，海拔有5000米之高，人没缺氧，车缺氧了，燃油有些烧不动，动力变弱了。上面还得过个哨所，得有通行证才能过。边防兵脾气也不好，可能直接上来骂娘，得小心点，毕竟人身上带着枪呢。上去之后还特别冷，老C老D裹着棉被冲出去拍照，给爷逗笑了。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/040807D0-7DC7-4806-811D-3DCED01F7815_1_201_a.jpeg)\n\n去了口岸之后，我们回到塔县吃了一顿冷水鱼。塔县并不是个吃冷水鱼的好地方，老板也做得不怎么样，导致这顿冷水鱼吃着感觉还不如吃鲫鱼。晚上我们便回了喀什，飞回了家。\n\n下次若还有机会，我倒是很想走走新藏公路，见识见识昆仑的魅力。","slug":"南疆游记","published":1,"updated":"2020-03-29T06:59:20.716Z","photos":[],"link":"","_id":"ck8ct7j5w0012gtvifhvta6ua","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>照片都是手机直出的，没有任何调色等修改</strong></p>\n<p>在19年的南疆之旅之前，我已去过新疆，不过前往的都是北疆景点，未曾踏足天山以南的土地。上次游玩之后，同行的人发来邀请，问是否明年想改换航线，前往南疆旅行一次。</p>\n<p>在北疆旅游的时候，但凡见到当地的汉人，他们都会说：北边都是汉化的地儿，兵团驻扎，你们要想感受感受风土人情，那还是得去南疆看看。想起夏尔西里的景色和烤羊的诱惑，假如南疆比这北疆还能更好玩，那便绝对值得一去。我们想也没想就答应了。</p>\n<p>所谓南疆北疆，是按天山划分的。这天山几乎横切了整个新疆，按我爸的话说，“抬头看到高山，得嘞，那就是天山”。我们虽然计划去南疆，但因为有朋友在北疆等我们，于是还是降落在了乌鲁木齐。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/ED5408C8-72EC-4110-953E-6FF33F88229C_1_105_c.jpeg\"  alt=\"\"></p>\n<p>乌鲁木齐这座城市汉化很严重，管理也很严格。在我18年来的时候，全国各地都在用4G了，而且都整上好几年了，到了乌鲁木齐一打开手机，诶嘿，还是3G网（周边城市有4G，就乌鲁木齐没有），速度慢得跟没有一样，妻管严的兄弟来这里玩估计随随便便就漏掉好多老婆的微信，回家的时候只能当光棍了。当时据说是只有申请才能用上4G（我们同行的人中有当地人能上），我们这些外来物种那就只能乖乖3G了。</p>\n<p>严格管理当然不只是网络管理，有一位部队里的兄弟在吃饭的时候直接吹牛，说在新疆11点后你四人大声打牌都要给你逮起来，新疆现在就是全国最安全的地方。</p>\n<p>18年的环境，他说这句话，我举双手赞成。我们当时就是在乌鲁木齐坐个车，一路上但凡到了十字路口就会有一个关卡，有的关卡甚至会有水泥铸的碉堡（和谐一点，叫保安亭好了）。大伙可都拿的是真枪实弹，哪有人能在这环境下整活？你到了十字路口，警察叔叔就过来了，让你把窗户摇下来——他一瞥，哟，是个汉人，走走走吧，没你事了，该干嘛干嘛去。但假如你是个维族人，兄弟，请你出示一下你的身份证！</p>\n<p>也亏得我们是汉人，这维族人简直就是寸步难行。其实我们汉人也一样，没了身份证你哪都跑不了，到处都有可能要检查身份证，加油站这种门口摆着巨大战时路障的更不用说了，你还得过安检。只是你被查到的概率远远低于维族人而已。你被查一次，他们大概已经被查20次了。</p>\n<p>在这样的环境下，大巴扎在18年的时候，关门关得特别早。大巴扎在维语中就是大集市的意思。出事以前，大巴扎半夜三更都特别热闹，当然今非昔比了。</p>\n<p>我19年再去的时候，环境改善了不少。不仅有4G了，大巴扎竟然开到晚上了。于是我们就进去恰了一顿夜宵。虽然游客不少，但是其中维族人比例属实不低。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/6BDA8F68-B75E-4DD3-847E-95088A5BBF21_1_105_c.jpeg\"  alt=\"\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/282348A7-709B-415E-9735-18820A7EAE54_1_105_c.jpeg\"  alt=\"\"></p>\n<p>你问我在大巴扎中印象最深的是什么？害，我会告诉你我吃夜宵的时候，<del>在我前面的维族志愿者小姐姐好看到爆表我完全忘不掉吗？</del> 不，是啤酒！人头大的啤酒你喝过吗！<del>很难喝</del></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/D329EC50-6258-4D2A-8A1F-790E0F54CA0E_1_105_c.jpeg\"  alt=\"\"></p>\n<p>隔天我们就直接飞向了阿克苏。阿克苏这名字是不是很耳熟？是不是脑子里蹦出来一个红苹果？</p>\n<p>因为坐飞机到阿克苏已经花了一早上，我们在阿克苏我们就去了一个景点：刀郎部落。且不说这个景点疯狂蹭刀郎（没错就是2002年第一场雪的刀郎）热度，这个景点本身做工低劣极其弟弟……他们企图把这个村包装成一个人文景观，但是实际上只有自然景观还算凑合，坐马车跑跑路还算惬意。那几个部落里跳舞的小兄弟看起来无精打采的，小姐姐也莫得只剩大姐姐了，建议别去浪费钱了</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/4DCEDA5E-01F8-47C4-A07C-F64D6651A90E_1_105_c.jpeg\"  alt=\"\"></p>\n<p>次日终于来到了本次旅途重头戏之一——沙漠公路。话说我自上次北疆之旅就对沙漠公路念念不忘，没办法，听起来实在是太酷了。但是上次时间有些不足，多半时间都花在独库公路上了。这次终于能见识到什么叫做沙漠公路了。</p>\n<p>说起来我也未曾去大沙漠中好好玩一圈，此前去过的也顶多就是陕甘宁那片区的小沙漠，它们跟塔克拉玛干比起来自然是不值一提。</p>\n<p>我们行过的路段是阿克苏到和田的部分。去之前司机小哥对沙漠公路是一顿胡夸海吹，跟我说到了沙漠之中，你就能感受到大漠孤烟直，长河落日圆的气氛！公路在沙漠中笔直穿过看不到边际，两边是一望无际的旷野……</p>\n<p>因为他这几句话，我刚上路的时候是满怀期待的。但是为了保护这条沙漠公路，公路两旁都有防护带，或是摆成方格状的干草，或是生存力顽强的草皮。其中有一个片区还种植了各式植物，据司机小哥说，这里是在做对照试验，看哪种方法防砂效果最佳。</p>\n<p>防砂固然要紧，但这沙漠公路看起来就没有那么酷了。本来我以为两侧是一望无尽的沙漠丘陵，你给我上面种些花里胡哨的植物，我总觉得破坏了其中的艺术气息。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/DC5C4B3D-A795-4672-8D13-62191E7E19A4_1_105_c.jpeg\"  alt=\"\"></p>\n<p>为了看看沙漠的真面目，我们找了几个地方停了车。翻过丘陵之后，却发现之后的沙漠也没想象中的那么广阔壮观。靠北，多半是之前看到的沙漠宣传照都被调了色！PS害人呐！真正的沙漠就这？</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/2C124614-02BC-4703-B640-F48C0FA77690_1_105_c.jpeg\"  alt=\"\"></p>\n<p>不过沙漠最终还是没让我们失望，行车不久后，我们便看到小哥口中的“大漠孤烟直”了。一开始我还不确定那是什么，以为前面失火了，寻思着大沙漠里难不成有人的车自燃了，谁知道靠近了一看，竟然是道通天高的龙卷风。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-5124d97939f8.gif\"  alt=\"\"></p>\n<p>我不知道你们有没有见过龙卷风，反正我是从来没见过。我只是小时候在百科全书上见过，之后就是各种灾难片。没想到在这大沙漠中竟然能看到龙卷风的真身。令人咋舌的是沙漠中远远不止这一阵龙卷风，随着我们深入，龙卷风变得随处可见！</p>\n<p>不过之前看新闻的时候我记得美国曾发生过一次龙卷风把人卷到空中的事件。这里的龙卷风威力并没有那么大。我不太清楚它们是如何形成的，但是有些小龙卷风在踏上这条公路之后便快速消失了。车从这些龙卷风中穿过并不会遭到太大的阻碍。不过有一次我企图开车窗拍张风哥近照，风哥突然加快了步伐，冲过来就喂了我一嘴沙。想到这我都觉得嘴里有点异样。</p>\n<p>在我们快到和田之前，司机一个拐弯拐进了沙漠里，原来有座热瓦克古佛寺藏在这沙漠之中。在这小道中我们一路颠簸，到了一个只有游客中心的地方。这游客中心可算是空无一人，门口与写着全国重点文物保护单位，却只有个大爷坐在门口阴凉处打瞌睡。我们上去前往交流，却发现这看管景点的大爷并不会汉语。司机小哥用几句蹩脚的维语问大爷入口是不是在这，大爷好像点了点头。我们也不管，就这么进去了。看来新疆的文物保护着实还是需要加大力度。</p>\n<p>这座古佛寺据说建于南北朝时期，还是被一个英国探险家发现的。谈到这就难受，过去大家对文物都不怎么当回事，不知道被别人拐了多少家产走。说起来作为一个历史麻瓜，我当时一瞬间脑子卡壳，这怎么在伊斯兰的地盘会有佛寺？原来新疆以前一度是佛国地区，要不是被伊斯兰国攻打，可能他们现在跟我们一样信教主要信佛教呢！不得不说，对付宗教还得靠宗教。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/D780C6BF-A6BC-409E-9C50-4CD2DBDA824E_1_105_c.jpeg\"  alt=\"\"></p>\n<p>下午到了和田之后我们一行人稍作休息，晚上跑到和田夜市恰了一顿饭。不得不说，现在回来看和田夜市的照片，真的，卫生环境不知道比武汉海鲜市场高到哪里去了（武汉海鲜市场的视频在YouTube上满天飞，很多老外说什么中国人还不如病毒，能吃得下这肮脏海鲜市场里东西的家伙根本不能算人。当然了，说出这种话的人根本不能算人，但是我们总得反省下吧，尼玛的2020年了菜市场还这样呢？）亏得你们还是生活条件不错的内地人！这里有几样菜比较有意思，牛羊肉就不必说了（新疆的羊肉串!=其他地方的羊肉串，新疆羊肉独一档，内蒙古羊肉在新疆羊肉面前就是乐色），酸奶（是什么奶我忘了）冰淇淋和烤蛋都挺好吃。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-8e0a5126f1fc.gif\"  alt=\"\"></p>\n<!--split-->\n\n<p>第二天一早起来，我们就去参观了一个植物园一样的地方。那里种植了树龄有足足1300年的核桃树，占地上百平米的无花果王，还有些葫芦，葡萄，西瓜之类的水果。估计是休息时间实在太长，有一位葫芦先生屁股都坐扁了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/0BF6261B-93FE-477F-9C22-20F137C19894_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这位是无花果王，怎么说呢，你看到的围起来的地方都是这株无花果的领地……</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/CA8A3D8B-E44A-4686-87D6-CA0405A5327F_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这天的中饭非常有意思，我们跑到了墨玉县去吃当地的特色菜。一个叫西瓜烧肉，一个叫肚烧肉。所谓西瓜烧肉，就是用西瓜当锅，然后将乳鸽和羊肉放在其中炖汤，炖出来的汤带有西瓜汁的味道，怪好喝的，不过西瓜炖得都发黑了，属实不太好看。肚烧肉也是一个意思，用猪肚还不知道是牛肚烤羊肉。不过我总觉得那羊肉没烤透，便没怎么吃。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/232B41AE-DE56-4DDD-83BE-6C46146710A2_1_201_a.jpeg\"  alt=\"\"></p>\n<p>吃完饭之后我们直接开车前往喀什。喀什据说是以前东突分子们的首都，假如搞什么独立，好像喀什会成为他们东突首府，具体是个什么情况我不清楚，反正独立我是不赞成的。</p>\n<p>在这去喀什的路上还有一段小插曲，就是我们想要上高速的时候，被警察拦住了。警察告诉我们说这段路不能走了，路那边好像有什么领导要过来，只能换小路走。我纳闷呢，咋能有人这么威风直接拦高速自己走。</p>\n<p>不过当时那段高速也没彻底修好，路上还有不少施工的人和车，要是有什么交通厅的领导来视察之类的，也是可以理解。警察说你们往边上绕吧，绕也能去喀什的。于是我们两辆车就从侧边的一条小路走去。</p>\n<p>结果走着走着发现这路在GPS上没了，大概是地图信息有段时间没更新了，或者是这路本来就没在地图上过。但我们隐隐约约看到不远处有一个上高速的入口，不由得欣喜若狂，一脚油门就继续在这砂石小径上继续走了，一同跟来的商务车便也踩着油门往前冲。我们是山地SUV，这都是小case，噌噌噌就过去了，跑回到了高速路上。</p>\n<p>其实我是不赞成回到这高速的，因为两边不是有交警拦着么，虽然我们这条小路上没人拦，但总觉得开上来好像不是很合法。交警叫我们绕道，应该是绕道走普通道路，不是绕道上高速啊。果不其然，开到一半就出事了，不久后我们看到一辆逆向的军车朝我们打着双闪冲过来了。我们立刻将车靠边停了，也没做什么后续动作。军车也没有理会我们，呼啸着从我们身旁开过去了。</p>\n<p>“这军车是开道的，后面应该有什么车队。”司机小哥说。</p>\n<p>不一时果真有车队到来。这是由几辆军车护航的大巴车队，我们依稀能见到这些大巴车上有隔开司机的铁栅栏。一共四十多量大巴，一路开过，根本没有人来打理我们一下，估计以为我们是来修高速的工人。随着最后一辆护卫车驶过，我们发动了引擎。</p>\n<p>“是监狱的车吧，要不就是……”</p>\n<p>我们也没有多想，继续往前开，突然想起我们后面那辆车来。这我们上了高速也有一阵了，虽然这高速还在修路况有些问题，但这商务车也不至于那么慢吧？十分应景的是电话这时候就响了，原来是后面的人来求助来了。</p>\n<p>“我们的商务车卡沙子里了！你们找根绳子来帮我们拉出来。”</p>\n<p>我们真的满头问号，我们这都开出来40分钟了快到叶城了，你们咋才告诉我们你们陷沙子里了啊？而且我们车上也没绳子啊。我们一边告诉他们我们会尽力去找，另一方面叫他们去找墨玉县的人帮帮忙。于是我们开车就去找路边的修路老伯。司机小哥掏了包烟带上钱就过去了，问维族老伯有绳子没有。</p>\n<p>老伯不会汉语，但总算听明白了我们的意思。他摆了摆手表示不要烟和钱，而且跟我们说没有绳子，但是会带我们去找绳子，说完就开了十分钟车带我们去他的小屋拿了根绳子。我们不停地谢谢，然后便往回走了。</p>\n<p>谁知开到一半，另外一头又打电话告诉我们不必来了。说是遇到了几个开车的维族小伙子，看到需要帮忙，直接热心肠帮忙给他们把车给揪出来了。</p>\n<p>大家都不由得感叹维族人的热心善良，这要是汉族人指不定要收你多少钱。最后我们把绳子还给老伯，老伯还是什么都不肯收。</p>\n<p>说道这里就不得不再提一句维族人的善良真诚了，真的，一路遇到的维族人无一不是热心善良的，小孩子也是天真可爱，看到你过来会睁大眼睛不停地摆手打招呼，跟内地印象中的新疆人完全不相符。按队里小哥的话说，外面都是善良的人，可能是因为但凡你有一点不善良的动机，你已经被拉去再教育了。从这点来看，我觉得大部分的维族人都太可怜了。假如说Trump说Chinese virus是歧视，那我们因为一次暴恐事件把所有维族人都严加管理，这又算是什么呢？（我没说Trump说Chinese virus是正确的行为）</p>\n<p>喀什玩的地方很多，有古城，艾提尕尔清真寺，大巴扎等等。你到了喀什会有种来到了中东的错觉，这里的很多建筑就跟中东战争电影里的一模一样。喀什古城就是其中一种跟中东风哥相仿的建筑区，这个建筑群建在一个大概两三层楼高的一个高台上，据说只有过去的权贵（天龙人）才能住在这里。你想象下我们中原的城墙，他们就住在那个高度上。那当真应该是意气奋发，抬头向窗外一看，嗨你们这些屁民，只能住在地面上。当然现在住的已经都是些朴实无华的人，你走过路过路边摊或者民宿的时候，还会有不少维族小姐姐来打招呼，<del>哎哟小哥进来玩呀，完全免费哦💕</del>。可别信了她们的邪，进去参观是免费的，可你跟她们互动来扭捏去过会说不定一会就挂不下面子疯狂消费了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/B8B5E8B5-C134-49A8-B3D8-759E5A930B20_1_105_c.jpeg\"  alt=\"\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/6FCB8EA6-767C-4286-BA48-02F5368186E6_1_105_c.jpeg\"  alt=\"\"></p>\n<p>同样，这里的维族人也很友好。我们跟维族阿姨说买馕的钱不用找了的时候，感觉她把一年的快乐都笑出来了。路边还有带着孩子让他给我们打招呼的可爱小姐姐，善良的人们呐祝你们一生幸福。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/21F3F998-E734-4E8B-9D39-2D2C63BADD67_1_105_c.jpeg\"  alt=\"\"></p>\n<p>接着我们去了那个亚洲最大的清真寺艾提尕尔清真寺和大巴扎。这儿的大巴扎不得不说还是比乌鲁木齐的有趣多了，东西多而广，衣食住行应有尽有。我们买了一堆坚果葡萄干之类的产品直接寄回家了，然后在市场里面闲逛。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/7F926F8D-6CED-478E-B45A-4ECA78AD3CE2_1_105_c.jpeg\"  alt=\"\"></p>\n<p>期间一个老伯先是问我们要不要买帽子（戴起来像皇军的那种），我们谢绝了之后，他突然压低声音问我们要不要狼牙。这倒是引起了我们的兴趣，我们跟着他走进屋里看了看，但也不能确定是不是真的狼牙，便还是走了出来。狼是保护动物，你猎杀不得，但是假如它攻击你的话，那你就可以反击。老A说了个故事，说他在西藏海拔五千多米的地方驾车时遇到过狼群，怎么甩也甩不掉，头狼深蓝色的眼睛就透过车窗死死地盯着自己。他当时差点就想去撞死那狼，但最后还是作罢。“狼真的有灵性，带着狼牙可以辟邪。这400块钱的狼牙，假如是真的肯定值，但是我看起来不像是真的。”他这么说。</p>\n<p>中午我们吃了一顿饭，天啊现在想起来我还馋得不行，那架烤羊肉！那大盘鸡！那羊肉抓饭！那蜂蜜藏红花！简直就是极致美味。什么烤全羊都是弟中弟，当你吃过那架子上金黄色肥而不腻的架烤羊肉，你就不知道其他羊肉还算不算羊肉了！</p>\n<p>羊肉手抓饭也是当之无愧的新疆必吃美味，在新疆这辽阔的地方当你开了八小时的车累得快死了，你想到下一顿是羊肉手抓饭，你就能继续开下去，说不定你还能再开八小时。</p>\n<p>饭桌上老C说阿尔泰的羊肉就是最好的羊肉，我们吃的就是阿尔泰羊肉。阿尔泰羊肉最好，其次才是伊犁的羊肉。别的地方小羊养到15kg才开涮，伊犁他们12kg就开始了。RIP小羊，我是爱（吃）你们的。</p>\n<!--split-->\n\n<p>吃完饭后我们也没歇着，直接向阿图什天门开去。据说这座天门被发现还是因为有飞行员在此地飞行，看到山中间竟有一个大洞，这才发现的。这个景点较新，并没有很多人去过，我们决定过去探探险。</p>\n<p>一路上都是一望无际的戈壁滩，在行车的过程中尤为壮观。可用手机一拍，好像又不是那么一回事了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/42708B60-13F2-466F-9E85-A656CE9CFAF6_1_105_c.jpeg\"  alt=\"\"></p>\n<p>来到天门我们几人买了门票，就徒步向里走去。这个景点在丰水期间好像会关门，而我们徒步进入的地方也似是一条河道。刚踏入这个景区我们便被壮观的风化山石镇住了。随行的小D还时不时的看看岩壁，按他的话说，搞不好这些岩壁上有化石。“以前这些地方都是沉在水里的，这里有化石丝毫不奇怪，我以前就捡到过化石。”他这么说。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/3D89B5ED-62C5-45D4-A685-36A65594A525_1_105_c.jpeg\"  alt=\"\"></p>\n<p>山间大风严重，有一座山直接被经年累月的风凿除了一个巨洞，宛如被一记重拳打中。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/3D115670-CBA0-4D0C-B2C9-1C5787DB8D66_1_105_c.jpeg\"  alt=\"\"></p>\n<p>走到后段，队内的中老年选手已经不太行了，少说走了有几公里路了。不过眼前出现了天门的光点，让大家都有了希望。所有人都顺着溪石向上攀登，不一时有了台阶，离山顶还有几百级。然而在到山顶之前，你都不会知道结局有多波澜壮阔！</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/8B758FEB-ED8D-4A45-BC67-9D80658F6A41_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这是一扇高达百米的门！我们在山下只能看见门的上半部分，殊不知其后还有深不见底的裂谷。远方的那座高山在烈日下被染成金色，队里一阵“我操”声。</p>\n<p>“消耗了我一年的运动量，真没算白来！”老A瞪大了眼，半天才“我操”出来。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/E3F7C8EE-EE71-40C3-A411-2E0932B007CB_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这时候再看看我们之前上来的路……GG，上山容易下山难，怕是又要忙活好久一阵了……</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/C15F7849-E970-477E-B4C0-184B784F14F4_1_105_c.jpeg\"  alt=\"\"></p>\n<p>下山之后的戈壁滩（这是我的微信profile图，假如你有看到过），新疆这地方，随手一拍都是美景啊</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/AB51348C-E5D9-4EA5-BDF4-4A56F1F1AB7F_1_105_c.jpeg\"  alt=\"\"></p>\n<p>倒数第二日我们走G314国道前往了塔县。塔县的全名是塔什库尔干塔吉克自治县，在帕米尔高原之上。喀什库尔干意思就是石头城，里面还有石头城遗迹，同时这里还有中国唯一的白人种族，塔吉克族。据老D所说，塔吉克族虽然是白人，但是异常爱国，他们很多人从小的梦想就是成为军人守护边疆。</p>\n<p>前往塔县之路是一条边境之路。你想去塔县，你得有边防证才能走这条边境之路。在这里就能看出中国基建狂魔之名号不是浪得虚名，有几个路段，在巨山之中，几十米高的桥就这么突兀地架过去了。这条路还尤为惊险，左右都能看到不少的山体滑坡，想来泥石流在这也不是什么怪事，毕竟山顶都是积雪。还有些路段被积水淹没了。</p>\n<p>在新疆的荒野中开车，突然遇到堵车，那是很正常的事情。之前我们在独库公路上就因为前方路面坍塌而不得不绕道，这次我们也好几次遇到了施工队，等待他们解决问题。好笑的是有时候路边会有巴扎，然后堵车的时候有的维族人就跑巴扎里去了，出来的时候抱着一只羊。羊还超级乖，可可爱爱地坐他怀里一动不动，我们都笑晕了。</p>\n<p>我们在这危险路段开了一段时间，海拔也是越开越高，车上大家逐渐困顿，一个个睡去。一段时间后终于拨开云雾，来到一片巨大的湖泊前。此湖名为白沙湖，如你所见，湖边的山全是由白沙构成的。湖呈现不真实的碧蓝色。我不知道怎么形容它，我只能说在这海拔3300+米的地方看到它，unreal。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/9FFFC562-FF06-4E01-B63B-C6BF05980592_1_105_c.jpeg\"  alt=\"\"></p>\n<p>首先声明下这图里俩人一车不是我们的人和车……然后我也不知道为什么这张的湖水颜色不一样。不过说实话两张照片中湖水的颜色都跟真实颜色有一定差距，真实的颜色更接近淡淡的青色。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/7CD71221-68BC-4F4C-8F73-522D0F5D0E8D_1_105_c.jpeg\"  alt=\"\"></p>\n<p>在这里我们喝了几碗羊汤就上路了。假如你爱干净的话可能你不会很喜欢这里，因为这里只有旱厕。但是羊汤很便宜，十块钱一碗，在这3300+的海拔上，属实不能算贵了。</p>\n<p>慕士塔格峰在就在白沙湖的边上，海拔有7500+，极其壮观。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/840FCE17-6E74-45B8-B504-EA4FE6AE0385_1_105_c.jpeg\"  alt=\"\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/3B0484FD-E6AB-4D2C-9067-01728C23CEA9_1_105_c.jpeg\"  alt=\"\"></p>\n<p>之后还有个葱岭圣湖。然而大家都刚刚看过白沙湖，直接贤者模式了，这葱岭圣湖便没怎么看直接路过了</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/C611EDD8-116D-488D-90F7-9A522D1362DC_1_105_c.jpeg\"  alt=\"\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/7A0389B7-3B0B-487F-AFFB-0362D2A1E762_1_105_c.jpeg\"  alt=\"\"></p>\n<p>到了塔县后我们休息了一晚，吃了吃高原牦牛火锅，去了趟高原湿地公园（我们那天大雾，拍照片拍不清楚。但是远方的山都被雾所阻隔了，我当时以为湿地大到离谱，第二天才发现四野是有山的）</p>\n<p>第二日我们就去了红其拉甫口岸，这是我们此行去的最后一个地方。这是跟巴基斯坦交接的口岸，海拔有5000米之高，人没缺氧，车缺氧了，燃油有些烧不动，动力变弱了。上面还得过个哨所，得有通行证才能过。边防兵脾气也不好，可能直接上来骂娘，得小心点，毕竟人身上带着枪呢。上去之后还特别冷，老C老D裹着棉被冲出去拍照，给爷逗笑了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/040807D0-7DC7-4806-811D-3DCED01F7815_1_201_a.jpeg\"  alt=\"\"></p>\n<p>去了口岸之后，我们回到塔县吃了一顿冷水鱼。塔县并不是个吃冷水鱼的好地方，老板也做得不怎么样，导致这顿冷水鱼吃着感觉还不如吃鲫鱼。晚上我们便回了喀什，飞回了家。</p>\n<p>下次若还有机会，我倒是很想走走新藏公路，见识见识昆仑的魅力。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p><strong>照片都是手机直出的，没有任何调色等修改</strong></p>\n<p>在19年的南疆之旅之前，我已去过新疆，不过前往的都是北疆景点，未曾踏足天山以南的土地。上次游玩之后，同行的人发来邀请，问是否明年想改换航线，前往南疆旅行一次。</p>\n<p>在北疆旅游的时候，但凡见到当地的汉人，他们都会说：北边都是汉化的地儿，兵团驻扎，你们要想感受感受风土人情，那还是得去南疆看看。想起夏尔西里的景色和烤羊的诱惑，假如南疆比这北疆还能更好玩，那便绝对值得一去。我们想也没想就答应了。</p>\n<p>所谓南疆北疆，是按天山划分的。这天山几乎横切了整个新疆，按我爸的话说，“抬头看到高山，得嘞，那就是天山”。我们虽然计划去南疆，但因为有朋友在北疆等我们，于是还是降落在了乌鲁木齐。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/ED5408C8-72EC-4110-953E-6FF33F88229C_1_105_c.jpeg\" alt=\"\"></p>\n<p>乌鲁木齐这座城市汉化很严重，管理也很严格。在我18年来的时候，全国各地都在用4G了，而且都整上好几年了，到了乌鲁木齐一打开手机，诶嘿，还是3G网（周边城市有4G，就乌鲁木齐没有），速度慢得跟没有一样，妻管严的兄弟来这里玩估计随随便便就漏掉好多老婆的微信，回家的时候只能当光棍了。当时据说是只有申请才能用上4G（我们同行的人中有当地人能上），我们这些外来物种那就只能乖乖3G了。</p>\n<p>严格管理当然不只是网络管理，有一位部队里的兄弟在吃饭的时候直接吹牛，说在新疆11点后你四人大声打牌都要给你逮起来，新疆现在就是全国最安全的地方。</p>\n<p>18年的环境，他说这句话，我举双手赞成。我们当时就是在乌鲁木齐坐个车，一路上但凡到了十字路口就会有一个关卡，有的关卡甚至会有水泥铸的碉堡（和谐一点，叫保安亭好了）。大伙可都拿的是真枪实弹，哪有人能在这环境下整活？你到了十字路口，警察叔叔就过来了，让你把窗户摇下来——他一瞥，哟，是个汉人，走走走吧，没你事了，该干嘛干嘛去。但假如你是个维族人，兄弟，请你出示一下你的身份证！</p>\n<p>也亏得我们是汉人，这维族人简直就是寸步难行。其实我们汉人也一样，没了身份证你哪都跑不了，到处都有可能要检查身份证，加油站这种门口摆着巨大战时路障的更不用说了，你还得过安检。只是你被查到的概率远远低于维族人而已。你被查一次，他们大概已经被查20次了。</p>\n<p>在这样的环境下，大巴扎在18年的时候，关门关得特别早。大巴扎在维语中就是大集市的意思。出事以前，大巴扎半夜三更都特别热闹，当然今非昔比了。</p>\n<p>我19年再去的时候，环境改善了不少。不仅有4G了，大巴扎竟然开到晚上了。于是我们就进去恰了一顿夜宵。虽然游客不少，但是其中维族人比例属实不低。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/6BDA8F68-B75E-4DD3-847E-95088A5BBF21_1_105_c.jpeg\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/282348A7-709B-415E-9735-18820A7EAE54_1_105_c.jpeg\" alt=\"\"></p>\n<p>你问我在大巴扎中印象最深的是什么？害，我会告诉你我吃夜宵的时候，<del>在我前面的维族志愿者小姐姐好看到爆表我完全忘不掉吗？</del> 不，是啤酒！人头大的啤酒你喝过吗！<del>很难喝</del></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/D329EC50-6258-4D2A-8A1F-790E0F54CA0E_1_105_c.jpeg\" alt=\"\"></p>\n<p>隔天我们就直接飞向了阿克苏。阿克苏这名字是不是很耳熟？是不是脑子里蹦出来一个红苹果？</p>\n<p>因为坐飞机到阿克苏已经花了一早上，我们在阿克苏我们就去了一个景点：刀郎部落。且不说这个景点疯狂蹭刀郎（没错就是2002年第一场雪的刀郎）热度，这个景点本身做工低劣极其弟弟……他们企图把这个村包装成一个人文景观，但是实际上只有自然景观还算凑合，坐马车跑跑路还算惬意。那几个部落里跳舞的小兄弟看起来无精打采的，小姐姐也莫得只剩大姐姐了，建议别去浪费钱了</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/4DCEDA5E-01F8-47C4-A07C-F64D6651A90E_1_105_c.jpeg\" alt=\"\"></p>\n<p>次日终于来到了本次旅途重头戏之一——沙漠公路。话说我自上次北疆之旅就对沙漠公路念念不忘，没办法，听起来实在是太酷了。但是上次时间有些不足，多半时间都花在独库公路上了。这次终于能见识到什么叫做沙漠公路了。</p>\n<p>说起来我也未曾去大沙漠中好好玩一圈，此前去过的也顶多就是陕甘宁那片区的小沙漠，它们跟塔克拉玛干比起来自然是不值一提。</p>\n<p>我们行过的路段是阿克苏到和田的部分。去之前司机小哥对沙漠公路是一顿胡夸海吹，跟我说到了沙漠之中，你就能感受到大漠孤烟直，长河落日圆的气氛！公路在沙漠中笔直穿过看不到边际，两边是一望无际的旷野……</p>\n<p>因为他这几句话，我刚上路的时候是满怀期待的。但是为了保护这条沙漠公路，公路两旁都有防护带，或是摆成方格状的干草，或是生存力顽强的草皮。其中有一个片区还种植了各式植物，据司机小哥说，这里是在做对照试验，看哪种方法防砂效果最佳。</p>\n<p>防砂固然要紧，但这沙漠公路看起来就没有那么酷了。本来我以为两侧是一望无尽的沙漠丘陵，你给我上面种些花里胡哨的植物，我总觉得破坏了其中的艺术气息。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/DC5C4B3D-A795-4672-8D13-62191E7E19A4_1_105_c.jpeg\" alt=\"\"></p>\n<p>为了看看沙漠的真面目，我们找了几个地方停了车。翻过丘陵之后，却发现之后的沙漠也没想象中的那么广阔壮观。靠北，多半是之前看到的沙漠宣传照都被调了色！PS害人呐！真正的沙漠就这？</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/2C124614-02BC-4703-B640-F48C0FA77690_1_105_c.jpeg\" alt=\"\"></p>\n<p>不过沙漠最终还是没让我们失望，行车不久后，我们便看到小哥口中的“大漠孤烟直”了。一开始我还不确定那是什么，以为前面失火了，寻思着大沙漠里难不成有人的车自燃了，谁知道靠近了一看，竟然是道通天高的龙卷风。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-5124d97939f8.gif\" alt=\"\"></p>\n<p>我不知道你们有没有见过龙卷风，反正我是从来没见过。我只是小时候在百科全书上见过，之后就是各种灾难片。没想到在这大沙漠中竟然能看到龙卷风的真身。令人咋舌的是沙漠中远远不止这一阵龙卷风，随着我们深入，龙卷风变得随处可见！</p>\n<p>不过之前看新闻的时候我记得美国曾发生过一次龙卷风把人卷到空中的事件。这里的龙卷风威力并没有那么大。我不太清楚它们是如何形成的，但是有些小龙卷风在踏上这条公路之后便快速消失了。车从这些龙卷风中穿过并不会遭到太大的阻碍。不过有一次我企图开车窗拍张风哥近照，风哥突然加快了步伐，冲过来就喂了我一嘴沙。想到这我都觉得嘴里有点异样。</p>\n<p>在我们快到和田之前，司机一个拐弯拐进了沙漠里，原来有座热瓦克古佛寺藏在这沙漠之中。在这小道中我们一路颠簸，到了一个只有游客中心的地方。这游客中心可算是空无一人，门口与写着全国重点文物保护单位，却只有个大爷坐在门口阴凉处打瞌睡。我们上去前往交流，却发现这看管景点的大爷并不会汉语。司机小哥用几句蹩脚的维语问大爷入口是不是在这，大爷好像点了点头。我们也不管，就这么进去了。看来新疆的文物保护着实还是需要加大力度。</p>\n<p>这座古佛寺据说建于南北朝时期，还是被一个英国探险家发现的。谈到这就难受，过去大家对文物都不怎么当回事，不知道被别人拐了多少家产走。说起来作为一个历史麻瓜，我当时一瞬间脑子卡壳，这怎么在伊斯兰的地盘会有佛寺？原来新疆以前一度是佛国地区，要不是被伊斯兰国攻打，可能他们现在跟我们一样信教主要信佛教呢！不得不说，对付宗教还得靠宗教。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/D780C6BF-A6BC-409E-9C50-4CD2DBDA824E_1_105_c.jpeg\" alt=\"\"></p>\n<p>下午到了和田之后我们一行人稍作休息，晚上跑到和田夜市恰了一顿饭。不得不说，现在回来看和田夜市的照片，真的，卫生环境不知道比武汉海鲜市场高到哪里去了（武汉海鲜市场的视频在YouTube上满天飞，很多老外说什么中国人还不如病毒，能吃得下这肮脏海鲜市场里东西的家伙根本不能算人。当然了，说出这种话的人根本不能算人，但是我们总得反省下吧，尼玛的2020年了菜市场还这样呢？）亏得你们还是生活条件不错的内地人！这里有几样菜比较有意思，牛羊肉就不必说了（新疆的羊肉串!=其他地方的羊肉串，新疆羊肉独一档，内蒙古羊肉在新疆羊肉面前就是乐色），酸奶（是什么奶我忘了）冰淇淋和烤蛋都挺好吃。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/ezgif-7-8e0a5126f1fc.gif\" alt=\"\"></p>\n<!--split-->\n\n<p>第二天一早起来，我们就去参观了一个植物园一样的地方。那里种植了树龄有足足1300年的核桃树，占地上百平米的无花果王，还有些葫芦，葡萄，西瓜之类的水果。估计是休息时间实在太长，有一位葫芦先生屁股都坐扁了。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/0BF6261B-93FE-477F-9C22-20F137C19894_1_105_c.jpeg\" alt=\"\"></p>\n<p>这位是无花果王，怎么说呢，你看到的围起来的地方都是这株无花果的领地……</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/CA8A3D8B-E44A-4686-87D6-CA0405A5327F_1_105_c.jpeg\" alt=\"\"></p>\n<p>这天的中饭非常有意思，我们跑到了墨玉县去吃当地的特色菜。一个叫西瓜烧肉，一个叫肚烧肉。所谓西瓜烧肉，就是用西瓜当锅，然后将乳鸽和羊肉放在其中炖汤，炖出来的汤带有西瓜汁的味道，怪好喝的，不过西瓜炖得都发黑了，属实不太好看。肚烧肉也是一个意思，用猪肚还不知道是牛肚烤羊肉。不过我总觉得那羊肉没烤透，便没怎么吃。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/232B41AE-DE56-4DDD-83BE-6C46146710A2_1_201_a.jpeg\" alt=\"\"></p>\n<p>吃完饭之后我们直接开车前往喀什。喀什据说是以前东突分子们的首都，假如搞什么独立，好像喀什会成为他们东突首府，具体是个什么情况我不清楚，反正独立我是不赞成的。</p>\n<p>在这去喀什的路上还有一段小插曲，就是我们想要上高速的时候，被警察拦住了。警察告诉我们说这段路不能走了，路那边好像有什么领导要过来，只能换小路走。我纳闷呢，咋能有人这么威风直接拦高速自己走。</p>\n<p>不过当时那段高速也没彻底修好，路上还有不少施工的人和车，要是有什么交通厅的领导来视察之类的，也是可以理解。警察说你们往边上绕吧，绕也能去喀什的。于是我们两辆车就从侧边的一条小路走去。</p>\n<p>结果走着走着发现这路在GPS上没了，大概是地图信息有段时间没更新了，或者是这路本来就没在地图上过。但我们隐隐约约看到不远处有一个上高速的入口，不由得欣喜若狂，一脚油门就继续在这砂石小径上继续走了，一同跟来的商务车便也踩着油门往前冲。我们是山地SUV，这都是小case，噌噌噌就过去了，跑回到了高速路上。</p>\n<p>其实我是不赞成回到这高速的，因为两边不是有交警拦着么，虽然我们这条小路上没人拦，但总觉得开上来好像不是很合法。交警叫我们绕道，应该是绕道走普通道路，不是绕道上高速啊。果不其然，开到一半就出事了，不久后我们看到一辆逆向的军车朝我们打着双闪冲过来了。我们立刻将车靠边停了，也没做什么后续动作。军车也没有理会我们，呼啸着从我们身旁开过去了。</p>\n<p>“这军车是开道的，后面应该有什么车队。”司机小哥说。</p>\n<p>不一时果真有车队到来。这是由几辆军车护航的大巴车队，我们依稀能见到这些大巴车上有隔开司机的铁栅栏。一共四十多量大巴，一路开过，根本没有人来打理我们一下，估计以为我们是来修高速的工人。随着最后一辆护卫车驶过，我们发动了引擎。</p>\n<p>“是监狱的车吧，要不就是……”</p>\n<p>我们也没有多想，继续往前开，突然想起我们后面那辆车来。这我们上了高速也有一阵了，虽然这高速还在修路况有些问题，但这商务车也不至于那么慢吧？十分应景的是电话这时候就响了，原来是后面的人来求助来了。</p>\n<p>“我们的商务车卡沙子里了！你们找根绳子来帮我们拉出来。”</p>\n<p>我们真的满头问号，我们这都开出来40分钟了快到叶城了，你们咋才告诉我们你们陷沙子里了啊？而且我们车上也没绳子啊。我们一边告诉他们我们会尽力去找，另一方面叫他们去找墨玉县的人帮帮忙。于是我们开车就去找路边的修路老伯。司机小哥掏了包烟带上钱就过去了，问维族老伯有绳子没有。</p>\n<p>老伯不会汉语，但总算听明白了我们的意思。他摆了摆手表示不要烟和钱，而且跟我们说没有绳子，但是会带我们去找绳子，说完就开了十分钟车带我们去他的小屋拿了根绳子。我们不停地谢谢，然后便往回走了。</p>\n<p>谁知开到一半，另外一头又打电话告诉我们不必来了。说是遇到了几个开车的维族小伙子，看到需要帮忙，直接热心肠帮忙给他们把车给揪出来了。</p>\n<p>大家都不由得感叹维族人的热心善良，这要是汉族人指不定要收你多少钱。最后我们把绳子还给老伯，老伯还是什么都不肯收。</p>\n<p>说道这里就不得不再提一句维族人的善良真诚了，真的，一路遇到的维族人无一不是热心善良的，小孩子也是天真可爱，看到你过来会睁大眼睛不停地摆手打招呼，跟内地印象中的新疆人完全不相符。按队里小哥的话说，外面都是善良的人，可能是因为但凡你有一点不善良的动机，你已经被拉去再教育了。从这点来看，我觉得大部分的维族人都太可怜了。假如说Trump说Chinese virus是歧视，那我们因为一次暴恐事件把所有维族人都严加管理，这又算是什么呢？（我没说Trump说Chinese virus是正确的行为）</p>\n<p>喀什玩的地方很多，有古城，艾提尕尔清真寺，大巴扎等等。你到了喀什会有种来到了中东的错觉，这里的很多建筑就跟中东战争电影里的一模一样。喀什古城就是其中一种跟中东风哥相仿的建筑区，这个建筑群建在一个大概两三层楼高的一个高台上，据说只有过去的权贵（天龙人）才能住在这里。你想象下我们中原的城墙，他们就住在那个高度上。那当真应该是意气奋发，抬头向窗外一看，嗨你们这些屁民，只能住在地面上。当然现在住的已经都是些朴实无华的人，你走过路过路边摊或者民宿的时候，还会有不少维族小姐姐来打招呼，<del>哎哟小哥进来玩呀，完全免费哦💕</del>。可别信了她们的邪，进去参观是免费的，可你跟她们互动来扭捏去过会说不定一会就挂不下面子疯狂消费了。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/B8B5E8B5-C134-49A8-B3D8-759E5A930B20_1_105_c.jpeg\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/6FCB8EA6-767C-4286-BA48-02F5368186E6_1_105_c.jpeg\" alt=\"\"></p>\n<p>同样，这里的维族人也很友好。我们跟维族阿姨说买馕的钱不用找了的时候，感觉她把一年的快乐都笑出来了。路边还有带着孩子让他给我们打招呼的可爱小姐姐，善良的人们呐祝你们一生幸福。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/21F3F998-E734-4E8B-9D39-2D2C63BADD67_1_105_c.jpeg\" alt=\"\"></p>\n<p>接着我们去了那个亚洲最大的清真寺艾提尕尔清真寺和大巴扎。这儿的大巴扎不得不说还是比乌鲁木齐的有趣多了，东西多而广，衣食住行应有尽有。我们买了一堆坚果葡萄干之类的产品直接寄回家了，然后在市场里面闲逛。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/7F926F8D-6CED-478E-B45A-4ECA78AD3CE2_1_105_c.jpeg\" alt=\"\"></p>\n<p>期间一个老伯先是问我们要不要买帽子（戴起来像皇军的那种），我们谢绝了之后，他突然压低声音问我们要不要狼牙。这倒是引起了我们的兴趣，我们跟着他走进屋里看了看，但也不能确定是不是真的狼牙，便还是走了出来。狼是保护动物，你猎杀不得，但是假如它攻击你的话，那你就可以反击。老A说了个故事，说他在西藏海拔五千多米的地方驾车时遇到过狼群，怎么甩也甩不掉，头狼深蓝色的眼睛就透过车窗死死地盯着自己。他当时差点就想去撞死那狼，但最后还是作罢。“狼真的有灵性，带着狼牙可以辟邪。这400块钱的狼牙，假如是真的肯定值，但是我看起来不像是真的。”他这么说。</p>\n<p>中午我们吃了一顿饭，天啊现在想起来我还馋得不行，那架烤羊肉！那大盘鸡！那羊肉抓饭！那蜂蜜藏红花！简直就是极致美味。什么烤全羊都是弟中弟，当你吃过那架子上金黄色肥而不腻的架烤羊肉，你就不知道其他羊肉还算不算羊肉了！</p>\n<p>羊肉手抓饭也是当之无愧的新疆必吃美味，在新疆这辽阔的地方当你开了八小时的车累得快死了，你想到下一顿是羊肉手抓饭，你就能继续开下去，说不定你还能再开八小时。</p>\n<p>饭桌上老C说阿尔泰的羊肉就是最好的羊肉，我们吃的就是阿尔泰羊肉。阿尔泰羊肉最好，其次才是伊犁的羊肉。别的地方小羊养到15kg才开涮，伊犁他们12kg就开始了。RIP小羊，我是爱（吃）你们的。</p>\n<!--split-->\n\n<p>吃完饭后我们也没歇着，直接向阿图什天门开去。据说这座天门被发现还是因为有飞行员在此地飞行，看到山中间竟有一个大洞，这才发现的。这个景点较新，并没有很多人去过，我们决定过去探探险。</p>\n<p>一路上都是一望无际的戈壁滩，在行车的过程中尤为壮观。可用手机一拍，好像又不是那么一回事了。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/42708B60-13F2-466F-9E85-A656CE9CFAF6_1_105_c.jpeg\" alt=\"\"></p>\n<p>来到天门我们几人买了门票，就徒步向里走去。这个景点在丰水期间好像会关门，而我们徒步进入的地方也似是一条河道。刚踏入这个景区我们便被壮观的风化山石镇住了。随行的小D还时不时的看看岩壁，按他的话说，搞不好这些岩壁上有化石。“以前这些地方都是沉在水里的，这里有化石丝毫不奇怪，我以前就捡到过化石。”他这么说。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/3D89B5ED-62C5-45D4-A685-36A65594A525_1_105_c.jpeg\" alt=\"\"></p>\n<p>山间大风严重，有一座山直接被经年累月的风凿除了一个巨洞，宛如被一记重拳打中。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/3D115670-CBA0-4D0C-B2C9-1C5787DB8D66_1_105_c.jpeg\" alt=\"\"></p>\n<p>走到后段，队内的中老年选手已经不太行了，少说走了有几公里路了。不过眼前出现了天门的光点，让大家都有了希望。所有人都顺着溪石向上攀登，不一时有了台阶，离山顶还有几百级。然而在到山顶之前，你都不会知道结局有多波澜壮阔！</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/8B758FEB-ED8D-4A45-BC67-9D80658F6A41_1_105_c.jpeg\" alt=\"\"></p>\n<p>这是一扇高达百米的门！我们在山下只能看见门的上半部分，殊不知其后还有深不见底的裂谷。远方的那座高山在烈日下被染成金色，队里一阵“我操”声。</p>\n<p>“消耗了我一年的运动量，真没算白来！”老A瞪大了眼，半天才“我操”出来。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/E3F7C8EE-EE71-40C3-A411-2E0932B007CB_1_105_c.jpeg\" alt=\"\"></p>\n<p>这时候再看看我们之前上来的路……GG，上山容易下山难，怕是又要忙活好久一阵了……</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/C15F7849-E970-477E-B4C0-184B784F14F4_1_105_c.jpeg\" alt=\"\"></p>\n<p>下山之后的戈壁滩（这是我的微信profile图，假如你有看到过），新疆这地方，随手一拍都是美景啊</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/AB51348C-E5D9-4EA5-BDF4-4A56F1F1AB7F_1_105_c.jpeg\" alt=\"\"></p>\n<p>倒数第二日我们走G314国道前往了塔县。塔县的全名是塔什库尔干塔吉克自治县，在帕米尔高原之上。喀什库尔干意思就是石头城，里面还有石头城遗迹，同时这里还有中国唯一的白人种族，塔吉克族。据老D所说，塔吉克族虽然是白人，但是异常爱国，他们很多人从小的梦想就是成为军人守护边疆。</p>\n<p>前往塔县之路是一条边境之路。你想去塔县，你得有边防证才能走这条边境之路。在这里就能看出中国基建狂魔之名号不是浪得虚名，有几个路段，在巨山之中，几十米高的桥就这么突兀地架过去了。这条路还尤为惊险，左右都能看到不少的山体滑坡，想来泥石流在这也不是什么怪事，毕竟山顶都是积雪。还有些路段被积水淹没了。</p>\n<p>在新疆的荒野中开车，突然遇到堵车，那是很正常的事情。之前我们在独库公路上就因为前方路面坍塌而不得不绕道，这次我们也好几次遇到了施工队，等待他们解决问题。好笑的是有时候路边会有巴扎，然后堵车的时候有的维族人就跑巴扎里去了，出来的时候抱着一只羊。羊还超级乖，可可爱爱地坐他怀里一动不动，我们都笑晕了。</p>\n<p>我们在这危险路段开了一段时间，海拔也是越开越高，车上大家逐渐困顿，一个个睡去。一段时间后终于拨开云雾，来到一片巨大的湖泊前。此湖名为白沙湖，如你所见，湖边的山全是由白沙构成的。湖呈现不真实的碧蓝色。我不知道怎么形容它，我只能说在这海拔3300+米的地方看到它，unreal。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/9FFFC562-FF06-4E01-B63B-C6BF05980592_1_105_c.jpeg\" alt=\"\"></p>\n<p>首先声明下这图里俩人一车不是我们的人和车……然后我也不知道为什么这张的湖水颜色不一样。不过说实话两张照片中湖水的颜色都跟真实颜色有一定差距，真实的颜色更接近淡淡的青色。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/7CD71221-68BC-4F4C-8F73-522D0F5D0E8D_1_105_c.jpeg\" alt=\"\"></p>\n<p>在这里我们喝了几碗羊汤就上路了。假如你爱干净的话可能你不会很喜欢这里，因为这里只有旱厕。但是羊汤很便宜，十块钱一碗，在这3300+的海拔上，属实不能算贵了。</p>\n<p>慕士塔格峰在就在白沙湖的边上，海拔有7500+，极其壮观。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/840FCE17-6E74-45B8-B504-EA4FE6AE0385_1_105_c.jpeg\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/3B0484FD-E6AB-4D2C-9067-01728C23CEA9_1_105_c.jpeg\" alt=\"\"></p>\n<p>之后还有个葱岭圣湖。然而大家都刚刚看过白沙湖，直接贤者模式了，这葱岭圣湖便没怎么看直接路过了</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/C611EDD8-116D-488D-90F7-9A522D1362DC_1_105_c.jpeg\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/7A0389B7-3B0B-487F-AFFB-0362D2A1E762_1_105_c.jpeg\" alt=\"\"></p>\n<p>到了塔县后我们休息了一晚，吃了吃高原牦牛火锅，去了趟高原湿地公园（我们那天大雾，拍照片拍不清楚。但是远方的山都被雾所阻隔了，我当时以为湿地大到离谱，第二天才发现四野是有山的）</p>\n<p>第二日我们就去了红其拉甫口岸，这是我们此行去的最后一个地方。这是跟巴基斯坦交接的口岸，海拔有5000米之高，人没缺氧，车缺氧了，燃油有些烧不动，动力变弱了。上面还得过个哨所，得有通行证才能过。边防兵脾气也不好，可能直接上来骂娘，得小心点，毕竟人身上带着枪呢。上去之后还特别冷，老C老D裹着棉被冲出去拍照，给爷逗笑了。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/040807D0-7DC7-4806-811D-3DCED01F7815_1_201_a.jpeg\" alt=\"\"></p>\n<p>去了口岸之后，我们回到塔县吃了一顿冷水鱼。塔县并不是个吃冷水鱼的好地方，老板也做得不怎么样，导致这顿冷水鱼吃着感觉还不如吃鲫鱼。晚上我们便回了喀什，飞回了家。</p>\n<p>下次若还有机会，我倒是很想走走新藏公路，见识见识昆仑的魅力。</p>\n"},{"layout":"post","title":"自学Node.JS笔记","date":"2020-03-22T05:56:00.000Z","description":"前后端兼备的语言","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200321225737.png","optimized_image":null,"author":"tty","hide":true,"_content":"\n因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。\n\n","source":"_posts/2020-03-21-自学Node.JS笔记.md","raw":"---\nlayout: post\ntitle:  自学Node.JS笔记\ndate:   2020-03-21 22:56:00\ndescription: 前后端兼备的语言\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200321225737.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\n  - javascript\n  - node\nauthor: tty\nhide: true\n---\n\n因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。\n\n","slug":"自学Node.JS笔记","published":1,"updated":"2020-03-29T06:59:20.716Z","photos":[],"link":"","_id":"ck8ct7j5x0016gtviexk25cro","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p>\n"},{"layout":"post","title":"Git基础简明教程","date":"2020-03-23T06:15:00.000Z","description":"简单复习Git相关内容","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200322231621.png","optimized_image":null,"author":"tty","_content":"\n部分来源：[颜海镜](https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/)\n\n## 简介\n\n1. 版本控制工具是什么\n\n   软件，用来保存软件开发过程中各个版本\n\n2. 为什么要用版本控制工具\n\n   1. 有利于打造自己的核心竞争力，积累经验保存项目\n   2. 能够提供以往版本记录，方便恢复数据\n   3. 分清责任不背锅\n   4. 科学合理的规划工作\n   5. 进行项目精度和进度的把控\n\n3. SVN 和 git 成为了主流\n\n   1. SVN的优缺点\n\n      优点：\n\n      1. 管理方便，逻辑明确，符合一般人思维逻辑\n      2. 集中式管理，保证代码一致性\n\n      缺点：\n\n      1. 给服务器压力较大\n      2. 如果不能连接到服务器则基本不能工作\n      3. 不太适合人数较多的开源开发\n\n   2. Git的优缺点\n\n      优点：\n\n      1. 适合多人分布式的开发\n      2. 适合灵活快速的开发\n      3. 给服务器压力小，强调个体\n      4. 可进行离线工作\n      5. 非常容易解决冲突\n\n      缺点：\n\n      1. 学习周期比较长\n      2. 不太符合常规的思维\n      3. 代码的保密性比较差，每人都有一份代码和历史改动\n\n   3. 如何选择？\n\n      看应用场景，进行综合比较：\n\n      - 对权限要求比较高，则进行集中式管理，使用SVN\n      - 对代码写作要求比较高，则使用Git\n\n## Git常用概念\n\n### 仓库（书店）\n\n所有版本的代码都在仓库里\n\n### 分支（书架）\n\n不同功能代码存放的地方（可能是测试代码）\n\n### 提交（书）\n\n每一个版本的代码\n\n### 三区\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323001246.png)\n\n1. 工作区\n\n   工作的目录\n\n2. 暂存区\n\n   项目目录和仓库之间的暂时存储区域 桥梁\n\n3. 仓库区\n\n   存放着所有的版本\n\n4. 远程仓库\n\n   github上的仓库\n\n## Git的基础操作\n\n1. 新建一个文件夹作为repo目录\n\n2. 在目录中使用命令\n\n   ```bash\n   git init\n   ```\n\n   初始化Git目录\n\n3. 创建一个文件，如：helloworld.html\n\n4. 查看文件状态\n\n   ```bash\n   git status\n   ```\n\n   这时候应该会查看到有一个文件被修改，并且被标记为untracked file\n\n5. 加入文件\n\n   第一种方法：\n\n   ```bash\n   git add hellworld.html\n   git status\n   ```\n\n   之后状态应该已经不同，会发现文件已经被放入暂存区\n\n   第二种方法：\n\n   ```bash\n   git add .\n   ```\n\n   表示暂存所有文件\n\n6. 将暂存区文件提交到仓库\n\n   ```bash\n   git commit -m '你的注释'\n   ```\n\n7. 假如你在期间再次更改了文件，则需要重复步骤5和6\n\n   ```bash\n   git log\n   ```\n\n   可以查看版本\n\n8. 假如想回滚到之前的版本，则copy之前的版本id，id可在git log中查到\n\n   ```bash\n   tty@MacBook-Pro % git log\n   commit 926f60662797c96ccc3eeb4d99ec09d6d5db3547 (HEAD -> master, origin/master)\n   Date:   Sun Mar 22 16:25:10 2020 -0700\n   \n       Update 2020-02-03-Bloomberg面试见闻.md\n       \n   commit c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de\n   Date:   Sun Mar 22 16:15:48 2020 -0700\n   \n       update paginate\n   ```\n\n   此时如果想回滚到上一次记录，则使用上此的commit id， 如下\n\n   ```bash\n   git checkout c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de\n   ```\n\n   假如你不想指定具体的某一次记录，而是想单纯的回到上一次的记录，则有更方便的选择\n\n   ```bash\n   git checkout -- .\n   ```\n\n## 分支\n\n当你在开发测试内容，或是新功能时，可能你就需要一个分支，以避免影响master branch的稳定性\n\n分支的概念在各个版本控制系统中早已存在，分支对于团队协作开发来说作用是非常大的，如：\n\n- 当一个项目还是1.0版时，开发团队可能要同时进行1.1版和2.0版的开发，此时，代码就会出现较大分歧，这时就需要用到分支了，不同的任务组在各自不同的分支上开发，互相之间不会影响。\n\n- 需要向项目中添加一个新功能，一般的团队都不会直接在主分支上修改而是新建一个branch，在上面更改代码，这样做的好处一是保证主线代码的完整性和可用性，也就是说，主线上都是稳定的代码，可以直接拿来发布。二是避免出现其他问题。\n\n- 发布是所有的功能模块的集成，分支可能是零散功能的半成品。\n\n- 万一出现冲突很严重，或者出现各种情况而造成当前的分支出了问题，冲突解决起来很麻烦，如果有一个分支始终保留着最新的稳定版本,最多就是吧当前分支删掉,从那个稳定分支重新分一支出来,这样处理起来更方便。\n\n- 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的风险，又或者丢失向领导汇报工作进度的风险。有了分支后，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n### 分支特性\n\n- Git的技术可以说是非常强大，说一切开发都依赖于分支一点都不过分。一般项目的master分支都是稳定的代码，可以直接发布或者被项目之外的人使用。\n\n- 新特性和BUG修改都在不同的分支上进行开发和测试，这样规范了整个软件的开发流程。\n\n分支之间的互不影响这种特性可以增加团队合作的效率。\n\n- Git分支的另外一个重要特性就是可以合并不同软件仓库（fork）的分支。如：开发团队有一个主软件仓库，开发者可以fork这个仓库，相当于克隆了一个私有的软件仓库，然后开发者就可以在自己的软件仓库中建立分支并开发测试，测试完毕之后，可以向主软件仓库提交merge request，这样新开发的特性就会被合并到主软件仓库的某个分支中。这种特性极大地推动了开源项目，多年前参加开源项目都是神话，自从Git出现后，每个人都可能成为开源项目的贡献者，就是基于这种特性。\n\n- 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，让人无法忍受，结果分支功能成了摆设，基本都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n### 创建与合并分支\n\n在版本回退里中已经知道每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。\n如果没有创建过任何分支的情况下，Git中只有一个分支，叫主分支（即master分支）。\n\n当我们创建新的分支，例如test时，Git新建了一个指针叫test，指向master相同的提交，再把HEAD指向test，就表示当前分支在test上。\n\n注：Git创建一个分支很快，因为除了增加一个test指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n假如我们在test上的工作完成了，就可以把test合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向test的当前提交，就完成了合并。\n\n注：Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，也可以删除test分支。删除test分支就是把test指针给删掉，删掉后，就剩下了一条master分支了。\n\n### 操作命令\n\n**创建并切换分支 （git checkout -b test ）**\n\n```bash\n$ git checkout -b test\n\nSwitched to a new branch ‘test’\n```\n\n注：git checkout命令加上-b参数表示创建并切换，相当于执行了以下两条命令：\n\n```bash\n$ git branch test\n$ git checkout test\n\nSwitched to branch ‘test’\n```\n\n**查看当前分支** （ git branch ）\n然后，用git branch命令查看当前分支：\n\n```bash\n$ git branch\n\n*test\nmaster\n```\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。此时，我们就可以在test分支上进行开发并正常提交。\n\n**分支的切换 （git checkout master ）**\n\n如果在test分支上完成了开发，我们可以切换回master分支:\n\n```bash\n$ git checkout master\n\nSwitched to branch ‘master’\n```\n\n注：当切换回master分支后，其实内容是不会有任何改变的，因为你所做的修改和提交工作全部在test分支上完成，而master分支的提交点是没有任何改变的。\n\n**分支合并 （git merge test）**\n\n我们试着把test分支下的工作成果合并到master主分支上：\n\n```bash\n$ git merge test\nUpdating d17efd8..fec145a\nFast-forward\n……. | 1 +\n…. file changed, 1 insertion(+)\n```\n\ngit merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支test合并过来。合并后，可以发现master主分支的内容和test分支的最新提交是完全一样的。\n\n注：上面的Fast-forward信息是Git告诉我们，这次合并是“快进模式”，也就是直接把master指向test的当前提交，所以合并速度非常快，当然也不是每次合并都能Fast-forward，后续会总结其他方式的合并。\n\n**删除分支 （git branch -d test）**\n\n合并完成后，若不再需要test分支，也可以放心的删除：\n\n```bash\n$ git branch -d test\n\nDeleted branch test (was fec145a).\n```\n\n删除后，再次运行 git branch 命令，可以看到只剩下master分支了。\n\n建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。\n\n### 图解4种git合并分支方法\n\n彼此分开的世界也能随时交叉合并，世界就这样开开合合，偶会需要解决合并冲突\n\ngit中的分支非常的轻量，其实就是一个文件，里面记录了分支所指向的commit id，下图中有两个分支分别是master和test，他们都指向了A2这个提交，HEAD是一个特殊的指针，他永远指向你当前所在的位置；有时候你可能不在某一个分支上，不要惊慌，你随时有权利去你想去的分支，git赋予了你新建，切换分支的能力\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005510.png)\n\n然后有时候世界并不总如上图那般美好，面对分叉的两个分支，git新手总是一脸茫然，本文我将讲述git中合并分支的方法\n\n在git中合并分支有三种方法，分别是merge，rebase，cherry-pick，而其中merge又有三种区别，下面将一一介绍\n\n#### fast-forward\n\n如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支\n\n```\ngit checkout master\ngit merge test\n```\n\n这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/498.gif)\n\n#### no-ff\n\n如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上`--no-ff`参数\n\n```\ngit checkout master\ngit merge –no-ff test\n```\n\n这种合并方法会在master分支上新建一个提交节点，从而完成合并\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/499.gif)\n\n#### squash\n\nsvn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点\n\nsquash和no-ff非常类似，区别只有一点不会保留对合入分支的引用\n\n```bash\ngit checkout master\ngit merge –squash test\n```\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/500.gif)\n\n#### rebase\n\n当要合并两个分叉的分支时，merge的方式是将待合入分支和当前分支不同的部分，在当前分支新建节点，如下图所示\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005658.png)\n\nrebase与merge不同，rebase会将合入分支上超前的节点在待合入分支上重新提交一遍，如下图，B1 B2会变为B1’ B2’，看起来会变成线性历史\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005638.png)\n\n#### cherry-pick\n\n这命令简直就是神器，给你自由，你想把那个节点merge过来就把那个节点merge过来，其合入的不是分支而是提交节点\n\n## 项目托管与协作\n\n托管：把项目或者代码放到服务器上以便其他人员能够使用\n\n协作：针对项目，不同的人进行操作\n\n从github或gitlab上克隆的库无需git init命令，已经初始化完成\n\n首次提交，在本地commit之后，再做远程提交\n\n```bash\ngit remote add origin https://github.com/id/repo.git #这里的id和repo是你github的id和repo\ngit push -u origin master #这里会有github验证\n```\n\n","source":"_posts/2020-03-22-Git基础简明教程.md","raw":"---\nlayout: post\ntitle:  Git基础简明教程\ndate:   2020-03-22 23:15:00\ndescription: 简单复习Git相关内容\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200322231621.png\noptimized_image: \ncategory: tutorial\ntags:\n  - tutorial\n  - code\nauthor: tty\n---\n\n部分来源：[颜海镜](https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/)\n\n## 简介\n\n1. 版本控制工具是什么\n\n   软件，用来保存软件开发过程中各个版本\n\n2. 为什么要用版本控制工具\n\n   1. 有利于打造自己的核心竞争力，积累经验保存项目\n   2. 能够提供以往版本记录，方便恢复数据\n   3. 分清责任不背锅\n   4. 科学合理的规划工作\n   5. 进行项目精度和进度的把控\n\n3. SVN 和 git 成为了主流\n\n   1. SVN的优缺点\n\n      优点：\n\n      1. 管理方便，逻辑明确，符合一般人思维逻辑\n      2. 集中式管理，保证代码一致性\n\n      缺点：\n\n      1. 给服务器压力较大\n      2. 如果不能连接到服务器则基本不能工作\n      3. 不太适合人数较多的开源开发\n\n   2. Git的优缺点\n\n      优点：\n\n      1. 适合多人分布式的开发\n      2. 适合灵活快速的开发\n      3. 给服务器压力小，强调个体\n      4. 可进行离线工作\n      5. 非常容易解决冲突\n\n      缺点：\n\n      1. 学习周期比较长\n      2. 不太符合常规的思维\n      3. 代码的保密性比较差，每人都有一份代码和历史改动\n\n   3. 如何选择？\n\n      看应用场景，进行综合比较：\n\n      - 对权限要求比较高，则进行集中式管理，使用SVN\n      - 对代码写作要求比较高，则使用Git\n\n## Git常用概念\n\n### 仓库（书店）\n\n所有版本的代码都在仓库里\n\n### 分支（书架）\n\n不同功能代码存放的地方（可能是测试代码）\n\n### 提交（书）\n\n每一个版本的代码\n\n### 三区\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323001246.png)\n\n1. 工作区\n\n   工作的目录\n\n2. 暂存区\n\n   项目目录和仓库之间的暂时存储区域 桥梁\n\n3. 仓库区\n\n   存放着所有的版本\n\n4. 远程仓库\n\n   github上的仓库\n\n## Git的基础操作\n\n1. 新建一个文件夹作为repo目录\n\n2. 在目录中使用命令\n\n   ```bash\n   git init\n   ```\n\n   初始化Git目录\n\n3. 创建一个文件，如：helloworld.html\n\n4. 查看文件状态\n\n   ```bash\n   git status\n   ```\n\n   这时候应该会查看到有一个文件被修改，并且被标记为untracked file\n\n5. 加入文件\n\n   第一种方法：\n\n   ```bash\n   git add hellworld.html\n   git status\n   ```\n\n   之后状态应该已经不同，会发现文件已经被放入暂存区\n\n   第二种方法：\n\n   ```bash\n   git add .\n   ```\n\n   表示暂存所有文件\n\n6. 将暂存区文件提交到仓库\n\n   ```bash\n   git commit -m '你的注释'\n   ```\n\n7. 假如你在期间再次更改了文件，则需要重复步骤5和6\n\n   ```bash\n   git log\n   ```\n\n   可以查看版本\n\n8. 假如想回滚到之前的版本，则copy之前的版本id，id可在git log中查到\n\n   ```bash\n   tty@MacBook-Pro % git log\n   commit 926f60662797c96ccc3eeb4d99ec09d6d5db3547 (HEAD -> master, origin/master)\n   Date:   Sun Mar 22 16:25:10 2020 -0700\n   \n       Update 2020-02-03-Bloomberg面试见闻.md\n       \n   commit c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de\n   Date:   Sun Mar 22 16:15:48 2020 -0700\n   \n       update paginate\n   ```\n\n   此时如果想回滚到上一次记录，则使用上此的commit id， 如下\n\n   ```bash\n   git checkout c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de\n   ```\n\n   假如你不想指定具体的某一次记录，而是想单纯的回到上一次的记录，则有更方便的选择\n\n   ```bash\n   git checkout -- .\n   ```\n\n## 分支\n\n当你在开发测试内容，或是新功能时，可能你就需要一个分支，以避免影响master branch的稳定性\n\n分支的概念在各个版本控制系统中早已存在，分支对于团队协作开发来说作用是非常大的，如：\n\n- 当一个项目还是1.0版时，开发团队可能要同时进行1.1版和2.0版的开发，此时，代码就会出现较大分歧，这时就需要用到分支了，不同的任务组在各自不同的分支上开发，互相之间不会影响。\n\n- 需要向项目中添加一个新功能，一般的团队都不会直接在主分支上修改而是新建一个branch，在上面更改代码，这样做的好处一是保证主线代码的完整性和可用性，也就是说，主线上都是稳定的代码，可以直接拿来发布。二是避免出现其他问题。\n\n- 发布是所有的功能模块的集成，分支可能是零散功能的半成品。\n\n- 万一出现冲突很严重，或者出现各种情况而造成当前的分支出了问题，冲突解决起来很麻烦，如果有一个分支始终保留着最新的稳定版本,最多就是吧当前分支删掉,从那个稳定分支重新分一支出来,这样处理起来更方便。\n\n- 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的风险，又或者丢失向领导汇报工作进度的风险。有了分支后，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n### 分支特性\n\n- Git的技术可以说是非常强大，说一切开发都依赖于分支一点都不过分。一般项目的master分支都是稳定的代码，可以直接发布或者被项目之外的人使用。\n\n- 新特性和BUG修改都在不同的分支上进行开发和测试，这样规范了整个软件的开发流程。\n\n分支之间的互不影响这种特性可以增加团队合作的效率。\n\n- Git分支的另外一个重要特性就是可以合并不同软件仓库（fork）的分支。如：开发团队有一个主软件仓库，开发者可以fork这个仓库，相当于克隆了一个私有的软件仓库，然后开发者就可以在自己的软件仓库中建立分支并开发测试，测试完毕之后，可以向主软件仓库提交merge request，这样新开发的特性就会被合并到主软件仓库的某个分支中。这种特性极大地推动了开源项目，多年前参加开源项目都是神话，自从Git出现后，每个人都可能成为开源项目的贡献者，就是基于这种特性。\n\n- 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，让人无法忍受，结果分支功能成了摆设，基本都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n### 创建与合并分支\n\n在版本回退里中已经知道每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。\n如果没有创建过任何分支的情况下，Git中只有一个分支，叫主分支（即master分支）。\n\n当我们创建新的分支，例如test时，Git新建了一个指针叫test，指向master相同的提交，再把HEAD指向test，就表示当前分支在test上。\n\n注：Git创建一个分支很快，因为除了增加一个test指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n假如我们在test上的工作完成了，就可以把test合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向test的当前提交，就完成了合并。\n\n注：Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，也可以删除test分支。删除test分支就是把test指针给删掉，删掉后，就剩下了一条master分支了。\n\n### 操作命令\n\n**创建并切换分支 （git checkout -b test ）**\n\n```bash\n$ git checkout -b test\n\nSwitched to a new branch ‘test’\n```\n\n注：git checkout命令加上-b参数表示创建并切换，相当于执行了以下两条命令：\n\n```bash\n$ git branch test\n$ git checkout test\n\nSwitched to branch ‘test’\n```\n\n**查看当前分支** （ git branch ）\n然后，用git branch命令查看当前分支：\n\n```bash\n$ git branch\n\n*test\nmaster\n```\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。此时，我们就可以在test分支上进行开发并正常提交。\n\n**分支的切换 （git checkout master ）**\n\n如果在test分支上完成了开发，我们可以切换回master分支:\n\n```bash\n$ git checkout master\n\nSwitched to branch ‘master’\n```\n\n注：当切换回master分支后，其实内容是不会有任何改变的，因为你所做的修改和提交工作全部在test分支上完成，而master分支的提交点是没有任何改变的。\n\n**分支合并 （git merge test）**\n\n我们试着把test分支下的工作成果合并到master主分支上：\n\n```bash\n$ git merge test\nUpdating d17efd8..fec145a\nFast-forward\n……. | 1 +\n…. file changed, 1 insertion(+)\n```\n\ngit merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支test合并过来。合并后，可以发现master主分支的内容和test分支的最新提交是完全一样的。\n\n注：上面的Fast-forward信息是Git告诉我们，这次合并是“快进模式”，也就是直接把master指向test的当前提交，所以合并速度非常快，当然也不是每次合并都能Fast-forward，后续会总结其他方式的合并。\n\n**删除分支 （git branch -d test）**\n\n合并完成后，若不再需要test分支，也可以放心的删除：\n\n```bash\n$ git branch -d test\n\nDeleted branch test (was fec145a).\n```\n\n删除后，再次运行 git branch 命令，可以看到只剩下master分支了。\n\n建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。\n\n### 图解4种git合并分支方法\n\n彼此分开的世界也能随时交叉合并，世界就这样开开合合，偶会需要解决合并冲突\n\ngit中的分支非常的轻量，其实就是一个文件，里面记录了分支所指向的commit id，下图中有两个分支分别是master和test，他们都指向了A2这个提交，HEAD是一个特殊的指针，他永远指向你当前所在的位置；有时候你可能不在某一个分支上，不要惊慌，你随时有权利去你想去的分支，git赋予了你新建，切换分支的能力\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005510.png)\n\n然后有时候世界并不总如上图那般美好，面对分叉的两个分支，git新手总是一脸茫然，本文我将讲述git中合并分支的方法\n\n在git中合并分支有三种方法，分别是merge，rebase，cherry-pick，而其中merge又有三种区别，下面将一一介绍\n\n#### fast-forward\n\n如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支\n\n```\ngit checkout master\ngit merge test\n```\n\n这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/498.gif)\n\n#### no-ff\n\n如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上`--no-ff`参数\n\n```\ngit checkout master\ngit merge –no-ff test\n```\n\n这种合并方法会在master分支上新建一个提交节点，从而完成合并\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/499.gif)\n\n#### squash\n\nsvn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点\n\nsquash和no-ff非常类似，区别只有一点不会保留对合入分支的引用\n\n```bash\ngit checkout master\ngit merge –squash test\n```\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/500.gif)\n\n#### rebase\n\n当要合并两个分叉的分支时，merge的方式是将待合入分支和当前分支不同的部分，在当前分支新建节点，如下图所示\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005658.png)\n\nrebase与merge不同，rebase会将合入分支上超前的节点在待合入分支上重新提交一遍，如下图，B1 B2会变为B1’ B2’，看起来会变成线性历史\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323005638.png)\n\n#### cherry-pick\n\n这命令简直就是神器，给你自由，你想把那个节点merge过来就把那个节点merge过来，其合入的不是分支而是提交节点\n\n## 项目托管与协作\n\n托管：把项目或者代码放到服务器上以便其他人员能够使用\n\n协作：针对项目，不同的人进行操作\n\n从github或gitlab上克隆的库无需git init命令，已经初始化完成\n\n首次提交，在本地commit之后，再做远程提交\n\n```bash\ngit remote add origin https://github.com/id/repo.git #这里的id和repo是你github的id和repo\ngit push -u origin master #这里会有github验证\n```\n\n","slug":"Git基础简明教程","published":1,"updated":"2020-03-29T06:59:20.716Z","photos":[],"link":"","_id":"ck8ct7j5y001agtvi9qm7ffbs","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>部分来源：<a href=\"https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/\" target=\"_blank\" rel=\"noopener\">颜海镜</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ol>\n<li><p>版本控制工具是什么</p>\n<p>软件，用来保存软件开发过程中各个版本</p>\n</li>\n<li><p>为什么要用版本控制工具</p>\n<ol>\n<li>有利于打造自己的核心竞争力，积累经验保存项目</li>\n<li>能够提供以往版本记录，方便恢复数据</li>\n<li>分清责任不背锅</li>\n<li>科学合理的规划工作</li>\n<li>进行项目精度和进度的把控</li>\n</ol>\n</li>\n<li><p>SVN 和 git 成为了主流</p>\n<ol>\n<li><p>SVN的优缺点</p>\n<p>优点：</p>\n<ol>\n<li>管理方便，逻辑明确，符合一般人思维逻辑</li>\n<li>集中式管理，保证代码一致性</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>给服务器压力较大</li>\n<li>如果不能连接到服务器则基本不能工作</li>\n<li>不太适合人数较多的开源开发</li>\n</ol>\n</li>\n<li><p>Git的优缺点</p>\n<p>优点：</p>\n<ol>\n<li>适合多人分布式的开发</li>\n<li>适合灵活快速的开发</li>\n<li>给服务器压力小，强调个体</li>\n<li>可进行离线工作</li>\n<li>非常容易解决冲突</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>学习周期比较长</li>\n<li>不太符合常规的思维</li>\n<li>代码的保密性比较差，每人都有一份代码和历史改动</li>\n</ol>\n</li>\n<li><p>如何选择？</p>\n<p>看应用场景，进行综合比较：</p>\n<ul>\n<li>对权限要求比较高，则进行集中式管理，使用SVN</li>\n<li>对代码写作要求比较高，则使用Git</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Git常用概念\"><a href=\"#Git常用概念\" class=\"headerlink\" title=\"Git常用概念\"></a>Git常用概念</h2><h3 id=\"仓库（书店）\"><a href=\"#仓库（书店）\" class=\"headerlink\" title=\"仓库（书店）\"></a>仓库（书店）</h3><p>所有版本的代码都在仓库里</p>\n<h3 id=\"分支（书架）\"><a href=\"#分支（书架）\" class=\"headerlink\" title=\"分支（书架）\"></a>分支（书架）</h3><p>不同功能代码存放的地方（可能是测试代码）</p>\n<h3 id=\"提交（书）\"><a href=\"#提交（书）\" class=\"headerlink\" title=\"提交（书）\"></a>提交（书）</h3><p>每一个版本的代码</p>\n<h3 id=\"三区\"><a href=\"#三区\" class=\"headerlink\" title=\"三区\"></a>三区</h3><p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323001246.png\"  alt=\"\"></p>\n<ol>\n<li><p>工作区</p>\n<p>工作的目录</p>\n</li>\n<li><p>暂存区</p>\n<p>项目目录和仓库之间的暂时存储区域 桥梁</p>\n</li>\n<li><p>仓库区</p>\n<p>存放着所有的版本</p>\n</li>\n<li><p>远程仓库</p>\n<p>github上的仓库</p>\n</li>\n</ol>\n<h2 id=\"Git的基础操作\"><a href=\"#Git的基础操作\" class=\"headerlink\" title=\"Git的基础操作\"></a>Git的基础操作</h2><ol>\n<li><p>新建一个文件夹作为repo目录</p>\n</li>\n<li><p>在目录中使用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>初始化Git目录</p>\n</li>\n<li><p>创建一个文件，如：helloworld.html</p>\n</li>\n<li><p>查看文件状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>这时候应该会查看到有一个文件被修改，并且被标记为untracked file</p>\n</li>\n<li><p>加入文件</p>\n<p>第一种方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add hellworld.html</span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>之后状态应该已经不同，会发现文件已经被放入暂存区</p>\n<p>第二种方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>表示暂存所有文件</p>\n</li>\n<li><p>将暂存区文件提交到仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">'你的注释'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假如你在期间再次更改了文件，则需要重复步骤5和6</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n\n<p>可以查看版本</p>\n</li>\n<li><p>假如想回滚到之前的版本，则copy之前的版本id，id可在git log中查到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty@MacBook-Pro % git <span class=\"built_in\">log</span></span><br><span class=\"line\">commit 926f60662797c96ccc3eeb4d99ec09d6d5db3547 (HEAD -&gt; master, origin/master)</span><br><span class=\"line\">Date:   Sun Mar 22 16:25:10 2020 -0700</span><br><span class=\"line\"></span><br><span class=\"line\">    Update 2020-02-03-Bloomberg面试见闻.md</span><br><span class=\"line\">    </span><br><span class=\"line\">commit c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br><span class=\"line\">Date:   Sun Mar 22 16:15:48 2020 -0700</span><br><span class=\"line\"></span><br><span class=\"line\">    update paginate</span><br></pre></td></tr></table></figure>\n\n<p>此时如果想回滚到上一次记录，则使用上此的commit id， 如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br></pre></td></tr></table></figure>\n\n<p>假如你不想指定具体的某一次记录，而是想单纯的回到上一次的记录，则有更方便的选择</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- .</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>当你在开发测试内容，或是新功能时，可能你就需要一个分支，以避免影响master branch的稳定性</p>\n<p>分支的概念在各个版本控制系统中早已存在，分支对于团队协作开发来说作用是非常大的，如：</p>\n<ul>\n<li><p>当一个项目还是1.0版时，开发团队可能要同时进行1.1版和2.0版的开发，此时，代码就会出现较大分歧，这时就需要用到分支了，不同的任务组在各自不同的分支上开发，互相之间不会影响。</p>\n</li>\n<li><p>需要向项目中添加一个新功能，一般的团队都不会直接在主分支上修改而是新建一个branch，在上面更改代码，这样做的好处一是保证主线代码的完整性和可用性，也就是说，主线上都是稳定的代码，可以直接拿来发布。二是避免出现其他问题。</p>\n</li>\n<li><p>发布是所有的功能模块的集成，分支可能是零散功能的半成品。</p>\n</li>\n<li><p>万一出现冲突很严重，或者出现各种情况而造成当前的分支出了问题，冲突解决起来很麻烦，如果有一个分支始终保留着最新的稳定版本,最多就是吧当前分支删掉,从那个稳定分支重新分一支出来,这样处理起来更方便。</p>\n</li>\n<li><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的风险，又或者丢失向领导汇报工作进度的风险。有了分支后，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>\n</li>\n</ul>\n<h3 id=\"分支特性\"><a href=\"#分支特性\" class=\"headerlink\" title=\"分支特性\"></a>分支特性</h3><ul>\n<li><p>Git的技术可以说是非常强大，说一切开发都依赖于分支一点都不过分。一般项目的master分支都是稳定的代码，可以直接发布或者被项目之外的人使用。</p>\n</li>\n<li><p>新特性和BUG修改都在不同的分支上进行开发和测试，这样规范了整个软件的开发流程。</p>\n</li>\n</ul>\n<p>分支之间的互不影响这种特性可以增加团队合作的效率。</p>\n<ul>\n<li><p>Git分支的另外一个重要特性就是可以合并不同软件仓库（fork）的分支。如：开发团队有一个主软件仓库，开发者可以fork这个仓库，相当于克隆了一个私有的软件仓库，然后开发者就可以在自己的软件仓库中建立分支并开发测试，测试完毕之后，可以向主软件仓库提交merge request，这样新开发的特性就会被合并到主软件仓库的某个分支中。这种特性极大地推动了开源项目，多年前参加开源项目都是神话，自从Git出现后，每个人都可能成为开源项目的贡献者，就是基于这种特性。</p>\n</li>\n<li><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，让人无法忍受，结果分支功能成了摆设，基本都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>\n</li>\n</ul>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><p>在版本回退里中已经知道每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。<br>如果没有创建过任何分支的情况下，Git中只有一个分支，叫主分支（即master分支）。</p>\n<p>当我们创建新的分支，例如test时，Git新建了一个指针叫test，指向master相同的提交，再把HEAD指向test，就表示当前分支在test上。</p>\n<p>注：Git创建一个分支很快，因为除了增加一个test指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>\n<p>假如我们在test上的工作完成了，就可以把test合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向test的当前提交，就完成了合并。</p>\n<p>注：Git合并分支也很快！就改改指针，工作区内容也不变！</p>\n<p>合并完分支后，也可以删除test分支。删除test分支就是把test指针给删掉，删掉后，就剩下了一条master分支了。</p>\n<h3 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h3><p><strong>创建并切换分支 （git checkout -b test ）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Switched to a new branch ‘<span class=\"built_in\">test</span>’</span><br></pre></td></tr></table></figure>\n\n<p>注：git checkout命令加上-b参数表示创建并切换，相当于执行了以下两条命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch <span class=\"built_in\">test</span></span><br><span class=\"line\">$ git checkout <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Switched to branch ‘<span class=\"built_in\">test</span>’</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看当前分支</strong> （ git branch ）<br>然后，用git branch命令查看当前分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\">*<span class=\"built_in\">test</span></span><br><span class=\"line\">master</span><br></pre></td></tr></table></figure>\n\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号。此时，我们就可以在test分支上进行开发并正常提交。</p>\n<p><strong>分支的切换 （git checkout master ）</strong></p>\n<p>如果在test分支上完成了开发，我们可以切换回master分支:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\">Switched to branch ‘master’</span><br></pre></td></tr></table></figure>\n\n<p>注：当切换回master分支后，其实内容是不会有任何改变的，因为你所做的修改和提交工作全部在test分支上完成，而master分支的提交点是没有任何改变的。</p>\n<p><strong>分支合并 （git merge test）</strong></p>\n<p>我们试着把test分支下的工作成果合并到master主分支上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge <span class=\"built_in\">test</span></span><br><span class=\"line\">Updating d17efd8..fec145a</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\">……. | 1 +</span><br><span class=\"line\">…. file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>git merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支test合并过来。合并后，可以发现master主分支的内容和test分支的最新提交是完全一样的。</p>\n<p>注：上面的Fast-forward信息是Git告诉我们，这次合并是“快进模式”，也就是直接把master指向test的当前提交，所以合并速度非常快，当然也不是每次合并都能Fast-forward，后续会总结其他方式的合并。</p>\n<p><strong>删除分支 （git branch -d test）</strong></p>\n<p>合并完成后，若不再需要test分支，也可以放心的删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Deleted branch <span class=\"built_in\">test</span> (was fec145a).</span><br></pre></td></tr></table></figure>\n\n<p>删除后，再次运行 git branch 命令，可以看到只剩下master分支了。</p>\n<p>建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。</p>\n<h3 id=\"图解4种git合并分支方法\"><a href=\"#图解4种git合并分支方法\" class=\"headerlink\" title=\"图解4种git合并分支方法\"></a>图解4种git合并分支方法</h3><p>彼此分开的世界也能随时交叉合并，世界就这样开开合合，偶会需要解决合并冲突</p>\n<p>git中的分支非常的轻量，其实就是一个文件，里面记录了分支所指向的commit id，下图中有两个分支分别是master和test，他们都指向了A2这个提交，HEAD是一个特殊的指针，他永远指向你当前所在的位置；有时候你可能不在某一个分支上，不要惊慌，你随时有权利去你想去的分支，git赋予了你新建，切换分支的能力</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005510.png\"  alt=\"\"></p>\n<p>然后有时候世界并不总如上图那般美好，面对分叉的两个分支，git新手总是一脸茫然，本文我将讲述git中合并分支的方法</p>\n<p>在git中合并分支有三种方法，分别是merge，rebase，cherry-pick，而其中merge又有三种区别，下面将一一介绍</p>\n<h4 id=\"fast-forward\"><a href=\"#fast-forward\" class=\"headerlink\" title=\"fast-forward\"></a>fast-forward</h4><p>如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n\n<p>这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/498.gif\"  alt=\"\"></p>\n<h4 id=\"no-ff\"><a href=\"#no-ff\" class=\"headerlink\" title=\"no-ff\"></a>no-ff</h4><p>如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上<code>--no-ff</code>参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge –no-ff test</span><br></pre></td></tr></table></figure>\n\n<p>这种合并方法会在master分支上新建一个提交节点，从而完成合并</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/499.gif\"  alt=\"\"></p>\n<h4 id=\"squash\"><a href=\"#squash\" class=\"headerlink\" title=\"squash\"></a>squash</h4><p>svn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点</p>\n<p>squash和no-ff非常类似，区别只有一点不会保留对合入分支的引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge –squash <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/500.gif\"  alt=\"\"></p>\n<h4 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h4><p>当要合并两个分叉的分支时，merge的方式是将待合入分支和当前分支不同的部分，在当前分支新建节点，如下图所示</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005658.png\"  alt=\"\"></p>\n<p>rebase与merge不同，rebase会将合入分支上超前的节点在待合入分支上重新提交一遍，如下图，B1 B2会变为B1’ B2’，看起来会变成线性历史</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005638.png\"  alt=\"\"></p>\n<h4 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h4><p>这命令简直就是神器，给你自由，你想把那个节点merge过来就把那个节点merge过来，其合入的不是分支而是提交节点</p>\n<h2 id=\"项目托管与协作\"><a href=\"#项目托管与协作\" class=\"headerlink\" title=\"项目托管与协作\"></a>项目托管与协作</h2><p>托管：把项目或者代码放到服务器上以便其他人员能够使用</p>\n<p>协作：针对项目，不同的人进行操作</p>\n<p>从github或gitlab上克隆的库无需git init命令，已经初始化完成</p>\n<p>首次提交，在本地commit之后，再做远程提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/id/repo.git <span class=\"comment\">#这里的id和repo是你github的id和repo</span></span><br><span class=\"line\">git push -u origin master <span class=\"comment\">#这里会有github验证</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>部分来源：<a href=\"https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/\" target=\"_blank\" rel=\"noopener\">颜海镜</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ol>\n<li><p>版本控制工具是什么</p>\n<p>软件，用来保存软件开发过程中各个版本</p>\n</li>\n<li><p>为什么要用版本控制工具</p>\n<ol>\n<li>有利于打造自己的核心竞争力，积累经验保存项目</li>\n<li>能够提供以往版本记录，方便恢复数据</li>\n<li>分清责任不背锅</li>\n<li>科学合理的规划工作</li>\n<li>进行项目精度和进度的把控</li>\n</ol>\n</li>\n<li><p>SVN 和 git 成为了主流</p>\n<ol>\n<li><p>SVN的优缺点</p>\n<p>优点：</p>\n<ol>\n<li>管理方便，逻辑明确，符合一般人思维逻辑</li>\n<li>集中式管理，保证代码一致性</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>给服务器压力较大</li>\n<li>如果不能连接到服务器则基本不能工作</li>\n<li>不太适合人数较多的开源开发</li>\n</ol>\n</li>\n<li><p>Git的优缺点</p>\n<p>优点：</p>\n<ol>\n<li>适合多人分布式的开发</li>\n<li>适合灵活快速的开发</li>\n<li>给服务器压力小，强调个体</li>\n<li>可进行离线工作</li>\n<li>非常容易解决冲突</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>学习周期比较长</li>\n<li>不太符合常规的思维</li>\n<li>代码的保密性比较差，每人都有一份代码和历史改动</li>\n</ol>\n</li>\n<li><p>如何选择？</p>\n<p>看应用场景，进行综合比较：</p>\n<ul>\n<li>对权限要求比较高，则进行集中式管理，使用SVN</li>\n<li>对代码写作要求比较高，则使用Git</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Git常用概念\"><a href=\"#Git常用概念\" class=\"headerlink\" title=\"Git常用概念\"></a>Git常用概念</h2><h3 id=\"仓库（书店）\"><a href=\"#仓库（书店）\" class=\"headerlink\" title=\"仓库（书店）\"></a>仓库（书店）</h3><p>所有版本的代码都在仓库里</p>\n<h3 id=\"分支（书架）\"><a href=\"#分支（书架）\" class=\"headerlink\" title=\"分支（书架）\"></a>分支（书架）</h3><p>不同功能代码存放的地方（可能是测试代码）</p>\n<h3 id=\"提交（书）\"><a href=\"#提交（书）\" class=\"headerlink\" title=\"提交（书）\"></a>提交（书）</h3><p>每一个版本的代码</p>\n<h3 id=\"三区\"><a href=\"#三区\" class=\"headerlink\" title=\"三区\"></a>三区</h3><p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323001246.png\" alt=\"\"></p>\n<ol>\n<li><p>工作区</p>\n<p>工作的目录</p>\n</li>\n<li><p>暂存区</p>\n<p>项目目录和仓库之间的暂时存储区域 桥梁</p>\n</li>\n<li><p>仓库区</p>\n<p>存放着所有的版本</p>\n</li>\n<li><p>远程仓库</p>\n<p>github上的仓库</p>\n</li>\n</ol>\n<h2 id=\"Git的基础操作\"><a href=\"#Git的基础操作\" class=\"headerlink\" title=\"Git的基础操作\"></a>Git的基础操作</h2><ol>\n<li><p>新建一个文件夹作为repo目录</p>\n</li>\n<li><p>在目录中使用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>初始化Git目录</p>\n</li>\n<li><p>创建一个文件，如：helloworld.html</p>\n</li>\n<li><p>查看文件状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>这时候应该会查看到有一个文件被修改，并且被标记为untracked file</p>\n</li>\n<li><p>加入文件</p>\n<p>第一种方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add hellworld.html</span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>之后状态应该已经不同，会发现文件已经被放入暂存区</p>\n<p>第二种方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>表示暂存所有文件</p>\n</li>\n<li><p>将暂存区文件提交到仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">'你的注释'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假如你在期间再次更改了文件，则需要重复步骤5和6</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n\n<p>可以查看版本</p>\n</li>\n<li><p>假如想回滚到之前的版本，则copy之前的版本id，id可在git log中查到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tty@MacBook-Pro % git <span class=\"built_in\">log</span></span><br><span class=\"line\">commit 926f60662797c96ccc3eeb4d99ec09d6d5db3547 (HEAD -&gt; master, origin/master)</span><br><span class=\"line\">Date:   Sun Mar 22 16:25:10 2020 -0700</span><br><span class=\"line\"></span><br><span class=\"line\">    Update 2020-02-03-Bloomberg面试见闻.md</span><br><span class=\"line\">    </span><br><span class=\"line\">commit c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br><span class=\"line\">Date:   Sun Mar 22 16:15:48 2020 -0700</span><br><span class=\"line\"></span><br><span class=\"line\">    update paginate</span><br></pre></td></tr></table></figure>\n\n<p>此时如果想回滚到上一次记录，则使用上此的commit id， 如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout c99efef6372eeb6aac5b0f0062dbd2c6a3bf26de</span><br></pre></td></tr></table></figure>\n\n<p>假如你不想指定具体的某一次记录，而是想单纯的回到上一次的记录，则有更方便的选择</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- .</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>当你在开发测试内容，或是新功能时，可能你就需要一个分支，以避免影响master branch的稳定性</p>\n<p>分支的概念在各个版本控制系统中早已存在，分支对于团队协作开发来说作用是非常大的，如：</p>\n<ul>\n<li><p>当一个项目还是1.0版时，开发团队可能要同时进行1.1版和2.0版的开发，此时，代码就会出现较大分歧，这时就需要用到分支了，不同的任务组在各自不同的分支上开发，互相之间不会影响。</p>\n</li>\n<li><p>需要向项目中添加一个新功能，一般的团队都不会直接在主分支上修改而是新建一个branch，在上面更改代码，这样做的好处一是保证主线代码的完整性和可用性，也就是说，主线上都是稳定的代码，可以直接拿来发布。二是避免出现其他问题。</p>\n</li>\n<li><p>发布是所有的功能模块的集成，分支可能是零散功能的半成品。</p>\n</li>\n<li><p>万一出现冲突很严重，或者出现各种情况而造成当前的分支出了问题，冲突解决起来很麻烦，如果有一个分支始终保留着最新的稳定版本,最多就是吧当前分支删掉,从那个稳定分支重新分一支出来,这样处理起来更方便。</p>\n</li>\n<li><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的风险，又或者丢失向领导汇报工作进度的风险。有了分支后，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>\n</li>\n</ul>\n<h3 id=\"分支特性\"><a href=\"#分支特性\" class=\"headerlink\" title=\"分支特性\"></a>分支特性</h3><ul>\n<li><p>Git的技术可以说是非常强大，说一切开发都依赖于分支一点都不过分。一般项目的master分支都是稳定的代码，可以直接发布或者被项目之外的人使用。</p>\n</li>\n<li><p>新特性和BUG修改都在不同的分支上进行开发和测试，这样规范了整个软件的开发流程。</p>\n</li>\n</ul>\n<p>分支之间的互不影响这种特性可以增加团队合作的效率。</p>\n<ul>\n<li><p>Git分支的另外一个重要特性就是可以合并不同软件仓库（fork）的分支。如：开发团队有一个主软件仓库，开发者可以fork这个仓库，相当于克隆了一个私有的软件仓库，然后开发者就可以在自己的软件仓库中建立分支并开发测试，测试完毕之后，可以向主软件仓库提交merge request，这样新开发的特性就会被合并到主软件仓库的某个分支中。这种特性极大地推动了开源项目，多年前参加开源项目都是神话，自从Git出现后，每个人都可能成为开源项目的贡献者，就是基于这种特性。</p>\n</li>\n<li><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，让人无法忍受，结果分支功能成了摆设，基本都不去用。但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>\n</li>\n</ul>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><p>在版本回退里中已经知道每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。<br>如果没有创建过任何分支的情况下，Git中只有一个分支，叫主分支（即master分支）。</p>\n<p>当我们创建新的分支，例如test时，Git新建了一个指针叫test，指向master相同的提交，再把HEAD指向test，就表示当前分支在test上。</p>\n<p>注：Git创建一个分支很快，因为除了增加一个test指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>\n<p>假如我们在test上的工作完成了，就可以把test合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向test的当前提交，就完成了合并。</p>\n<p>注：Git合并分支也很快！就改改指针，工作区内容也不变！</p>\n<p>合并完分支后，也可以删除test分支。删除test分支就是把test指针给删掉，删掉后，就剩下了一条master分支了。</p>\n<h3 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h3><p><strong>创建并切换分支 （git checkout -b test ）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Switched to a new branch ‘<span class=\"built_in\">test</span>’</span><br></pre></td></tr></table></figure>\n\n<p>注：git checkout命令加上-b参数表示创建并切换，相当于执行了以下两条命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch <span class=\"built_in\">test</span></span><br><span class=\"line\">$ git checkout <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Switched to branch ‘<span class=\"built_in\">test</span>’</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看当前分支</strong> （ git branch ）<br>然后，用git branch命令查看当前分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\">*<span class=\"built_in\">test</span></span><br><span class=\"line\">master</span><br></pre></td></tr></table></figure>\n\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号。此时，我们就可以在test分支上进行开发并正常提交。</p>\n<p><strong>分支的切换 （git checkout master ）</strong></p>\n<p>如果在test分支上完成了开发，我们可以切换回master分支:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\">Switched to branch ‘master’</span><br></pre></td></tr></table></figure>\n\n<p>注：当切换回master分支后，其实内容是不会有任何改变的，因为你所做的修改和提交工作全部在test分支上完成，而master分支的提交点是没有任何改变的。</p>\n<p><strong>分支合并 （git merge test）</strong></p>\n<p>我们试着把test分支下的工作成果合并到master主分支上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge <span class=\"built_in\">test</span></span><br><span class=\"line\">Updating d17efd8..fec145a</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\">……. | 1 +</span><br><span class=\"line\">…. file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>git merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支test合并过来。合并后，可以发现master主分支的内容和test分支的最新提交是完全一样的。</p>\n<p>注：上面的Fast-forward信息是Git告诉我们，这次合并是“快进模式”，也就是直接把master指向test的当前提交，所以合并速度非常快，当然也不是每次合并都能Fast-forward，后续会总结其他方式的合并。</p>\n<p><strong>删除分支 （git branch -d test）</strong></p>\n<p>合并完成后，若不再需要test分支，也可以放心的删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">Deleted branch <span class=\"built_in\">test</span> (was fec145a).</span><br></pre></td></tr></table></figure>\n\n<p>删除后，再次运行 git branch 命令，可以看到只剩下master分支了。</p>\n<p>建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。</p>\n<h3 id=\"图解4种git合并分支方法\"><a href=\"#图解4种git合并分支方法\" class=\"headerlink\" title=\"图解4种git合并分支方法\"></a>图解4种git合并分支方法</h3><p>彼此分开的世界也能随时交叉合并，世界就这样开开合合，偶会需要解决合并冲突</p>\n<p>git中的分支非常的轻量，其实就是一个文件，里面记录了分支所指向的commit id，下图中有两个分支分别是master和test，他们都指向了A2这个提交，HEAD是一个特殊的指针，他永远指向你当前所在的位置；有时候你可能不在某一个分支上，不要惊慌，你随时有权利去你想去的分支，git赋予了你新建，切换分支的能力</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005510.png\" alt=\"\"></p>\n<p>然后有时候世界并不总如上图那般美好，面对分叉的两个分支，git新手总是一脸茫然，本文我将讲述git中合并分支的方法</p>\n<p>在git中合并分支有三种方法，分别是merge，rebase，cherry-pick，而其中merge又有三种区别，下面将一一介绍</p>\n<h4 id=\"fast-forward\"><a href=\"#fast-forward\" class=\"headerlink\" title=\"fast-forward\"></a>fast-forward</h4><p>如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n\n<p>这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/498.gif\" alt=\"\"></p>\n<h4 id=\"no-ff\"><a href=\"#no-ff\" class=\"headerlink\" title=\"no-ff\"></a>no-ff</h4><p>如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上<code>--no-ff</code>参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge –no-ff test</span><br></pre></td></tr></table></figure>\n\n<p>这种合并方法会在master分支上新建一个提交节点，从而完成合并</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/499.gif\" alt=\"\"></p>\n<h4 id=\"squash\"><a href=\"#squash\" class=\"headerlink\" title=\"squash\"></a>squash</h4><p>svn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点</p>\n<p>squash和no-ff非常类似，区别只有一点不会保留对合入分支的引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge –squash <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/500.gif\" alt=\"\"></p>\n<h4 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h4><p>当要合并两个分叉的分支时，merge的方式是将待合入分支和当前分支不同的部分，在当前分支新建节点，如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005658.png\" alt=\"\"></p>\n<p>rebase与merge不同，rebase会将合入分支上超前的节点在待合入分支上重新提交一遍，如下图，B1 B2会变为B1’ B2’，看起来会变成线性历史</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323005638.png\" alt=\"\"></p>\n<h4 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h4><p>这命令简直就是神器，给你自由，你想把那个节点merge过来就把那个节点merge过来，其合入的不是分支而是提交节点</p>\n<h2 id=\"项目托管与协作\"><a href=\"#项目托管与协作\" class=\"headerlink\" title=\"项目托管与协作\"></a>项目托管与协作</h2><p>托管：把项目或者代码放到服务器上以便其他人员能够使用</p>\n<p>协作：针对项目，不同的人进行操作</p>\n<p>从github或gitlab上克隆的库无需git init命令，已经初始化完成</p>\n<p>首次提交，在本地commit之后，再做远程提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/id/repo.git <span class=\"comment\">#这里的id和repo是你github的id和repo</span></span><br><span class=\"line\">git push -u origin master <span class=\"comment\">#这里会有github验证</span></span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"程序员标配？Herman Miller Sayl","date":"2020-03-22T22:01:00.000Z","description":"过分溢价的人体工学椅？","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200322150525.png","optimized_image":null,"author":"tty","_content":"\n因为疫情原因，公司决定work from home，给所有员工400刀的预算去买自己在家办公所需。我寻思着自己的东西都买的差的不多了，显示器是个游戏显示器不太好意思拿去报销，桌子是转租房自带的不是自己买的，家里只有一台一百刀的打印机能报销。正好Amazon上买的Amazon basic椅子并不好用，决定买张Herman Miller的椅子，试试感觉。\n\nHerman Miller的大家应该都听说过，一张$1500+的Herman Miller Embody号称程序员之梦。我个人觉得自己没这么高需求，而且工作第一桶金还没拿到呢，买这么贵的不合适，就买了一张亚马逊上最便宜的Herman Miller Sayl。这张椅子据说是很多顶级公司的会议室标配。顶级公司没去过，椅子可以先买张爽爽。\n\n个人买的是$510的版本，主要是当时我没细看它们有什么区别，直接买了张最便宜的。按论坛上说的，“Herman Miller的椅子，买就行了，不会差的”。于是我就真没看，直接买了，现在想想稍微有点后悔，还是应该稍微加点钱上高级点的版本的。\n\nHerman Miller的椅子运送都是整只装好了运送的。箱子大而沉。我琢磨着大概510刀有一半是组装费用，这么一算倒还是挺值的！\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/5B5F402D-89F2-441F-9918-490853DBA67E_1_105_c.jpeg)\n\n拆开箱子以后椅子可以直接拉出来。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/86182C54-1523-4CA6-8AC9-2DFE4A8889D3_1_105_c.jpeg)\n\n从箱子里拿出来后的Herman Miller Sayl\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E9E8D6E2-A252-41AA-BFAF-D82F546DFCE9_1_105_c.jpeg)\n\n这个版本是Stationary Seat Depth and Arms，也就是说坐垫和手把都是不可调整的，而且后背也没有可调整的支撑位置。在其他版本之中，后背的支撑处有一个可以上下滑动调整支撑腰部位置的模块。\n\n在这个版本的Sayl上，仍具备的功能有：\n\n- 上下高度调整\n\n- 后仰弹力调整：\n\n  椅子的靠背可以向后仰，但是后仰的角度并不能固定住，需要你施加力量。右侧有一旋钮，可以改变力量强度。你可以调整成很轻松随意一靠就能后仰，或者根本仰不动\n\n- 后仰角度调整：\n\n  你可以调整最大后仰的角度，有三种，一种是前倾，一种是后仰15度左右，另一种是后仰45度左右\n\n### 个人感受\n\n首先坐垫并不柔软。这是一块类硬海绵材质的坐垫，你坐下去可能它形变都不到一厘米，这方面的体验实际上不太好，整得有点像坐火车硬座。\n\n这个靠背就有点意思了，它确实能给你的腰足够的支撑。我也算是误打误撞，没有买可调整的腰部模块，但是无需调整，这张的椅子刚好支撑到了我的腰部。又因为这低配椅子没有可调节的坐垫模块，坐垫比较狭窄，我必须靠内坐才能舒服。这就导致我必须在这张椅子上坐正坐直。好在腰部支撑力足够，坐久了并不会累——除了屁股。这坐垫可太硬了。\n\n之前看到有个评测说这张椅子能矫正你的坐姿，让你在不知不觉之间坐正坐直。看来此言不虚。","source":"_posts/2020-03-22-程序员标配？Herman-Miller-Sayl.md","raw":"---\nlayout: post\ntitle:  程序员标配？Herman Miller Sayl\ndate:   2020-03-22 15:01:00\ndescription: 过分溢价的人体工学椅？\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200322150525.png\noptimized_image: \ncategory: review\ntags:\n  - review\n  - life\nauthor: tty\n---\n\n因为疫情原因，公司决定work from home，给所有员工400刀的预算去买自己在家办公所需。我寻思着自己的东西都买的差的不多了，显示器是个游戏显示器不太好意思拿去报销，桌子是转租房自带的不是自己买的，家里只有一台一百刀的打印机能报销。正好Amazon上买的Amazon basic椅子并不好用，决定买张Herman Miller的椅子，试试感觉。\n\nHerman Miller的大家应该都听说过，一张$1500+的Herman Miller Embody号称程序员之梦。我个人觉得自己没这么高需求，而且工作第一桶金还没拿到呢，买这么贵的不合适，就买了一张亚马逊上最便宜的Herman Miller Sayl。这张椅子据说是很多顶级公司的会议室标配。顶级公司没去过，椅子可以先买张爽爽。\n\n个人买的是$510的版本，主要是当时我没细看它们有什么区别，直接买了张最便宜的。按论坛上说的，“Herman Miller的椅子，买就行了，不会差的”。于是我就真没看，直接买了，现在想想稍微有点后悔，还是应该稍微加点钱上高级点的版本的。\n\nHerman Miller的椅子运送都是整只装好了运送的。箱子大而沉。我琢磨着大概510刀有一半是组装费用，这么一算倒还是挺值的！\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/5B5F402D-89F2-441F-9918-490853DBA67E_1_105_c.jpeg)\n\n拆开箱子以后椅子可以直接拉出来。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/86182C54-1523-4CA6-8AC9-2DFE4A8889D3_1_105_c.jpeg)\n\n从箱子里拿出来后的Herman Miller Sayl\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E9E8D6E2-A252-41AA-BFAF-D82F546DFCE9_1_105_c.jpeg)\n\n这个版本是Stationary Seat Depth and Arms，也就是说坐垫和手把都是不可调整的，而且后背也没有可调整的支撑位置。在其他版本之中，后背的支撑处有一个可以上下滑动调整支撑腰部位置的模块。\n\n在这个版本的Sayl上，仍具备的功能有：\n\n- 上下高度调整\n\n- 后仰弹力调整：\n\n  椅子的靠背可以向后仰，但是后仰的角度并不能固定住，需要你施加力量。右侧有一旋钮，可以改变力量强度。你可以调整成很轻松随意一靠就能后仰，或者根本仰不动\n\n- 后仰角度调整：\n\n  你可以调整最大后仰的角度，有三种，一种是前倾，一种是后仰15度左右，另一种是后仰45度左右\n\n### 个人感受\n\n首先坐垫并不柔软。这是一块类硬海绵材质的坐垫，你坐下去可能它形变都不到一厘米，这方面的体验实际上不太好，整得有点像坐火车硬座。\n\n这个靠背就有点意思了，它确实能给你的腰足够的支撑。我也算是误打误撞，没有买可调整的腰部模块，但是无需调整，这张的椅子刚好支撑到了我的腰部。又因为这低配椅子没有可调节的坐垫模块，坐垫比较狭窄，我必须靠内坐才能舒服。这就导致我必须在这张椅子上坐正坐直。好在腰部支撑力足够，坐久了并不会累——除了屁股。这坐垫可太硬了。\n\n之前看到有个评测说这张椅子能矫正你的坐姿，让你在不知不觉之间坐正坐直。看来此言不虚。","slug":"程序员标配？Herman-Miller-Sayl","published":1,"updated":"2020-03-29T06:59:20.717Z","photos":[],"link":"","_id":"ck8ct7j5z001dgtvi77ng2i0n","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>因为疫情原因，公司决定work from home，给所有员工400刀的预算去买自己在家办公所需。我寻思着自己的东西都买的差的不多了，显示器是个游戏显示器不太好意思拿去报销，桌子是转租房自带的不是自己买的，家里只有一台一百刀的打印机能报销。正好Amazon上买的Amazon basic椅子并不好用，决定买张Herman Miller的椅子，试试感觉。</p>\n<p>Herman Miller的大家应该都听说过，一张$1500+的Herman Miller Embody号称程序员之梦。我个人觉得自己没这么高需求，而且工作第一桶金还没拿到呢，买这么贵的不合适，就买了一张亚马逊上最便宜的Herman Miller Sayl。这张椅子据说是很多顶级公司的会议室标配。顶级公司没去过，椅子可以先买张爽爽。</p>\n<p>个人买的是$510的版本，主要是当时我没细看它们有什么区别，直接买了张最便宜的。按论坛上说的，“Herman Miller的椅子，买就行了，不会差的”。于是我就真没看，直接买了，现在想想稍微有点后悔，还是应该稍微加点钱上高级点的版本的。</p>\n<p>Herman Miller的椅子运送都是整只装好了运送的。箱子大而沉。我琢磨着大概510刀有一半是组装费用，这么一算倒还是挺值的！</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/5B5F402D-89F2-441F-9918-490853DBA67E_1_105_c.jpeg\"  alt=\"\"></p>\n<p>拆开箱子以后椅子可以直接拉出来。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/86182C54-1523-4CA6-8AC9-2DFE4A8889D3_1_105_c.jpeg\"  alt=\"\"></p>\n<p>从箱子里拿出来后的Herman Miller Sayl</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/E9E8D6E2-A252-41AA-BFAF-D82F546DFCE9_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这个版本是Stationary Seat Depth and Arms，也就是说坐垫和手把都是不可调整的，而且后背也没有可调整的支撑位置。在其他版本之中，后背的支撑处有一个可以上下滑动调整支撑腰部位置的模块。</p>\n<p>在这个版本的Sayl上，仍具备的功能有：</p>\n<ul>\n<li><p>上下高度调整</p>\n</li>\n<li><p>后仰弹力调整：</p>\n<p>椅子的靠背可以向后仰，但是后仰的角度并不能固定住，需要你施加力量。右侧有一旋钮，可以改变力量强度。你可以调整成很轻松随意一靠就能后仰，或者根本仰不动</p>\n</li>\n<li><p>后仰角度调整：</p>\n<p>你可以调整最大后仰的角度，有三种，一种是前倾，一种是后仰15度左右，另一种是后仰45度左右</p>\n</li>\n</ul>\n<h3 id=\"个人感受\"><a href=\"#个人感受\" class=\"headerlink\" title=\"个人感受\"></a>个人感受</h3><p>首先坐垫并不柔软。这是一块类硬海绵材质的坐垫，你坐下去可能它形变都不到一厘米，这方面的体验实际上不太好，整得有点像坐火车硬座。</p>\n<p>这个靠背就有点意思了，它确实能给你的腰足够的支撑。我也算是误打误撞，没有买可调整的腰部模块，但是无需调整，这张的椅子刚好支撑到了我的腰部。又因为这低配椅子没有可调节的坐垫模块，坐垫比较狭窄，我必须靠内坐才能舒服。这就导致我必须在这张椅子上坐正坐直。好在腰部支撑力足够，坐久了并不会累——除了屁股。这坐垫可太硬了。</p>\n<p>之前看到有个评测说这张椅子能矫正你的坐姿，让你在不知不觉之间坐正坐直。看来此言不虚。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>因为疫情原因，公司决定work from home，给所有员工400刀的预算去买自己在家办公所需。我寻思着自己的东西都买的差的不多了，显示器是个游戏显示器不太好意思拿去报销，桌子是转租房自带的不是自己买的，家里只有一台一百刀的打印机能报销。正好Amazon上买的Amazon basic椅子并不好用，决定买张Herman Miller的椅子，试试感觉。</p>\n<p>Herman Miller的大家应该都听说过，一张$1500+的Herman Miller Embody号称程序员之梦。我个人觉得自己没这么高需求，而且工作第一桶金还没拿到呢，买这么贵的不合适，就买了一张亚马逊上最便宜的Herman Miller Sayl。这张椅子据说是很多顶级公司的会议室标配。顶级公司没去过，椅子可以先买张爽爽。</p>\n<p>个人买的是$510的版本，主要是当时我没细看它们有什么区别，直接买了张最便宜的。按论坛上说的，“Herman Miller的椅子，买就行了，不会差的”。于是我就真没看，直接买了，现在想想稍微有点后悔，还是应该稍微加点钱上高级点的版本的。</p>\n<p>Herman Miller的椅子运送都是整只装好了运送的。箱子大而沉。我琢磨着大概510刀有一半是组装费用，这么一算倒还是挺值的！</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/5B5F402D-89F2-441F-9918-490853DBA67E_1_105_c.jpeg\" alt=\"\"></p>\n<p>拆开箱子以后椅子可以直接拉出来。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/86182C54-1523-4CA6-8AC9-2DFE4A8889D3_1_105_c.jpeg\" alt=\"\"></p>\n<p>从箱子里拿出来后的Herman Miller Sayl</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/E9E8D6E2-A252-41AA-BFAF-D82F546DFCE9_1_105_c.jpeg\" alt=\"\"></p>\n<p>这个版本是Stationary Seat Depth and Arms，也就是说坐垫和手把都是不可调整的，而且后背也没有可调整的支撑位置。在其他版本之中，后背的支撑处有一个可以上下滑动调整支撑腰部位置的模块。</p>\n<p>在这个版本的Sayl上，仍具备的功能有：</p>\n<ul>\n<li><p>上下高度调整</p>\n</li>\n<li><p>后仰弹力调整：</p>\n<p>椅子的靠背可以向后仰，但是后仰的角度并不能固定住，需要你施加力量。右侧有一旋钮，可以改变力量强度。你可以调整成很轻松随意一靠就能后仰，或者根本仰不动</p>\n</li>\n<li><p>后仰角度调整：</p>\n<p>你可以调整最大后仰的角度，有三种，一种是前倾，一种是后仰15度左右，另一种是后仰45度左右</p>\n</li>\n</ul>\n<h3 id=\"个人感受\"><a href=\"#个人感受\" class=\"headerlink\" title=\"个人感受\"></a>个人感受</h3><p>首先坐垫并不柔软。这是一块类硬海绵材质的坐垫，你坐下去可能它形变都不到一厘米，这方面的体验实际上不太好，整得有点像坐火车硬座。</p>\n<p>这个靠背就有点意思了，它确实能给你的腰足够的支撑。我也算是误打误撞，没有买可调整的腰部模块，但是无需调整，这张的椅子刚好支撑到了我的腰部。又因为这低配椅子没有可调节的坐垫模块，坐垫比较狭窄，我必须靠内坐才能舒服。这就导致我必须在这张椅子上坐正坐直。好在腰部支撑力足够，坐久了并不会累——除了屁股。这坐垫可太硬了。</p>\n<p>之前看到有个评测说这张椅子能矫正你的坐姿，让你在不知不觉之间坐正坐直。看来此言不虚。</p>\n"},{"layout":"post","title":"MongoDB快速入门","date":"2020-03-23T18:51:00.000Z","description":"MongoDB常用指令总结","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200323135523.png","optimized_image":null,"author":"tty","_content":"\n# Mongo与MySQL\n\nMysql数据库有什么缺陷?\n\n- 关系型数据库表结构复杂,扩展性差;\n- 需要较高的学习成本,复杂的表结构会产生更高的维护成本\n\n关系型数据库的\"连接查询\"会影响查询效率?\n\n- 会使查询效率变低\n\n连接查询效率低,为什么还要分表?\n\n- 分表可以减少数据冗余\n\n数据库可以不使用复杂的表结构么?\n\n- 可以,但要多消耗一些存储空间,mongodb(非关系型数据库)就为此而生\n\nMongo优势\n\n- mongo默认开启了新手模式,登录无需键入用户名和密码,只需要在终端输入`mongo`即可进入交互环境\n\n- mongo没有\"表\"的概念,也不用设计表(mongo使用\"集合\"存储 多个\"键值对\",取代表的功能)\n\n- mongo有数据库的概念,但可以不经创建,直接使用(类似vim编辑器创建新文件,如果新文件中未添加数据,则新文件不会保存到硬盘;与vim不同的是,如果用户添加了数据,vim需要手动确认,保存文件,mongo会自动保存数据到相应的数据库)\n\n- mongo没有mysql中\"记录\"的概念,mongo使用\"文档\"存储任意数量的\"键值对\"信息(\"记录\"中的信息受表中各字段的约束,\"文档\"可以存放任意数量的键值对)\n\n- mongo无需手动设置\"主键\",系统会自动为每一个\"文档\"自动添加\"_id\"键值对,保证数据的唯一性.\n\n### MongoDB 概念解析\n\n| SQL术语/概念 | MongoDB术语/概念 |              解释/说明              |\n| :----------: | :--------------: | :---------------------------------: |\n|   database   |     database     |               数据库                |\n|    table     |    collection    |            数据库表/集合            |\n|     row      |     document     |           数据记录行/文档           |\n|    column    |      field       |             数据字段/域             |\n|    index     |      index       |                索引                 |\n| table joins  |                  |        表连接,MongoDB不支持         |\n| primary key  |   primary key    | 主键,MongoDb自动将_id字段设置为主键 |\n\n# MongoDB基本用法\n\n## 数据库管理系统\n\n### 1.服务端\n\n- (1)开启服务\n\n  `sudo service mongod start`\n- (2)重启服务\n\n  `sudo service mongod restart`\n- (3)关闭服务\n\n  `sudo service mongod stop`\n\n### 2.客户端\n\n- (1)登录数据库\n\n  `mongo`\n- (2)退出数据库\n\n  `exit`\n\n## 数据库\n\n### 1.查看数据库\n\n`show dbs`\n\n### 2.使用数据库\n\n- 格式\n\n  use 数据库名\n- 示例\n\n  `use students`\n\n### 3.查看当前数据库\n\n`db`\n\n### 4.删除当前数据库\n\n`db.dropDatabase()`\n\n## 集合\n\n### 1.创建集合\n\n格式\n- db.createCollection(\"集合名称\")\n- db.createCollection(name, options) \n\n说明\n- name: 要创建的集合名称\n- options: 可选参数, 指定有关内存大小及索引的选项\n\n示例(创建名为`stu`的集合)\n\n- `db.createCollection(\"stu\")`\n\n### 2.查看当前数据库的集合\n\n`show collections`\n`show tables`\n\n### 3.删除集合\n\n- 格式\n  `db.集合名.drop()`\n- 示例(移除名为`stu`的文档)\n  `db.stu.drop()`\n\n## 文档\n\n### 1.插入文档\n\n- 格式\ndb.集合名.insert({})\n- 示例\n\n  `db.stu.insert({name:\"李明\",age:18,gender: true,birthday:\"1995-12-08\",height:186.6})`\n\n### 2.删除文档\n\nremove() 方法的基本语法格式如下所示：\n\n```mongo\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- query :（可选）删除的文档的条件。\n- justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。\n- writeConcern :（可选）抛出异常的级别。\n\n我们移除 name 为 '守护之心' 的文档：\n\n```mongo\n> db.gift.remove({'name':'守护之心'})\nWriteResult({ \"nRemoved\" : 1 })\n```\n\n如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：\n\n```mongo\ndb.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n```\n\n### 3.修改文档\n\nupdate() 方法用于更新已存在的文档。语法格式如下：\n\n```mongo\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- query : update的查询条件，类似sql update查询内where后面的。\n- update : update的对象和一些更新的操作符（如inc...）等，也可以理解为sql update查询内set后面的\n- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n- multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。\n\n我们在集合 gift 中插入如下数据：\n\n```mongo\n>db.gift.insert({\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"10\"\n})\n```\n\n接着我们通过 update() 方法来更新礼物价格(price),并查看，更新成功:\n\n```mongo\n> db.gift.update({'id':'1'},{$set:{'price':'888'}})\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })\n> db.gift.find().pretty()\n{\n\t\"_id\" : ObjectId(\"5d1a9e46b35668bf92c989e3\"),\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"888\"\n}\n```\n\n### 4.查询文档\n\nMongoDB 查询数据的语法格式如下：\n\n```mongo\ndb.collection.find(query, projection)\n```\n\n参数说明：\n\n- query ：可选，使用查询操作符指定查询条件\n- projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：\n\n```mongo\ndb.collection.find(query, projection).pretty()\n```\n\n以下实例我们查询了集合 col 中的数据：\n\n```mongo\ndb.gift.find().pretty();\n{\n\t\"_id\" : ObjectId(\"5d1951a6659f4eaa30bac84f\"),\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"10\"\n}\n```\n\n## 条件操作符\n\n条件操作符用于比较两个表达式并从mongoDB集合中获取数据。\n\nMongoDB中条件操作符有：\n\n- (>) 大于 - $gt\n- (<) 小于 - $lt\n- (>=) 大于等于 - $gte\n- (<= ) 小于等于 - $lte\n\n## $type操作符\n\n$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。\n\nMongoDB 中可以使用的类型如下表所示：\n\n| **类型**                | **数字** | **备注**         |\n| :---------------------- | :------- | :--------------- |\n| Double                  | 1        |                  |\n| String                  | 2        |                  |\n| Object                  | 3        |                  |\n| Array                   | 4        |                  |\n| Binary data             | 5        |                  |\n| Undefined               | 6        | 已废弃。         |\n| Object id               | 7        |                  |\n| Boolean                 | 8        |                  |\n| Date                    | 9        |                  |\n| Null                    | 10       |                  |\n| Regular Expression      | 11       |                  |\n| JavaScript              | 13       |                  |\n| Symbol                  | 14       |                  |\n| JavaScript (with scope) | 15       |                  |\n| 32-bit integer          | 16       |                  |\n| Timestamp               | 17       |                  |\n| 64-bit integer          | 18       |                  |\n| Min key                 | 255      | Query with `-1`. |\n| Max key                 | 127      |                  |\n\n**我们使用的数据库名称为\"runoob\" 我们的集合名称为\"col\"，以下为我们插入的数据。**\n\n简单的集合\"col\"：\n\n```\n>db.col.insert({\n    title: 'PHP 教程', \n    description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['php'],\n    likes: 200\n})\n```\n\n\n\n```\n>db.col.insert({title: 'Java 教程', \n    description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['java'],\n    likes: 150\n})\n```\n\n\n\n```\n>db.col.insert({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb'],\n    likes: 100\n})\n```\n\n使用find()命令查看数据：\n\n```json\n> db.col.find()\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n\n\n### MongoDB 操作符 - $type 实例\n\n如果想获取 \"col\" 集合中 title 为 String 的数据，你可以使用以下命令：\n\n```mongo\ndb.col.find({\"title\" : {$type : 2}})\n或\ndb.col.find({\"title\" : {$type : 'string'}})\n```\n\n输出结果为：\n\n```json\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n## MongoDB 常用方法\n\n### MongoDB Limit() 方法\n\n如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。\n\n#### 语法\n\nlimit()方法基本语法如下所示：\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\n\n#### 实例\n\n集合 col 中的数据如下：\n\n```json\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n以下实例为显示查询文档中的两条记录：\n\n```\n> db.col.find({},{\"title\":1,_id:0}).limit(2)\n{ \"title\" : \"PHP 教程\" }\n{ \"title\" : \"Java 教程\" }\n>\n```\n\n注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。\n\n------\n\n### MongoDB Skip() 方法\n\n我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。\n\n#### 语法\n\nskip() 方法脚本语法格式如下：\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\n\n#### 实例\n\n以下实例只会显示第二条文档数据\n\n```\n>db.col.find({},{\"title\":1,_id:0}).limit(1).skip(1)\n{ \"title\" : \"Java 教程\" }\n>\n```\n\n**注:**skip()方法默认参数为 0 。\n\n### MongoDB sort() 方法\n\n在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n\n#### 语法\n\nsort()方法基本语法如下所示：\n\n```\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n\n# MongoDB 索引\n\n索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。\n\n这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。\n\n索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构\n\n## createIndex() 方法\n\nMongoDB使用 createIndex() 方法来创建索引。\n\n> 注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。\n\n### 语法\n\ncreateIndex()方法基本语法格式如下所示：\n\n```\n>db.collection.createIndex(keys, options)\n```\n\n语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。\n\n### 实例\n\n```\n>db.col.createIndex({\"title\":1})\n```\n\ncreateIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。\n\n```\n>db.col.createIndex({\"title\":1,\"description\":-1})\n```\n\ncreateIndex() 接收可选参数，可选参数列表如下：\n\n| Parameter          | Type          | Description                                                  |\n| :----------------- | :------------ | :----------------------------------------------------------- |\n| background         | Boolean       | 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \"background\" 可选参数。 \"background\" 默认值为**false**。 |\n| unique             | Boolean       | 建立的索引是否唯一。指定为true创建唯一索引。默认值为**false**. |\n| name               | string        | 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 |\n| dropDups           | Boolean       | **3.0+版本已废弃。**在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 **false**. |\n| sparse             | Boolean       | 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 **false**. |\n| expireAfterSeconds | integer       | 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 |\n| v                  | index version | 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 |\n| weights            | document      | 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 |\n| default_language   | string        | 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 |\n| language_override  | string        | 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. |\n\n### 实例\n\n在后台创建索引：\n\n```\ndb.values.createIndex({open: 1, close: 1}, {background: true})\n```\n\n通过在创建索引时加 background:true 的选项，让创建工作在后台执行\n\n# MongoDB 聚合\n\nMongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n\n## aggregate() 方法\n\nMongoDB中聚合的方法使用aggregate()。\n\n### 语法\n\naggregate() 方法的基本语法格式如下所示：\n\n```\n>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n```\n\n### 实例\n\n集合中的数据如下：\n\n```json\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by_user: 'runoob.com',\n   url: 'http://www.runoob.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n},\n{\n   _id: ObjectId(7df78ad8902d)\n   title: 'NoSQL Overview', \n   description: 'No sql database is very fast',\n   by_user: 'runoob.com',\n   url: 'http://www.runoob.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 10\n},\n{\n   _id: ObjectId(7df78ad8902e)\n   title: 'Neo4j Overview', \n   description: 'Neo4j is no sql database',\n   by_user: 'Neo4j',\n   url: 'http://www.neo4j.com',\n   tags: ['neo4j', 'database', 'NoSQL'],\n   likes: 750\n},\n```\n\n现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：\n\n```\n> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}])\n{\n   \"result\" : [\n      {\n         \"_id\" : \"runoob.com\",\n         \"num_tutorial\" : 2\n      },\n      {\n         \"_id\" : \"Neo4j\",\n         \"num_tutorial\" : 1\n      }\n   ],\n   \"ok\" : 1\n}\n>\n```\n\n以上实例类似sql语句：\n\n```\n select by_user, count(*) from mycol group by by_user\n```\n\n在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。\n\n下表展示了一些聚合的表达式:\n\n| 表达式    | 描述                                           | 实例                                                         |\n| :-------- | :--------------------------------------------- | :----------------------------------------------------------- |\n| $sum      | 计算总和。                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}]) |\n| $avg      | 计算平均值                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}]) |\n| $min      | 获取集合中所有文档对应值得最小值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}]) |\n| $max      | 获取集合中所有文档对应值得最大值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}]) |\n| $push     | 在结果文档中插入值到一个数组中。               | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}]) |\n| $addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}]) |\n| $first    | 根据资源文档的排序获取第一个文档数据。         | db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}]) |\n| $last     | 根据资源文档的排序获取最后一个文档数据         | db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}]) |\n\n## 管道的概念\n\n管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。\n\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。\n\n表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。\n\n这里我们介绍一下聚合框架中常用的几个操作：\n\n- $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。\n- $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。\n- $limit：用来限制MongoDB聚合管道返回的文档数。\n- $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。\n- $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。\n- $group：将集合中的文档分组，可用于统计结果。\n- $sort：将输入文档排序后输出。\n- $geoNear：输出接近某一地理位置的有序文档。\n\n### 管道操作符实例\n\n1、$project实例\n\n```\ndb.article.aggregate(\n    { $project : {\n        title : 1 ,\n        author : 1 ,\n    }}\n );\n```\n\n这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:\n\n```\ndb.article.aggregate(\n    { $project : {\n        _id : 0 ,\n        title : 1 ,\n        author : 1\n    }});\n```\n\n2.$match实例\n\n```\ndb.articles.aggregate( [\n                        { $match : { score : { $gt : 70, $lte : 90 } } },\n                        { $group: { _id: null, count: { $sum: 1 } } }\n                       ] );\n```\n\n$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。\n\n3.$skip实例\n\n```\ndb.article.aggregate(\n    { $skip : 5 });\n```\n\n经过$skip管道操作符处理后，前五个文档被\"过滤\"掉。\n\n# MongoDB 分片\n\n## 分片\n\n在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。\n\n当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。\n\n## 为什么使用分片\n\n- 复制所有的写入操作到主节点\n- 延迟的敏感数据会在主节点查询\n- 单个副本集限制在12个节点\n- 当请求量巨大时会出现内存不足。\n- 本地磁盘不足\n- 垂直扩展价格昂贵\n\n## MongoDB分片\n\n下图展示了在MongoDB中使用分片集群结构分布：\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323133206.png)\n\n上图中主要有如下所述三个主要组件：\n\n- Shard:\n\n  用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障\n\n- Config Server:\n\n  mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。\n\n- Query Routers:\n\n  前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。\n\n## 分片实例\n\n分片结构端口分布如下：\n\n```\nShard Server 1：27020\nShard Server 2：27021\nShard Server 3：27022\nShard Server 4：27023\nConfig Server ：27100\nRoute Process：40000\n```\n\n步骤一：启动Shard Server\n\n```\n[root@100 /]# mkdir -p /www/mongoDB/shard/s0\n[root@100 /]# mkdir -p /www/mongoDB/shard/s1\n[root@100 /]# mkdir -p /www/mongoDB/shard/s2\n[root@100 /]# mkdir -p /www/mongoDB/shard/s3\n[root@100 /]# mkdir -p /www/mongoDB/shard/log\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27020 --dbpath=/www/mongoDB/shard/s0 --logpath=/www/mongoDB/shard/log/s0.log --logappend --fork\n....\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27023 --dbpath=/www/mongoDB/shard/s3 --logpath=/www/mongoDB/shard/log/s3.log --logappend --fork\n```\n\n步骤二： 启动Config Server\n\n```\n[root@100 /]# mkdir -p /www/mongoDB/shard/config\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27100 --dbpath=/www/mongoDB/shard/config --logpath=/www/mongoDB/shard/log/config.log --logappend --fork\n```\n\n**注意：**这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。\n\n步骤三： 启动Route Process\n\n```\n/usr/local/mongoDB/bin/mongos --port 40000 --configdb localhost:27100 --fork --logpath=/www/mongoDB/shard/log/route.log --chunkSize 500\n```\n\nmongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.\n\n步骤四： 配置Sharding\n\n接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点\n\n```\n[root@100 shard]# /usr/local/mongoDB/bin/mongo admin --port 40000\nMongoDB shell version: 2.0.7\nconnecting to: 127.0.0.1:40000/admin\nmongos> db.runCommand({ addshard:\"localhost:27020\" })\n{ \"shardAdded\" : \"shard0000\", \"ok\" : 1 }\n......\nmongos> db.runCommand({ addshard:\"localhost:27029\" })\n{ \"shardAdded\" : \"shard0009\", \"ok\" : 1 }\nmongos> db.runCommand({ enablesharding:\"test\" }) #设置分片存储的数据库\n{ \"ok\" : 1 }\nmongos> db.runCommand({ shardcollection: \"test.log\", key: { id:1,time:1}})\n{ \"collectionsharded\" : \"test.log\", \"ok\" : 1 }\n```\n\n步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000\n\n# Node.js 连接 MongoDB\n\nMongoDB是一种文档导向数据库管理系统，由C++撰写而成。\n\n本章节我们将为大家介绍如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。\n\n## 安装驱动\n\n```\n$ npm install mongodb\n```\n\n接下来我们来实现增删改查功能。\n\n## 创建数据库\n\n要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。\n\n如果数据库不存在，MongoDB 将创建数据库并建立连接。\n\n#### 创建连接\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/runoob\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  console.log(\"数据库已创建!\");\n  db.close();\n});\n```\n\n## 创建集合\n\n我们可以使用 createCollection() 方法来创建集合：\n\n#### 创建集合\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = 'mongodb://localhost:27017/runoob';\nMongoClient.connect(url, { useNewUrlParser: true }, function (err, db) {\n    if (err) throw err;\n    console.log('数据库已创建');\n    var dbase = db.db(\"runoob\");\n    dbase.createCollection('site', function (err, res) {\n        if (err) throw err;\n        console.log(\"创建集合!\");\n        db.close();\n    });\n});\n```\n\n## 数据库操作( CURD )\n\n与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。\n\n### 插入数据\n\n以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 **insertOne()**：\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj = { name: \"菜鸟教程\", url: \"www.runoob\" };\n    dbo.collection(\"site\").insertOne(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档插入成功\");\n        db.close();\n    });\n});\n```\n\n输出结果\n\n```bash\n$ node test.js\n文档插入成功\n```\n\n\n\n#### 插入一条数据\n\nvar MongoClient = require('mongodb').MongoClient; var url = \"mongodb://localhost:27017/\";  MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {    if (err) throw err;    var dbo = db.db(\"runoob\");    var myobj = { name: \"菜鸟教程\", url: \"www.runoob\" };    dbo.collection(\"site\").insertOne(myobj, function(err, res) {        if (err) throw err;        console.log(\"文档插入成功\");        db.close();    }); });\n\n执行以下命令输出就结果为：\n\n```\n$ node test.js\n文档插入成功\n```\n\n从输出结果来看，数据已插入成功。\n\n我们也可以打开 MongoDB 的客户端查看数据，如：\n\n```\n> show dbs\nrunoob  0.000GB          # 自动创建了 runoob 数据库\n> show tables\nsite                     # 自动创建了 site 集合（数据表）\n> db.site.find()\n{ \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"), \"name\" : \"菜鸟教程\", \"url\" : \"www.runoob\" }\n```\n\n如果要插入多条数据可以使用 **insertMany()**：\n\n## 插入多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj =  [\n        { name: '菜鸟工具', url: 'https://c.runoob.com', type: 'cn'},\n        { name: 'Google', url: 'https://www.google.com', type: 'en'},\n        { name: 'Facebook', url: 'https://www.google.com', type: 'en'}\n       ];\n    dbo.collection(\"site\").insertMany(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"插入的文档数量为: \" + res.insertedCount);\n        db.close();\n    });\n});\n```\n\nres.insertedCount 为插入的条数。\n\n### 查询数据\n\n可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\"). find({}).toArray(function(err, result) { // 返回集合中所有数据\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n以下实例检索 name 为 \"菜鸟教程\" 的实例：\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n     var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    dbo.collection(\"site\").find(whereStr).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n结果：\n\n```json\n[ { _id: 5a794e36763eb821b24db854,\n    name: '菜鸟教程',\n    url: 'www.runoob' } ]\n```\n\n### 更新数据\n\n我们也可以对数据库的数据进行修改，以下实例将 name 为 \"菜鸟教程\" 的 url 改为 https://www.runoob.com：\n\n```javascript\n更新一条数据\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档更新成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已修改：\n\n```\n> db.site.find().pretty()\n{\n    \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"),\n    \"name\" : \"菜鸟教程\",\n    \"url\" : \"https://www.runoob.com\"     // 已修改为 https\n}\n```\n\n如果要更新所有符合条的文档数据可以使用 **updateMany()**：\n\n#### 更新多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"type\":'en'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n         console.log(res.result.nModified + \" 条文档被更新\");\n        db.close();\n    });\n});\n```\n\nresult.nModified 为更新的条数。\n\n### 删除数据\n\n以下实例将 name 为 \"菜鸟教程\" 的数据删除 :\n\n#### 删除一条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    dbo.collection(\"site\").deleteOne(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(\"文档删除成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已删除：\n\n```\n> db.site.find()\n> \n```\n\n如果要删除多条语句可以使用 **deleteMany()** 方法\n\n以下实例将 type 为 en 的所有数据删除 :\n\n#### 删除多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = { type: \"en\" };  // 查询条件\n    dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(obj.result.n + \" 条文档被删除\");\n        db.close();\n    });\n});\n```\n\nobj.result.n 删除的条数。\n\n### 排序\n\n排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。\n\n例如：\n\n```\n{ type: 1 }  // 按 type 字段升序\n{ type: -1 } // 按 type 字段降序\n```\n\n按 type 升序排列:\n\n#### 排序\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var mysort = { type: 1 };\n    dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n### 查询分页\n\n如果要设置指定的返回条数可以使用 **limit()** 方法，该方法只接受一个参数，指定了返回的条数。\n\n#### limit()：读取两条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n\n\n如果要指定跳过的条数，可以使用 **skip()** 方法。\n\n#### skip(): 跳过前面两条数据，读取两条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n### 连接操作\n\nmongoDB 不是一个关系型数据库，但我们可以使用 **$lookup** 来实现左连接。\n\n例如我们有两个集合数据分别为：\n\n集合1：orders\n\n```\n[\n  { _id: 1, product_id: 154, status: 1 }\n]\n```\n\n集合2：products\n\n```\n[\n  { _id: 154, name: '笔记本电脑' },\n  { _id: 155, name: '耳机' },\n  { _id: 156, name: '台式电脑' }\n]\n```\n\n#### $lookup 实现左连接\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://127.0.0.1:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  var dbo = db.db(\"runoob\");\n  dbo.collection('orders').aggregate([\n    { $lookup:\n       {\n         from: 'products',            // 右集合\n         localField: 'product_id',    // 左集合 join 字段\n         foreignField: '_id',         // 右集合 join 字段\n         as: 'orderdetails'           // 新生成字段（类型array）\n       }\n     }\n    ]).toArray(function(err, res) {\n    if (err) throw err;\n    console.log(JSON.stringify(res));\n    db.close();\n  });\n});\n```\n\n### 删除集合\n\n我们可以使用 **drop()** 方法来删除集合：\n\n#### drop()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    // 删除 test 集合\n    dbo.collection(\"test\").drop(function(err, delOK) {  // 执行成功 delOK 返回 true，否则返回 false\n        if (err) throw err;\n        if (delOK) console.log(\"集合已删除\");\n        db.close();\n    });\n});\n```\n\n# reference\n\n1. 作者：Jay_huaxiao\n   链接：https://juejin.im/post/5d1883a05188255eea62e096\n   来源：掘金\n\n2. 作者：zhaoolee\n   链接：https://www.jianshu.com/p/a95c6b21c382\n   来源：简书\n\n3. 来源：菜鸟教程","source":"_posts/2020-03-23-MongoDB快速入门.md","raw":"---\nlayout: post\ntitle:  MongoDB快速入门\ndate:   2020-03-23 11:51:00\ndescription: MongoDB常用指令总结\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200323135523.png\noptimized_image: \ncategory: database\ntags:\n  - tutorial\n  - code\n  - database\nauthor: tty\n---\n\n# Mongo与MySQL\n\nMysql数据库有什么缺陷?\n\n- 关系型数据库表结构复杂,扩展性差;\n- 需要较高的学习成本,复杂的表结构会产生更高的维护成本\n\n关系型数据库的\"连接查询\"会影响查询效率?\n\n- 会使查询效率变低\n\n连接查询效率低,为什么还要分表?\n\n- 分表可以减少数据冗余\n\n数据库可以不使用复杂的表结构么?\n\n- 可以,但要多消耗一些存储空间,mongodb(非关系型数据库)就为此而生\n\nMongo优势\n\n- mongo默认开启了新手模式,登录无需键入用户名和密码,只需要在终端输入`mongo`即可进入交互环境\n\n- mongo没有\"表\"的概念,也不用设计表(mongo使用\"集合\"存储 多个\"键值对\",取代表的功能)\n\n- mongo有数据库的概念,但可以不经创建,直接使用(类似vim编辑器创建新文件,如果新文件中未添加数据,则新文件不会保存到硬盘;与vim不同的是,如果用户添加了数据,vim需要手动确认,保存文件,mongo会自动保存数据到相应的数据库)\n\n- mongo没有mysql中\"记录\"的概念,mongo使用\"文档\"存储任意数量的\"键值对\"信息(\"记录\"中的信息受表中各字段的约束,\"文档\"可以存放任意数量的键值对)\n\n- mongo无需手动设置\"主键\",系统会自动为每一个\"文档\"自动添加\"_id\"键值对,保证数据的唯一性.\n\n### MongoDB 概念解析\n\n| SQL术语/概念 | MongoDB术语/概念 |              解释/说明              |\n| :----------: | :--------------: | :---------------------------------: |\n|   database   |     database     |               数据库                |\n|    table     |    collection    |            数据库表/集合            |\n|     row      |     document     |           数据记录行/文档           |\n|    column    |      field       |             数据字段/域             |\n|    index     |      index       |                索引                 |\n| table joins  |                  |        表连接,MongoDB不支持         |\n| primary key  |   primary key    | 主键,MongoDb自动将_id字段设置为主键 |\n\n# MongoDB基本用法\n\n## 数据库管理系统\n\n### 1.服务端\n\n- (1)开启服务\n\n  `sudo service mongod start`\n- (2)重启服务\n\n  `sudo service mongod restart`\n- (3)关闭服务\n\n  `sudo service mongod stop`\n\n### 2.客户端\n\n- (1)登录数据库\n\n  `mongo`\n- (2)退出数据库\n\n  `exit`\n\n## 数据库\n\n### 1.查看数据库\n\n`show dbs`\n\n### 2.使用数据库\n\n- 格式\n\n  use 数据库名\n- 示例\n\n  `use students`\n\n### 3.查看当前数据库\n\n`db`\n\n### 4.删除当前数据库\n\n`db.dropDatabase()`\n\n## 集合\n\n### 1.创建集合\n\n格式\n- db.createCollection(\"集合名称\")\n- db.createCollection(name, options) \n\n说明\n- name: 要创建的集合名称\n- options: 可选参数, 指定有关内存大小及索引的选项\n\n示例(创建名为`stu`的集合)\n\n- `db.createCollection(\"stu\")`\n\n### 2.查看当前数据库的集合\n\n`show collections`\n`show tables`\n\n### 3.删除集合\n\n- 格式\n  `db.集合名.drop()`\n- 示例(移除名为`stu`的文档)\n  `db.stu.drop()`\n\n## 文档\n\n### 1.插入文档\n\n- 格式\ndb.集合名.insert({})\n- 示例\n\n  `db.stu.insert({name:\"李明\",age:18,gender: true,birthday:\"1995-12-08\",height:186.6})`\n\n### 2.删除文档\n\nremove() 方法的基本语法格式如下所示：\n\n```mongo\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- query :（可选）删除的文档的条件。\n- justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。\n- writeConcern :（可选）抛出异常的级别。\n\n我们移除 name 为 '守护之心' 的文档：\n\n```mongo\n> db.gift.remove({'name':'守护之心'})\nWriteResult({ \"nRemoved\" : 1 })\n```\n\n如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：\n\n```mongo\ndb.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n```\n\n### 3.修改文档\n\nupdate() 方法用于更新已存在的文档。语法格式如下：\n\n```mongo\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- query : update的查询条件，类似sql update查询内where后面的。\n- update : update的对象和一些更新的操作符（如inc...）等，也可以理解为sql update查询内set后面的\n- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n- multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。\n\n我们在集合 gift 中插入如下数据：\n\n```mongo\n>db.gift.insert({\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"10\"\n})\n```\n\n接着我们通过 update() 方法来更新礼物价格(price),并查看，更新成功:\n\n```mongo\n> db.gift.update({'id':'1'},{$set:{'price':'888'}})\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })\n> db.gift.find().pretty()\n{\n\t\"_id\" : ObjectId(\"5d1a9e46b35668bf92c989e3\"),\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"888\"\n}\n```\n\n### 4.查询文档\n\nMongoDB 查询数据的语法格式如下：\n\n```mongo\ndb.collection.find(query, projection)\n```\n\n参数说明：\n\n- query ：可选，使用查询操作符指定查询条件\n- projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：\n\n```mongo\ndb.collection.find(query, projection).pretty()\n```\n\n以下实例我们查询了集合 col 中的数据：\n\n```mongo\ndb.gift.find().pretty();\n{\n\t\"_id\" : ObjectId(\"5d1951a6659f4eaa30bac84f\"),\n\t\"id\" : \"1\",\n\t\"name\" : \"守护之心\",\n\t\"price\" : \"10\"\n}\n```\n\n## 条件操作符\n\n条件操作符用于比较两个表达式并从mongoDB集合中获取数据。\n\nMongoDB中条件操作符有：\n\n- (>) 大于 - $gt\n- (<) 小于 - $lt\n- (>=) 大于等于 - $gte\n- (<= ) 小于等于 - $lte\n\n## $type操作符\n\n$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。\n\nMongoDB 中可以使用的类型如下表所示：\n\n| **类型**                | **数字** | **备注**         |\n| :---------------------- | :------- | :--------------- |\n| Double                  | 1        |                  |\n| String                  | 2        |                  |\n| Object                  | 3        |                  |\n| Array                   | 4        |                  |\n| Binary data             | 5        |                  |\n| Undefined               | 6        | 已废弃。         |\n| Object id               | 7        |                  |\n| Boolean                 | 8        |                  |\n| Date                    | 9        |                  |\n| Null                    | 10       |                  |\n| Regular Expression      | 11       |                  |\n| JavaScript              | 13       |                  |\n| Symbol                  | 14       |                  |\n| JavaScript (with scope) | 15       |                  |\n| 32-bit integer          | 16       |                  |\n| Timestamp               | 17       |                  |\n| 64-bit integer          | 18       |                  |\n| Min key                 | 255      | Query with `-1`. |\n| Max key                 | 127      |                  |\n\n**我们使用的数据库名称为\"runoob\" 我们的集合名称为\"col\"，以下为我们插入的数据。**\n\n简单的集合\"col\"：\n\n```\n>db.col.insert({\n    title: 'PHP 教程', \n    description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['php'],\n    likes: 200\n})\n```\n\n\n\n```\n>db.col.insert({title: 'Java 教程', \n    description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['java'],\n    likes: 150\n})\n```\n\n\n\n```\n>db.col.insert({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb'],\n    likes: 100\n})\n```\n\n使用find()命令查看数据：\n\n```json\n> db.col.find()\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n\n\n### MongoDB 操作符 - $type 实例\n\n如果想获取 \"col\" 集合中 title 为 String 的数据，你可以使用以下命令：\n\n```mongo\ndb.col.find({\"title\" : {$type : 2}})\n或\ndb.col.find({\"title\" : {$type : 'string'}})\n```\n\n输出结果为：\n\n```json\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n## MongoDB 常用方法\n\n### MongoDB Limit() 方法\n\n如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。\n\n#### 语法\n\nlimit()方法基本语法如下所示：\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\n\n#### 实例\n\n集合 col 中的数据如下：\n\n```json\n{ \"_id\" : ObjectId(\"56066542ade2f21f36b0313a\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 }\n{ \"_id\" : ObjectId(\"56066549ade2f21f36b0313b\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 }\n{ \"_id\" : ObjectId(\"5606654fade2f21f36b0313c\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 }\n```\n\n以下实例为显示查询文档中的两条记录：\n\n```\n> db.col.find({},{\"title\":1,_id:0}).limit(2)\n{ \"title\" : \"PHP 教程\" }\n{ \"title\" : \"Java 教程\" }\n>\n```\n\n注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。\n\n------\n\n### MongoDB Skip() 方法\n\n我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。\n\n#### 语法\n\nskip() 方法脚本语法格式如下：\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\n\n#### 实例\n\n以下实例只会显示第二条文档数据\n\n```\n>db.col.find({},{\"title\":1,_id:0}).limit(1).skip(1)\n{ \"title\" : \"Java 教程\" }\n>\n```\n\n**注:**skip()方法默认参数为 0 。\n\n### MongoDB sort() 方法\n\n在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n\n#### 语法\n\nsort()方法基本语法如下所示：\n\n```\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n\n# MongoDB 索引\n\n索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。\n\n这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。\n\n索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构\n\n## createIndex() 方法\n\nMongoDB使用 createIndex() 方法来创建索引。\n\n> 注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。\n\n### 语法\n\ncreateIndex()方法基本语法格式如下所示：\n\n```\n>db.collection.createIndex(keys, options)\n```\n\n语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。\n\n### 实例\n\n```\n>db.col.createIndex({\"title\":1})\n```\n\ncreateIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。\n\n```\n>db.col.createIndex({\"title\":1,\"description\":-1})\n```\n\ncreateIndex() 接收可选参数，可选参数列表如下：\n\n| Parameter          | Type          | Description                                                  |\n| :----------------- | :------------ | :----------------------------------------------------------- |\n| background         | Boolean       | 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \"background\" 可选参数。 \"background\" 默认值为**false**。 |\n| unique             | Boolean       | 建立的索引是否唯一。指定为true创建唯一索引。默认值为**false**. |\n| name               | string        | 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 |\n| dropDups           | Boolean       | **3.0+版本已废弃。**在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 **false**. |\n| sparse             | Boolean       | 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 **false**. |\n| expireAfterSeconds | integer       | 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 |\n| v                  | index version | 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 |\n| weights            | document      | 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 |\n| default_language   | string        | 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 |\n| language_override  | string        | 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. |\n\n### 实例\n\n在后台创建索引：\n\n```\ndb.values.createIndex({open: 1, close: 1}, {background: true})\n```\n\n通过在创建索引时加 background:true 的选项，让创建工作在后台执行\n\n# MongoDB 聚合\n\nMongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n\n## aggregate() 方法\n\nMongoDB中聚合的方法使用aggregate()。\n\n### 语法\n\naggregate() 方法的基本语法格式如下所示：\n\n```\n>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n```\n\n### 实例\n\n集合中的数据如下：\n\n```json\n{\n   _id: ObjectId(7df78ad8902c)\n   title: 'MongoDB Overview', \n   description: 'MongoDB is no sql database',\n   by_user: 'runoob.com',\n   url: 'http://www.runoob.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 100\n},\n{\n   _id: ObjectId(7df78ad8902d)\n   title: 'NoSQL Overview', \n   description: 'No sql database is very fast',\n   by_user: 'runoob.com',\n   url: 'http://www.runoob.com',\n   tags: ['mongodb', 'database', 'NoSQL'],\n   likes: 10\n},\n{\n   _id: ObjectId(7df78ad8902e)\n   title: 'Neo4j Overview', \n   description: 'Neo4j is no sql database',\n   by_user: 'Neo4j',\n   url: 'http://www.neo4j.com',\n   tags: ['neo4j', 'database', 'NoSQL'],\n   likes: 750\n},\n```\n\n现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：\n\n```\n> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}])\n{\n   \"result\" : [\n      {\n         \"_id\" : \"runoob.com\",\n         \"num_tutorial\" : 2\n      },\n      {\n         \"_id\" : \"Neo4j\",\n         \"num_tutorial\" : 1\n      }\n   ],\n   \"ok\" : 1\n}\n>\n```\n\n以上实例类似sql语句：\n\n```\n select by_user, count(*) from mycol group by by_user\n```\n\n在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。\n\n下表展示了一些聚合的表达式:\n\n| 表达式    | 描述                                           | 实例                                                         |\n| :-------- | :--------------------------------------------- | :----------------------------------------------------------- |\n| $sum      | 计算总和。                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}]) |\n| $avg      | 计算平均值                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}]) |\n| $min      | 获取集合中所有文档对应值得最小值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}]) |\n| $max      | 获取集合中所有文档对应值得最大值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}]) |\n| $push     | 在结果文档中插入值到一个数组中。               | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}]) |\n| $addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}]) |\n| $first    | 根据资源文档的排序获取第一个文档数据。         | db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}]) |\n| $last     | 根据资源文档的排序获取最后一个文档数据         | db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}]) |\n\n## 管道的概念\n\n管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。\n\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。\n\n表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。\n\n这里我们介绍一下聚合框架中常用的几个操作：\n\n- $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。\n- $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。\n- $limit：用来限制MongoDB聚合管道返回的文档数。\n- $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。\n- $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。\n- $group：将集合中的文档分组，可用于统计结果。\n- $sort：将输入文档排序后输出。\n- $geoNear：输出接近某一地理位置的有序文档。\n\n### 管道操作符实例\n\n1、$project实例\n\n```\ndb.article.aggregate(\n    { $project : {\n        title : 1 ,\n        author : 1 ,\n    }}\n );\n```\n\n这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:\n\n```\ndb.article.aggregate(\n    { $project : {\n        _id : 0 ,\n        title : 1 ,\n        author : 1\n    }});\n```\n\n2.$match实例\n\n```\ndb.articles.aggregate( [\n                        { $match : { score : { $gt : 70, $lte : 90 } } },\n                        { $group: { _id: null, count: { $sum: 1 } } }\n                       ] );\n```\n\n$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。\n\n3.$skip实例\n\n```\ndb.article.aggregate(\n    { $skip : 5 });\n```\n\n经过$skip管道操作符处理后，前五个文档被\"过滤\"掉。\n\n# MongoDB 分片\n\n## 分片\n\n在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。\n\n当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。\n\n## 为什么使用分片\n\n- 复制所有的写入操作到主节点\n- 延迟的敏感数据会在主节点查询\n- 单个副本集限制在12个节点\n- 当请求量巨大时会出现内存不足。\n- 本地磁盘不足\n- 垂直扩展价格昂贵\n\n## MongoDB分片\n\n下图展示了在MongoDB中使用分片集群结构分布：\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/20200323133206.png)\n\n上图中主要有如下所述三个主要组件：\n\n- Shard:\n\n  用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障\n\n- Config Server:\n\n  mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。\n\n- Query Routers:\n\n  前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。\n\n## 分片实例\n\n分片结构端口分布如下：\n\n```\nShard Server 1：27020\nShard Server 2：27021\nShard Server 3：27022\nShard Server 4：27023\nConfig Server ：27100\nRoute Process：40000\n```\n\n步骤一：启动Shard Server\n\n```\n[root@100 /]# mkdir -p /www/mongoDB/shard/s0\n[root@100 /]# mkdir -p /www/mongoDB/shard/s1\n[root@100 /]# mkdir -p /www/mongoDB/shard/s2\n[root@100 /]# mkdir -p /www/mongoDB/shard/s3\n[root@100 /]# mkdir -p /www/mongoDB/shard/log\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27020 --dbpath=/www/mongoDB/shard/s0 --logpath=/www/mongoDB/shard/log/s0.log --logappend --fork\n....\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27023 --dbpath=/www/mongoDB/shard/s3 --logpath=/www/mongoDB/shard/log/s3.log --logappend --fork\n```\n\n步骤二： 启动Config Server\n\n```\n[root@100 /]# mkdir -p /www/mongoDB/shard/config\n[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27100 --dbpath=/www/mongoDB/shard/config --logpath=/www/mongoDB/shard/log/config.log --logappend --fork\n```\n\n**注意：**这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。\n\n步骤三： 启动Route Process\n\n```\n/usr/local/mongoDB/bin/mongos --port 40000 --configdb localhost:27100 --fork --logpath=/www/mongoDB/shard/log/route.log --chunkSize 500\n```\n\nmongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.\n\n步骤四： 配置Sharding\n\n接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点\n\n```\n[root@100 shard]# /usr/local/mongoDB/bin/mongo admin --port 40000\nMongoDB shell version: 2.0.7\nconnecting to: 127.0.0.1:40000/admin\nmongos> db.runCommand({ addshard:\"localhost:27020\" })\n{ \"shardAdded\" : \"shard0000\", \"ok\" : 1 }\n......\nmongos> db.runCommand({ addshard:\"localhost:27029\" })\n{ \"shardAdded\" : \"shard0009\", \"ok\" : 1 }\nmongos> db.runCommand({ enablesharding:\"test\" }) #设置分片存储的数据库\n{ \"ok\" : 1 }\nmongos> db.runCommand({ shardcollection: \"test.log\", key: { id:1,time:1}})\n{ \"collectionsharded\" : \"test.log\", \"ok\" : 1 }\n```\n\n步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000\n\n# Node.js 连接 MongoDB\n\nMongoDB是一种文档导向数据库管理系统，由C++撰写而成。\n\n本章节我们将为大家介绍如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。\n\n## 安装驱动\n\n```\n$ npm install mongodb\n```\n\n接下来我们来实现增删改查功能。\n\n## 创建数据库\n\n要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。\n\n如果数据库不存在，MongoDB 将创建数据库并建立连接。\n\n#### 创建连接\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/runoob\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  console.log(\"数据库已创建!\");\n  db.close();\n});\n```\n\n## 创建集合\n\n我们可以使用 createCollection() 方法来创建集合：\n\n#### 创建集合\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = 'mongodb://localhost:27017/runoob';\nMongoClient.connect(url, { useNewUrlParser: true }, function (err, db) {\n    if (err) throw err;\n    console.log('数据库已创建');\n    var dbase = db.db(\"runoob\");\n    dbase.createCollection('site', function (err, res) {\n        if (err) throw err;\n        console.log(\"创建集合!\");\n        db.close();\n    });\n});\n```\n\n## 数据库操作( CURD )\n\n与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。\n\n### 插入数据\n\n以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 **insertOne()**：\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj = { name: \"菜鸟教程\", url: \"www.runoob\" };\n    dbo.collection(\"site\").insertOne(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档插入成功\");\n        db.close();\n    });\n});\n```\n\n输出结果\n\n```bash\n$ node test.js\n文档插入成功\n```\n\n\n\n#### 插入一条数据\n\nvar MongoClient = require('mongodb').MongoClient; var url = \"mongodb://localhost:27017/\";  MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {    if (err) throw err;    var dbo = db.db(\"runoob\");    var myobj = { name: \"菜鸟教程\", url: \"www.runoob\" };    dbo.collection(\"site\").insertOne(myobj, function(err, res) {        if (err) throw err;        console.log(\"文档插入成功\");        db.close();    }); });\n\n执行以下命令输出就结果为：\n\n```\n$ node test.js\n文档插入成功\n```\n\n从输出结果来看，数据已插入成功。\n\n我们也可以打开 MongoDB 的客户端查看数据，如：\n\n```\n> show dbs\nrunoob  0.000GB          # 自动创建了 runoob 数据库\n> show tables\nsite                     # 自动创建了 site 集合（数据表）\n> db.site.find()\n{ \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"), \"name\" : \"菜鸟教程\", \"url\" : \"www.runoob\" }\n```\n\n如果要插入多条数据可以使用 **insertMany()**：\n\n## 插入多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj =  [\n        { name: '菜鸟工具', url: 'https://c.runoob.com', type: 'cn'},\n        { name: 'Google', url: 'https://www.google.com', type: 'en'},\n        { name: 'Facebook', url: 'https://www.google.com', type: 'en'}\n       ];\n    dbo.collection(\"site\").insertMany(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"插入的文档数量为: \" + res.insertedCount);\n        db.close();\n    });\n});\n```\n\nres.insertedCount 为插入的条数。\n\n### 查询数据\n\n可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\"). find({}).toArray(function(err, result) { // 返回集合中所有数据\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n以下实例检索 name 为 \"菜鸟教程\" 的实例：\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n     var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    dbo.collection(\"site\").find(whereStr).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n结果：\n\n```json\n[ { _id: 5a794e36763eb821b24db854,\n    name: '菜鸟教程',\n    url: 'www.runoob' } ]\n```\n\n### 更新数据\n\n我们也可以对数据库的数据进行修改，以下实例将 name 为 \"菜鸟教程\" 的 url 改为 https://www.runoob.com：\n\n```javascript\n更新一条数据\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档更新成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已修改：\n\n```\n> db.site.find().pretty()\n{\n    \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"),\n    \"name\" : \"菜鸟教程\",\n    \"url\" : \"https://www.runoob.com\"     // 已修改为 https\n}\n```\n\n如果要更新所有符合条的文档数据可以使用 **updateMany()**：\n\n#### 更新多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"type\":'en'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n         console.log(res.result.nModified + \" 条文档被更新\");\n        db.close();\n    });\n});\n```\n\nresult.nModified 为更新的条数。\n\n### 删除数据\n\n以下实例将 name 为 \"菜鸟教程\" 的数据删除 :\n\n#### 删除一条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    dbo.collection(\"site\").deleteOne(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(\"文档删除成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已删除：\n\n```\n> db.site.find()\n> \n```\n\n如果要删除多条语句可以使用 **deleteMany()** 方法\n\n以下实例将 type 为 en 的所有数据删除 :\n\n#### 删除多条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = { type: \"en\" };  // 查询条件\n    dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(obj.result.n + \" 条文档被删除\");\n        db.close();\n    });\n});\n```\n\nobj.result.n 删除的条数。\n\n### 排序\n\n排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。\n\n例如：\n\n```\n{ type: 1 }  // 按 type 字段升序\n{ type: -1 } // 按 type 字段降序\n```\n\n按 type 升序排列:\n\n#### 排序\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var mysort = { type: 1 };\n    dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n### 查询分页\n\n如果要设置指定的返回条数可以使用 **limit()** 方法，该方法只接受一个参数，指定了返回的条数。\n\n#### limit()：读取两条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n\n\n如果要指定跳过的条数，可以使用 **skip()** 方法。\n\n#### skip(): 跳过前面两条数据，读取两条数据\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n### 连接操作\n\nmongoDB 不是一个关系型数据库，但我们可以使用 **$lookup** 来实现左连接。\n\n例如我们有两个集合数据分别为：\n\n集合1：orders\n\n```\n[\n  { _id: 1, product_id: 154, status: 1 }\n]\n```\n\n集合2：products\n\n```\n[\n  { _id: 154, name: '笔记本电脑' },\n  { _id: 155, name: '耳机' },\n  { _id: 156, name: '台式电脑' }\n]\n```\n\n#### $lookup 实现左连接\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://127.0.0.1:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  var dbo = db.db(\"runoob\");\n  dbo.collection('orders').aggregate([\n    { $lookup:\n       {\n         from: 'products',            // 右集合\n         localField: 'product_id',    // 左集合 join 字段\n         foreignField: '_id',         // 右集合 join 字段\n         as: 'orderdetails'           // 新生成字段（类型array）\n       }\n     }\n    ]).toArray(function(err, res) {\n    if (err) throw err;\n    console.log(JSON.stringify(res));\n    db.close();\n  });\n});\n```\n\n### 删除集合\n\n我们可以使用 **drop()** 方法来删除集合：\n\n#### drop()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    // 删除 test 集合\n    dbo.collection(\"test\").drop(function(err, delOK) {  // 执行成功 delOK 返回 true，否则返回 false\n        if (err) throw err;\n        if (delOK) console.log(\"集合已删除\");\n        db.close();\n    });\n});\n```\n\n# reference\n\n1. 作者：Jay_huaxiao\n   链接：https://juejin.im/post/5d1883a05188255eea62e096\n   来源：掘金\n\n2. 作者：zhaoolee\n   链接：https://www.jianshu.com/p/a95c6b21c382\n   来源：简书\n\n3. 来源：菜鸟教程","slug":"MongoDB快速入门","published":1,"updated":"2020-03-29T06:59:20.717Z","photos":[],"link":"","_id":"ck8ct7j60001hgtvi1u0td7c9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"Mongo与MySQL\"><a href=\"#Mongo与MySQL\" class=\"headerlink\" title=\"Mongo与MySQL\"></a>Mongo与MySQL</h1><p>Mysql数据库有什么缺陷?</p>\n<ul>\n<li>关系型数据库表结构复杂,扩展性差;</li>\n<li>需要较高的学习成本,复杂的表结构会产生更高的维护成本</li>\n</ul>\n<p>关系型数据库的”连接查询”会影响查询效率?</p>\n<ul>\n<li>会使查询效率变低</li>\n</ul>\n<p>连接查询效率低,为什么还要分表?</p>\n<ul>\n<li>分表可以减少数据冗余</li>\n</ul>\n<p>数据库可以不使用复杂的表结构么?</p>\n<ul>\n<li>可以,但要多消耗一些存储空间,mongodb(非关系型数据库)就为此而生</li>\n</ul>\n<p>Mongo优势</p>\n<ul>\n<li><p>mongo默认开启了新手模式,登录无需键入用户名和密码,只需要在终端输入<code>mongo</code>即可进入交互环境</p>\n</li>\n<li><p>mongo没有”表”的概念,也不用设计表(mongo使用”集合”存储 多个”键值对”,取代表的功能)</p>\n</li>\n<li><p>mongo有数据库的概念,但可以不经创建,直接使用(类似vim编辑器创建新文件,如果新文件中未添加数据,则新文件不会保存到硬盘;与vim不同的是,如果用户添加了数据,vim需要手动确认,保存文件,mongo会自动保存数据到相应的数据库)</p>\n</li>\n<li><p>mongo没有mysql中”记录”的概念,mongo使用”文档”存储任意数量的”键值对”信息(“记录”中的信息受表中各字段的约束,”文档”可以存放任意数量的键值对)</p>\n</li>\n<li><p>mongo无需手动设置”主键”,系统会自动为每一个”文档”自动添加”_id”键值对,保证数据的唯一性.</p>\n</li>\n</ul>\n<h3 id=\"MongoDB-概念解析\"><a href=\"#MongoDB-概念解析\" class=\"headerlink\" title=\"MongoDB 概念解析\"></a>MongoDB 概念解析</h3><table>\n<thead>\n<tr>\n<th align=\"center\">SQL术语/概念</th>\n<th align=\"center\">MongoDB术语/概念</th>\n<th align=\"center\">解释/说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">database</td>\n<td align=\"center\">database</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">collection</td>\n<td align=\"center\">数据库表/集合</td>\n</tr>\n<tr>\n<td align=\"center\">row</td>\n<td align=\"center\">document</td>\n<td align=\"center\">数据记录行/文档</td>\n</tr>\n<tr>\n<td align=\"center\">column</td>\n<td align=\"center\">field</td>\n<td align=\"center\">数据字段/域</td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">index</td>\n<td align=\"center\">索引</td>\n</tr>\n<tr>\n<td align=\"center\">table joins</td>\n<td align=\"center\"></td>\n<td align=\"center\">表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td align=\"center\">primary key</td>\n<td align=\"center\">primary key</td>\n<td align=\"center\">主键,MongoDb自动将_id字段设置为主键</td>\n</tr>\n</tbody></table>\n<h1 id=\"MongoDB基本用法\"><a href=\"#MongoDB基本用法\" class=\"headerlink\" title=\"MongoDB基本用法\"></a>MongoDB基本用法</h1><h2 id=\"数据库管理系统\"><a href=\"#数据库管理系统\" class=\"headerlink\" title=\"数据库管理系统\"></a>数据库管理系统</h2><h3 id=\"1-服务端\"><a href=\"#1-服务端\" class=\"headerlink\" title=\"1.服务端\"></a>1.服务端</h3><ul>\n<li><p>(1)开启服务</p>\n<p><code>sudo service mongod start</code></p>\n</li>\n<li><p>(2)重启服务</p>\n<p><code>sudo service mongod restart</code></p>\n</li>\n<li><p>(3)关闭服务</p>\n<p><code>sudo service mongod stop</code></p>\n</li>\n</ul>\n<h3 id=\"2-客户端\"><a href=\"#2-客户端\" class=\"headerlink\" title=\"2.客户端\"></a>2.客户端</h3><ul>\n<li><p>(1)登录数据库</p>\n<p><code>mongo</code></p>\n</li>\n<li><p>(2)退出数据库</p>\n<p><code>exit</code></p>\n</li>\n</ul>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"1-查看数据库\"><a href=\"#1-查看数据库\" class=\"headerlink\" title=\"1.查看数据库\"></a>1.查看数据库</h3><p><code>show dbs</code></p>\n<h3 id=\"2-使用数据库\"><a href=\"#2-使用数据库\" class=\"headerlink\" title=\"2.使用数据库\"></a>2.使用数据库</h3><ul>\n<li><p>格式</p>\n<p>use 数据库名</p>\n</li>\n<li><p>示例</p>\n<p><code>use students</code></p>\n</li>\n</ul>\n<h3 id=\"3-查看当前数据库\"><a href=\"#3-查看当前数据库\" class=\"headerlink\" title=\"3.查看当前数据库\"></a>3.查看当前数据库</h3><p><code>db</code></p>\n<h3 id=\"4-删除当前数据库\"><a href=\"#4-删除当前数据库\" class=\"headerlink\" title=\"4.删除当前数据库\"></a>4.删除当前数据库</h3><p><code>db.dropDatabase()</code></p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"1-创建集合\"><a href=\"#1-创建集合\" class=\"headerlink\" title=\"1.创建集合\"></a>1.创建集合</h3><p>格式</p>\n<ul>\n<li>db.createCollection(“集合名称”)</li>\n<li>db.createCollection(name, options) </li>\n</ul>\n<p>说明</p>\n<ul>\n<li>name: 要创建的集合名称</li>\n<li>options: 可选参数, 指定有关内存大小及索引的选项</li>\n</ul>\n<p>示例(创建名为<code>stu</code>的集合)</p>\n<ul>\n<li><code>db.createCollection(&quot;stu&quot;)</code></li>\n</ul>\n<h3 id=\"2-查看当前数据库的集合\"><a href=\"#2-查看当前数据库的集合\" class=\"headerlink\" title=\"2.查看当前数据库的集合\"></a>2.查看当前数据库的集合</h3><p><code>show collections</code><br><code>show tables</code></p>\n<h3 id=\"3-删除集合\"><a href=\"#3-删除集合\" class=\"headerlink\" title=\"3.删除集合\"></a>3.删除集合</h3><ul>\n<li>格式<br><code>db.集合名.drop()</code></li>\n<li>示例(移除名为<code>stu</code>的文档)<br><code>db.stu.drop()</code></li>\n</ul>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><h3 id=\"1-插入文档\"><a href=\"#1-插入文档\" class=\"headerlink\" title=\"1.插入文档\"></a>1.插入文档</h3><ul>\n<li><p>格式<br>db.集合名.insert({})</p>\n</li>\n<li><p>示例</p>\n<p><code>db.stu.insert({name:&quot;李明&quot;,age:18,gender: true,birthday:&quot;1995-12-08&quot;,height:186.6})</code></p>\n</li>\n</ul>\n<h3 id=\"2-删除文档\"><a href=\"#2-删除文档\" class=\"headerlink\" title=\"2.删除文档\"></a>2.删除文档</h3><p>remove() 方法的基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     justOne: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query :（可选）删除的文档的条件。</li>\n<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>\n<li>writeConcern :（可选）抛出异常的级别。</li>\n</ul>\n<p>我们移除 name 为 ‘守护之心’ 的文档：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.gift.remove(&#123;&#39;name&#39;:&#39;守护之心&#39;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改文档\"><a href=\"#3-修改文档\" class=\"headerlink\" title=\"3.修改文档\"></a>3.修改文档</h3><p>update() 方法用于更新已存在的文档。语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query : update的查询条件，类似sql update查询内where后面的。</li>\n<li>update : update的对象和一些更新的操作符（如inc…）等，也可以理解为sql update查询内set后面的</li>\n<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。</li>\n</ul>\n<p>我们在集合 gift 中插入如下数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.gift.insert(&#123;</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;10&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>接着我们通过 update() 方法来更新礼物价格(price),并查看，更新成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.gift.update(&#123;&#39;id&#39;:&#39;1&#39;&#125;,&#123;$set:&#123;&#39;price&#39;:&#39;888&#39;&#125;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class=\"line\">&gt; db.gift.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5d1a9e46b35668bf92c989e3&quot;),</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;888&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-查询文档\"><a href=\"#4-查询文档\" class=\"headerlink\" title=\"4.查询文档\"></a>4.查询文档</h3><p>MongoDB 查询数据的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query ：可选，使用查询操作符指定查询条件</li>\n<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li>\n</ul>\n<p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection).pretty()</span><br></pre></td></tr></table></figure>\n\n<p>以下实例我们查询了集合 col 中的数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.gift.find().pretty();</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5d1951a6659f4eaa30bac84f&quot;),</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;10&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h2><p>条件操作符用于比较两个表达式并从mongoDB集合中获取数据。</p>\n<p>MongoDB中条件操作符有：</p>\n<ul>\n<li>(&gt;) 大于 - $gt</li>\n<li>(&lt;) 小于 - $lt</li>\n<li>(&gt;=) 大于等于 - $gte</li>\n<li>(&lt;= ) 小于等于 - $lte</li>\n</ul>\n<h2 id=\"type操作符\"><a href=\"#type操作符\" class=\"headerlink\" title=\"$type操作符\"></a>$type操作符</h2><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p>\n<p>MongoDB 中可以使用的类型如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>类型</strong></th>\n<th align=\"left\"><strong>数字</strong></th>\n<th align=\"left\"><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Double</td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">String</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Object</td>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Array</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Binary data</td>\n<td align=\"left\">5</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Undefined</td>\n<td align=\"left\">6</td>\n<td align=\"left\">已废弃。</td>\n</tr>\n<tr>\n<td align=\"left\">Object id</td>\n<td align=\"left\">7</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">8</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Date</td>\n<td align=\"left\">9</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Null</td>\n<td align=\"left\">10</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Regular Expression</td>\n<td align=\"left\">11</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">JavaScript</td>\n<td align=\"left\">13</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Symbol</td>\n<td align=\"left\">14</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">JavaScript (with scope)</td>\n<td align=\"left\">15</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">32-bit integer</td>\n<td align=\"left\">16</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Timestamp</td>\n<td align=\"left\">17</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">64-bit integer</td>\n<td align=\"left\">18</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Min key</td>\n<td align=\"left\">255</td>\n<td align=\"left\">Query with <code>-1</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Max key</td>\n<td align=\"left\">127</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p><strong>我们使用的数据库名称为”runoob” 我们的集合名称为”col”，以下为我们插入的数据。</strong></p>\n<p>简单的集合”col”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;</span><br><span class=\"line\">    title: &#39;PHP 教程&#39;, </span><br><span class=\"line\">    description: &#39;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;php&#39;],</span><br><span class=\"line\">    likes: 200</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;title: &#39;Java 教程&#39;, </span><br><span class=\"line\">    description: &#39;Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;java&#39;],</span><br><span class=\"line\">    likes: 150</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, </span><br><span class=\"line\">    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;mongodb&#39;],</span><br><span class=\"line\">    likes: 100</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>使用find()命令查看数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col.find()</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MongoDB-操作符-type-实例\"><a href=\"#MongoDB-操作符-type-实例\" class=\"headerlink\" title=\"MongoDB 操作符 - $type 实例\"></a>MongoDB 操作符 - $type 实例</h3><p>如果想获取 “col” 集合中 title 为 String 的数据，你可以使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class=\"line\">或</span><br><span class=\"line\">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MongoDB-常用方法\"><a href=\"#MongoDB-常用方法\" class=\"headerlink\" title=\"MongoDB 常用方法\"></a>MongoDB 常用方法</h2><h3 id=\"MongoDB-Limit-方法\"><a href=\"#MongoDB-Limit-方法\" class=\"headerlink\" title=\"MongoDB Limit() 方法\"></a>MongoDB Limit() 方法</h3><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>limit()方法基本语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>集合 col 中的数据如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下实例为显示查询文档中的两条记录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;PHP 教程&quot; &#125;</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。</p>\n<hr>\n<h3 id=\"MongoDB-Skip-方法\"><a href=\"#MongoDB-Skip-方法\" class=\"headerlink\" title=\"MongoDB Skip() 方法\"></a>MongoDB Skip() 方法</h3><p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>skip() 方法脚本语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>以下实例只会显示第二条文档数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注:</strong>skip()方法默认参数为 0 。</p>\n<h3 id=\"MongoDB-sort-方法\"><a href=\"#MongoDB-sort-方法\" class=\"headerlink\" title=\"MongoDB sort() 方法\"></a>MongoDB sort() 方法</h3><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>\n<h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>sort()方法基本语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MongoDB-索引\"><a href=\"#MongoDB-索引\" class=\"headerlink\" title=\"MongoDB 索引\"></a>MongoDB 索引</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p>\n<p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>\n<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p>\n<h2 id=\"createIndex-方法\"><a href=\"#createIndex-方法\" class=\"headerlink\" title=\"createIndex() 方法\"></a>createIndex() 方法</h2><p>MongoDB使用 createIndex() 方法来创建索引。</p>\n<blockquote>\n<p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p>\n</blockquote>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>createIndex()方法基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.collection.createIndex(keys, options)</span><br></pre></td></tr></table></figure>\n\n<p>语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.createIndex(&#123;&quot;title&quot;:1&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>createIndex() 接收可选参数，可选参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Parameter</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">background</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\">unique</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">name</td>\n<td align=\"left\">string</td>\n<td align=\"left\">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>\n</tr>\n<tr>\n<td align=\"left\">dropDups</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\"><strong>3.0+版本已废弃。</strong>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">sparse</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">expireAfterSeconds</td>\n<td align=\"left\">integer</td>\n<td align=\"left\">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>\n</tr>\n<tr>\n<td align=\"left\">v</td>\n<td align=\"left\">index version</td>\n<td align=\"left\">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>\n</tr>\n<tr>\n<td align=\"left\">weights</td>\n<td align=\"left\">document</td>\n<td align=\"left\">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>\n</tr>\n<tr>\n<td align=\"left\">default_language</td>\n<td align=\"left\">string</td>\n<td align=\"left\">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>\n</tr>\n<tr>\n<td align=\"left\">language_override</td>\n<td align=\"left\">string</td>\n<td align=\"left\">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>在后台创建索引：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>通过在创建索引时加 background:true 的选项，让创建工作在后台执行</p>\n<h1 id=\"MongoDB-聚合\"><a href=\"#MongoDB-聚合\" class=\"headerlink\" title=\"MongoDB 聚合\"></a>MongoDB 聚合</h1><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p>\n<h2 id=\"aggregate-方法\"><a href=\"#aggregate-方法\" class=\"headerlink\" title=\"aggregate() 方法\"></a>aggregate() 方法</h2><p>MongoDB中聚合的方法使用aggregate()。</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>aggregate() 方法的基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>集合中的数据如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902c)</span><br><span class=\"line\">   title: 'MongoDB Overview', </span><br><span class=\"line\">   description: 'MongoDB is no sql database',</span><br><span class=\"line\">   by_user: 'runoob.com',</span><br><span class=\"line\">   url: 'http://www.runoob.com',</span><br><span class=\"line\">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 100</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902d)</span><br><span class=\"line\">   title: 'NoSQL Overview', </span><br><span class=\"line\">   description: 'No sql database is very fast',</span><br><span class=\"line\">   by_user: 'runoob.com',</span><br><span class=\"line\">   url: 'http://www.runoob.com',</span><br><span class=\"line\">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 10</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902e)</span><br><span class=\"line\">   title: 'Neo4j Overview', </span><br><span class=\"line\">   description: 'Neo4j is no sql database',</span><br><span class=\"line\">   by_user: 'Neo4j',</span><br><span class=\"line\">   url: 'http://www.neo4j.com',</span><br><span class=\"line\">   tags: ['neo4j', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 750</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;result&quot; : [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_id&quot; : &quot;runoob.com&quot;,</span><br><span class=\"line\">         &quot;num_tutorial&quot; : 2</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class=\"line\">         &quot;num_tutorial&quot; : 1</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   ],</span><br><span class=\"line\">   &quot;ok&quot; : 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上实例类似sql语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select by_user, count(*) from mycol group by by_user</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。</p>\n<p>下表展示了一些聚合的表达式:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表达式</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$sum</td>\n<td align=\"left\">计算总和。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$avg</td>\n<td align=\"left\">计算平均值</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$min</td>\n<td align=\"left\">获取集合中所有文档对应值得最小值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$max</td>\n<td align=\"left\">获取集合中所有文档对应值得最大值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$push</td>\n<td align=\"left\">在结果文档中插入值到一个数组中。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$addToSet</td>\n<td align=\"left\">在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$first</td>\n<td align=\"left\">根据资源文档的排序获取第一个文档数据。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$last</td>\n<td align=\"left\">根据资源文档的排序获取最后一个文档数据</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>\n</tr>\n</tbody></table>\n<h2 id=\"管道的概念\"><a href=\"#管道的概念\" class=\"headerlink\" title=\"管道的概念\"></a>管道的概念</h2><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p>\n<p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>\n<p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p>\n<p>这里我们介绍一下聚合框架中常用的几个操作：</p>\n<ul>\n<li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li>\n<li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li>\n<li>$limit：用来限制MongoDB聚合管道返回的文档数。</li>\n<li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li>\n<li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li>\n<li>$group：将集合中的文档分组，可用于统计结果。</li>\n<li>$sort：将输入文档排序后输出。</li>\n<li>$geoNear：输出接近某一地理位置的有序文档。</li>\n</ul>\n<h3 id=\"管道操作符实例\"><a href=\"#管道操作符实例\" class=\"headerlink\" title=\"管道操作符实例\"></a>管道操作符实例</h3><p>1、$project实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $project : &#123;</span><br><span class=\"line\">        title : 1 ,</span><br><span class=\"line\">        author : 1 ,</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n\n<p>这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $project : &#123;</span><br><span class=\"line\">        _id : 0 ,</span><br><span class=\"line\">        title : 1 ,</span><br><span class=\"line\">        author : 1</span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>2.$match实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.articles.aggregate( [</span><br><span class=\"line\">                        &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;,</span><br><span class=\"line\">                        &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;</span><br><span class=\"line\">                       ] );</span><br></pre></td></tr></table></figure>\n\n<p>$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。</p>\n<p>3.$skip实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $skip : 5 &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>经过$skip管道操作符处理后，前五个文档被”过滤”掉。</p>\n<h1 id=\"MongoDB-分片\"><a href=\"#MongoDB-分片\" class=\"headerlink\" title=\"MongoDB 分片\"></a>MongoDB 分片</h1><h2 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h2><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p>\n<p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>\n<h2 id=\"为什么使用分片\"><a href=\"#为什么使用分片\" class=\"headerlink\" title=\"为什么使用分片\"></a>为什么使用分片</h2><ul>\n<li>复制所有的写入操作到主节点</li>\n<li>延迟的敏感数据会在主节点查询</li>\n<li>单个副本集限制在12个节点</li>\n<li>当请求量巨大时会出现内存不足。</li>\n<li>本地磁盘不足</li>\n<li>垂直扩展价格昂贵</li>\n</ul>\n<h2 id=\"MongoDB分片\"><a href=\"#MongoDB分片\" class=\"headerlink\" title=\"MongoDB分片\"></a>MongoDB分片</h2><p>下图展示了在MongoDB中使用分片集群结构分布：</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323133206.png\"  alt=\"\"></p>\n<p>上图中主要有如下所述三个主要组件：</p>\n<ul>\n<li><p>Shard:</p>\n<p>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</p>\n</li>\n<li><p>Config Server:</p>\n<p>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</p>\n</li>\n<li><p>Query Routers:</p>\n<p>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p>\n</li>\n</ul>\n<h2 id=\"分片实例\"><a href=\"#分片实例\" class=\"headerlink\" title=\"分片实例\"></a>分片实例</h2><p>分片结构端口分布如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shard Server 1：27020</span><br><span class=\"line\">Shard Server 2：27021</span><br><span class=\"line\">Shard Server 3：27022</span><br><span class=\"line\">Shard Server 4：27023</span><br><span class=\"line\">Config Server ：27100</span><br><span class=\"line\">Route Process：40000</span><br></pre></td></tr></table></figure>\n\n<p>步骤一：启动Shard Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s1</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s2</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27020 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s0.log --logappend --fork</span><br><span class=\"line\">....</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27023 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s3.log --logappend --fork</span><br></pre></td></tr></table></figure>\n\n<p>步骤二： 启动Config Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27100 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;config.log --logappend --fork</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。</p>\n<p>步骤三： 启动Route Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongos --port 40000 --configdb localhost:27100 --fork --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;route.log --chunkSize 500</span><br></pre></td></tr></table></figure>\n\n<p>mongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p>\n<p>步骤四： 配置Sharding</p>\n<p>接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 shard]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongo admin --port 40000</span><br><span class=\"line\">MongoDB shell version: 2.0.7</span><br><span class=\"line\">connecting to: 127.0.0.1:40000&#x2F;admin</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27020&quot; &#125;)</span><br><span class=\"line\">&#123; &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27029&quot; &#125;)</span><br><span class=\"line\">&#123; &quot;shardAdded&quot; : &quot;shard0009&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; enablesharding:&quot;test&quot; &#125;) #设置分片存储的数据库</span><br><span class=\"line\">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; shardcollection: &quot;test.log&quot;, key: &#123; id:1,time:1&#125;&#125;)</span><br><span class=\"line\">&#123; &quot;collectionsharded&quot; : &quot;test.log&quot;, &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000</p>\n<h1 id=\"Node-js-连接-MongoDB\"><a href=\"#Node-js-连接-MongoDB\" class=\"headerlink\" title=\"Node.js 连接 MongoDB\"></a>Node.js 连接 MongoDB</h1><p>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。</p>\n<p>本章节我们将为大家介绍如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。</p>\n<h2 id=\"安装驱动\"><a href=\"#安装驱动\" class=\"headerlink\" title=\"安装驱动\"></a>安装驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install mongodb</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们来实现增删改查功能。</p>\n<h2 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h2><p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。</p>\n<p>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p>\n<h4 id=\"创建连接\"><a href=\"#创建连接\" class=\"headerlink\" title=\"创建连接\"></a>创建连接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/runoob\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"数据库已创建!\"</span>);</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建集合\"><a href=\"#创建集合\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h2><p>我们可以使用 createCollection() 方法来创建集合：</p>\n<h4 id=\"创建集合-1\"><a href=\"#创建集合-1\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'mongodb://localhost:27017/runoob'</span>;</span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'数据库已创建'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbase = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbase.createCollection(<span class=\"string\">'site'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"创建集合!\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库操作-CURD\"><a href=\"#数据库操作-CURD\" class=\"headerlink\" title=\"数据库操作( CURD )\"></a>数据库操作( CURD )</h2><p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 <strong>insertOne()</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">url</span>: <span class=\"string\">\"www.runoob\"</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertOne(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档插入成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test.js</span><br><span class=\"line\">文档插入成功</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"插入一条数据\"><a href=\"#插入一条数据\" class=\"headerlink\" title=\"插入一条数据\"></a>插入一条数据</h4><p>var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“;  MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {    if (err) throw err;    var dbo = db.db(“runoob”);    var myobj = { name: “菜鸟教程”, url: “<a href=\"http://www.runoob&quot;\" target=\"_blank\" rel=\"noopener\">www.runoob&quot;</a> };    dbo.collection(“site”).insertOne(myobj, function(err, res) {        if (err) throw err;        console.log(“文档插入成功”);        db.close();    }); });</p>\n<p>执行以下命令输出就结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test.js</span><br><span class=\"line\">文档插入成功</span><br></pre></td></tr></table></figure>\n\n<p>从输出结果来看，数据已插入成功。</p>\n<p>我们也可以打开 MongoDB 的客户端查看数据，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">runoob  0.000GB          # 自动创建了 runoob 数据库</span><br><span class=\"line\">&gt; show tables</span><br><span class=\"line\">site                     # 自动创建了 site 集合（数据表）</span><br><span class=\"line\">&gt; db.site.find()</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;), &quot;name&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;www.runoob&quot; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要插入多条数据可以使用 <strong>insertMany()</strong>：</p>\n<h2 id=\"插入多条数据\"><a href=\"#插入多条数据\" class=\"headerlink\" title=\"插入多条数据\"></a>插入多条数据</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj =  [</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'菜鸟工具'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://c.runoob.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'cn'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Google'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Facebook'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;</span><br><span class=\"line\">       ];</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertMany(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"插入的文档数量为: \"</span> + res.insertedCount);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>res.insertedCount 为插入的条数。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>). find(&#123;&#125;).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123; <span class=\"comment\">// 返回集合中所有数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>以下实例检索 name 为 “菜鸟教程” 的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find(whereStr).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ &#123; _id: 5a794e36763eb821b24db854,</span><br><span class=\"line\">    name: '菜鸟教程',</span><br><span class=\"line\">    url: 'www.runoob' &#125; ]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><p>我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 <a href=\"https://www.runoob.com：\">https://www.runoob.com：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更新一条数据</span><br><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateOne(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档更新成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，进入 mongo 管理工具查看数据已修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.site.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;),</span><br><span class=\"line\">    &quot;name&quot; : &quot;菜鸟教程&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https:&#x2F;&#x2F;www.runoob.com&quot;     &#x2F;&#x2F; 已修改为 https</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要更新所有符合条的文档数据可以使用 <strong>updateMany()</strong>：</p>\n<h4 id=\"更新多条数据\"><a href=\"#更新多条数据\" class=\"headerlink\" title=\"更新多条数据\"></a>更新多条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"type\"</span>:<span class=\"string\">'en'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateMany(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.result.nModified + <span class=\"string\">\" 条文档被更新\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>result.nModified 为更新的条数。</p>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>以下实例将 name 为 “菜鸟教程” 的数据删除 :</p>\n<h4 id=\"删除一条数据\"><a href=\"#删除一条数据\" class=\"headerlink\" title=\"删除一条数据\"></a>删除一条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).deleteOne(whereStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档删除成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，进入 mongo 管理工具查看数据已删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.site.find()</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果要删除多条语句可以使用 <strong>deleteMany()</strong> 方法</p>\n<p>以下实例将 type 为 en 的所有数据删除 :</p>\n<h4 id=\"删除多条数据\"><a href=\"#删除多条数据\" class=\"headerlink\" title=\"删除多条数据\"></a>删除多条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"en\"</span> &#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).deleteMany(whereStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(obj.result.n + <span class=\"string\">\" 条文档被删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>obj.result.n 删除的条数。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; type: 1 &#125;  &#x2F;&#x2F; 按 type 字段升序</span><br><span class=\"line\">&#123; type: -1 &#125; &#x2F;&#x2F; 按 type 字段降序</span><br></pre></td></tr></table></figure>\n\n<p>按 type 升序排列:</p>\n<h4 id=\"排序-1\"><a href=\"#排序-1\" class=\"headerlink\" title=\"排序\"></a>排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mysort = &#123; <span class=\"attr\">type</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().sort(mysort).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查询分页\"><a href=\"#查询分页\" class=\"headerlink\" title=\"查询分页\"></a>查询分页</h3><p>如果要设置指定的返回条数可以使用 <strong>limit()</strong> 方法，该方法只接受一个参数，指定了返回的条数。</p>\n<h4 id=\"limit-：读取两条数据\"><a href=\"#limit-：读取两条数据\" class=\"headerlink\" title=\"limit()：读取两条数据\"></a>limit()：读取两条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果要指定跳过的条数，可以使用 <strong>skip()</strong> 方法。</p>\n<h4 id=\"skip-跳过前面两条数据，读取两条数据\"><a href=\"#skip-跳过前面两条数据，读取两条数据\" class=\"headerlink\" title=\"skip(): 跳过前面两条数据，读取两条数据\"></a>skip(): 跳过前面两条数据，读取两条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().skip(<span class=\"number\">2</span>).limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接操作\"><a href=\"#连接操作\" class=\"headerlink\" title=\"连接操作\"></a>连接操作</h3><p>mongoDB 不是一个关系型数据库，但我们可以使用 <strong>$lookup</strong> 来实现左连接。</p>\n<p>例如我们有两个集合数据分别为：</p>\n<p>集合1：orders</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123; _id: 1, product_id: 154, status: 1 &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>集合2：products</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123; _id: 154, name: &#39;笔记本电脑&#39; &#125;,</span><br><span class=\"line\">  &#123; _id: 155, name: &#39;耳机&#39; &#125;,</span><br><span class=\"line\">  &#123; _id: 156, name: &#39;台式电脑&#39; &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lookup-实现左连接\"><a href=\"#lookup-实现左连接\" class=\"headerlink\" title=\"$lookup 实现左连接\"></a>$lookup 实现左连接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://127.0.0.1:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">  dbo.collection(<span class=\"string\">'orders'</span>).aggregate([</span><br><span class=\"line\">    &#123; <span class=\"attr\">$lookup</span>:</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         <span class=\"keyword\">from</span>: <span class=\"string\">'products'</span>,            <span class=\"comment\">// 右集合</span></span><br><span class=\"line\">         localField: <span class=\"string\">'product_id'</span>,    <span class=\"comment\">// 左集合 join 字段</span></span><br><span class=\"line\">         foreignField: <span class=\"string\">'_id'</span>,         <span class=\"comment\">// 右集合 join 字段</span></span><br><span class=\"line\">         <span class=\"keyword\">as</span>: <span class=\"string\">'orderdetails'</span>           <span class=\"comment\">// 新生成字段（类型array）</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ]).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(res));</span><br><span class=\"line\">    db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除集合\"><a href=\"#删除集合\" class=\"headerlink\" title=\"删除集合\"></a>删除集合</h3><p>我们可以使用 <strong>drop()</strong> 方法来删除集合：</p>\n<h4 id=\"drop\"><a href=\"#drop\" class=\"headerlink\" title=\"drop()\"></a>drop()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 删除 test 集合</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"test\"</span>).drop(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, delOK</span>) </span>&#123;  <span class=\"comment\">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delOK) <span class=\"built_in\">console</span>.log(<span class=\"string\">\"集合已删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><ol>\n<li><p>作者：Jay_huaxiao<br>链接：<a href=\"https://juejin.im/post/5d1883a05188255eea62e096\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d1883a05188255eea62e096</a><br>来源：掘金</p>\n</li>\n<li><p>作者：zhaoolee<br>链接：<a href=\"https://www.jianshu.com/p/a95c6b21c382\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a95c6b21c382</a><br>来源：简书</p>\n</li>\n<li><p>来源：菜鸟教程</p>\n</li>\n</ol>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<h1 id=\"Mongo与MySQL\"><a href=\"#Mongo与MySQL\" class=\"headerlink\" title=\"Mongo与MySQL\"></a>Mongo与MySQL</h1><p>Mysql数据库有什么缺陷?</p>\n<ul>\n<li>关系型数据库表结构复杂,扩展性差;</li>\n<li>需要较高的学习成本,复杂的表结构会产生更高的维护成本</li>\n</ul>\n<p>关系型数据库的”连接查询”会影响查询效率?</p>\n<ul>\n<li>会使查询效率变低</li>\n</ul>\n<p>连接查询效率低,为什么还要分表?</p>\n<ul>\n<li>分表可以减少数据冗余</li>\n</ul>\n<p>数据库可以不使用复杂的表结构么?</p>\n<ul>\n<li>可以,但要多消耗一些存储空间,mongodb(非关系型数据库)就为此而生</li>\n</ul>\n<p>Mongo优势</p>\n<ul>\n<li><p>mongo默认开启了新手模式,登录无需键入用户名和密码,只需要在终端输入<code>mongo</code>即可进入交互环境</p>\n</li>\n<li><p>mongo没有”表”的概念,也不用设计表(mongo使用”集合”存储 多个”键值对”,取代表的功能)</p>\n</li>\n<li><p>mongo有数据库的概念,但可以不经创建,直接使用(类似vim编辑器创建新文件,如果新文件中未添加数据,则新文件不会保存到硬盘;与vim不同的是,如果用户添加了数据,vim需要手动确认,保存文件,mongo会自动保存数据到相应的数据库)</p>\n</li>\n<li><p>mongo没有mysql中”记录”的概念,mongo使用”文档”存储任意数量的”键值对”信息(“记录”中的信息受表中各字段的约束,”文档”可以存放任意数量的键值对)</p>\n</li>\n<li><p>mongo无需手动设置”主键”,系统会自动为每一个”文档”自动添加”_id”键值对,保证数据的唯一性.</p>\n</li>\n</ul>\n<h3 id=\"MongoDB-概念解析\"><a href=\"#MongoDB-概念解析\" class=\"headerlink\" title=\"MongoDB 概念解析\"></a>MongoDB 概念解析</h3><table>\n<thead>\n<tr>\n<th align=\"center\">SQL术语/概念</th>\n<th align=\"center\">MongoDB术语/概念</th>\n<th align=\"center\">解释/说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">database</td>\n<td align=\"center\">database</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">collection</td>\n<td align=\"center\">数据库表/集合</td>\n</tr>\n<tr>\n<td align=\"center\">row</td>\n<td align=\"center\">document</td>\n<td align=\"center\">数据记录行/文档</td>\n</tr>\n<tr>\n<td align=\"center\">column</td>\n<td align=\"center\">field</td>\n<td align=\"center\">数据字段/域</td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">index</td>\n<td align=\"center\">索引</td>\n</tr>\n<tr>\n<td align=\"center\">table joins</td>\n<td align=\"center\"></td>\n<td align=\"center\">表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td align=\"center\">primary key</td>\n<td align=\"center\">primary key</td>\n<td align=\"center\">主键,MongoDb自动将_id字段设置为主键</td>\n</tr>\n</tbody></table>\n<h1 id=\"MongoDB基本用法\"><a href=\"#MongoDB基本用法\" class=\"headerlink\" title=\"MongoDB基本用法\"></a>MongoDB基本用法</h1><h2 id=\"数据库管理系统\"><a href=\"#数据库管理系统\" class=\"headerlink\" title=\"数据库管理系统\"></a>数据库管理系统</h2><h3 id=\"1-服务端\"><a href=\"#1-服务端\" class=\"headerlink\" title=\"1.服务端\"></a>1.服务端</h3><ul>\n<li><p>(1)开启服务</p>\n<p><code>sudo service mongod start</code></p>\n</li>\n<li><p>(2)重启服务</p>\n<p><code>sudo service mongod restart</code></p>\n</li>\n<li><p>(3)关闭服务</p>\n<p><code>sudo service mongod stop</code></p>\n</li>\n</ul>\n<h3 id=\"2-客户端\"><a href=\"#2-客户端\" class=\"headerlink\" title=\"2.客户端\"></a>2.客户端</h3><ul>\n<li><p>(1)登录数据库</p>\n<p><code>mongo</code></p>\n</li>\n<li><p>(2)退出数据库</p>\n<p><code>exit</code></p>\n</li>\n</ul>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"1-查看数据库\"><a href=\"#1-查看数据库\" class=\"headerlink\" title=\"1.查看数据库\"></a>1.查看数据库</h3><p><code>show dbs</code></p>\n<h3 id=\"2-使用数据库\"><a href=\"#2-使用数据库\" class=\"headerlink\" title=\"2.使用数据库\"></a>2.使用数据库</h3><ul>\n<li><p>格式</p>\n<p>use 数据库名</p>\n</li>\n<li><p>示例</p>\n<p><code>use students</code></p>\n</li>\n</ul>\n<h3 id=\"3-查看当前数据库\"><a href=\"#3-查看当前数据库\" class=\"headerlink\" title=\"3.查看当前数据库\"></a>3.查看当前数据库</h3><p><code>db</code></p>\n<h3 id=\"4-删除当前数据库\"><a href=\"#4-删除当前数据库\" class=\"headerlink\" title=\"4.删除当前数据库\"></a>4.删除当前数据库</h3><p><code>db.dropDatabase()</code></p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"1-创建集合\"><a href=\"#1-创建集合\" class=\"headerlink\" title=\"1.创建集合\"></a>1.创建集合</h3><p>格式</p>\n<ul>\n<li>db.createCollection(“集合名称”)</li>\n<li>db.createCollection(name, options) </li>\n</ul>\n<p>说明</p>\n<ul>\n<li>name: 要创建的集合名称</li>\n<li>options: 可选参数, 指定有关内存大小及索引的选项</li>\n</ul>\n<p>示例(创建名为<code>stu</code>的集合)</p>\n<ul>\n<li><code>db.createCollection(&quot;stu&quot;)</code></li>\n</ul>\n<h3 id=\"2-查看当前数据库的集合\"><a href=\"#2-查看当前数据库的集合\" class=\"headerlink\" title=\"2.查看当前数据库的集合\"></a>2.查看当前数据库的集合</h3><p><code>show collections</code><br><code>show tables</code></p>\n<h3 id=\"3-删除集合\"><a href=\"#3-删除集合\" class=\"headerlink\" title=\"3.删除集合\"></a>3.删除集合</h3><ul>\n<li>格式<br><code>db.集合名.drop()</code></li>\n<li>示例(移除名为<code>stu</code>的文档)<br><code>db.stu.drop()</code></li>\n</ul>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><h3 id=\"1-插入文档\"><a href=\"#1-插入文档\" class=\"headerlink\" title=\"1.插入文档\"></a>1.插入文档</h3><ul>\n<li><p>格式<br>db.集合名.insert({})</p>\n</li>\n<li><p>示例</p>\n<p><code>db.stu.insert({name:&quot;李明&quot;,age:18,gender: true,birthday:&quot;1995-12-08&quot;,height:186.6})</code></p>\n</li>\n</ul>\n<h3 id=\"2-删除文档\"><a href=\"#2-删除文档\" class=\"headerlink\" title=\"2.删除文档\"></a>2.删除文档</h3><p>remove() 方法的基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     justOne: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query :（可选）删除的文档的条件。</li>\n<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>\n<li>writeConcern :（可选）抛出异常的级别。</li>\n</ul>\n<p>我们移除 name 为 ‘守护之心’ 的文档：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.gift.remove(&#123;&#39;name&#39;:&#39;守护之心&#39;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改文档\"><a href=\"#3-修改文档\" class=\"headerlink\" title=\"3.修改文档\"></a>3.修改文档</h3><p>update() 方法用于更新已存在的文档。语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query : update的查询条件，类似sql update查询内where后面的。</li>\n<li>update : update的对象和一些更新的操作符（如inc…）等，也可以理解为sql update查询内set后面的</li>\n<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。</li>\n</ul>\n<p>我们在集合 gift 中插入如下数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.gift.insert(&#123;</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;10&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>接着我们通过 update() 方法来更新礼物价格(price),并查看，更新成功:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.gift.update(&#123;&#39;id&#39;:&#39;1&#39;&#125;,&#123;$set:&#123;&#39;price&#39;:&#39;888&#39;&#125;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class=\"line\">&gt; db.gift.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5d1a9e46b35668bf92c989e3&quot;),</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;888&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-查询文档\"><a href=\"#4-查询文档\" class=\"headerlink\" title=\"4.查询文档\"></a>4.查询文档</h3><p>MongoDB 查询数据的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li>query ：可选，使用查询操作符指定查询条件</li>\n<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li>\n</ul>\n<p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection).pretty()</span><br></pre></td></tr></table></figure>\n\n<p>以下实例我们查询了集合 col 中的数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.gift.find().pretty();</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5d1951a6659f4eaa30bac84f&quot;),</span><br><span class=\"line\">\t&quot;id&quot; : &quot;1&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;守护之心&quot;,</span><br><span class=\"line\">\t&quot;price&quot; : &quot;10&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h2><p>条件操作符用于比较两个表达式并从mongoDB集合中获取数据。</p>\n<p>MongoDB中条件操作符有：</p>\n<ul>\n<li>(&gt;) 大于 - $gt</li>\n<li>(&lt;) 小于 - $lt</li>\n<li>(&gt;=) 大于等于 - $gte</li>\n<li>(&lt;= ) 小于等于 - $lte</li>\n</ul>\n<h2 id=\"type操作符\"><a href=\"#type操作符\" class=\"headerlink\" title=\"$type操作符\"></a>$type操作符</h2><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p>\n<p>MongoDB 中可以使用的类型如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>类型</strong></th>\n<th align=\"left\"><strong>数字</strong></th>\n<th align=\"left\"><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Double</td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">String</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Object</td>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Array</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Binary data</td>\n<td align=\"left\">5</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Undefined</td>\n<td align=\"left\">6</td>\n<td align=\"left\">已废弃。</td>\n</tr>\n<tr>\n<td align=\"left\">Object id</td>\n<td align=\"left\">7</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">8</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Date</td>\n<td align=\"left\">9</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Null</td>\n<td align=\"left\">10</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Regular Expression</td>\n<td align=\"left\">11</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">JavaScript</td>\n<td align=\"left\">13</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Symbol</td>\n<td align=\"left\">14</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">JavaScript (with scope)</td>\n<td align=\"left\">15</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">32-bit integer</td>\n<td align=\"left\">16</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Timestamp</td>\n<td align=\"left\">17</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">64-bit integer</td>\n<td align=\"left\">18</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Min key</td>\n<td align=\"left\">255</td>\n<td align=\"left\">Query with <code>-1</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Max key</td>\n<td align=\"left\">127</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p><strong>我们使用的数据库名称为”runoob” 我们的集合名称为”col”，以下为我们插入的数据。</strong></p>\n<p>简单的集合”col”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;</span><br><span class=\"line\">    title: &#39;PHP 教程&#39;, </span><br><span class=\"line\">    description: &#39;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;php&#39;],</span><br><span class=\"line\">    likes: 200</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;title: &#39;Java 教程&#39;, </span><br><span class=\"line\">    description: &#39;Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;java&#39;],</span><br><span class=\"line\">    likes: 150</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, </span><br><span class=\"line\">    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,</span><br><span class=\"line\">    by: &#39;菜鸟教程&#39;,</span><br><span class=\"line\">    url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;,</span><br><span class=\"line\">    tags: [&#39;mongodb&#39;],</span><br><span class=\"line\">    likes: 100</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>使用find()命令查看数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col.find()</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MongoDB-操作符-type-实例\"><a href=\"#MongoDB-操作符-type-实例\" class=\"headerlink\" title=\"MongoDB 操作符 - $type 实例\"></a>MongoDB 操作符 - $type 实例</h3><p>如果想获取 “col” 集合中 title 为 String 的数据，你可以使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class=\"line\">或</span><br><span class=\"line\">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MongoDB-常用方法\"><a href=\"#MongoDB-常用方法\" class=\"headerlink\" title=\"MongoDB 常用方法\"></a>MongoDB 常用方法</h2><h3 id=\"MongoDB-Limit-方法\"><a href=\"#MongoDB-Limit-方法\" class=\"headerlink\" title=\"MongoDB Limit() 方法\"></a>MongoDB Limit() 方法</h3><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>limit()方法基本语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>集合 col 中的数据如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066542ade2f21f36b0313a\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"PHP 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"php\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">200</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56066549ade2f21f36b0313b\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"Java 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"java\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">150</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5606654fade2f21f36b0313c\"</span>), <span class=\"attr\">\"title\"</span> : <span class=\"string\">\"MongoDB 教程\"</span>, <span class=\"attr\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>, <span class=\"attr\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>, <span class=\"attr\">\"tags\"</span> : [ <span class=\"string\">\"mongodb\"</span> ], <span class=\"attr\">\"likes\"</span> : <span class=\"number\">100</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下实例为显示查询文档中的两条记录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;PHP 教程&quot; &#125;</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。</p>\n<hr>\n<h3 id=\"MongoDB-Skip-方法\"><a href=\"#MongoDB-Skip-方法\" class=\"headerlink\" title=\"MongoDB Skip() 方法\"></a>MongoDB Skip() 方法</h3><p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>skip() 方法脚本语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>以下实例只会显示第二条文档数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)</span><br><span class=\"line\">&#123; &quot;title&quot; : &quot;Java 教程&quot; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注:</strong>skip()方法默认参数为 0 。</p>\n<h3 id=\"MongoDB-sort-方法\"><a href=\"#MongoDB-sort-方法\" class=\"headerlink\" title=\"MongoDB sort() 方法\"></a>MongoDB sort() 方法</h3><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>\n<h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>sort()方法基本语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MongoDB-索引\"><a href=\"#MongoDB-索引\" class=\"headerlink\" title=\"MongoDB 索引\"></a>MongoDB 索引</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p>\n<p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>\n<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p>\n<h2 id=\"createIndex-方法\"><a href=\"#createIndex-方法\" class=\"headerlink\" title=\"createIndex() 方法\"></a>createIndex() 方法</h2><p>MongoDB使用 createIndex() 方法来创建索引。</p>\n<blockquote>\n<p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p>\n</blockquote>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>createIndex()方法基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.collection.createIndex(keys, options)</span><br></pre></td></tr></table></figure>\n\n<p>语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.createIndex(&#123;&quot;title&quot;:1&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>createIndex() 接收可选参数，可选参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Parameter</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">background</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\">unique</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">name</td>\n<td align=\"left\">string</td>\n<td align=\"left\">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>\n</tr>\n<tr>\n<td align=\"left\">dropDups</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\"><strong>3.0+版本已废弃。</strong>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">sparse</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\">expireAfterSeconds</td>\n<td align=\"left\">integer</td>\n<td align=\"left\">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>\n</tr>\n<tr>\n<td align=\"left\">v</td>\n<td align=\"left\">index version</td>\n<td align=\"left\">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>\n</tr>\n<tr>\n<td align=\"left\">weights</td>\n<td align=\"left\">document</td>\n<td align=\"left\">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>\n</tr>\n<tr>\n<td align=\"left\">default_language</td>\n<td align=\"left\">string</td>\n<td align=\"left\">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>\n</tr>\n<tr>\n<td align=\"left\">language_override</td>\n<td align=\"left\">string</td>\n<td align=\"left\">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>在后台创建索引：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>通过在创建索引时加 background:true 的选项，让创建工作在后台执行</p>\n<h1 id=\"MongoDB-聚合\"><a href=\"#MongoDB-聚合\" class=\"headerlink\" title=\"MongoDB 聚合\"></a>MongoDB 聚合</h1><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p>\n<h2 id=\"aggregate-方法\"><a href=\"#aggregate-方法\" class=\"headerlink\" title=\"aggregate() 方法\"></a>aggregate() 方法</h2><p>MongoDB中聚合的方法使用aggregate()。</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>aggregate() 方法的基本语法格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>集合中的数据如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902c)</span><br><span class=\"line\">   title: 'MongoDB Overview', </span><br><span class=\"line\">   description: 'MongoDB is no sql database',</span><br><span class=\"line\">   by_user: 'runoob.com',</span><br><span class=\"line\">   url: 'http://www.runoob.com',</span><br><span class=\"line\">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 100</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902d)</span><br><span class=\"line\">   title: 'NoSQL Overview', </span><br><span class=\"line\">   description: 'No sql database is very fast',</span><br><span class=\"line\">   by_user: 'runoob.com',</span><br><span class=\"line\">   url: 'http://www.runoob.com',</span><br><span class=\"line\">   tags: ['mongodb', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 10</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   _id: ObjectId(7df78ad8902e)</span><br><span class=\"line\">   title: 'Neo4j Overview', </span><br><span class=\"line\">   description: 'Neo4j is no sql database',</span><br><span class=\"line\">   by_user: 'Neo4j',</span><br><span class=\"line\">   url: 'http://www.neo4j.com',</span><br><span class=\"line\">   tags: ['neo4j', 'database', 'NoSQL'],</span><br><span class=\"line\">   likes: 750</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;result&quot; : [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_id&quot; : &quot;runoob.com&quot;,</span><br><span class=\"line\">         &quot;num_tutorial&quot; : 2</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class=\"line\">         &quot;num_tutorial&quot; : 1</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   ],</span><br><span class=\"line\">   &quot;ok&quot; : 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上实例类似sql语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select by_user, count(*) from mycol group by by_user</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。</p>\n<p>下表展示了一些聚合的表达式:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表达式</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$sum</td>\n<td align=\"left\">计算总和。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$avg</td>\n<td align=\"left\">计算平均值</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$min</td>\n<td align=\"left\">获取集合中所有文档对应值得最小值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$max</td>\n<td align=\"left\">获取集合中所有文档对应值得最大值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$push</td>\n<td align=\"left\">在结果文档中插入值到一个数组中。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$addToSet</td>\n<td align=\"left\">在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$first</td>\n<td align=\"left\">根据资源文档的排序获取第一个文档数据。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$last</td>\n<td align=\"left\">根据资源文档的排序获取最后一个文档数据</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>\n</tr>\n</tbody></table>\n<h2 id=\"管道的概念\"><a href=\"#管道的概念\" class=\"headerlink\" title=\"管道的概念\"></a>管道的概念</h2><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p>\n<p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>\n<p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p>\n<p>这里我们介绍一下聚合框架中常用的几个操作：</p>\n<ul>\n<li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li>\n<li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li>\n<li>$limit：用来限制MongoDB聚合管道返回的文档数。</li>\n<li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li>\n<li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li>\n<li>$group：将集合中的文档分组，可用于统计结果。</li>\n<li>$sort：将输入文档排序后输出。</li>\n<li>$geoNear：输出接近某一地理位置的有序文档。</li>\n</ul>\n<h3 id=\"管道操作符实例\"><a href=\"#管道操作符实例\" class=\"headerlink\" title=\"管道操作符实例\"></a>管道操作符实例</h3><p>1、$project实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $project : &#123;</span><br><span class=\"line\">        title : 1 ,</span><br><span class=\"line\">        author : 1 ,</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n\n<p>这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $project : &#123;</span><br><span class=\"line\">        _id : 0 ,</span><br><span class=\"line\">        title : 1 ,</span><br><span class=\"line\">        author : 1</span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>2.$match实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.articles.aggregate( [</span><br><span class=\"line\">                        &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;,</span><br><span class=\"line\">                        &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;</span><br><span class=\"line\">                       ] );</span><br></pre></td></tr></table></figure>\n\n<p>$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。</p>\n<p>3.$skip实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.article.aggregate(</span><br><span class=\"line\">    &#123; $skip : 5 &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>经过$skip管道操作符处理后，前五个文档被”过滤”掉。</p>\n<h1 id=\"MongoDB-分片\"><a href=\"#MongoDB-分片\" class=\"headerlink\" title=\"MongoDB 分片\"></a>MongoDB 分片</h1><h2 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h2><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p>\n<p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>\n<h2 id=\"为什么使用分片\"><a href=\"#为什么使用分片\" class=\"headerlink\" title=\"为什么使用分片\"></a>为什么使用分片</h2><ul>\n<li>复制所有的写入操作到主节点</li>\n<li>延迟的敏感数据会在主节点查询</li>\n<li>单个副本集限制在12个节点</li>\n<li>当请求量巨大时会出现内存不足。</li>\n<li>本地磁盘不足</li>\n<li>垂直扩展价格昂贵</li>\n</ul>\n<h2 id=\"MongoDB分片\"><a href=\"#MongoDB分片\" class=\"headerlink\" title=\"MongoDB分片\"></a>MongoDB分片</h2><p>下图展示了在MongoDB中使用分片集群结构分布：</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/20200323133206.png\" alt=\"\"></p>\n<p>上图中主要有如下所述三个主要组件：</p>\n<ul>\n<li><p>Shard:</p>\n<p>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</p>\n</li>\n<li><p>Config Server:</p>\n<p>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</p>\n</li>\n<li><p>Query Routers:</p>\n<p>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p>\n</li>\n</ul>\n<h2 id=\"分片实例\"><a href=\"#分片实例\" class=\"headerlink\" title=\"分片实例\"></a>分片实例</h2><p>分片结构端口分布如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shard Server 1：27020</span><br><span class=\"line\">Shard Server 2：27021</span><br><span class=\"line\">Shard Server 3：27022</span><br><span class=\"line\">Shard Server 4：27023</span><br><span class=\"line\">Config Server ：27100</span><br><span class=\"line\">Route Process：40000</span><br></pre></td></tr></table></figure>\n\n<p>步骤一：启动Shard Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s1</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s2</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3</span><br><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27020 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s0 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s0.log --logappend --fork</span><br><span class=\"line\">....</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27023 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;s3 --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;s3.log --logappend --fork</span><br></pre></td></tr></table></figure>\n\n<p>步骤二： 启动Config Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 &#x2F;]# mkdir -p &#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config</span><br><span class=\"line\">[root@100 &#x2F;]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongod --port 27100 --dbpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;config --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;config.log --logappend --fork</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。</p>\n<p>步骤三： 启动Route Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongos --port 40000 --configdb localhost:27100 --fork --logpath&#x3D;&#x2F;www&#x2F;mongoDB&#x2F;shard&#x2F;log&#x2F;route.log --chunkSize 500</span><br></pre></td></tr></table></figure>\n\n<p>mongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p>\n<p>步骤四： 配置Sharding</p>\n<p>接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@100 shard]# &#x2F;usr&#x2F;local&#x2F;mongoDB&#x2F;bin&#x2F;mongo admin --port 40000</span><br><span class=\"line\">MongoDB shell version: 2.0.7</span><br><span class=\"line\">connecting to: 127.0.0.1:40000&#x2F;admin</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27020&quot; &#125;)</span><br><span class=\"line\">&#123; &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; addshard:&quot;localhost:27029&quot; &#125;)</span><br><span class=\"line\">&#123; &quot;shardAdded&quot; : &quot;shard0009&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; enablesharding:&quot;test&quot; &#125;) #设置分片存储的数据库</span><br><span class=\"line\">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class=\"line\">mongos&gt; db.runCommand(&#123; shardcollection: &quot;test.log&quot;, key: &#123; id:1,time:1&#125;&#125;)</span><br><span class=\"line\">&#123; &quot;collectionsharded&quot; : &quot;test.log&quot;, &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000</p>\n<h1 id=\"Node-js-连接-MongoDB\"><a href=\"#Node-js-连接-MongoDB\" class=\"headerlink\" title=\"Node.js 连接 MongoDB\"></a>Node.js 连接 MongoDB</h1><p>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。</p>\n<p>本章节我们将为大家介绍如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。</p>\n<h2 id=\"安装驱动\"><a href=\"#安装驱动\" class=\"headerlink\" title=\"安装驱动\"></a>安装驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install mongodb</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们来实现增删改查功能。</p>\n<h2 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h2><p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。</p>\n<p>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p>\n<h4 id=\"创建连接\"><a href=\"#创建连接\" class=\"headerlink\" title=\"创建连接\"></a>创建连接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/runoob\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"数据库已创建!\"</span>);</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建集合\"><a href=\"#创建集合\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h2><p>我们可以使用 createCollection() 方法来创建集合：</p>\n<h4 id=\"创建集合-1\"><a href=\"#创建集合-1\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'mongodb://localhost:27017/runoob'</span>;</span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'数据库已创建'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbase = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbase.createCollection(<span class=\"string\">'site'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"创建集合!\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库操作-CURD\"><a href=\"#数据库操作-CURD\" class=\"headerlink\" title=\"数据库操作( CURD )\"></a>数据库操作( CURD )</h2><p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 <strong>insertOne()</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">url</span>: <span class=\"string\">\"www.runoob\"</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertOne(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档插入成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test.js</span><br><span class=\"line\">文档插入成功</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"插入一条数据\"><a href=\"#插入一条数据\" class=\"headerlink\" title=\"插入一条数据\"></a>插入一条数据</h4><p>var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“;  MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {    if (err) throw err;    var dbo = db.db(“runoob”);    var myobj = { name: “菜鸟教程”, url: “<a href=\"http://www.runoob&quot;\" target=\"_blank\" rel=\"noopener\">www.runoob&quot;</a> };    dbo.collection(“site”).insertOne(myobj, function(err, res) {        if (err) throw err;        console.log(“文档插入成功”);        db.close();    }); });</p>\n<p>执行以下命令输出就结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test.js</span><br><span class=\"line\">文档插入成功</span><br></pre></td></tr></table></figure>\n\n<p>从输出结果来看，数据已插入成功。</p>\n<p>我们也可以打开 MongoDB 的客户端查看数据，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">runoob  0.000GB          # 自动创建了 runoob 数据库</span><br><span class=\"line\">&gt; show tables</span><br><span class=\"line\">site                     # 自动创建了 site 集合（数据表）</span><br><span class=\"line\">&gt; db.site.find()</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;), &quot;name&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;www.runoob&quot; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要插入多条数据可以使用 <strong>insertMany()</strong>：</p>\n<h2 id=\"插入多条数据\"><a href=\"#插入多条数据\" class=\"headerlink\" title=\"插入多条数据\"></a>插入多条数据</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj =  [</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'菜鸟工具'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://c.runoob.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'cn'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Google'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Facebook'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;</span><br><span class=\"line\">       ];</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertMany(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"插入的文档数量为: \"</span> + res.insertedCount);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>res.insertedCount 为插入的条数。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>). find(&#123;&#125;).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123; <span class=\"comment\">// 返回集合中所有数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>以下实例检索 name 为 “菜鸟教程” 的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find(whereStr).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ &#123; _id: 5a794e36763eb821b24db854,</span><br><span class=\"line\">    name: '菜鸟教程',</span><br><span class=\"line\">    url: 'www.runoob' &#125; ]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><p>我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 <a href=\"https://www.runoob.com：\">https://www.runoob.com：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更新一条数据</span><br><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateOne(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档更新成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，进入 mongo 管理工具查看数据已修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.site.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;),</span><br><span class=\"line\">    &quot;name&quot; : &quot;菜鸟教程&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https:&#x2F;&#x2F;www.runoob.com&quot;     &#x2F;&#x2F; 已修改为 https</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要更新所有符合条的文档数据可以使用 <strong>updateMany()</strong>：</p>\n<h4 id=\"更新多条数据\"><a href=\"#更新多条数据\" class=\"headerlink\" title=\"更新多条数据\"></a>更新多条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"type\"</span>:<span class=\"string\">'en'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateMany(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.result.nModified + <span class=\"string\">\" 条文档被更新\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>result.nModified 为更新的条数。</p>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>以下实例将 name 为 “菜鸟教程” 的数据删除 :</p>\n<h4 id=\"删除一条数据\"><a href=\"#删除一条数据\" class=\"headerlink\" title=\"删除一条数据\"></a>删除一条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).deleteOne(whereStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档删除成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，进入 mongo 管理工具查看数据已删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.site.find()</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果要删除多条语句可以使用 <strong>deleteMany()</strong> 方法</p>\n<p>以下实例将 type 为 en 的所有数据删除 :</p>\n<h4 id=\"删除多条数据\"><a href=\"#删除多条数据\" class=\"headerlink\" title=\"删除多条数据\"></a>删除多条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"en\"</span> &#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).deleteMany(whereStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(obj.result.n + <span class=\"string\">\" 条文档被删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>obj.result.n 删除的条数。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; type: 1 &#125;  &#x2F;&#x2F; 按 type 字段升序</span><br><span class=\"line\">&#123; type: -1 &#125; &#x2F;&#x2F; 按 type 字段降序</span><br></pre></td></tr></table></figure>\n\n<p>按 type 升序排列:</p>\n<h4 id=\"排序-1\"><a href=\"#排序-1\" class=\"headerlink\" title=\"排序\"></a>排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mysort = &#123; <span class=\"attr\">type</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().sort(mysort).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查询分页\"><a href=\"#查询分页\" class=\"headerlink\" title=\"查询分页\"></a>查询分页</h3><p>如果要设置指定的返回条数可以使用 <strong>limit()</strong> 方法，该方法只接受一个参数，指定了返回的条数。</p>\n<h4 id=\"limit-：读取两条数据\"><a href=\"#limit-：读取两条数据\" class=\"headerlink\" title=\"limit()：读取两条数据\"></a>limit()：读取两条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果要指定跳过的条数，可以使用 <strong>skip()</strong> 方法。</p>\n<h4 id=\"skip-跳过前面两条数据，读取两条数据\"><a href=\"#skip-跳过前面两条数据，读取两条数据\" class=\"headerlink\" title=\"skip(): 跳过前面两条数据，读取两条数据\"></a>skip(): 跳过前面两条数据，读取两条数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().skip(<span class=\"number\">2</span>).limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接操作\"><a href=\"#连接操作\" class=\"headerlink\" title=\"连接操作\"></a>连接操作</h3><p>mongoDB 不是一个关系型数据库，但我们可以使用 <strong>$lookup</strong> 来实现左连接。</p>\n<p>例如我们有两个集合数据分别为：</p>\n<p>集合1：orders</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123; _id: 1, product_id: 154, status: 1 &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>集合2：products</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123; _id: 154, name: &#39;笔记本电脑&#39; &#125;,</span><br><span class=\"line\">  &#123; _id: 155, name: &#39;耳机&#39; &#125;,</span><br><span class=\"line\">  &#123; _id: 156, name: &#39;台式电脑&#39; &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lookup-实现左连接\"><a href=\"#lookup-实现左连接\" class=\"headerlink\" title=\"$lookup 实现左连接\"></a>$lookup 实现左连接</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://127.0.0.1:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">  dbo.collection(<span class=\"string\">'orders'</span>).aggregate([</span><br><span class=\"line\">    &#123; <span class=\"attr\">$lookup</span>:</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         <span class=\"keyword\">from</span>: <span class=\"string\">'products'</span>,            <span class=\"comment\">// 右集合</span></span><br><span class=\"line\">         localField: <span class=\"string\">'product_id'</span>,    <span class=\"comment\">// 左集合 join 字段</span></span><br><span class=\"line\">         foreignField: <span class=\"string\">'_id'</span>,         <span class=\"comment\">// 右集合 join 字段</span></span><br><span class=\"line\">         <span class=\"keyword\">as</span>: <span class=\"string\">'orderdetails'</span>           <span class=\"comment\">// 新生成字段（类型array）</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ]).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(res));</span><br><span class=\"line\">    db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除集合\"><a href=\"#删除集合\" class=\"headerlink\" title=\"删除集合\"></a>删除集合</h3><p>我们可以使用 <strong>drop()</strong> 方法来删除集合：</p>\n<h4 id=\"drop\"><a href=\"#drop\" class=\"headerlink\" title=\"drop()\"></a>drop()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">MongoClient.connect(url, &#123; <span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 删除 test 集合</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"test\"</span>).drop(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, delOK</span>) </span>&#123;  <span class=\"comment\">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delOK) <span class=\"built_in\">console</span>.log(<span class=\"string\">\"集合已删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><ol>\n<li><p>作者：Jay_huaxiao<br>链接：<a href=\"https://juejin.im/post/5d1883a05188255eea62e096\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d1883a05188255eea62e096</a><br>来源：掘金</p>\n</li>\n<li><p>作者：zhaoolee<br>链接：<a href=\"https://www.jianshu.com/p/a95c6b21c382\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a95c6b21c382</a><br>来源：简书</p>\n</li>\n<li><p>来源：菜鸟教程</p>\n</li>\n</ol>\n"},{"layout":"post","title":"ES6特性笔记","date":"2020-03-26T04:35:00.000Z","description":"ES2015(ES6)特性笔记总结","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200325213740.png","optimized_image":null,"author":"tty","_content":"\n谷歌对特殊符号的不支持真是让我无语！很多查询都变得无比艰难！总结一下，我可不想再查一次了\n\n提前说明这不是tutorial，我也没加tutorial标签。这里只有我想记一下的内容\n\n## 解构赋值\n\n你是不是见到过以下的情况\n\n```javascript\nconst { promisify } = require('util')\n```\n\n却不知道这大括号是干什么用的？\n\n这是ES6的解构赋值。\n\n**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。\n\n### 语法\n\n```js\nvar a, b, rest;\n[a, b] = [10, 20];\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n[a, b, ...rest] = [10, 20, 30, 40, 50];\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // [30, 40, 50]\n\n({ a, b } = { a: 10, b: 20 });\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n\n// Stage 4（已完成）提案中的特性\n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // {c: 30, d: 40}\n```\n\n### 描述\n\n对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。\n\n```js\nvar x = [1, 2, 3, 4, 5];\n```\n\n解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。\n\n```js\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y); // 1\nconsole.log(z); // 2\n```\n\nJavaScript 中，解构赋值的作用类似于 Perl 和 Python 语言中的相似特性。\n\n关于解构赋值，查看\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n","source":"_posts/2020-03-25-ES6特性笔记.md","raw":"---\nlayout: post\ntitle:  ES6特性笔记\ndate:   2020-03-25 21:35:00\ndescription: ES2015(ES6)特性笔记总结\nsubtitle:\ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200325213740.png\noptimized_image:\ncategory: javascript\ntags:\n  - code\n  - javascript\nauthor: tty\n---\n\n谷歌对特殊符号的不支持真是让我无语！很多查询都变得无比艰难！总结一下，我可不想再查一次了\n\n提前说明这不是tutorial，我也没加tutorial标签。这里只有我想记一下的内容\n\n## 解构赋值\n\n你是不是见到过以下的情况\n\n```javascript\nconst { promisify } = require('util')\n```\n\n却不知道这大括号是干什么用的？\n\n这是ES6的解构赋值。\n\n**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。\n\n### 语法\n\n```js\nvar a, b, rest;\n[a, b] = [10, 20];\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n[a, b, ...rest] = [10, 20, 30, 40, 50];\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // [30, 40, 50]\n\n({ a, b } = { a: 10, b: 20 });\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n\n// Stage 4（已完成）提案中的特性\n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // {c: 30, d: 40}\n```\n\n### 描述\n\n对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。\n\n```js\nvar x = [1, 2, 3, 4, 5];\n```\n\n解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。\n\n```js\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y); // 1\nconsole.log(z); // 2\n```\n\nJavaScript 中，解构赋值的作用类似于 Perl 和 Python 语言中的相似特性。\n\n关于解构赋值，查看\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n","slug":"ES6特性笔记","published":1,"updated":"2020-03-29T06:59:20.717Z","photos":[],"link":"","_id":"ck8ct7j61001lgtvi0kojd427","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>谷歌对特殊符号的不支持真是让我无语！很多查询都变得无比艰难！总结一下，我可不想再查一次了</p>\n<p>提前说明这不是tutorial，我也没加tutorial标签。这里只有我想记一下的内容</p>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>你是不是见到过以下的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>却不知道这大括号是干什么用的？</p>\n<p>这是ES6的解构赋值。</p>\n<p><strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b, rest;</span><br><span class=\"line\">[a, b] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">[a, b, ...rest] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [30, 40, 50]</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Stage 4（已完成）提案中的特性</span></span><br><span class=\"line\">(&#123;a, b, ...rest&#125; = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> [y, z] = x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 中，解构赋值的作用类似于 Perl 和 Python 语言中的相似特性。</p>\n<p>关于解构赋值，查看</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>谷歌对特殊符号的不支持真是让我无语！很多查询都变得无比艰难！总结一下，我可不想再查一次了</p>\n<p>提前说明这不是tutorial，我也没加tutorial标签。这里只有我想记一下的内容</p>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>你是不是见到过以下的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>却不知道这大括号是干什么用的？</p>\n<p>这是ES6的解构赋值。</p>\n<p><strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b, rest;</span><br><span class=\"line\">[a, b] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">[a, b, ...rest] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [30, 40, 50]</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Stage 4（已完成）提案中的特性</span></span><br><span class=\"line\">(&#123;a, b, ...rest&#125; = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> [y, z] = x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 中，解构赋值的作用类似于 Perl 和 Python 语言中的相似特性。</p>\n<p>关于解构赋值，查看</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n"},{"layout":"post","title":"Lodash笔记","date":"2020-03-25T21:35:00.000Z","description":"一个JavaScript常用库","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200325231158.png","optimized_image":null,"author":"tty","_content":"\n一部分来自官方文档，一部分内容来自：\n\n作者：戈德斯文\n链接：https://www.jianshu.com/p/d46abfa4ddc9\n来源：简书\n\n## 为什么使用lodash\n\n通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。\n\n## 常用lodash函数\n\n##### _.times N次循环\n\n```html\n<script type=\"text/javascript\">\n    console.log('------- javascript -------');\n    //js原生的循环方法\n    for(var i = 0; i < 5; i++){\n        console.log(i);\n    }\n    console.log('------- lodash -------');\n    //ladash的times方法\n    _.times(5,function(a){\n        console.log(a);\n    });\n</script>\n```\n\n`for`语句是执行循环的不二选择，但在上面代码的使用场景下，`_.times()`的解决方式更加简洁和易于理解。\n\n##### _.map 深层查找属性值\n\n```html\n<script type=\"text/javascript\">\n    var ownerArr = [{\n        \"owner\": \"Colin\",\n        \"pets\": [{\"name\": \"dog1\"}, {\"name\": \"dog2\"}]\n    }, {\n        \"owner\": \"John\",\n        \"pets\": [{\"name\": \"dog3\"}, {\"name\": \"dog4\"}]\n    }];\n    var jsMap = ownerArr.map(function (owner) {\n        return owner.pets[0].name;\n    });\n    console.log('------- jsMap -------');\n    console.log(jsMap);\n\n    var lodashMap = _.map(ownerArr, 'pets[0].name');\n    console.log('------- lodashMap -------');\n    console.log(lodashMap);\n</script>\n```\n\nLodash中的`_.map`方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。\n\n##### _.cloneDeep 深克隆对象\n\n```html\n<script type=\"text/javascript\">\n    var objA = {\n        \"name\": \"戈德斯文\"\n    };\n    var objB = _.cloneDeep(objA);\n    console.log(objA);\n    console.log(objB);\n    console.log(objA === objB);\n</script>\n```\n\n深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:`JSON.parse(JSON.stringify(objectToClone))` 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。\n\n##### _.random 在指定范围内获取一个随机值\n\n```html\n<script type=\"text/javascript\">\n    function getRandomNumber(min, max){\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    console.log(getRandomNumber(15, 20));\n\n    console.log(_.random(15, 20));\n\n</script>\n```\n\nLodash中的 `_.random` 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数`_.random(15,20,true)`\n\n##### _.assign 扩展对象\n\n```html\n<script type=\"text/javascript\">\n    Object.prototype.extend = function(obj) {\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {    //判断被扩展的对象有没有某个属性，\n                this[i] = obj[i];\n            }\n        }\n    };\n\n    var objA = {\"name\": \"戈德斯文\", \"car\": \"宝马\"};\n    var objB = {\"name\": \"柴硕\", \"loveEat\": true};\n\n    objA.extend(objB);\n    console.log(objA); \n\n    console.log(_.assign(objA, objB));\n</script>\n```\n\n`_.assign` 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并\n\n##### _.sample _.sampleSize 从列表中随机的选择列表项\n\n```html\n<script type=\"text/javascript\">\n    var smartTeam = [\"戈德斯文\", \"杨海月\", \"柴硕\", \"师贝贝\"];\n\n    function randomSmarter(smartTeam){\n        var index = Math.floor(Math.random() * smartTeam.length);\n        return smartTeam[index];\n    }\n\n    console.log(randomSmarter(smartTeam));\n\n    // Lodash\n    console.log(_.sample(smartTeam));\n    console.log(_.sampleSize(smartTeam,2));\n</script>\n```\n\n此外，你也可以指定随机返回元素的个数`_.sampleSize(smartTeam,n)`，n为需要返回的元素个数\n\n##### _.includes 判断对象中是否含有某元素\n\n```html\n<script type=\"text/javascript\">\n    var smartPerson = {\n            'name': '戈德斯文',\n            'gender': 'male'\n        },\n        smartTeam = [\"戈德斯文\", \"杨海月\", \"柴硕\", \"师贝贝\"];\n\n\n    console.log(_.includes(smartPerson, '戈德斯文'));\n    console.log(_.includes(smartTeam, '杨海月'));\n    console.log(_.includes(smartTeam, '杨海月',2));\n</script>\n```\n\n`_.includes()`第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标\n\n##### _.forEach 遍历循环\n\n```html\n<script type=\"text/javascript\">\n    _([1, 2]).forEach(function(value) {\n        console.log(value);\n    });\n    _.forEach([1, 3] , function(value, key) {\n        console.log(key,value);\n    });\n</script>\n```\n\n这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后`key`是元素的下标，当传入的是对象的时候，`key`是属性，`value`是值\n\n##### _.map 遍历循环执行某个方法\n\n`_.map()`\n\n```html\n<script type=\"text/javascript\">\n    function square(n) {\n        return n * n;\n    }\n\n    console.log(_.map([4, 8], square));\n    // => [16, 64]\n\n    console.log(_.map({ 'a': 4, 'b': 8 }, square));\n    // => [16, 64] (iteration order is not guaranteed)\n\n    var users = [\n        { 'user': 'barney' },\n        { 'user': 'fred' }\n    ];\n\n    // The `_.property` iteratee shorthand.\n    console.log(_.map(users, 'user'));\n    // => ['barney', 'fred']\n</script>\n```\n\n##### _.isEmpty 检验值是否为空\n\n`_.isEmpty()`\n\n```html\n<script type=\"text/javascript\">\n    _.isEmpty(null);\n    // => true\n\n    _.isEmpty(true);\n    // => true\n\n    _.isEmpty(1);\n    // => true\n\n    _.isEmpty([1, 2, 3]);\n    // => false\n\n    _.isEmpty({ 'a': 1 });\n    // => false\n</script>\n```\n\n##### _.find()、_.filter()、_.reject() 查找属性\n\n`_.find()`、`_.filter()`、`_.reject()`\n\n```html\n<script type=\"text/javascript\">\n    var users = [\n        {'user': 'barney', 'age': 36, 'active': true},\n        {'user': 'fred', 'age': 40, 'active': false},\n        {'user': 'pebbles', 'age': 1, 'active': true}\n    ];\n\n    console.log(_.find(users, function (o) {\n        return o.age < 40;\n    }));\n    console.log(_.find(users, {'age': 1, 'active': true}));\n    console.log(_.filter(users, {'age': 1, 'active': true}));\n    console.log(_.find(users, ['active', false]));\n    console.log(_.filter(users, ['active', false]));\n    console.log(_.find(users, 'active'));\n    console.log(_.filter(users, 'active'));\n\n</script>\n```\n\n`_.find()`第一个返回真值的第一个元素。\n `_.filter()`返回真值的所有元素的数组。\n `_.reject()`是`_.filter`的反向方法，不返回真值的（集合）元素\n\n##### _.uniq 数组去重\n\n`_.uniq(array)`创建一个去重后的array数组副本。\n\n参数\n `array (Array)`: 要检查的数组。\n\n返回新的去重后的数组\n\n```html\n<script type=\"text/javascript\">\n    var arr1 = [2, 1, 2];\n\n    var arr2 = _.uniq(arr1);\n\n\n    function unique(arr) {\n        var newArr = [];\n        for (var i = 0; i < arr.length; i++) {\n            if(newArr.indexOf(arr[i]) == -1){\n                newArr.push(arr[i]);\n            }\n        }\n        return newArr;\n    }\n\n    console.log(arr1);\n    console.log(arr2);\n    console.log(unique(arr1));\n</script>\n```\n\n`_.uniqBy(array,[iteratee=_.identity])`这个方法类似 `_.uniq`，除了它接受一个 `iteratee`（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。\n\n\n\n```html\n<script type=\"text/javascript\">\n    console.log(_.uniqBy([2.1, 1.2, 2.3], Math.floor));\n    // => [2.1, 1.2]\n    \n    console.log(_.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x'));\n    // => [{ 'x': 1 }, { 'x': 2 }]\n</script>\n```\n\n`Math.floor`只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。\n\n##### _.template 模板插入\n\n`_.template([string=''], [options={}])`\n\n\n\n```html\n<div id=\"container\"></div>\n\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"></script>\n<script type=\"text/javascript\">\n    $(function () {\n        var data = [{name: '戈德斯文'}, {name: '柴硕'}, {name: '杨海月'}];\n        var t = _.template($(\"#tpl\").html());\n        $(\"#container\").html(t(data));\n    });\n</script>\n<script type=\"text/template\" id=\"tpl\">\n    <% _.each(obj,function(e,i){ %>\n        <ul>\n            <li><%= e.name %><%= i %></li>\n        </ul>\n    <%})%>\n</script>\n```\n\n##### _.get 根据path找到object相关properties\n\n`_.get(object, path, [defaultValue])`\n\n```javascript\nvar object = { 'a': [{ 'b': { 'c': 3 } }] };\n \n_.get(object, 'a[0].b.c');\n// => 3\n \n_.get(object, ['a', '0', 'b', 'c']);\n// => 3\n \n_.get(object, 'a.b.c', 'default');\n// => 'default'\n```\n\n##### _.concat 将一些array连在一起\n\n`_.concat(array, [values])`\n\n```JavaScript\nvar array = [1];\nvar other = _.concat(array, 2, [3], [[4]]);\n \nconsole.log(other);\n// => [1, 2, 3, [4]]\n \nconsole.log(array);\n// => [1]\n```\n\n##### _.compact 移除falsey values\n\n`_.compact(array)`\n\nCreates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\n```javascript\n_.compact([0, 1, false, 2, '', 3]);\n// => [1, 2, 3]\n```\n\n##### _.prototype.value\n\n`_.prototype.value()`\n\nExecutes the chain sequence to resolve the unwrapped value.\n\n```javascript\n_([1, 2, 3]).value();\n// => [1, 2, 3]\n```\n\n##### _prototype.filter 查找符合条件的\n\n`_.filter(collection, [predicate=_.identity])`\n\n```javascript\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n \n_.filter(users, function(o) { return !o.active; });\n// => objects for ['fred']\n \n// The `_.matches` iteratee shorthand.\n_.filter(users, { 'age': 36, 'active': true });\n// => objects for ['barney']\n \n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, ['active', false]);\n// => objects for ['fred']\n \n// The `_.property` iteratee shorthand.\n_.filter(users, 'active');\n// => objects for ['barney']\n```\n\n##### _.keyBy 以新key重建数据结构\n\n`_.keyBy(collection, [iteratee=_.identity])`\n\n```JavaScript\nvar array = [\n  { 'dir': 'left', 'code': 97 },\n  { 'dir': 'right', 'code': 100 }\n];\n \n_.keyBy(array, function(o) {\n  return String.fromCharCode(o.code);\n});\n// => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n \n_.keyBy(array, 'dir');\n// => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n```","source":"_posts/2020-03-25-Lodash笔记.md","raw":"---\nlayout: post\ntitle:  Lodash笔记\ndate:   2020-03-25 14:35:00\ndescription: 一个JavaScript常用库\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200325231158.png\noptimized_image: \ncategory: javascript\ntags:\n  - code\n  - javascript\nauthor: tty\n---\n\n一部分来自官方文档，一部分内容来自：\n\n作者：戈德斯文\n链接：https://www.jianshu.com/p/d46abfa4ddc9\n来源：简书\n\n## 为什么使用lodash\n\n通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。\n\n## 常用lodash函数\n\n##### _.times N次循环\n\n```html\n<script type=\"text/javascript\">\n    console.log('------- javascript -------');\n    //js原生的循环方法\n    for(var i = 0; i < 5; i++){\n        console.log(i);\n    }\n    console.log('------- lodash -------');\n    //ladash的times方法\n    _.times(5,function(a){\n        console.log(a);\n    });\n</script>\n```\n\n`for`语句是执行循环的不二选择，但在上面代码的使用场景下，`_.times()`的解决方式更加简洁和易于理解。\n\n##### _.map 深层查找属性值\n\n```html\n<script type=\"text/javascript\">\n    var ownerArr = [{\n        \"owner\": \"Colin\",\n        \"pets\": [{\"name\": \"dog1\"}, {\"name\": \"dog2\"}]\n    }, {\n        \"owner\": \"John\",\n        \"pets\": [{\"name\": \"dog3\"}, {\"name\": \"dog4\"}]\n    }];\n    var jsMap = ownerArr.map(function (owner) {\n        return owner.pets[0].name;\n    });\n    console.log('------- jsMap -------');\n    console.log(jsMap);\n\n    var lodashMap = _.map(ownerArr, 'pets[0].name');\n    console.log('------- lodashMap -------');\n    console.log(lodashMap);\n</script>\n```\n\nLodash中的`_.map`方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。\n\n##### _.cloneDeep 深克隆对象\n\n```html\n<script type=\"text/javascript\">\n    var objA = {\n        \"name\": \"戈德斯文\"\n    };\n    var objB = _.cloneDeep(objA);\n    console.log(objA);\n    console.log(objB);\n    console.log(objA === objB);\n</script>\n```\n\n深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:`JSON.parse(JSON.stringify(objectToClone))` 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。\n\n##### _.random 在指定范围内获取一个随机值\n\n```html\n<script type=\"text/javascript\">\n    function getRandomNumber(min, max){\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    console.log(getRandomNumber(15, 20));\n\n    console.log(_.random(15, 20));\n\n</script>\n```\n\nLodash中的 `_.random` 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数`_.random(15,20,true)`\n\n##### _.assign 扩展对象\n\n```html\n<script type=\"text/javascript\">\n    Object.prototype.extend = function(obj) {\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {    //判断被扩展的对象有没有某个属性，\n                this[i] = obj[i];\n            }\n        }\n    };\n\n    var objA = {\"name\": \"戈德斯文\", \"car\": \"宝马\"};\n    var objB = {\"name\": \"柴硕\", \"loveEat\": true};\n\n    objA.extend(objB);\n    console.log(objA); \n\n    console.log(_.assign(objA, objB));\n</script>\n```\n\n`_.assign` 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并\n\n##### _.sample _.sampleSize 从列表中随机的选择列表项\n\n```html\n<script type=\"text/javascript\">\n    var smartTeam = [\"戈德斯文\", \"杨海月\", \"柴硕\", \"师贝贝\"];\n\n    function randomSmarter(smartTeam){\n        var index = Math.floor(Math.random() * smartTeam.length);\n        return smartTeam[index];\n    }\n\n    console.log(randomSmarter(smartTeam));\n\n    // Lodash\n    console.log(_.sample(smartTeam));\n    console.log(_.sampleSize(smartTeam,2));\n</script>\n```\n\n此外，你也可以指定随机返回元素的个数`_.sampleSize(smartTeam,n)`，n为需要返回的元素个数\n\n##### _.includes 判断对象中是否含有某元素\n\n```html\n<script type=\"text/javascript\">\n    var smartPerson = {\n            'name': '戈德斯文',\n            'gender': 'male'\n        },\n        smartTeam = [\"戈德斯文\", \"杨海月\", \"柴硕\", \"师贝贝\"];\n\n\n    console.log(_.includes(smartPerson, '戈德斯文'));\n    console.log(_.includes(smartTeam, '杨海月'));\n    console.log(_.includes(smartTeam, '杨海月',2));\n</script>\n```\n\n`_.includes()`第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标\n\n##### _.forEach 遍历循环\n\n```html\n<script type=\"text/javascript\">\n    _([1, 2]).forEach(function(value) {\n        console.log(value);\n    });\n    _.forEach([1, 3] , function(value, key) {\n        console.log(key,value);\n    });\n</script>\n```\n\n这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后`key`是元素的下标，当传入的是对象的时候，`key`是属性，`value`是值\n\n##### _.map 遍历循环执行某个方法\n\n`_.map()`\n\n```html\n<script type=\"text/javascript\">\n    function square(n) {\n        return n * n;\n    }\n\n    console.log(_.map([4, 8], square));\n    // => [16, 64]\n\n    console.log(_.map({ 'a': 4, 'b': 8 }, square));\n    // => [16, 64] (iteration order is not guaranteed)\n\n    var users = [\n        { 'user': 'barney' },\n        { 'user': 'fred' }\n    ];\n\n    // The `_.property` iteratee shorthand.\n    console.log(_.map(users, 'user'));\n    // => ['barney', 'fred']\n</script>\n```\n\n##### _.isEmpty 检验值是否为空\n\n`_.isEmpty()`\n\n```html\n<script type=\"text/javascript\">\n    _.isEmpty(null);\n    // => true\n\n    _.isEmpty(true);\n    // => true\n\n    _.isEmpty(1);\n    // => true\n\n    _.isEmpty([1, 2, 3]);\n    // => false\n\n    _.isEmpty({ 'a': 1 });\n    // => false\n</script>\n```\n\n##### _.find()、_.filter()、_.reject() 查找属性\n\n`_.find()`、`_.filter()`、`_.reject()`\n\n```html\n<script type=\"text/javascript\">\n    var users = [\n        {'user': 'barney', 'age': 36, 'active': true},\n        {'user': 'fred', 'age': 40, 'active': false},\n        {'user': 'pebbles', 'age': 1, 'active': true}\n    ];\n\n    console.log(_.find(users, function (o) {\n        return o.age < 40;\n    }));\n    console.log(_.find(users, {'age': 1, 'active': true}));\n    console.log(_.filter(users, {'age': 1, 'active': true}));\n    console.log(_.find(users, ['active', false]));\n    console.log(_.filter(users, ['active', false]));\n    console.log(_.find(users, 'active'));\n    console.log(_.filter(users, 'active'));\n\n</script>\n```\n\n`_.find()`第一个返回真值的第一个元素。\n `_.filter()`返回真值的所有元素的数组。\n `_.reject()`是`_.filter`的反向方法，不返回真值的（集合）元素\n\n##### _.uniq 数组去重\n\n`_.uniq(array)`创建一个去重后的array数组副本。\n\n参数\n `array (Array)`: 要检查的数组。\n\n返回新的去重后的数组\n\n```html\n<script type=\"text/javascript\">\n    var arr1 = [2, 1, 2];\n\n    var arr2 = _.uniq(arr1);\n\n\n    function unique(arr) {\n        var newArr = [];\n        for (var i = 0; i < arr.length; i++) {\n            if(newArr.indexOf(arr[i]) == -1){\n                newArr.push(arr[i]);\n            }\n        }\n        return newArr;\n    }\n\n    console.log(arr1);\n    console.log(arr2);\n    console.log(unique(arr1));\n</script>\n```\n\n`_.uniqBy(array,[iteratee=_.identity])`这个方法类似 `_.uniq`，除了它接受一个 `iteratee`（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。\n\n\n\n```html\n<script type=\"text/javascript\">\n    console.log(_.uniqBy([2.1, 1.2, 2.3], Math.floor));\n    // => [2.1, 1.2]\n    \n    console.log(_.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x'));\n    // => [{ 'x': 1 }, { 'x': 2 }]\n</script>\n```\n\n`Math.floor`只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。\n\n##### _.template 模板插入\n\n`_.template([string=''], [options={}])`\n\n\n\n```html\n<div id=\"container\"></div>\n\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"></script>\n<script type=\"text/javascript\">\n    $(function () {\n        var data = [{name: '戈德斯文'}, {name: '柴硕'}, {name: '杨海月'}];\n        var t = _.template($(\"#tpl\").html());\n        $(\"#container\").html(t(data));\n    });\n</script>\n<script type=\"text/template\" id=\"tpl\">\n    <% _.each(obj,function(e,i){ %>\n        <ul>\n            <li><%= e.name %><%= i %></li>\n        </ul>\n    <%})%>\n</script>\n```\n\n##### _.get 根据path找到object相关properties\n\n`_.get(object, path, [defaultValue])`\n\n```javascript\nvar object = { 'a': [{ 'b': { 'c': 3 } }] };\n \n_.get(object, 'a[0].b.c');\n// => 3\n \n_.get(object, ['a', '0', 'b', 'c']);\n// => 3\n \n_.get(object, 'a.b.c', 'default');\n// => 'default'\n```\n\n##### _.concat 将一些array连在一起\n\n`_.concat(array, [values])`\n\n```JavaScript\nvar array = [1];\nvar other = _.concat(array, 2, [3], [[4]]);\n \nconsole.log(other);\n// => [1, 2, 3, [4]]\n \nconsole.log(array);\n// => [1]\n```\n\n##### _.compact 移除falsey values\n\n`_.compact(array)`\n\nCreates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\n```javascript\n_.compact([0, 1, false, 2, '', 3]);\n// => [1, 2, 3]\n```\n\n##### _.prototype.value\n\n`_.prototype.value()`\n\nExecutes the chain sequence to resolve the unwrapped value.\n\n```javascript\n_([1, 2, 3]).value();\n// => [1, 2, 3]\n```\n\n##### _prototype.filter 查找符合条件的\n\n`_.filter(collection, [predicate=_.identity])`\n\n```javascript\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n \n_.filter(users, function(o) { return !o.active; });\n// => objects for ['fred']\n \n// The `_.matches` iteratee shorthand.\n_.filter(users, { 'age': 36, 'active': true });\n// => objects for ['barney']\n \n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, ['active', false]);\n// => objects for ['fred']\n \n// The `_.property` iteratee shorthand.\n_.filter(users, 'active');\n// => objects for ['barney']\n```\n\n##### _.keyBy 以新key重建数据结构\n\n`_.keyBy(collection, [iteratee=_.identity])`\n\n```JavaScript\nvar array = [\n  { 'dir': 'left', 'code': 97 },\n  { 'dir': 'right', 'code': 100 }\n];\n \n_.keyBy(array, function(o) {\n  return String.fromCharCode(o.code);\n});\n// => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n \n_.keyBy(array, 'dir');\n// => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n```","slug":"Lodash笔记","published":1,"updated":"2020-03-29T06:59:20.717Z","photos":[],"link":"","_id":"ck8ct7j62001pgtvi97lv2qkg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>一部分来自官方文档，一部分内容来自：</p>\n<p>作者：戈德斯文<br>链接：<a href=\"https://www.jianshu.com/p/d46abfa4ddc9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/d46abfa4ddc9</a><br>来源：简书</p>\n<h2 id=\"为什么使用lodash\"><a href=\"#为什么使用lodash\" class=\"headerlink\" title=\"为什么使用lodash\"></a>为什么使用lodash</h2><p>通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。</p>\n<h2 id=\"常用lodash函数\"><a href=\"#常用lodash函数\" class=\"headerlink\" title=\"常用lodash函数\"></a>常用lodash函数</h2><h5 id=\"times-N次循环\"><a href=\"#times-N次循环\" class=\"headerlink\" title=\"_.times N次循环\"></a>_.times N次循环</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- javascript -------'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">//js原生的循环方法</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(i);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- lodash -------'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">//ladash的times方法</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    _.times(<span class=\"number\">5</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(a);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>语句是执行循环的不二选择，但在上面代码的使用场景下，<code>_.times()</code>的解决方式更加简洁和易于理解。</p>\n<h5 id=\"map-深层查找属性值\"><a href=\"#map-深层查找属性值\" class=\"headerlink\" title=\"_.map 深层查找属性值\"></a>_.map 深层查找属性值</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> ownerArr = [&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"Colin\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pets\"</span>: [&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog1\"</span>&#125;, &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog2\"</span>&#125;]</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"John\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pets\"</span>: [&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog3\"</span>&#125;, &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog4\"</span>&#125;]</span></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> jsMap = ownerArr.map(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(owner)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> owner.pets[<span class=\"number\">0</span>].name;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- jsMap -------'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(jsMap);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> lodashMap = _.map(ownerArr, <span class=\"string\">'pets[0].name'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- lodashMap -------'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(lodashMap);</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lodash中的<code>_.map</code>方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。</p>\n<h5 id=\"cloneDeep-深克隆对象\"><a href=\"#cloneDeep-深克隆对象\" class=\"headerlink\" title=\"_.cloneDeep 深克隆对象\"></a>_.cloneDeep 深克隆对象</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objA = &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"戈德斯文\"</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objB = _.cloneDeep(objA);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objB);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA === objB);</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:<code>JSON.parse(JSON.stringify(objectToClone))</code> 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。</p>\n<h5 id=\"random-在指定范围内获取一个随机值\"><a href=\"#random-在指定范围内获取一个随机值\" class=\"headerlink\" title=\"_.random 在指定范围内获取一个随机值\"></a>_.random 在指定范围内获取一个随机值</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomNumber</span><span class=\"params\">(min, max)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(getRandomNumber(<span class=\"number\">15</span>, <span class=\"number\">20</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.random(<span class=\"number\">15</span>, <span class=\"number\">20</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lodash中的 <code>_.random</code> 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数<code>_.random(15,20,true)</code></p>\n<h5 id=\"assign-扩展对象\"><a href=\"#assign-扩展对象\" class=\"headerlink\" title=\"_.assign 扩展对象\"></a>_.assign 扩展对象</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">Object</span>.prototype.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> obj) &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"keyword\">if</span> (obj.hasOwnProperty(i)) &#123;    <span class=\"comment\">//判断被扩展的对象有没有某个属性，</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">this</span>[i] = obj[i];</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objA = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"car\"</span>: <span class=\"string\">\"宝马\"</span>&#125;;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objB = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"loveEat\"</span>: <span class=\"literal\">true</span>&#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objA.extend(objB);</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA); </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.assign(objA, objB));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.assign</code> 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并</p>\n<h5 id=\"sample-sampleSize-从列表中随机的选择列表项\"><a href=\"#sample-sampleSize-从列表中随机的选择列表项\" class=\"headerlink\" title=\"_.sample _.sampleSize 从列表中随机的选择列表项\"></a>_.sample _.sampleSize 从列表中随机的选择列表项</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> smartTeam = [<span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"杨海月\"</span>, <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"师贝贝\"</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomSmarter</span><span class=\"params\">(smartTeam)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * smartTeam.length);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> smartTeam[index];</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(randomSmarter(smartTeam));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// Lodash</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.sample(smartTeam));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.sampleSize(smartTeam,<span class=\"number\">2</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，你也可以指定随机返回元素的个数<code>_.sampleSize(smartTeam,n)</code>，n为需要返回的元素个数</p>\n<h5 id=\"includes-判断对象中是否含有某元素\"><a href=\"#includes-判断对象中是否含有某元素\" class=\"headerlink\" title=\"_.includes 判断对象中是否含有某元素\"></a>_.includes 判断对象中是否含有某元素</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> smartPerson = &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"string\">'name'</span>: <span class=\"string\">'戈德斯文'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"string\">'gender'</span>: <span class=\"string\">'male'</span></span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"><span class=\"actionscript\">        smartTeam = [<span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"杨海月\"</span>, <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"师贝贝\"</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartPerson, <span class=\"string\">'戈德斯文'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartTeam, <span class=\"string\">'杨海月'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartTeam, <span class=\"string\">'杨海月'</span>,<span class=\"number\">2</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.includes()</code>第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标</p>\n<h5 id=\"forEach-遍历循环\"><a href=\"#forEach-遍历循环\" class=\"headerlink\" title=\"_.forEach 遍历循环\"></a>_.forEach 遍历循环</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    _([<span class=\"number\">1</span>, <span class=\"number\">2</span>]).forEach(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(value);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"actionscript\">    _.forEach([<span class=\"number\">1</span>, <span class=\"number\">3</span>] , <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value, key)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(key,value);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后<code>key</code>是元素的下标，当传入的是对象的时候，<code>key</code>是属性，<code>value</code>是值</p>\n<h5 id=\"map-遍历循环执行某个方法\"><a href=\"#map-遍历循环执行某个方法\" class=\"headerlink\" title=\"_.map 遍历循环执行某个方法\"></a>_.map 遍历循环执行某个方法</h5><p><code>_.map()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span><span class=\"params\">(n)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> n * n;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map([<span class=\"number\">4</span>, <span class=\"number\">8</span>], square));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [16, 64]</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map(&#123; <span class=\"string\">'a'</span>: <span class=\"number\">4</span>, <span class=\"string\">'b'</span>: <span class=\"number\">8</span> &#125;, square));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [16, 64] (iteration order is not guaranteed)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> users = [</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span> &#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span> &#125;</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// The `_.property` iteratee shorthand.</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map(users, <span class=\"string\">'user'</span>));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; ['barney', 'fred']</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"isEmpty-检验值是否为空\"><a href=\"#isEmpty-检验值是否为空\" class=\"headerlink\" title=\"_.isEmpty 检验值是否为空\"></a>_.isEmpty 检验值是否为空</h5><p><code>_.isEmpty()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(<span class=\"literal\">null</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(<span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    _.isEmpty(1);</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    _.isEmpty([1, 2, 3]);</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; false</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(&#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span> &#125;);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; false</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"find-、-filter-、-reject-查找属性\"><a href=\"#find-、-filter-、-reject-查找属性\" class=\"headerlink\" title=\".find()、.filter()、_.reject() 查找属性\"></a><em>.find()、</em>.filter()、_.reject() 查找属性</h5><p><code>_.find()</code>、<code>_.filter()</code>、<code>_.reject()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> users = [</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">40</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">false</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'pebbles'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> o.age &lt; <span class=\"number\">40</span>;</span></span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, <span class=\"string\">'active'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, <span class=\"string\">'active'</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.find()</code>第一个返回真值的第一个元素。<br> <code>_.filter()</code>返回真值的所有元素的数组。<br> <code>_.reject()</code>是<code>_.filter</code>的反向方法，不返回真值的（集合）元素</p>\n<h5 id=\"uniq-数组去重\"><a href=\"#uniq-数组去重\" class=\"headerlink\" title=\"_.uniq 数组去重\"></a>_.uniq 数组去重</h5><p><code>_.uniq(array)</code>创建一个去重后的array数组副本。</p>\n<p>参数<br> <code>array (Array)</code>: 要检查的数组。</p>\n<p>返回新的去重后的数组</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> arr1 = [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> arr2 = _.uniq(arr1);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span><span class=\"params\">(arr)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> newArr = [];</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class=\"line\">            if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">                newArr.push(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> newArr;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(arr1);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(arr2);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(unique(arr1));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.uniqBy(array,[iteratee=_.identity])</code>这个方法类似 <code>_.uniq</code>，除了它接受一个 <code>iteratee</code>（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.uniqBy([<span class=\"number\">2.1</span>, <span class=\"number\">1.2</span>, <span class=\"number\">2.3</span>], <span class=\"built_in\">Math</span>.floor));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [2.1, 1.2]</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.uniqBy([&#123; <span class=\"string\">'x'</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"string\">'x'</span>: <span class=\"number\">2</span> &#125;, &#123; <span class=\"string\">'x'</span>: <span class=\"number\">1</span> &#125;], <span class=\"string\">'x'</span>));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Math.floor</code>只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。</p>\n<h5 id=\"template-模板插入\"><a href=\"#template-模板插入\" class=\"headerlink\" title=\"_.template 模板插入\"></a>_.template 模板插入</h5><p><code>_.template([string=&#39;&#39;], [options={}])</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> data = [&#123;name: <span class=\"string\">'戈德斯文'</span>&#125;, &#123;name: <span class=\"string\">'柴硕'</span>&#125;, &#123;name: <span class=\"string\">'杨海月'</span>&#125;];</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> t = _.template($(<span class=\"string\">\"#tpl\"</span>).html());</span></span><br><span class=\"line\"><span class=\"javascript\">        $(<span class=\"string\">\"#container\"</span>).html(t(data));</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"tpl\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    &lt;% _.each(obj,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e,i)</span></span>&#123; %&gt;</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">e.name</span> %&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">i</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">%&#125;)%</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"get-根据path找到object相关properties\"><a href=\"#get-根据path找到object相关properties\" class=\"headerlink\" title=\"_.get 根据path找到object相关properties\"></a>_.get 根据path找到object相关properties</h5><p><code>_.get(object, path, [defaultValue])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">'a'</span>: [&#123; <span class=\"string\">'b'</span>: &#123; <span class=\"string\">'c'</span>: <span class=\"number\">3</span> &#125; &#125;] &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, <span class=\"string\">'a[0].b.c'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'0'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, <span class=\"string\">'a.b.c'</span>, <span class=\"string\">'default'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'default'</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"concat-将一些array连在一起\"><a href=\"#concat-将一些array连在一起\" class=\"headerlink\" title=\"_.concat 将一些array连在一起\"></a>_.concat 将一些array连在一起</h5><p><code>_.concat(array, [values])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> other = _.concat(array, <span class=\"number\">2</span>, [<span class=\"number\">3</span>], [[<span class=\"number\">4</span>]]);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(other);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3, [4]]</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"compact-移除falsey-values\"><a href=\"#compact-移除falsey-values\" class=\"headerlink\" title=\"_.compact 移除falsey values\"></a>_.compact 移除falsey values</h5><p><code>_.compact(array)</code></p>\n<p>Creates an array with all falsey values removed. The values <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, and <code>NaN</code> are falsey.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.compact([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">false</span>, <span class=\"number\">2</span>, <span class=\"string\">''</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"prototype-value\"><a href=\"#prototype-value\" class=\"headerlink\" title=\"_.prototype.value\"></a>_.prototype.value</h5><p><code>_.prototype.value()</code></p>\n<p>Executes the chain sequence to resolve the unwrapped value.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]).value();</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"prototype-filter-查找符合条件的\"><a href=\"#prototype-filter-查找符合条件的\" class=\"headerlink\" title=\"_prototype.filter 查找符合条件的\"></a>_prototype.filter 查找符合条件的</h5><p><code>_.filter(collection, [predicate=_.identity])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span>,   <span class=\"string\">'age'</span>: <span class=\"number\">40</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"> </span><br><span class=\"line\">_.filter(users, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123; <span class=\"keyword\">return</span> !o.active; &#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['fred']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.matches` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, &#123; <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['barney']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.matchesProperty` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['fred']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.property` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, <span class=\"string\">'active'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['barney']</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"keyBy-以新key重建数据结构\"><a href=\"#keyBy-以新key重建数据结构\" class=\"headerlink\" title=\"_.keyBy 以新key重建数据结构\"></a>_.keyBy 以新key重建数据结构</h5><p><code>_.keyBy(collection, [iteratee=_.identity])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [</span><br><span class=\"line\">  &#123; <span class=\"string\">'dir'</span>: <span class=\"string\">'left'</span>, <span class=\"string\">'code'</span>: <span class=\"number\">97</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">'dir'</span>: <span class=\"string\">'right'</span>, <span class=\"string\">'code'</span>: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"> </span><br><span class=\"line\">_.keyBy(array, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(o.code);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'a': &#123; 'dir': 'left', 'code': 97 &#125;, 'd': &#123; 'dir': 'right', 'code': 100 &#125; &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.keyBy(array, <span class=\"string\">'dir'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'left': &#123; 'dir': 'left', 'code': 97 &#125;, 'right': &#123; 'dir': 'right', 'code': 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>一部分来自官方文档，一部分内容来自：</p>\n<p>作者：戈德斯文<br>链接：<a href=\"https://www.jianshu.com/p/d46abfa4ddc9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/d46abfa4ddc9</a><br>来源：简书</p>\n<h2 id=\"为什么使用lodash\"><a href=\"#为什么使用lodash\" class=\"headerlink\" title=\"为什么使用lodash\"></a>为什么使用lodash</h2><p>通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。</p>\n<h2 id=\"常用lodash函数\"><a href=\"#常用lodash函数\" class=\"headerlink\" title=\"常用lodash函数\"></a>常用lodash函数</h2><h5 id=\"times-N次循环\"><a href=\"#times-N次循环\" class=\"headerlink\" title=\"_.times N次循环\"></a>_.times N次循环</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- javascript -------'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">//js原生的循环方法</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(i);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- lodash -------'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">//ladash的times方法</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    _.times(<span class=\"number\">5</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(a);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>语句是执行循环的不二选择，但在上面代码的使用场景下，<code>_.times()</code>的解决方式更加简洁和易于理解。</p>\n<h5 id=\"map-深层查找属性值\"><a href=\"#map-深层查找属性值\" class=\"headerlink\" title=\"_.map 深层查找属性值\"></a>_.map 深层查找属性值</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> ownerArr = [&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"Colin\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pets\"</span>: [&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog1\"</span>&#125;, &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog2\"</span>&#125;]</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"John\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pets\"</span>: [&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog3\"</span>&#125;, &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"dog4\"</span>&#125;]</span></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> jsMap = ownerArr.map(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(owner)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> owner.pets[<span class=\"number\">0</span>].name;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- jsMap -------'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(jsMap);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> lodashMap = _.map(ownerArr, <span class=\"string\">'pets[0].name'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'------- lodashMap -------'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(lodashMap);</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lodash中的<code>_.map</code>方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。</p>\n<h5 id=\"cloneDeep-深克隆对象\"><a href=\"#cloneDeep-深克隆对象\" class=\"headerlink\" title=\"_.cloneDeep 深克隆对象\"></a>_.cloneDeep 深克隆对象</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objA = &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"戈德斯文\"</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objB = _.cloneDeep(objA);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objB);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA === objB);</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:<code>JSON.parse(JSON.stringify(objectToClone))</code> 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。</p>\n<h5 id=\"random-在指定范围内获取一个随机值\"><a href=\"#random-在指定范围内获取一个随机值\" class=\"headerlink\" title=\"_.random 在指定范围内获取一个随机值\"></a>_.random 在指定范围内获取一个随机值</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomNumber</span><span class=\"params\">(min, max)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(getRandomNumber(<span class=\"number\">15</span>, <span class=\"number\">20</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.random(<span class=\"number\">15</span>, <span class=\"number\">20</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lodash中的 <code>_.random</code> 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数<code>_.random(15,20,true)</code></p>\n<h5 id=\"assign-扩展对象\"><a href=\"#assign-扩展对象\" class=\"headerlink\" title=\"_.assign 扩展对象\"></a>_.assign 扩展对象</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">Object</span>.prototype.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> obj) &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"keyword\">if</span> (obj.hasOwnProperty(i)) &#123;    <span class=\"comment\">//判断被扩展的对象有没有某个属性，</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">this</span>[i] = obj[i];</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objA = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"car\"</span>: <span class=\"string\">\"宝马\"</span>&#125;;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> objB = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"loveEat\"</span>: <span class=\"literal\">true</span>&#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objA.extend(objB);</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(objA); </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.assign(objA, objB));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.assign</code> 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并</p>\n<h5 id=\"sample-sampleSize-从列表中随机的选择列表项\"><a href=\"#sample-sampleSize-从列表中随机的选择列表项\" class=\"headerlink\" title=\"_.sample _.sampleSize 从列表中随机的选择列表项\"></a>_.sample _.sampleSize 从列表中随机的选择列表项</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> smartTeam = [<span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"杨海月\"</span>, <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"师贝贝\"</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomSmarter</span><span class=\"params\">(smartTeam)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * smartTeam.length);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> smartTeam[index];</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(randomSmarter(smartTeam));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// Lodash</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.sample(smartTeam));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.sampleSize(smartTeam,<span class=\"number\">2</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，你也可以指定随机返回元素的个数<code>_.sampleSize(smartTeam,n)</code>，n为需要返回的元素个数</p>\n<h5 id=\"includes-判断对象中是否含有某元素\"><a href=\"#includes-判断对象中是否含有某元素\" class=\"headerlink\" title=\"_.includes 判断对象中是否含有某元素\"></a>_.includes 判断对象中是否含有某元素</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> smartPerson = &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"string\">'name'</span>: <span class=\"string\">'戈德斯文'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"string\">'gender'</span>: <span class=\"string\">'male'</span></span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"><span class=\"actionscript\">        smartTeam = [<span class=\"string\">\"戈德斯文\"</span>, <span class=\"string\">\"杨海月\"</span>, <span class=\"string\">\"柴硕\"</span>, <span class=\"string\">\"师贝贝\"</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartPerson, <span class=\"string\">'戈德斯文'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartTeam, <span class=\"string\">'杨海月'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.includes(smartTeam, <span class=\"string\">'杨海月'</span>,<span class=\"number\">2</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.includes()</code>第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标</p>\n<h5 id=\"forEach-遍历循环\"><a href=\"#forEach-遍历循环\" class=\"headerlink\" title=\"_.forEach 遍历循环\"></a>_.forEach 遍历循环</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    _([<span class=\"number\">1</span>, <span class=\"number\">2</span>]).forEach(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(value);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"actionscript\">    _.forEach([<span class=\"number\">1</span>, <span class=\"number\">3</span>] , <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value, key)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(key,value);</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后<code>key</code>是元素的下标，当传入的是对象的时候，<code>key</code>是属性，<code>value</code>是值</p>\n<h5 id=\"map-遍历循环执行某个方法\"><a href=\"#map-遍历循环执行某个方法\" class=\"headerlink\" title=\"_.map 遍历循环执行某个方法\"></a>_.map 遍历循环执行某个方法</h5><p><code>_.map()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span><span class=\"params\">(n)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> n * n;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map([<span class=\"number\">4</span>, <span class=\"number\">8</span>], square));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [16, 64]</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map(&#123; <span class=\"string\">'a'</span>: <span class=\"number\">4</span>, <span class=\"string\">'b'</span>: <span class=\"number\">8</span> &#125;, square));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [16, 64] (iteration order is not guaranteed)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> users = [</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span> &#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span> &#125;</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// The `_.property` iteratee shorthand.</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.map(users, <span class=\"string\">'user'</span>));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; ['barney', 'fred']</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"isEmpty-检验值是否为空\"><a href=\"#isEmpty-检验值是否为空\" class=\"headerlink\" title=\"_.isEmpty 检验值是否为空\"></a>_.isEmpty 检验值是否为空</h5><p><code>_.isEmpty()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(<span class=\"literal\">null</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(<span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    _.isEmpty(1);</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    _.isEmpty([1, 2, 3]);</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; false</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    _.isEmpty(&#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span> &#125;);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; false</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"find-、-filter-、-reject-查找属性\"><a href=\"#find-、-filter-、-reject-查找属性\" class=\"headerlink\" title=\".find()、.filter()、_.reject() 查找属性\"></a><em>.find()、</em>.filter()、_.reject() 查找属性</h5><p><code>_.find()</code>、<code>_.filter()</code>、<code>_.reject()</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> users = [</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">40</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">false</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        &#123;<span class=\"string\">'user'</span>: <span class=\"string\">'pebbles'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> o.age &lt; <span class=\"number\">40</span>;</span></span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">1</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span>&#125;));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.find(users, <span class=\"string\">'active'</span>));</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.filter(users, <span class=\"string\">'active'</span>));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.find()</code>第一个返回真值的第一个元素。<br> <code>_.filter()</code>返回真值的所有元素的数组。<br> <code>_.reject()</code>是<code>_.filter</code>的反向方法，不返回真值的（集合）元素</p>\n<h5 id=\"uniq-数组去重\"><a href=\"#uniq-数组去重\" class=\"headerlink\" title=\"_.uniq 数组去重\"></a>_.uniq 数组去重</h5><p><code>_.uniq(array)</code>创建一个去重后的array数组副本。</p>\n<p>参数<br> <code>array (Array)</code>: 要检查的数组。</p>\n<p>返回新的去重后的数组</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> arr1 = [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> arr2 = _.uniq(arr1);</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span><span class=\"params\">(arr)</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> newArr = [];</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class=\"line\">            if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">                newArr.push(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">return</span> newArr;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(arr1);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(arr2);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(unique(arr1));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.uniqBy(array,[iteratee=_.identity])</code>这个方法类似 <code>_.uniq</code>，除了它接受一个 <code>iteratee</code>（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.uniqBy([<span class=\"number\">2.1</span>, <span class=\"number\">1.2</span>, <span class=\"number\">2.3</span>], <span class=\"built_in\">Math</span>.floor));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [2.1, 1.2]</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(_.uniqBy([&#123; <span class=\"string\">'x'</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"string\">'x'</span>: <span class=\"number\">2</span> &#125;, &#123; <span class=\"string\">'x'</span>: <span class=\"number\">1</span> &#125;], <span class=\"string\">'x'</span>));</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Math.floor</code>只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。</p>\n<h5 id=\"template-模板插入\"><a href=\"#template-模板插入\" class=\"headerlink\" title=\"_.template 模板插入\"></a>_.template 模板插入</h5><p><code>_.template([string=&#39;&#39;], [options={}])</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> data = [&#123;name: <span class=\"string\">'戈德斯文'</span>&#125;, &#123;name: <span class=\"string\">'柴硕'</span>&#125;, &#123;name: <span class=\"string\">'杨海月'</span>&#125;];</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> t = _.template($(<span class=\"string\">\"#tpl\"</span>).html());</span></span><br><span class=\"line\"><span class=\"javascript\">        $(<span class=\"string\">\"#container\"</span>).html(t(data));</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"tpl\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    &lt;% _.each(obj,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e,i)</span></span>&#123; %&gt;</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">e.name</span> %&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">i</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">%&#125;)%</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"get-根据path找到object相关properties\"><a href=\"#get-根据path找到object相关properties\" class=\"headerlink\" title=\"_.get 根据path找到object相关properties\"></a>_.get 根据path找到object相关properties</h5><p><code>_.get(object, path, [defaultValue])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">'a'</span>: [&#123; <span class=\"string\">'b'</span>: &#123; <span class=\"string\">'c'</span>: <span class=\"number\">3</span> &#125; &#125;] &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, <span class=\"string\">'a[0].b.c'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'0'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.get(object, <span class=\"string\">'a.b.c'</span>, <span class=\"string\">'default'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'default'</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"concat-将一些array连在一起\"><a href=\"#concat-将一些array连在一起\" class=\"headerlink\" title=\"_.concat 将一些array连在一起\"></a>_.concat 将一些array连在一起</h5><p><code>_.concat(array, [values])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> other = _.concat(array, <span class=\"number\">2</span>, [<span class=\"number\">3</span>], [[<span class=\"number\">4</span>]]);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(other);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3, [4]]</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"compact-移除falsey-values\"><a href=\"#compact-移除falsey-values\" class=\"headerlink\" title=\"_.compact 移除falsey values\"></a>_.compact 移除falsey values</h5><p><code>_.compact(array)</code></p>\n<p>Creates an array with all falsey values removed. The values <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, and <code>NaN</code> are falsey.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.compact([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">false</span>, <span class=\"number\">2</span>, <span class=\"string\">''</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"prototype-value\"><a href=\"#prototype-value\" class=\"headerlink\" title=\"_.prototype.value\"></a>_.prototype.value</h5><p><code>_.prototype.value()</code></p>\n<p>Executes the chain sequence to resolve the unwrapped value.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]).value();</span><br><span class=\"line\"><span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"prototype-filter-查找符合条件的\"><a href=\"#prototype-filter-查找符合条件的\" class=\"headerlink\" title=\"_prototype.filter 查找符合条件的\"></a>_prototype.filter 查找符合条件的</h5><p><code>_.filter(collection, [predicate=_.identity])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'barney'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">'user'</span>: <span class=\"string\">'fred'</span>,   <span class=\"string\">'age'</span>: <span class=\"number\">40</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"> </span><br><span class=\"line\">_.filter(users, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123; <span class=\"keyword\">return</span> !o.active; &#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['fred']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.matches` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, &#123; <span class=\"string\">'age'</span>: <span class=\"number\">36</span>, <span class=\"string\">'active'</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['barney']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.matchesProperty` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, [<span class=\"string\">'active'</span>, <span class=\"literal\">false</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['fred']</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The `_.property` iteratee shorthand.</span></span><br><span class=\"line\">_.filter(users, <span class=\"string\">'active'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; objects for ['barney']</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"keyBy-以新key重建数据结构\"><a href=\"#keyBy-以新key重建数据结构\" class=\"headerlink\" title=\"_.keyBy 以新key重建数据结构\"></a>_.keyBy 以新key重建数据结构</h5><p><code>_.keyBy(collection, [iteratee=_.identity])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [</span><br><span class=\"line\">  &#123; <span class=\"string\">'dir'</span>: <span class=\"string\">'left'</span>, <span class=\"string\">'code'</span>: <span class=\"number\">97</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">'dir'</span>: <span class=\"string\">'right'</span>, <span class=\"string\">'code'</span>: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"> </span><br><span class=\"line\">_.keyBy(array, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(o.code);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'a': &#123; 'dir': 'left', 'code': 97 &#125;, 'd': &#123; 'dir': 'right', 'code': 100 &#125; &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.keyBy(array, <span class=\"string\">'dir'</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'left': &#123; 'dir': 'left', 'code': 97 &#125;, 'right': &#123; 'dir': 'right', 'code': 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"JS测试教程","date":"2020-03-26T19:32:00.000Z","description":"JavaScript程序测试","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200326135918.png","optimized_image":null,"author":"tty","_content":"\n来源：[阮一峰](https://javascript.ruanyifeng.com/tool/testing.html)\n\n## 为什么要写测试？\n\nWeb应用程序越来越复杂，这意味着有更多的可能出错。测试是帮助我们提高代码质量、降低错误的最好方法和工具之一。\n\n- 测试可以确保得到预期结果。\n- 加快开发速度。\n- 方便维护。\n- 提供用法的文档。\n\n通过测试提供软件的质量，在开始的时候，可能会降低开发速度。但是从长期看，尤其是那种代码需要长期维护、不断开发的情况，测试会大大加快开发速度，减轻维护难度。\n\n## 测试的类型\n\n### 单元测试\n\n单元测试（unit testing）指的是以软件的单元（unit）为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或组件。它的基本特征就是，只要输入不变，必定返回同样的输出。\n\n“单元测试”这个词，本身就暗示，软件应该以模块化结构存在。每个模块的运作，是独立于其他模块的。一个软件越容易写单元测试，往往暗示着它的模块化结构越好，各模块之间的耦合就越弱；越难写单元测试，或者每次单元测试，不得不模拟大量的外部条件，很可能暗示软件的模块化结构越差，模块之间存在较强的耦合。\n\n单元测试的要求是，每个模块都必须有单元测试，而软件由模块组成。\n\n单元测试通常采取断言（assertion）的形式，也就是测试某个功能的返回结果，是否与预期结果一致。如果与预期不一致，就表示测试失败。\n\n单元测试是函数正常工作、不出错的最基本、最有效的方法之一。 每一个单元测试发出一个特定的输入到所要测试的函数，看看函数是否返回预期的输出，或者采取了预期的行动。单元测试证明了所测试的代码行为符合预期。\n\n单元测试有助于代码的模块化，因此有助于长期的重用。因为有了测试，你就知道代码是可靠的，可以按照预期运行。从这个角度说，测试可以节省开发时间。单元测试的另一个好处是，有了测试，就等于就有了代码功能的文档，有助于其他开发者了解代码的意图。\n\n单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。\n\n一般来说，单元测试的步骤如下。\n\n- 准备所有的测试条件\n- 调用（触发）所要测试的函数\n- 验证运行结果是否正确\n- 还原被修改的记录\n\n### 其他测试类型\n\n（1）集成测试\n\n集成测试（Integration test）指的是多个部分在一起测试，比如测试一个数据库连接模块，是否能够连接数据库。\n\n（2）功能测试\n\n功能测试（Functional test）指的是，自动测试整个应用程序的某个功能，比如使用Selenium工具自动打开浏览器运行程序。\n\n（3）端对端测试\n\n端对端测试（End-to-End testing）指的是全链路测试，即从开始端到终止端的测试，比如测试从用户界面、通过网络、经过应用程序处理、到达数据库，是否能够返回正确结果。端对端测试的目的是，确保整个系统能够正常运行，各个子系统之间依赖关系正常，数据能够在子系统之间、模块之间正确传递。\n\n（4）冒烟测试\n\n冒烟测试（smoke testing）指的是，正式的全面测试开始之前，对主要功能进行的预测试。它的主要目的是，确认主要功能能否满足需要，软件是否能运行。冒烟测试可以是手工测试，也可以是自动化测试。\n\n这个名字最早来自对电子元件的测试，第一次对电子元件通电，看看它是否会冒烟。如果没有冒烟，说明通过了测试；如果电流达到某个临界点之后，才出现冒烟，这时可以评估是否能够接受这个临界点。\n\n## 开发模式\n\n测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。\n\n### TDD\n\nTDD是“测试驱动的开发”（Test-Driven Development）的简称，指的是先写好测试，然后再根据测试完成开发。使用这种开发方式，会有很高的测试覆盖率。\n\nTDD的开发步骤如下。\n\n- 先写一个测试。\n- 写出最小数量的代码，使其能够通过测试。\n- 优化代码。\n- 重复前面三步。\n\nTDD开发的测试覆盖率通常在90%以上，这意味着维护代码和新增特性会非常容易。因为测试保证了你可以信任这些代码，修改它们不会破坏其他代码的运行。\n\nTDD接口提供以下四个方法。\n\n- suite()\n- test()\n- setup()\n- teardown()\n\n下面代码是测试计数器是否加1。\n\n```js\nsuite('Counter', function() {\n  test('tick increases count to 1', function() {\n    var counter = new Counter();\n    counter.tick();\n    assert.equal(counter.count, 1);\n  });\n});\n```\n\n### BDD\n\nBDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。\n\nBDD认为，**不应该针对代码的实现细节写测试，而是要针对行为写测试**。BDD测试的是行为，即软件应该怎样运行。\n\nBDD接口提供以下六个方法。\n\n- describe()\n- it()\n- before()\n- after()\n- beforeEach()\n- afterEach()\n\n下面是测试计数器是否加1的BDD写法。\n\n```js\ndescribe('Counter', function() {\n  it('should increase count by 1 after calling tick', function() {\n    var counter = new Counter();\n    var expectedCount = counter.count + 1;\n    counter.tick();\n    assert.equal(counter.count, expectedCount);\n  });\n});\n```\n\n下面是一个BDD开发的示例。现在，需要开发一个`Foo`类，该类的实例有一个`sayHi`方法，会对类参数说“Hi”。这就是`Foo`类的规格，根据这个规格，我们可以写出测试用例文件`foo.spec.js`。\n\n```js\ndescribe('Simple object', function() {\n  var foo;\n\n  beforeEach(function() {\n    foo = new Foo('John');\n  });\n\n  it('should say hi', function() {\n    expect(foo.sayHi()).toEqual('John says hi!');\n  });\n});\n```\n\n有了测试用例以后，我们再写出实际的脚本文件`foo.js`。\n\n```js\nfunction Foo(name) {\n  this.name = name;\n}\n\nFoo.prototype.sayHi = function() {\n  return this.name + ' says hi!';\n};\n```\n\n为了把测试用例与脚本文件分开，我们通常把测试用例放在`test`子目录之中。然后，我们就可以使用Mocha、Jasmine等测试框架，执行测试用例，看看脚本文件是否通过测试。\n\n### BDD术语\n\n（1）测试套件\n\n测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。\n\n测试套件由一个`describe`函数构成，它接受两个参数：第一个参数是字符串，表示测试套件的名字或标题，表示将要测试什么；第二个参数是函数，用来实现这个测试套件。\n\n```js\ndescribe(\"A suite\", function() {\n  // ...\n});\n```\n\n（2）测试用例\n\n测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。测试用例由`it`函数构成，它与`describe`函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。\n\n```js\ndescribe(\"A suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    // ...\n  });\n});\n```\n\n（3）断言\n\n断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。\n\n断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为`true`，测试用例才会通过。\n\n```js\ndescribe(\"A suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    expect(true).toBe(true);\n  });\n});\n```\n\n## 断言\n\n断言是判断实际值与预期值是否相等的工具。\n\n断言有assert、expect、should三种风格，或者称为三种写法。\n\n```js\n// assert风格\nassert.equal(event.detail.item, '(item)‘);\n\n// expect风格\nexpect(event.detail.item).to.equal('(item)');\n\n// should风格\nevent.detail.item.should.equal('(item)');\n```\n\nChai.js是一个很流行的断言库，同时支持上面三种风格。\n\n（1） assert风格\n\n```js\nvar assert = require('chai').assert;\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nassert.typeOf(foo, 'string', 'foo is a string');\nassert.equal(foo, 'bar', 'foo equal `bar`');\nassert.lengthOf(foo, 3, 'foo`s value has a length of 3');\nassert.lengthOf(beverages.tea, 3, 'beverages has 3 types of tea');\n```\n\n上面代码中，assert方法的最后一个参数是错误提示信息，只有测试没有通过时，才会显示。\n\n（2）expect风格\n\n```js\nvar expect = require('chai').expect;\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nexpect(foo).to.be.a('string');\nexpect(foo).to.equal('bar');\nexpect(foo).to.have.length(3);\nexpect(beverages).to.have.property('tea').with.length(3);\n```\n\n（3）should风格\n\n```js\nvar should = require('chai').should();\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nfoo.should.be.a('string');\nfoo.should.equal('bar');\nfoo.should.have.length(3);\nbeverages.should.have.property('tea').with.length(3);\n```\n\n## Mocha.js\n\n### 概述\n\nMocha（发音“摩卡”）是现在最流行的前端测试框架之一，此外常用的测试框架还有[Jasmine](https://jasmine.github.io/)、[Tape](https://github.com/substack/tape/)、[zuul](https://github.com/defunctzombie/zuul/)等。所谓“测试框架”，就是运行测试的工具。\n\nMocha使用下面的命令安装。\n\n```js\n# 全局安装\n$ npm install -g mocha chai\n\n# 项目内安装\n$ npm i -D mocha chai\n```\n\n上面代码中，除了安装Mocha以外，还安装了断言库`chai`，这是因为Mocha自身不带断言库，必须安装外部断言库。\n\n测试套件文件一般放在`test`子目录下面，配置文件`mocha.opts`也放在这个目录里面。\n\n### 浏览器测试\n\n使用浏览器测试时，先用`mocha init`命令在指定目录生成初始化文件。\n\n```bash\n$ mocha init <path>\n```\n\n运行上面命令，就会在该目录下生成一个`index.html`文件，以及配套的脚本和样式表。\n\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Unit.js tests in the browser with Mocha</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\" href=\"mocha.css\" />\n  </head>\n  <body>\n    <h1>Unit.js tests in the browser with Mocha</h1>\n    <div id=\"mocha\"></div>\n    <script src=\"mocha.js\"></script>\n    <script>\n      mocha.setup('bdd');\n    </script>\n    <script src=\"tests.js\"></script>\n    <script>\n      mocha.run();\n    </script>\n  </body>\n</html>\n```\n\n然后在该文件中，加入你要测试的文件（比如`app.js`）、测试脚本（`app.spec.js`）和断言库（`chai.js`）。\n\n```js\n<script src=\"app.js\"></script>\n<script src=\"http://chaijs.com/chai.js\"></script>\n<script src=\"app.spec.js\"></script>\n```\n\n各个文件的内容如下。\n\n```js\n// app.js\nfunction add(x, y){\n  return x + y;\n}\n\n// app.spec.js\nvar expect = chai.expect;\n\ndescribe('测试add函数', function () {\n  it('1加1应该等于2', function () {\n    expect(add(1, 1)).to.equal(2);\n  });\n});\n```\n\n### 命令行测试\n\nMocha除了在浏览器运行，还可以在命令行运行。\n\n还是使用上面的文件，作为例子，但是要改成CommonJS格式。\n\n```js\n// app.js\nfunction add(x, y){\n  return x + y;\n}\n\nmodule.exports = add;\n\n// app.spec.js\nvar expect = require('chai').expect;\nvar add = require('../app');\n\ndescribe('测试add函数', function () {\n  it('1加1应该等于2', function () {\n    expect(add(1, 1)).to.equal(2);\n  });\n});\n```\n\n然后，在命令行下执行`mocha`，就会执行测试。\n\n```bash\n$ mocha\n```\n\n上面的命令等同于下面的形式。\n\n```bash\n$ mocha test --reporter spec --recursive --growl\n```\n\n### mocha.opts\n\n所有Mocha的命令行参数，都可以写在`test`目录下的配置文件`mocha.opts`之中。\n\n下面是一个典型的配置文件。\n\n```properties\n--reporter spec\n--recursive\n--growl\n```\n\n上面三个设置的含义如下。\n\n- 使用spec报告模板\n- 包括子目录\n- 打开桌面通知插件growl\n\n如果希望测试非存放于test子目录的测试用例，可以在`mocha.opts`写入以下内容。\n\n```properties\nserver-tests\n--recursive\n```\n\n上面代码指定运行`server-tests`目录及其子目录之中的测试脚本。\n\n### 生成规格文件\n\nMocha支持从测试用例生成规格文件。\n\n```bash\n$ mocha test/app.spec.js -R markdown > spec.md\n```\n\n上面命令生成单个`app.spec.js`规格。\n\n生成HTML格式的报告，使用下面的命令。\n\n```bash\n$ mocha test/app.spec.js -R doc > spec.html\n```\n\n如果要生成整个`test`目录，对应的规格文件，使用下面的命令。\n\n```bash\n$ mocha test -R markdown > spec.md --recursive\n```\n\n只要提供测试脚本的路径，Mocha就可以运行这个测试脚本。\n\n```bash\n$ mocha -w src/index.test.js\n```\n\n上面命令运行测试脚本`src/index.test.js`，参数`-w`表示watch，即当这个脚本一有变动，就会运行。\n\n指定测试脚本时，可以使用通配符，同时指定多个文件。\n\n```bash\n$ mocha --reporter spec spec/{my,awesome}.js\n$ mocha --ui tdd test/unit/*.js etc\n```\n\n上面代码中，参数`--reporter`指定生成的报告格式（上面代码是spec格式），`-ui`指定采用哪一种测试模式（上面代码是tdd模式）。\n\n除了使用shell通配符，还可以使用node通配符。\n\n```bash\n$ mocha --compilers js:babel-core/register 'test/**/*.@(js|jsx)'\n```\n\n上面代码指定运行`test`目录下面任何子目录中，文件后缀名为`js`或`jsx`的测试脚本。注意，Node的通配符要放在单引号之中，因为否则星号（`*`）会先被shell解释。\n\n如果要改用shell通配符，执行`test`目录下面任何子目录的测试脚本，要写成下面这样。\n\n```bash\n$ mocha test/**.js\n```\n\n如果测试脚本不止一个，最好将它们放在专门的目录当中。Mocha默认执行`test`目录的测试脚本，所以可以将所有测试脚本放在`test`子目录。`--recursive`参数可以指定运行子目录之中的测试脚本。\n\n```bash\n$ mocha --recursive\n```\n\n上面命令会运行`test`子目录之中的所有测试脚本。\n\n`--grep`参数用于搜索测试用例的名称（即it方法的第一个参数），然后只执行匹配的测试用例。\n\n```bash\n$ mocha --reporter spec --grep \"Fnord:\" server-test/*.js\n```\n\n上面代码只测试名称中包含“Fnord：”的测试用例。\n\n`--invert`参数表示只运行不符合条件的测试脚本。\n\n```bash\n$ mocha --grep auth --invert\n```\n\n如果测试脚本用到了ES6语法，还需要用`--compiler`参数指定babel进行转码。\n\n```bash\n$ mocha --compilers js:babel/register --recursive\n```\n\n上面命令会在运行测试脚本之前，先用Babel进行转码。`--compilers`参数的值是用冒号分隔的一个字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用`babel/register`模块，处理一下JS文件。\n\n`--require`参数指定测试脚本默认包含的文件。下面是一个`test_helper.js`文件。\n\n```js\n// test/test_helper.js\nimport chai from 'chai';\n```\n\n使用`--require`参数，将上面这个脚本包含进所有测试脚本。\n\n```bash\n$ mocha --compilers js:babel/register --require ./test/test_helper.js  --recursive\n```\n\n### 测试脚本的写法\n\n测试脚本中，describe方法和it方法都允许调用only方法，表示只运行某个测试套件或测试用例。\n\n```js\n// 例一\ndescribe('Array', function(){\n  describe.only('#indexOf()', function(){\n    ...\n  });\n});\n\n// 例二\ndescribe(\"using only\", function() {\n  it.only(\"this is the only test to be run\", function() {\n\n  });\n\n  it(\"this is not run\", function() {\n\n  });\n});\n```\n\n上面代码中，只有带有`only`方法的测试套件或测试用例会运行。\n\ndescribe方法和it方法还可以调用skip方法，表示跳过指定的测试套件或测试用例。\n\n```js\n// 例一\ndescribe.skip('Article', function() {\n  // ...\n});\n\n// 例二\ndescribe(\"using only\", function() {\n  it.skip(\"this is the only test to be run\", function() {\n\n  });\n\n  it(\"this is not run\", function() {\n\n  });\n});\n```\n\n上面代码中，带有`skip`方法的测试套件或测试用例会被忽略。\n\n如果测试用例包含异步操作，可以done方法显式指定测试用例的运行结束时间。\n\n```js\nit('logs a', function(done) {\n  var f = function(){\n    console.log('logs a');\n    done();\n  };\n  setTimeout(f, 500);\n});\n```\n\n上面代码中，正常情况下，函数f还没有执行，Mocha就已经结束运行了。为了保证Mocha等到测试用例跑完再结束运行，可以手动调用done方法\n\n## Promise的测试\n\n对于异步的测试，测试用例之中，通常必须调用`done`方法，显式表明异步操作的结束。\n\n```js\nvar expect = require('chai').expect;\n\nit('should do something with promises', function(done) {\n  var result = asyncTest();\n\n  result.then(function(data) {\n    expect(data).to.equal('foobar');\n    done();\n  }, function(error) {\n    assert.fail(error);\n    done();\n  });\n});\n```\n\n上面代码之中，Promise对象的`then`方法之中，必须指定`reject`时的回调函数，并且使用`assert.fail`方法抛出错误，否则这个错误就不会被外界感知。\n\n```js\nresult.then(function(data) {\n  expect(data).to.equal(blah);\n  done();\n});\n```\n\n上面代码之中，如果Promise被`reject`，是不会被捕获的，因为Promise之中的错误，不会”泄漏“到外界。\n\nMocha内置了对Promise的支持。\n\n```js\nit('should fail the test', function() {\n  var p = Promise.reject('Promise被reject');\n\n  return p;\n});\n```\n\n上面代码中，Mocha能够捕获`reject`的Promise。\n\n因此，使用Mocha时，Promise的测试可以简化成下面的写法。\n\n```js\nvar expect = require('chai').expect;\n\nit('should do something with promises', function() {\n  var result = asyncTest();\n\n  return result.then(function(data) {\n    expect(data).to.equal('foobar');\n  });\n});\n```\n\n## 模拟数据\n\n单元测试时，很多时候，测试的代码会请求HTTP服务器。这时，我们就需要模拟服务器的回应，不能在单元测试时去请求真实服务器数据，否则就不叫单元测试了，而是连同服务器一起测试了。\n\n一些工具库可以模拟服务器回应。\n\n- [nock](https://github.com/pgte/nock)\n- [sinon](http://sinonjs.org/docs/#server)\n- [faux-jax](https://github.com/algolia/faux-jax)\n- [MITM](https://github.com/moll/node-mitm)\n\n## 覆盖率\n\n测试的覆盖率需要安装istanbul模块。\n\n```bash\n$ npm i -D istanbul\n```\n\n然后，在package.json设置运行覆盖率检查的命令。\n\n```json\n\"scripts\": {\n  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js\",\n  \"check-coverage\": \"istanbul check-coverage --statements 100 --branches 100 --functions 100 --lines 100\"\n}\n```\n\n上面代码中，`test:cover`是生成覆盖率报告，`check-coverage`是设置覆盖率通过的门槛。\n\n然后，将`coverage`目录写入`.gitignore`防止连这个目录一起提交。\n\n如果希望在`git commit`提交之前，先运行一次测试，可以安装ghooks模块，配置`pre-commit`钩子。\n\n安装ghooks。\n\n```bash\n$ npm i -D ghooks\n```\n\n在package.json之中，配置`pre-commit`钩子。\n\n```json\n\"config\": {\n  \"ghooks\": {\n    \"pre-commit\": \"npm run test:cover && npm run check-coverage\"\n  }\n}\n```\n\n还可以把覆盖率检查，加入`.travis.yml`文件。\n\n```yaml\nscript:\n  - npm run test:cover\n  - npm run check-coverage\n```\n\n如果测试脚本使用ES6，`scripts`字段还需要加入Babel转码。\n\n```json\n\"scripts\": {\n  \"test\": \"mocha src/index.test.js -w --compilers js:babel/register\",\n  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js --compilers js:babel/register\"\n}\n```\n\n覆盖率报告可以上传到[codecov.io](https://codecov.io/)。先安装这个模块。\n\n```bash\n$ npm i -D codecov.io\n```\n\n然后在package.json增加一个字段。\n\n```json\n\"scripts\": {\n  \"report-coverage\": \"cat ./coverage/lcov.info | codecov\"\n}\n```\n\n最后，在CI的配置文件`.travis.yml`之中，增加运行这个命令。\n\n```bash\nafter_success:\n  - npm run report-coverage\n  - npm run semantic-release\n```\n\n## WebDriver\n\nWebDriver是一个浏览器的自动化框架。它在各种浏览器的基础上，提供一个统一接口，将接收到的指令转为浏览器的原生指令，驱动浏览器。\n\nWebDriver由Selenium项目演变而来。Selenium是一个测试自动化框架，它的1.0版叫做Selenium RC，通过一个代理服务器，将测试脚本转为JavaScript脚本，注入不同的浏览器，再由浏览器执行这些脚本后返回结果。WebDriver就是Selenium 2.0，它对每个浏览器提供一个驱动，测试脚本通过驱动转换为浏览器原生命令，在浏览器中执行。\n\n### 定制测试环境\n\nDesiredCapabilities对象用于定制测试环境。\n\n- 定制DesiredCapabilities对象的各个属性\n- 创建DesiredCapabilities实例\n- 将DesiredCapabilities实例作为参数，新建一个WebDriver实例\n\n### 操作浏览器的方法\n\nWebDriver提供以下方法操作浏览器。\n\nclose()：退出或关闭当前浏览器窗口。\n\n```js\ndriver.close();\n```\n\nquit()：关闭所有浏览器窗口，中止当前浏览器driver和session。\n\n```js\ndriver.quit();\n```\n\ngetTitle()：返回当前网页的标题。\n\n```js\ndriver.getTitle();\n```\n\ngetCurrentUrl()：返回当前网页的网址。\n\n```js\ndriver.getCurrentUrl();\n```\n\ngetPageSource()：返回当前网页的源码。\n\n```js\n// 断言是否含有指定文本\nassert(driver.getPageSource().contains(\"Hello World\"),\n  \"预期含有文本Hello World\");\n```\n\nclick()：模拟鼠标点击。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\"))\n  .click();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webDriver\");\ndriver.findElement(By.id(\"sblsbb\"))\n  .click();\n```\n\nclear()：清空文本输入框。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\")).clear();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webDriver\");\ndriver.findElement(By.name(\"q\"))\n  .clear();\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"testing\");\n```\n\nsendKeys()：在文本输入框输入文本。\n\n```js\ndriver.findElement(By.locatorType(\"path\"))\n  .sendKeys(\"your text\");\n```\n\nsubmit()：提交表单，或者用来模拟按下回车键。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\"))\n  .submit();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webdriver\");\nelement.submit();\n```\n\nfindElement()：返回选中的第一个元素。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.id(\"lst-ib\"));\n```\n\nfindElements()：返回选中的所有元素（0个或多个）。\n\n```js\n// 例一\ndriver.findElement(By.id(\"searchbox\"))\n  .sendKeys(\"webdriver\");\ndriver.findElements(By.xpath(\"//div[3]/ul/li\"))\n  .get(0)\n  .click();\n\n// 例二\ndriver.findElements(By.tagName(\"select\"))\n  .get(0)\n  .findElements(By.tagName(\"option\"))\n  .get(3)\n  .click()\n  .get(4)\n  .click()\n  .get(5)\n  .click();\n\n// 例三：获取页面所有链接\nvar links = driver\n  .get(\"https://www.google.com\")\n  .findElements(By.tagName(\"a\"));\nvar linkSize = links.size();\nvar linksSrc = [];\n\nconsole.log(linkSize);\n\nfor(var i=0;i<linkSize;i++) {\n  linksSrc[i] = links.get(i).getAttribute(\"href\");\n}\n\nfor(int i=0;i<linkSize;i++){\n  driver.navigate().to(linksSrc[i]);\n  Thread.sleep(3000);\n}\n```\n\n可以使用`size()`，查看到底选中了多少个元素。\n\n### 网页元素的定位\n\nWebDriver提供8种定位器，用于定位网页元素。\n\n- By.id：HTML元素的id属性\n- By.name：HTML元素的name属性\n- By.xpath：使用XPath语法选中HTML元素\n- By.cssSelector：使用CSS选择器语法\n- By.className：HTML元素的class属性\n- By.linkText：链接文本（只用于选中链接）\n- By.tagName：HTML元素的标签名\n- By.partialLinkText：部分链接文本（只用于选中链接）\n\n下面是一个使用id定位器，选中网页元素的例子。\n\n```js\ndriver.findElement(By.id(\"sblsbb\")).click();\n```\n\n### 网页元素的方法\n\n以下方法属于网页元素的方法，而不是webDriver实例的方法。需要注意的是，有些方法是某些元素特有的，比如只有文本框才能输入文字。如果在网页元素上调用不支持的方法，WebDriver不会报错，也不会给出给出任何提示，只会静静地忽略。\n\ngetAttribute()：返回网页元素指定属性的值。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.xpath(\"//div[@id='lst-ib']\"))\n  .getAttribute(\"class\");\n```\n\ngetText()：返回网页元素的内部文本。\n\n```js\ndriver.findElement(By.locatorType(\"path\")).getText();\n```\n\ngetTagName()：返回指定元素的标签名。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.xpath(\"//div[@class='sbib_b']\"))\n  .getTagName();\n```\n\nisDisplayed()：返回一个布尔值，表示元素是否可见。\n\n```js\ndriver.get(\"https://www.google.com\");\nassert(driver.findElement(By.name(\"q\"))\n  .isDisplayed(),\n  '搜索框应该可选择');\n```\n\nisEnabled()：返回一个布尔值，表示文本框是否可编辑。\n\n```js\ndriver.get(\"https://www.google.com\");\nvar Element = driver.findElement(By.name(\"q\"));\nif (Element.isEnabled()) {\n  driver.findElement(By.name(\"q\"))\n    .sendKeys(\"Selenium Essentials\");\n} else {\n  throw new Error();\n}\n```\n\nisSelected()：返回一个布尔值，表示一个元素是否可选择。\n\n```js\ndriver.findElement(By.xpath(\"//select[@name='jump']/option[1]\"))\n  .isSelected()\n```\n\ngetSize()：返回一个网页元素的宽度和高度。\n\n```js\nvar dimensions=driver.findElement(By.locatorType(\"path\"))\n  .getSize(); \ndimensions.width;\ndimensions.height;\n```\n\ngetLocation()：返回网页元素左上角的x坐标和y坐标。\n\n```js\nvar point = driver.findElement(By.locatorType(\"path\")).getLocation();\npoint.x; // 等同于 point.getX();\npoint.y; // 等同于 point.getY();\n```\n\ngetCssValue()：返回网页元素指定的CSS属性的值。\n\n```js\ndriver.get(\"https://www.google.com\");\nvar element = driver.findElement(By.xpath(\"//div[@id='hplogo']\"));\nconsole.log(element.getCssValue(\"font-size\"));\nconsole.log(element.getCssValue(\"font-weight\"));\nconsole.log(element.getCssValue(\"color\"));\nconsole.log(element.getCssValue(\"background-size\"));\n```\n\n### 页面跳转的方法\n\n以下方法用来跳转到某一个页面。\n\nget()：要求浏览器跳到某个网址。\n\n```js\ndriver.get(\"URL\");\n```\n\nnavigate().back()：浏览器回退。\n\n```js\ndriver.navigate().back();\n```\n\nnavigate().forward()：浏览器前进。\n\n```js\ndriver.navigate().forward();\n```\n\nnavigate().to()：跳转到浏览器历史中的某个页面。\n\n```js\ndriver.navigate().to(\"URL\");\n```\n\nnavigate().refresh()：刷新当前页面。\n\n```js\ndriver.navigate().refresh();\n// 等同于\ndriver.navigate()\n  .to(driver.getCurrentUrl());\n// 等同于\ndriver.findElement(By.locatorType(\"path\"))\n  .sendKeys(Keys.F5);\n```\n\n\n\n### cookie的方法\n\ngetCookies()：获取cookie\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.manage().getCookies();\n```\n\ngetCookieNamed() ：返回指定名称的cookie。\n\n```js\ndriver.get(\"https://www.google.com\");\nconsole.log(driver.manage().getCookieNamed(\"NID\"));\n```\n\naddCookie()：将cookie加入当前页面。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.manage().addCookie(cookie0);\n```\n\ndeleteCookie()：删除指定的cookie。\n\n```js\ndriver.get(\"https://www.google.co.in\");\ndriver.manage().deleteCookieNamed(\"NID\");\n```\n\n\n\n### 浏览器窗口的方法\n\nmaximize()：最大化浏览器窗口。\n\n```js\nvar driver = new FirefoxDriver();\ndriver.manage().window().maximize();\n```\n\ngetSize()：返回浏览器窗口、图像、网页元素的宽和高。\n\n```js\ndriver.manage().window().getSize();\n```\n\ngetPosition()：返回浏览器窗口左上角的x坐标和y坐标。\n\n```js\nconsole.log(\"Position X: \" + driver.manage().window().getPosition().x);\nconsole.log(\"Position Y: \" + driver.manage().window().getPosition().y);\nconsole.log(\"Position X: \" + driver.manage().window().getPosition().getX());\nconsole.log(\"Position Y: \" + driver.manage().window().getPosition().getY());\n```\n\nsetSize()：定制浏览器窗口的大小。\n\n```js\nvar d = new Dimension(320, 480);\ndriver.manage().window().setSize(d);\ndriver.manage().window().setSize(new Dimension(320, 480));\n```\n\nsetPosition()：移动浏览器左上角到指定位置。\n\n```js\nvar p = new Point(200, 200);\ndriver.manage().window().setPosition(p);\ndriver.manage().window().setPosition(new Point(300, 150));\n```\n\ngetWindowHandle()：返回当前浏览器窗口。\n\n```js\nvar parentwindow = driver.getWindowHandle();\ndriver.switchTo().window(parentwindow);\n```\n\ngetWindowHandles()：返回所有浏览器窗口。\n\n```js\nvar childwindows =  driver.getWindowHandles();\ndriver.switchTo().window(childwindow);\n```\n\nswitchTo.window()：在浏览器窗口之间切换。\n\n```js\ndriver.SwitchTo().Window(childwindow);\ndriver.close();\ndriver.SwitchTo().Window(parentWindow);\n```\n\n### 弹出窗口\n\n以下方法处理浏览器的弹出窗口。\n\ndismiss() ：关闭弹出窗口。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.dismiss();\n```\n\naccept()：接受弹出窗口，相当于按下接受OK按钮。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.accept();\n```\n\ngetText()：返回弹出窗口的文本值。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.getText();\n```\n\nsendKeys()：向弹出窗口发送文本字符串。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.sendKeys(\"Text to be passed\");\n```\n\nauthenticateUsing()：处理HTTP认证。\n\n```js\nvar user = new UserAndPassword(\"USERNAME\", \"PASSWORD\");\nalert.authenticateUsing(user);\n```\n\n### 鼠标和键盘的方法\n\n以下方法模拟鼠标和键盘的动作。\n\n- click()：鼠标在当前位置点击。\n- clickAndHold()：按下鼠标不放\n- contextClick()：右击鼠标\n- doubleClick()：双击鼠标\n- dragAndDrop()：鼠标拖放到目标元素\n- dragAndDropBy()：鼠标拖放到目标坐标\n- keyDown()：按下某个键\n- keyUp()：从按下状态释放某个键\n- moveByOffset()：移动鼠标到另一个坐标位置\n- moveToElement()：移动鼠标到另一个网页元素\n- release()：释放拖拉的元素\n- sendKeys()：控制键盘输出\n\n## 参考链接\n\n- Jani Hartikainen, http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/","source":"_posts/2020-03-26-JS测试教程.md","raw":"---\nlayout: post\ntitle:  JS测试教程\ndate:   2020-03-26 12:32:00\ndescription: JavaScript程序测试\nsubtitle: \ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200326135918.png\noptimized_image: \ncategory: tutorial\ntags:\n  - code\n  - javascript\n  - tutorial\nauthor: tty\n---\n\n来源：[阮一峰](https://javascript.ruanyifeng.com/tool/testing.html)\n\n## 为什么要写测试？\n\nWeb应用程序越来越复杂，这意味着有更多的可能出错。测试是帮助我们提高代码质量、降低错误的最好方法和工具之一。\n\n- 测试可以确保得到预期结果。\n- 加快开发速度。\n- 方便维护。\n- 提供用法的文档。\n\n通过测试提供软件的质量，在开始的时候，可能会降低开发速度。但是从长期看，尤其是那种代码需要长期维护、不断开发的情况，测试会大大加快开发速度，减轻维护难度。\n\n## 测试的类型\n\n### 单元测试\n\n单元测试（unit testing）指的是以软件的单元（unit）为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或组件。它的基本特征就是，只要输入不变，必定返回同样的输出。\n\n“单元测试”这个词，本身就暗示，软件应该以模块化结构存在。每个模块的运作，是独立于其他模块的。一个软件越容易写单元测试，往往暗示着它的模块化结构越好，各模块之间的耦合就越弱；越难写单元测试，或者每次单元测试，不得不模拟大量的外部条件，很可能暗示软件的模块化结构越差，模块之间存在较强的耦合。\n\n单元测试的要求是，每个模块都必须有单元测试，而软件由模块组成。\n\n单元测试通常采取断言（assertion）的形式，也就是测试某个功能的返回结果，是否与预期结果一致。如果与预期不一致，就表示测试失败。\n\n单元测试是函数正常工作、不出错的最基本、最有效的方法之一。 每一个单元测试发出一个特定的输入到所要测试的函数，看看函数是否返回预期的输出，或者采取了预期的行动。单元测试证明了所测试的代码行为符合预期。\n\n单元测试有助于代码的模块化，因此有助于长期的重用。因为有了测试，你就知道代码是可靠的，可以按照预期运行。从这个角度说，测试可以节省开发时间。单元测试的另一个好处是，有了测试，就等于就有了代码功能的文档，有助于其他开发者了解代码的意图。\n\n单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。\n\n一般来说，单元测试的步骤如下。\n\n- 准备所有的测试条件\n- 调用（触发）所要测试的函数\n- 验证运行结果是否正确\n- 还原被修改的记录\n\n### 其他测试类型\n\n（1）集成测试\n\n集成测试（Integration test）指的是多个部分在一起测试，比如测试一个数据库连接模块，是否能够连接数据库。\n\n（2）功能测试\n\n功能测试（Functional test）指的是，自动测试整个应用程序的某个功能，比如使用Selenium工具自动打开浏览器运行程序。\n\n（3）端对端测试\n\n端对端测试（End-to-End testing）指的是全链路测试，即从开始端到终止端的测试，比如测试从用户界面、通过网络、经过应用程序处理、到达数据库，是否能够返回正确结果。端对端测试的目的是，确保整个系统能够正常运行，各个子系统之间依赖关系正常，数据能够在子系统之间、模块之间正确传递。\n\n（4）冒烟测试\n\n冒烟测试（smoke testing）指的是，正式的全面测试开始之前，对主要功能进行的预测试。它的主要目的是，确认主要功能能否满足需要，软件是否能运行。冒烟测试可以是手工测试，也可以是自动化测试。\n\n这个名字最早来自对电子元件的测试，第一次对电子元件通电，看看它是否会冒烟。如果没有冒烟，说明通过了测试；如果电流达到某个临界点之后，才出现冒烟，这时可以评估是否能够接受这个临界点。\n\n## 开发模式\n\n测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。\n\n### TDD\n\nTDD是“测试驱动的开发”（Test-Driven Development）的简称，指的是先写好测试，然后再根据测试完成开发。使用这种开发方式，会有很高的测试覆盖率。\n\nTDD的开发步骤如下。\n\n- 先写一个测试。\n- 写出最小数量的代码，使其能够通过测试。\n- 优化代码。\n- 重复前面三步。\n\nTDD开发的测试覆盖率通常在90%以上，这意味着维护代码和新增特性会非常容易。因为测试保证了你可以信任这些代码，修改它们不会破坏其他代码的运行。\n\nTDD接口提供以下四个方法。\n\n- suite()\n- test()\n- setup()\n- teardown()\n\n下面代码是测试计数器是否加1。\n\n```js\nsuite('Counter', function() {\n  test('tick increases count to 1', function() {\n    var counter = new Counter();\n    counter.tick();\n    assert.equal(counter.count, 1);\n  });\n});\n```\n\n### BDD\n\nBDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。\n\nBDD认为，**不应该针对代码的实现细节写测试，而是要针对行为写测试**。BDD测试的是行为，即软件应该怎样运行。\n\nBDD接口提供以下六个方法。\n\n- describe()\n- it()\n- before()\n- after()\n- beforeEach()\n- afterEach()\n\n下面是测试计数器是否加1的BDD写法。\n\n```js\ndescribe('Counter', function() {\n  it('should increase count by 1 after calling tick', function() {\n    var counter = new Counter();\n    var expectedCount = counter.count + 1;\n    counter.tick();\n    assert.equal(counter.count, expectedCount);\n  });\n});\n```\n\n下面是一个BDD开发的示例。现在，需要开发一个`Foo`类，该类的实例有一个`sayHi`方法，会对类参数说“Hi”。这就是`Foo`类的规格，根据这个规格，我们可以写出测试用例文件`foo.spec.js`。\n\n```js\ndescribe('Simple object', function() {\n  var foo;\n\n  beforeEach(function() {\n    foo = new Foo('John');\n  });\n\n  it('should say hi', function() {\n    expect(foo.sayHi()).toEqual('John says hi!');\n  });\n});\n```\n\n有了测试用例以后，我们再写出实际的脚本文件`foo.js`。\n\n```js\nfunction Foo(name) {\n  this.name = name;\n}\n\nFoo.prototype.sayHi = function() {\n  return this.name + ' says hi!';\n};\n```\n\n为了把测试用例与脚本文件分开，我们通常把测试用例放在`test`子目录之中。然后，我们就可以使用Mocha、Jasmine等测试框架，执行测试用例，看看脚本文件是否通过测试。\n\n### BDD术语\n\n（1）测试套件\n\n测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。\n\n测试套件由一个`describe`函数构成，它接受两个参数：第一个参数是字符串，表示测试套件的名字或标题，表示将要测试什么；第二个参数是函数，用来实现这个测试套件。\n\n```js\ndescribe(\"A suite\", function() {\n  // ...\n});\n```\n\n（2）测试用例\n\n测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。测试用例由`it`函数构成，它与`describe`函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。\n\n```js\ndescribe(\"A suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    // ...\n  });\n});\n```\n\n（3）断言\n\n断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。\n\n断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为`true`，测试用例才会通过。\n\n```js\ndescribe(\"A suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    expect(true).toBe(true);\n  });\n});\n```\n\n## 断言\n\n断言是判断实际值与预期值是否相等的工具。\n\n断言有assert、expect、should三种风格，或者称为三种写法。\n\n```js\n// assert风格\nassert.equal(event.detail.item, '(item)‘);\n\n// expect风格\nexpect(event.detail.item).to.equal('(item)');\n\n// should风格\nevent.detail.item.should.equal('(item)');\n```\n\nChai.js是一个很流行的断言库，同时支持上面三种风格。\n\n（1） assert风格\n\n```js\nvar assert = require('chai').assert;\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nassert.typeOf(foo, 'string', 'foo is a string');\nassert.equal(foo, 'bar', 'foo equal `bar`');\nassert.lengthOf(foo, 3, 'foo`s value has a length of 3');\nassert.lengthOf(beverages.tea, 3, 'beverages has 3 types of tea');\n```\n\n上面代码中，assert方法的最后一个参数是错误提示信息，只有测试没有通过时，才会显示。\n\n（2）expect风格\n\n```js\nvar expect = require('chai').expect;\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nexpect(foo).to.be.a('string');\nexpect(foo).to.equal('bar');\nexpect(foo).to.have.length(3);\nexpect(beverages).to.have.property('tea').with.length(3);\n```\n\n（3）should风格\n\n```js\nvar should = require('chai').should();\nvar foo = 'bar';\nvar beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nfoo.should.be.a('string');\nfoo.should.equal('bar');\nfoo.should.have.length(3);\nbeverages.should.have.property('tea').with.length(3);\n```\n\n## Mocha.js\n\n### 概述\n\nMocha（发音“摩卡”）是现在最流行的前端测试框架之一，此外常用的测试框架还有[Jasmine](https://jasmine.github.io/)、[Tape](https://github.com/substack/tape/)、[zuul](https://github.com/defunctzombie/zuul/)等。所谓“测试框架”，就是运行测试的工具。\n\nMocha使用下面的命令安装。\n\n```js\n# 全局安装\n$ npm install -g mocha chai\n\n# 项目内安装\n$ npm i -D mocha chai\n```\n\n上面代码中，除了安装Mocha以外，还安装了断言库`chai`，这是因为Mocha自身不带断言库，必须安装外部断言库。\n\n测试套件文件一般放在`test`子目录下面，配置文件`mocha.opts`也放在这个目录里面。\n\n### 浏览器测试\n\n使用浏览器测试时，先用`mocha init`命令在指定目录生成初始化文件。\n\n```bash\n$ mocha init <path>\n```\n\n运行上面命令，就会在该目录下生成一个`index.html`文件，以及配套的脚本和样式表。\n\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Unit.js tests in the browser with Mocha</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\" href=\"mocha.css\" />\n  </head>\n  <body>\n    <h1>Unit.js tests in the browser with Mocha</h1>\n    <div id=\"mocha\"></div>\n    <script src=\"mocha.js\"></script>\n    <script>\n      mocha.setup('bdd');\n    </script>\n    <script src=\"tests.js\"></script>\n    <script>\n      mocha.run();\n    </script>\n  </body>\n</html>\n```\n\n然后在该文件中，加入你要测试的文件（比如`app.js`）、测试脚本（`app.spec.js`）和断言库（`chai.js`）。\n\n```js\n<script src=\"app.js\"></script>\n<script src=\"http://chaijs.com/chai.js\"></script>\n<script src=\"app.spec.js\"></script>\n```\n\n各个文件的内容如下。\n\n```js\n// app.js\nfunction add(x, y){\n  return x + y;\n}\n\n// app.spec.js\nvar expect = chai.expect;\n\ndescribe('测试add函数', function () {\n  it('1加1应该等于2', function () {\n    expect(add(1, 1)).to.equal(2);\n  });\n});\n```\n\n### 命令行测试\n\nMocha除了在浏览器运行，还可以在命令行运行。\n\n还是使用上面的文件，作为例子，但是要改成CommonJS格式。\n\n```js\n// app.js\nfunction add(x, y){\n  return x + y;\n}\n\nmodule.exports = add;\n\n// app.spec.js\nvar expect = require('chai').expect;\nvar add = require('../app');\n\ndescribe('测试add函数', function () {\n  it('1加1应该等于2', function () {\n    expect(add(1, 1)).to.equal(2);\n  });\n});\n```\n\n然后，在命令行下执行`mocha`，就会执行测试。\n\n```bash\n$ mocha\n```\n\n上面的命令等同于下面的形式。\n\n```bash\n$ mocha test --reporter spec --recursive --growl\n```\n\n### mocha.opts\n\n所有Mocha的命令行参数，都可以写在`test`目录下的配置文件`mocha.opts`之中。\n\n下面是一个典型的配置文件。\n\n```properties\n--reporter spec\n--recursive\n--growl\n```\n\n上面三个设置的含义如下。\n\n- 使用spec报告模板\n- 包括子目录\n- 打开桌面通知插件growl\n\n如果希望测试非存放于test子目录的测试用例，可以在`mocha.opts`写入以下内容。\n\n```properties\nserver-tests\n--recursive\n```\n\n上面代码指定运行`server-tests`目录及其子目录之中的测试脚本。\n\n### 生成规格文件\n\nMocha支持从测试用例生成规格文件。\n\n```bash\n$ mocha test/app.spec.js -R markdown > spec.md\n```\n\n上面命令生成单个`app.spec.js`规格。\n\n生成HTML格式的报告，使用下面的命令。\n\n```bash\n$ mocha test/app.spec.js -R doc > spec.html\n```\n\n如果要生成整个`test`目录，对应的规格文件，使用下面的命令。\n\n```bash\n$ mocha test -R markdown > spec.md --recursive\n```\n\n只要提供测试脚本的路径，Mocha就可以运行这个测试脚本。\n\n```bash\n$ mocha -w src/index.test.js\n```\n\n上面命令运行测试脚本`src/index.test.js`，参数`-w`表示watch，即当这个脚本一有变动，就会运行。\n\n指定测试脚本时，可以使用通配符，同时指定多个文件。\n\n```bash\n$ mocha --reporter spec spec/{my,awesome}.js\n$ mocha --ui tdd test/unit/*.js etc\n```\n\n上面代码中，参数`--reporter`指定生成的报告格式（上面代码是spec格式），`-ui`指定采用哪一种测试模式（上面代码是tdd模式）。\n\n除了使用shell通配符，还可以使用node通配符。\n\n```bash\n$ mocha --compilers js:babel-core/register 'test/**/*.@(js|jsx)'\n```\n\n上面代码指定运行`test`目录下面任何子目录中，文件后缀名为`js`或`jsx`的测试脚本。注意，Node的通配符要放在单引号之中，因为否则星号（`*`）会先被shell解释。\n\n如果要改用shell通配符，执行`test`目录下面任何子目录的测试脚本，要写成下面这样。\n\n```bash\n$ mocha test/**.js\n```\n\n如果测试脚本不止一个，最好将它们放在专门的目录当中。Mocha默认执行`test`目录的测试脚本，所以可以将所有测试脚本放在`test`子目录。`--recursive`参数可以指定运行子目录之中的测试脚本。\n\n```bash\n$ mocha --recursive\n```\n\n上面命令会运行`test`子目录之中的所有测试脚本。\n\n`--grep`参数用于搜索测试用例的名称（即it方法的第一个参数），然后只执行匹配的测试用例。\n\n```bash\n$ mocha --reporter spec --grep \"Fnord:\" server-test/*.js\n```\n\n上面代码只测试名称中包含“Fnord：”的测试用例。\n\n`--invert`参数表示只运行不符合条件的测试脚本。\n\n```bash\n$ mocha --grep auth --invert\n```\n\n如果测试脚本用到了ES6语法，还需要用`--compiler`参数指定babel进行转码。\n\n```bash\n$ mocha --compilers js:babel/register --recursive\n```\n\n上面命令会在运行测试脚本之前，先用Babel进行转码。`--compilers`参数的值是用冒号分隔的一个字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用`babel/register`模块，处理一下JS文件。\n\n`--require`参数指定测试脚本默认包含的文件。下面是一个`test_helper.js`文件。\n\n```js\n// test/test_helper.js\nimport chai from 'chai';\n```\n\n使用`--require`参数，将上面这个脚本包含进所有测试脚本。\n\n```bash\n$ mocha --compilers js:babel/register --require ./test/test_helper.js  --recursive\n```\n\n### 测试脚本的写法\n\n测试脚本中，describe方法和it方法都允许调用only方法，表示只运行某个测试套件或测试用例。\n\n```js\n// 例一\ndescribe('Array', function(){\n  describe.only('#indexOf()', function(){\n    ...\n  });\n});\n\n// 例二\ndescribe(\"using only\", function() {\n  it.only(\"this is the only test to be run\", function() {\n\n  });\n\n  it(\"this is not run\", function() {\n\n  });\n});\n```\n\n上面代码中，只有带有`only`方法的测试套件或测试用例会运行。\n\ndescribe方法和it方法还可以调用skip方法，表示跳过指定的测试套件或测试用例。\n\n```js\n// 例一\ndescribe.skip('Article', function() {\n  // ...\n});\n\n// 例二\ndescribe(\"using only\", function() {\n  it.skip(\"this is the only test to be run\", function() {\n\n  });\n\n  it(\"this is not run\", function() {\n\n  });\n});\n```\n\n上面代码中，带有`skip`方法的测试套件或测试用例会被忽略。\n\n如果测试用例包含异步操作，可以done方法显式指定测试用例的运行结束时间。\n\n```js\nit('logs a', function(done) {\n  var f = function(){\n    console.log('logs a');\n    done();\n  };\n  setTimeout(f, 500);\n});\n```\n\n上面代码中，正常情况下，函数f还没有执行，Mocha就已经结束运行了。为了保证Mocha等到测试用例跑完再结束运行，可以手动调用done方法\n\n## Promise的测试\n\n对于异步的测试，测试用例之中，通常必须调用`done`方法，显式表明异步操作的结束。\n\n```js\nvar expect = require('chai').expect;\n\nit('should do something with promises', function(done) {\n  var result = asyncTest();\n\n  result.then(function(data) {\n    expect(data).to.equal('foobar');\n    done();\n  }, function(error) {\n    assert.fail(error);\n    done();\n  });\n});\n```\n\n上面代码之中，Promise对象的`then`方法之中，必须指定`reject`时的回调函数，并且使用`assert.fail`方法抛出错误，否则这个错误就不会被外界感知。\n\n```js\nresult.then(function(data) {\n  expect(data).to.equal(blah);\n  done();\n});\n```\n\n上面代码之中，如果Promise被`reject`，是不会被捕获的，因为Promise之中的错误，不会”泄漏“到外界。\n\nMocha内置了对Promise的支持。\n\n```js\nit('should fail the test', function() {\n  var p = Promise.reject('Promise被reject');\n\n  return p;\n});\n```\n\n上面代码中，Mocha能够捕获`reject`的Promise。\n\n因此，使用Mocha时，Promise的测试可以简化成下面的写法。\n\n```js\nvar expect = require('chai').expect;\n\nit('should do something with promises', function() {\n  var result = asyncTest();\n\n  return result.then(function(data) {\n    expect(data).to.equal('foobar');\n  });\n});\n```\n\n## 模拟数据\n\n单元测试时，很多时候，测试的代码会请求HTTP服务器。这时，我们就需要模拟服务器的回应，不能在单元测试时去请求真实服务器数据，否则就不叫单元测试了，而是连同服务器一起测试了。\n\n一些工具库可以模拟服务器回应。\n\n- [nock](https://github.com/pgte/nock)\n- [sinon](http://sinonjs.org/docs/#server)\n- [faux-jax](https://github.com/algolia/faux-jax)\n- [MITM](https://github.com/moll/node-mitm)\n\n## 覆盖率\n\n测试的覆盖率需要安装istanbul模块。\n\n```bash\n$ npm i -D istanbul\n```\n\n然后，在package.json设置运行覆盖率检查的命令。\n\n```json\n\"scripts\": {\n  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js\",\n  \"check-coverage\": \"istanbul check-coverage --statements 100 --branches 100 --functions 100 --lines 100\"\n}\n```\n\n上面代码中，`test:cover`是生成覆盖率报告，`check-coverage`是设置覆盖率通过的门槛。\n\n然后，将`coverage`目录写入`.gitignore`防止连这个目录一起提交。\n\n如果希望在`git commit`提交之前，先运行一次测试，可以安装ghooks模块，配置`pre-commit`钩子。\n\n安装ghooks。\n\n```bash\n$ npm i -D ghooks\n```\n\n在package.json之中，配置`pre-commit`钩子。\n\n```json\n\"config\": {\n  \"ghooks\": {\n    \"pre-commit\": \"npm run test:cover && npm run check-coverage\"\n  }\n}\n```\n\n还可以把覆盖率检查，加入`.travis.yml`文件。\n\n```yaml\nscript:\n  - npm run test:cover\n  - npm run check-coverage\n```\n\n如果测试脚本使用ES6，`scripts`字段还需要加入Babel转码。\n\n```json\n\"scripts\": {\n  \"test\": \"mocha src/index.test.js -w --compilers js:babel/register\",\n  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js --compilers js:babel/register\"\n}\n```\n\n覆盖率报告可以上传到[codecov.io](https://codecov.io/)。先安装这个模块。\n\n```bash\n$ npm i -D codecov.io\n```\n\n然后在package.json增加一个字段。\n\n```json\n\"scripts\": {\n  \"report-coverage\": \"cat ./coverage/lcov.info | codecov\"\n}\n```\n\n最后，在CI的配置文件`.travis.yml`之中，增加运行这个命令。\n\n```bash\nafter_success:\n  - npm run report-coverage\n  - npm run semantic-release\n```\n\n## WebDriver\n\nWebDriver是一个浏览器的自动化框架。它在各种浏览器的基础上，提供一个统一接口，将接收到的指令转为浏览器的原生指令，驱动浏览器。\n\nWebDriver由Selenium项目演变而来。Selenium是一个测试自动化框架，它的1.0版叫做Selenium RC，通过一个代理服务器，将测试脚本转为JavaScript脚本，注入不同的浏览器，再由浏览器执行这些脚本后返回结果。WebDriver就是Selenium 2.0，它对每个浏览器提供一个驱动，测试脚本通过驱动转换为浏览器原生命令，在浏览器中执行。\n\n### 定制测试环境\n\nDesiredCapabilities对象用于定制测试环境。\n\n- 定制DesiredCapabilities对象的各个属性\n- 创建DesiredCapabilities实例\n- 将DesiredCapabilities实例作为参数，新建一个WebDriver实例\n\n### 操作浏览器的方法\n\nWebDriver提供以下方法操作浏览器。\n\nclose()：退出或关闭当前浏览器窗口。\n\n```js\ndriver.close();\n```\n\nquit()：关闭所有浏览器窗口，中止当前浏览器driver和session。\n\n```js\ndriver.quit();\n```\n\ngetTitle()：返回当前网页的标题。\n\n```js\ndriver.getTitle();\n```\n\ngetCurrentUrl()：返回当前网页的网址。\n\n```js\ndriver.getCurrentUrl();\n```\n\ngetPageSource()：返回当前网页的源码。\n\n```js\n// 断言是否含有指定文本\nassert(driver.getPageSource().contains(\"Hello World\"),\n  \"预期含有文本Hello World\");\n```\n\nclick()：模拟鼠标点击。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\"))\n  .click();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webDriver\");\ndriver.findElement(By.id(\"sblsbb\"))\n  .click();\n```\n\nclear()：清空文本输入框。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\")).clear();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webDriver\");\ndriver.findElement(By.name(\"q\"))\n  .clear();\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"testing\");\n```\n\nsendKeys()：在文本输入框输入文本。\n\n```js\ndriver.findElement(By.locatorType(\"path\"))\n  .sendKeys(\"your text\");\n```\n\nsubmit()：提交表单，或者用来模拟按下回车键。\n\n```js\n// 例一\ndriver.findElement(By.locatorType(\"path\"))\n  .submit();\n\n// 例二\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.name(\"q\"))\n  .sendKeys(\"webdriver\");\nelement.submit();\n```\n\nfindElement()：返回选中的第一个元素。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.id(\"lst-ib\"));\n```\n\nfindElements()：返回选中的所有元素（0个或多个）。\n\n```js\n// 例一\ndriver.findElement(By.id(\"searchbox\"))\n  .sendKeys(\"webdriver\");\ndriver.findElements(By.xpath(\"//div[3]/ul/li\"))\n  .get(0)\n  .click();\n\n// 例二\ndriver.findElements(By.tagName(\"select\"))\n  .get(0)\n  .findElements(By.tagName(\"option\"))\n  .get(3)\n  .click()\n  .get(4)\n  .click()\n  .get(5)\n  .click();\n\n// 例三：获取页面所有链接\nvar links = driver\n  .get(\"https://www.google.com\")\n  .findElements(By.tagName(\"a\"));\nvar linkSize = links.size();\nvar linksSrc = [];\n\nconsole.log(linkSize);\n\nfor(var i=0;i<linkSize;i++) {\n  linksSrc[i] = links.get(i).getAttribute(\"href\");\n}\n\nfor(int i=0;i<linkSize;i++){\n  driver.navigate().to(linksSrc[i]);\n  Thread.sleep(3000);\n}\n```\n\n可以使用`size()`，查看到底选中了多少个元素。\n\n### 网页元素的定位\n\nWebDriver提供8种定位器，用于定位网页元素。\n\n- By.id：HTML元素的id属性\n- By.name：HTML元素的name属性\n- By.xpath：使用XPath语法选中HTML元素\n- By.cssSelector：使用CSS选择器语法\n- By.className：HTML元素的class属性\n- By.linkText：链接文本（只用于选中链接）\n- By.tagName：HTML元素的标签名\n- By.partialLinkText：部分链接文本（只用于选中链接）\n\n下面是一个使用id定位器，选中网页元素的例子。\n\n```js\ndriver.findElement(By.id(\"sblsbb\")).click();\n```\n\n### 网页元素的方法\n\n以下方法属于网页元素的方法，而不是webDriver实例的方法。需要注意的是，有些方法是某些元素特有的，比如只有文本框才能输入文字。如果在网页元素上调用不支持的方法，WebDriver不会报错，也不会给出给出任何提示，只会静静地忽略。\n\ngetAttribute()：返回网页元素指定属性的值。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.xpath(\"//div[@id='lst-ib']\"))\n  .getAttribute(\"class\");\n```\n\ngetText()：返回网页元素的内部文本。\n\n```js\ndriver.findElement(By.locatorType(\"path\")).getText();\n```\n\ngetTagName()：返回指定元素的标签名。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.findElement(By.xpath(\"//div[@class='sbib_b']\"))\n  .getTagName();\n```\n\nisDisplayed()：返回一个布尔值，表示元素是否可见。\n\n```js\ndriver.get(\"https://www.google.com\");\nassert(driver.findElement(By.name(\"q\"))\n  .isDisplayed(),\n  '搜索框应该可选择');\n```\n\nisEnabled()：返回一个布尔值，表示文本框是否可编辑。\n\n```js\ndriver.get(\"https://www.google.com\");\nvar Element = driver.findElement(By.name(\"q\"));\nif (Element.isEnabled()) {\n  driver.findElement(By.name(\"q\"))\n    .sendKeys(\"Selenium Essentials\");\n} else {\n  throw new Error();\n}\n```\n\nisSelected()：返回一个布尔值，表示一个元素是否可选择。\n\n```js\ndriver.findElement(By.xpath(\"//select[@name='jump']/option[1]\"))\n  .isSelected()\n```\n\ngetSize()：返回一个网页元素的宽度和高度。\n\n```js\nvar dimensions=driver.findElement(By.locatorType(\"path\"))\n  .getSize(); \ndimensions.width;\ndimensions.height;\n```\n\ngetLocation()：返回网页元素左上角的x坐标和y坐标。\n\n```js\nvar point = driver.findElement(By.locatorType(\"path\")).getLocation();\npoint.x; // 等同于 point.getX();\npoint.y; // 等同于 point.getY();\n```\n\ngetCssValue()：返回网页元素指定的CSS属性的值。\n\n```js\ndriver.get(\"https://www.google.com\");\nvar element = driver.findElement(By.xpath(\"//div[@id='hplogo']\"));\nconsole.log(element.getCssValue(\"font-size\"));\nconsole.log(element.getCssValue(\"font-weight\"));\nconsole.log(element.getCssValue(\"color\"));\nconsole.log(element.getCssValue(\"background-size\"));\n```\n\n### 页面跳转的方法\n\n以下方法用来跳转到某一个页面。\n\nget()：要求浏览器跳到某个网址。\n\n```js\ndriver.get(\"URL\");\n```\n\nnavigate().back()：浏览器回退。\n\n```js\ndriver.navigate().back();\n```\n\nnavigate().forward()：浏览器前进。\n\n```js\ndriver.navigate().forward();\n```\n\nnavigate().to()：跳转到浏览器历史中的某个页面。\n\n```js\ndriver.navigate().to(\"URL\");\n```\n\nnavigate().refresh()：刷新当前页面。\n\n```js\ndriver.navigate().refresh();\n// 等同于\ndriver.navigate()\n  .to(driver.getCurrentUrl());\n// 等同于\ndriver.findElement(By.locatorType(\"path\"))\n  .sendKeys(Keys.F5);\n```\n\n\n\n### cookie的方法\n\ngetCookies()：获取cookie\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.manage().getCookies();\n```\n\ngetCookieNamed() ：返回指定名称的cookie。\n\n```js\ndriver.get(\"https://www.google.com\");\nconsole.log(driver.manage().getCookieNamed(\"NID\"));\n```\n\naddCookie()：将cookie加入当前页面。\n\n```js\ndriver.get(\"https://www.google.com\");\ndriver.manage().addCookie(cookie0);\n```\n\ndeleteCookie()：删除指定的cookie。\n\n```js\ndriver.get(\"https://www.google.co.in\");\ndriver.manage().deleteCookieNamed(\"NID\");\n```\n\n\n\n### 浏览器窗口的方法\n\nmaximize()：最大化浏览器窗口。\n\n```js\nvar driver = new FirefoxDriver();\ndriver.manage().window().maximize();\n```\n\ngetSize()：返回浏览器窗口、图像、网页元素的宽和高。\n\n```js\ndriver.manage().window().getSize();\n```\n\ngetPosition()：返回浏览器窗口左上角的x坐标和y坐标。\n\n```js\nconsole.log(\"Position X: \" + driver.manage().window().getPosition().x);\nconsole.log(\"Position Y: \" + driver.manage().window().getPosition().y);\nconsole.log(\"Position X: \" + driver.manage().window().getPosition().getX());\nconsole.log(\"Position Y: \" + driver.manage().window().getPosition().getY());\n```\n\nsetSize()：定制浏览器窗口的大小。\n\n```js\nvar d = new Dimension(320, 480);\ndriver.manage().window().setSize(d);\ndriver.manage().window().setSize(new Dimension(320, 480));\n```\n\nsetPosition()：移动浏览器左上角到指定位置。\n\n```js\nvar p = new Point(200, 200);\ndriver.manage().window().setPosition(p);\ndriver.manage().window().setPosition(new Point(300, 150));\n```\n\ngetWindowHandle()：返回当前浏览器窗口。\n\n```js\nvar parentwindow = driver.getWindowHandle();\ndriver.switchTo().window(parentwindow);\n```\n\ngetWindowHandles()：返回所有浏览器窗口。\n\n```js\nvar childwindows =  driver.getWindowHandles();\ndriver.switchTo().window(childwindow);\n```\n\nswitchTo.window()：在浏览器窗口之间切换。\n\n```js\ndriver.SwitchTo().Window(childwindow);\ndriver.close();\ndriver.SwitchTo().Window(parentWindow);\n```\n\n### 弹出窗口\n\n以下方法处理浏览器的弹出窗口。\n\ndismiss() ：关闭弹出窗口。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.dismiss();\n```\n\naccept()：接受弹出窗口，相当于按下接受OK按钮。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.accept();\n```\n\ngetText()：返回弹出窗口的文本值。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.getText();\n```\n\nsendKeys()：向弹出窗口发送文本字符串。\n\n```js\nvar alert = driver.switchTo().alert();\nalert.sendKeys(\"Text to be passed\");\n```\n\nauthenticateUsing()：处理HTTP认证。\n\n```js\nvar user = new UserAndPassword(\"USERNAME\", \"PASSWORD\");\nalert.authenticateUsing(user);\n```\n\n### 鼠标和键盘的方法\n\n以下方法模拟鼠标和键盘的动作。\n\n- click()：鼠标在当前位置点击。\n- clickAndHold()：按下鼠标不放\n- contextClick()：右击鼠标\n- doubleClick()：双击鼠标\n- dragAndDrop()：鼠标拖放到目标元素\n- dragAndDropBy()：鼠标拖放到目标坐标\n- keyDown()：按下某个键\n- keyUp()：从按下状态释放某个键\n- moveByOffset()：移动鼠标到另一个坐标位置\n- moveToElement()：移动鼠标到另一个网页元素\n- release()：释放拖拉的元素\n- sendKeys()：控制键盘输出\n\n## 参考链接\n\n- Jani Hartikainen, http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/","slug":"JS测试教程","published":1,"updated":"2020-03-29T06:59:20.718Z","photos":[],"link":"","_id":"ck8ct7j63001sgtvi42ox43mq","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>来源：<a href=\"https://javascript.ruanyifeng.com/tool/testing.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n<h2 id=\"为什么要写测试？\"><a href=\"#为什么要写测试？\" class=\"headerlink\" title=\"为什么要写测试？\"></a>为什么要写测试？</h2><p>Web应用程序越来越复杂，这意味着有更多的可能出错。测试是帮助我们提高代码质量、降低错误的最好方法和工具之一。</p>\n<ul>\n<li>测试可以确保得到预期结果。</li>\n<li>加快开发速度。</li>\n<li>方便维护。</li>\n<li>提供用法的文档。</li>\n</ul>\n<p>通过测试提供软件的质量，在开始的时候，可能会降低开发速度。但是从长期看，尤其是那种代码需要长期维护、不断开发的情况，测试会大大加快开发速度，减轻维护难度。</p>\n<h2 id=\"测试的类型\"><a href=\"#测试的类型\" class=\"headerlink\" title=\"测试的类型\"></a>测试的类型</h2><h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>单元测试（unit testing）指的是以软件的单元（unit）为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或组件。它的基本特征就是，只要输入不变，必定返回同样的输出。</p>\n<p>“单元测试”这个词，本身就暗示，软件应该以模块化结构存在。每个模块的运作，是独立于其他模块的。一个软件越容易写单元测试，往往暗示着它的模块化结构越好，各模块之间的耦合就越弱；越难写单元测试，或者每次单元测试，不得不模拟大量的外部条件，很可能暗示软件的模块化结构越差，模块之间存在较强的耦合。</p>\n<p>单元测试的要求是，每个模块都必须有单元测试，而软件由模块组成。</p>\n<p>单元测试通常采取断言（assertion）的形式，也就是测试某个功能的返回结果，是否与预期结果一致。如果与预期不一致，就表示测试失败。</p>\n<p>单元测试是函数正常工作、不出错的最基本、最有效的方法之一。 每一个单元测试发出一个特定的输入到所要测试的函数，看看函数是否返回预期的输出，或者采取了预期的行动。单元测试证明了所测试的代码行为符合预期。</p>\n<p>单元测试有助于代码的模块化，因此有助于长期的重用。因为有了测试，你就知道代码是可靠的，可以按照预期运行。从这个角度说，测试可以节省开发时间。单元测试的另一个好处是，有了测试，就等于就有了代码功能的文档，有助于其他开发者了解代码的意图。</p>\n<p>单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。</p>\n<p>一般来说，单元测试的步骤如下。</p>\n<ul>\n<li>准备所有的测试条件</li>\n<li>调用（触发）所要测试的函数</li>\n<li>验证运行结果是否正确</li>\n<li>还原被修改的记录</li>\n</ul>\n<h3 id=\"其他测试类型\"><a href=\"#其他测试类型\" class=\"headerlink\" title=\"其他测试类型\"></a>其他测试类型</h3><p>（1）集成测试</p>\n<p>集成测试（Integration test）指的是多个部分在一起测试，比如测试一个数据库连接模块，是否能够连接数据库。</p>\n<p>（2）功能测试</p>\n<p>功能测试（Functional test）指的是，自动测试整个应用程序的某个功能，比如使用Selenium工具自动打开浏览器运行程序。</p>\n<p>（3）端对端测试</p>\n<p>端对端测试（End-to-End testing）指的是全链路测试，即从开始端到终止端的测试，比如测试从用户界面、通过网络、经过应用程序处理、到达数据库，是否能够返回正确结果。端对端测试的目的是，确保整个系统能够正常运行，各个子系统之间依赖关系正常，数据能够在子系统之间、模块之间正确传递。</p>\n<p>（4）冒烟测试</p>\n<p>冒烟测试（smoke testing）指的是，正式的全面测试开始之前，对主要功能进行的预测试。它的主要目的是，确认主要功能能否满足需要，软件是否能运行。冒烟测试可以是手工测试，也可以是自动化测试。</p>\n<p>这个名字最早来自对电子元件的测试，第一次对电子元件通电，看看它是否会冒烟。如果没有冒烟，说明通过了测试；如果电流达到某个临界点之后，才出现冒烟，这时可以评估是否能够接受这个临界点。</p>\n<h2 id=\"开发模式\"><a href=\"#开发模式\" class=\"headerlink\" title=\"开发模式\"></a>开发模式</h2><p>测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。</p>\n<h3 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h3><p>TDD是“测试驱动的开发”（Test-Driven Development）的简称，指的是先写好测试，然后再根据测试完成开发。使用这种开发方式，会有很高的测试覆盖率。</p>\n<p>TDD的开发步骤如下。</p>\n<ul>\n<li>先写一个测试。</li>\n<li>写出最小数量的代码，使其能够通过测试。</li>\n<li>优化代码。</li>\n<li>重复前面三步。</li>\n</ul>\n<p>TDD开发的测试覆盖率通常在90%以上，这意味着维护代码和新增特性会非常容易。因为测试保证了你可以信任这些代码，修改它们不会破坏其他代码的运行。</p>\n<p>TDD接口提供以下四个方法。</p>\n<ul>\n<li>suite()</li>\n<li>test()</li>\n<li>setup()</li>\n<li>teardown()</li>\n</ul>\n<p>下面代码是测试计数器是否加1。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suite(<span class=\"string\">'Counter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  test(<span class=\"string\">'tick increases count to 1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">    counter.tick();</span><br><span class=\"line\">    assert.equal(counter.count, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BDD\"><a href=\"#BDD\" class=\"headerlink\" title=\"BDD\"></a>BDD</h3><p>BDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。</p>\n<p>BDD认为，<strong>不应该针对代码的实现细节写测试，而是要针对行为写测试</strong>。BDD测试的是行为，即软件应该怎样运行。</p>\n<p>BDD接口提供以下六个方法。</p>\n<ul>\n<li>describe()</li>\n<li>it()</li>\n<li>before()</li>\n<li>after()</li>\n<li>beforeEach()</li>\n<li>afterEach()</li>\n</ul>\n<p>下面是测试计数器是否加1的BDD写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Counter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'should increase count by 1 after calling tick'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> expectedCount = counter.count + <span class=\"number\">1</span>;</span><br><span class=\"line\">    counter.tick();</span><br><span class=\"line\">    assert.equal(counter.count, expectedCount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个BDD开发的示例。现在，需要开发一个<code>Foo</code>类，该类的实例有一个<code>sayHi</code>方法，会对类参数说“Hi”。这就是<code>Foo</code>类的规格，根据这个规格，我们可以写出测试用例文件<code>foo.spec.js</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Simple object'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo(<span class=\"string\">'John'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'should say hi'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(foo.sayHi()).toEqual(<span class=\"string\">'John says hi!'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有了测试用例以后，我们再写出实际的脚本文件<code>foo.js</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' says hi!'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>为了把测试用例与脚本文件分开，我们通常把测试用例放在<code>test</code>子目录之中。然后，我们就可以使用Mocha、Jasmine等测试框架，执行测试用例，看看脚本文件是否通过测试。</p>\n<h3 id=\"BDD术语\"><a href=\"#BDD术语\" class=\"headerlink\" title=\"BDD术语\"></a>BDD术语</h3><p>（1）测试套件</p>\n<p>测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。</p>\n<p>测试套件由一个<code>describe</code>函数构成，它接受两个参数：第一个参数是字符串，表示测试套件的名字或标题，表示将要测试什么；第二个参数是函数，用来实现这个测试套件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（2）测试用例</p>\n<p>测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。测试用例由<code>it</code>函数构成，它与<code>describe</code>函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"contains spec with an expectation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（3）断言</p>\n<p>断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。</p>\n<p>断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为<code>true</code>，测试用例才会通过。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"contains spec with an expectation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(<span class=\"literal\">true</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>断言是判断实际值与预期值是否相等的工具。</p>\n<p>断言有assert、expect、should三种风格，或者称为三种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assert风格</span></span><br><span class=\"line\">assert.equal(event.detail.item, <span class=\"string\">'(item)‘);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// expect风格</span></span><br><span class=\"line\"><span class=\"string\">expect(event.detail.item).to.equal('</span>(item)<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// should风格</span></span><br><span class=\"line\"><span class=\"string\">event.detail.item.should.equal('</span>(item)<span class=\"string\">');</span></span><br></pre></td></tr></table></figure>\n\n<p>Chai.js是一个很流行的断言库，同时支持上面三种风格。</p>\n<p>（1） assert风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).assert;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">assert.typeOf(foo, <span class=\"string\">'string'</span>, <span class=\"string\">'foo is a string'</span>);</span><br><span class=\"line\">assert.equal(foo, <span class=\"string\">'bar'</span>, <span class=\"string\">'foo equal `bar`'</span>);</span><br><span class=\"line\">assert.lengthOf(foo, <span class=\"number\">3</span>, <span class=\"string\">'foo`s value has a length of 3'</span>);</span><br><span class=\"line\">assert.lengthOf(beverages.tea, <span class=\"number\">3</span>, <span class=\"string\">'beverages has 3 types of tea'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，assert方法的最后一个参数是错误提示信息，只有测试没有通过时，才会显示。</p>\n<p>（2）expect风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">expect(foo).to.be.a(<span class=\"string\">'string'</span>);</span><br><span class=\"line\">expect(foo).to.equal(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">expect(foo).to.have.length(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(beverages).to.have.property(<span class=\"string\">'tea'</span>).with.length(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（3）should风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).should();</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.should.be.a(<span class=\"string\">'string'</span>);</span><br><span class=\"line\">foo.should.equal(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">foo.should.have.length(<span class=\"number\">3</span>);</span><br><span class=\"line\">beverages.should.have.property(<span class=\"string\">'tea'</span>).with.length(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mocha-js\"><a href=\"#Mocha-js\" class=\"headerlink\" title=\"Mocha.js\"></a>Mocha.js</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Mocha（发音“摩卡”）是现在最流行的前端测试框架之一，此外常用的测试框架还有<a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>、<a href=\"https://github.com/substack/tape/\" target=\"_blank\" rel=\"noopener\">Tape</a>、<a href=\"https://github.com/defunctzombie/zuul/\" target=\"_blank\" rel=\"noopener\">zuul</a>等。所谓“测试框架”，就是运行测试的工具。</p>\n<p>Mocha使用下面的命令安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 全局安装</span><br><span class=\"line\">$ npm install -g mocha chai</span><br><span class=\"line\"></span><br><span class=\"line\"># 项目内安装</span><br><span class=\"line\">$ npm i -D mocha chai</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，除了安装Mocha以外，还安装了断言库<code>chai</code>，这是因为Mocha自身不带断言库，必须安装外部断言库。</p>\n<p>测试套件文件一般放在<code>test</code>子目录下面，配置文件<code>mocha.opts</code>也放在这个目录里面。</p>\n<h3 id=\"浏览器测试\"><a href=\"#浏览器测试\" class=\"headerlink\" title=\"浏览器测试\"></a>浏览器测试</h3><p>使用浏览器测试时，先用<code>mocha init</code>命令在指定目录生成初始化文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha init &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面命令，就会在该目录下生成一个<code>index.html</code>文件，以及配套的脚本和样式表。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Unit.js tests <span class=\"keyword\">in</span> the browser <span class=\"keyword\">with</span> Mocha&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;meta http-equiv=\"Content-Type\" content=\"text/</span>html; charset=UTF<span class=\"number\">-8</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;meta name=\"</span>viewport<span class=\"string\">\" content=\"</span>width=device-width, initial-scale=<span class=\"number\">1.0</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>mocha.css<span class=\"string\">\" /&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h1&gt;Unit.js tests in the browser with Mocha&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=\"</span>mocha<span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>mocha.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      mocha.setup('bdd');</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>tests.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      mocha.run();</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在该文件中，加入你要测试的文件（比如<code>app.js</code>）、测试脚本（<code>app.spec.js</code>）和断言库（<code>chai.js</code>）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"http:/</span><span class=\"regexp\">/chaijs.com/</span>chai.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;script src=\"</span>app.spec.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>各个文件的内容如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.spec.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> expect = chai.expect;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'测试add函数'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'1加1应该等于2'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)).to.equal(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令行测试\"><a href=\"#命令行测试\" class=\"headerlink\" title=\"命令行测试\"></a>命令行测试</h3><p>Mocha除了在浏览器运行，还可以在命令行运行。</p>\n<p>还是使用上面的文件，作为例子，但是要改成CommonJS格式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.spec.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"built_in\">require</span>(<span class=\"string\">'../app'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'测试add函数'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'1加1应该等于2'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)).to.equal(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后，在命令行下执行<code>mocha</code>，就会执行测试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令等同于下面的形式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span> --reporter spec --recursive --growl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mocha-opts\"><a href=\"#mocha-opts\" class=\"headerlink\" title=\"mocha.opts\"></a>mocha.opts</h3><p>所有Mocha的命令行参数，都可以写在<code>test</code>目录下的配置文件<code>mocha.opts</code>之中。</p>\n<p>下面是一个典型的配置文件。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">--reporter</span> <span class=\"string\">spec</span></span><br><span class=\"line\"><span class=\"attr\">--recursive</span></span><br><span class=\"line\"><span class=\"attr\">--growl</span></span><br></pre></td></tr></table></figure>\n\n<p>上面三个设置的含义如下。</p>\n<ul>\n<li>使用spec报告模板</li>\n<li>包括子目录</li>\n<li>打开桌面通知插件growl</li>\n</ul>\n<p>如果希望测试非存放于test子目录的测试用例，可以在<code>mocha.opts</code>写入以下内容。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server-tests</span></span><br><span class=\"line\"><span class=\"attr\">--recursive</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定运行<code>server-tests</code>目录及其子目录之中的测试脚本。</p>\n<h3 id=\"生成规格文件\"><a href=\"#生成规格文件\" class=\"headerlink\" title=\"生成规格文件\"></a>生成规格文件</h3><p>Mocha支持从测试用例生成规格文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/app.spec.js -R markdown &gt; spec.md</span><br></pre></td></tr></table></figure>\n\n<p>上面命令生成单个<code>app.spec.js</code>规格。</p>\n<p>生成HTML格式的报告，使用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/app.spec.js -R doc &gt; spec.html</span><br></pre></td></tr></table></figure>\n\n<p>如果要生成整个<code>test</code>目录，对应的规格文件，使用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span> -R markdown &gt; spec.md --recursive</span><br></pre></td></tr></table></figure>\n\n<p>只要提供测试脚本的路径，Mocha就可以运行这个测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha -w src/index.test.js</span><br></pre></td></tr></table></figure>\n\n<p>上面命令运行测试脚本<code>src/index.test.js</code>，参数<code>-w</code>表示watch，即当这个脚本一有变动，就会运行。</p>\n<p>指定测试脚本时，可以使用通配符，同时指定多个文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --reporter spec spec/&#123;my,awesome&#125;.js</span><br><span class=\"line\">$ mocha --ui tdd <span class=\"built_in\">test</span>/unit/*.js etc</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，参数<code>--reporter</code>指定生成的报告格式（上面代码是spec格式），<code>-ui</code>指定采用哪一种测试模式（上面代码是tdd模式）。</p>\n<p>除了使用shell通配符，还可以使用node通配符。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel-core/register <span class=\"string\">'test/**/*.@(js|jsx)'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定运行<code>test</code>目录下面任何子目录中，文件后缀名为<code>js</code>或<code>jsx</code>的测试脚本。注意，Node的通配符要放在单引号之中，因为否则星号（<code>*</code>）会先被shell解释。</p>\n<p>如果要改用shell通配符，执行<code>test</code>目录下面任何子目录的测试脚本，要写成下面这样。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/**.js</span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本不止一个，最好将它们放在专门的目录当中。Mocha默认执行<code>test</code>目录的测试脚本，所以可以将所有测试脚本放在<code>test</code>子目录。<code>--recursive</code>参数可以指定运行子目录之中的测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --recursive</span><br></pre></td></tr></table></figure>\n\n<p>上面命令会运行<code>test</code>子目录之中的所有测试脚本。</p>\n<p><code>--grep</code>参数用于搜索测试用例的名称（即it方法的第一个参数），然后只执行匹配的测试用例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --reporter spec --grep <span class=\"string\">\"Fnord:\"</span> server-test/*.js</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只测试名称中包含“Fnord：”的测试用例。</p>\n<p><code>--invert</code>参数表示只运行不符合条件的测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --grep auth --invert</span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本用到了ES6语法，还需要用<code>--compiler</code>参数指定babel进行转码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel/register --recursive</span><br></pre></td></tr></table></figure>\n\n<p>上面命令会在运行测试脚本之前，先用Babel进行转码。<code>--compilers</code>参数的值是用冒号分隔的一个字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用<code>babel/register</code>模块，处理一下JS文件。</p>\n<p><code>--require</code>参数指定测试脚本默认包含的文件。下面是一个<code>test_helper.js</code>文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test/test_helper.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> chai <span class=\"keyword\">from</span> <span class=\"string\">'chai'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>--require</code>参数，将上面这个脚本包含进所有测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel/register --require ./<span class=\"built_in\">test</span>/test_helper.js  --recursive</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试脚本的写法\"><a href=\"#测试脚本的写法\" class=\"headerlink\" title=\"测试脚本的写法\"></a>测试脚本的写法</h3><p>测试脚本中，describe方法和it方法都允许调用only方法，表示只运行某个测试套件或测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">describe(<span class=\"string\">'Array'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  describe.only(<span class=\"string\">'#indexOf()'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">describe(<span class=\"string\">\"using only\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it.only(<span class=\"string\">\"this is the only test to be run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">\"this is not run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只有带有<code>only</code>方法的测试套件或测试用例会运行。</p>\n<p>describe方法和it方法还可以调用skip方法，表示跳过指定的测试套件或测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">describe.skip(<span class=\"string\">'Article'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">describe(<span class=\"string\">\"using only\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it.skip(<span class=\"string\">\"this is the only test to be run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">\"this is not run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，带有<code>skip</code>方法的测试套件或测试用例会被忽略。</p>\n<p>如果测试用例包含异步操作，可以done方法显式指定测试用例的运行结束时间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'logs a'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'logs a'</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  setTimeout(f, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，正常情况下，函数f还没有执行，Mocha就已经结束运行了。为了保证Mocha等到测试用例跑完再结束运行，可以手动调用done方法</p>\n<h2 id=\"Promise的测试\"><a href=\"#Promise的测试\" class=\"headerlink\" title=\"Promise的测试\"></a>Promise的测试</h2><p>对于异步的测试，测试用例之中，通常必须调用<code>done</code>方法，显式表明异步操作的结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should do something with promises'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = asyncTest();</span><br><span class=\"line\"></span><br><span class=\"line\">  result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    expect(data).to.equal(<span class=\"string\">'foobar'</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    assert.fail(error);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，Promise对象的<code>then</code>方法之中，必须指定<code>reject</code>时的回调函数，并且使用<code>assert.fail</code>方法抛出错误，否则这个错误就不会被外界感知。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  expect(data).to.equal(blah);</span><br><span class=\"line\">  done();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，如果Promise被<code>reject</code>，是不会被捕获的，因为Promise之中的错误，不会”泄漏“到外界。</p>\n<p>Mocha内置了对Promise的支持。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'should fail the test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'Promise被reject'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Mocha能够捕获<code>reject</code>的Promise。</p>\n<p>因此，使用Mocha时，Promise的测试可以简化成下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should do something with promises'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = asyncTest();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    expect(data).to.equal(<span class=\"string\">'foobar'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模拟数据\"><a href=\"#模拟数据\" class=\"headerlink\" title=\"模拟数据\"></a>模拟数据</h2><p>单元测试时，很多时候，测试的代码会请求HTTP服务器。这时，我们就需要模拟服务器的回应，不能在单元测试时去请求真实服务器数据，否则就不叫单元测试了，而是连同服务器一起测试了。</p>\n<p>一些工具库可以模拟服务器回应。</p>\n<ul>\n<li><a href=\"https://github.com/pgte/nock\" target=\"_blank\" rel=\"noopener\">nock</a></li>\n<li><a href=\"http://sinonjs.org/docs/#server\" target=\"_blank\" rel=\"noopener\">sinon</a></li>\n<li><a href=\"https://github.com/algolia/faux-jax\" target=\"_blank\" rel=\"noopener\">faux-jax</a></li>\n<li><a href=\"https://github.com/moll/node-mitm\" target=\"_blank\" rel=\"noopener\">MITM</a></li>\n</ul>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的覆盖率需要安装istanbul模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D istanbul</span><br></pre></td></tr></table></figure>\n\n<p>然后，在package.json设置运行覆盖率检查的命令。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js\",</span><br><span class=\"line\">  \"check-coverage\": \"istanbul check-coverage --statements 100 --branches 100 --functions 100 --lines 100\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>test:cover</code>是生成覆盖率报告，<code>check-coverage</code>是设置覆盖率通过的门槛。</p>\n<p>然后，将<code>coverage</code>目录写入<code>.gitignore</code>防止连这个目录一起提交。</p>\n<p>如果希望在<code>git commit</code>提交之前，先运行一次测试，可以安装ghooks模块，配置<code>pre-commit</code>钩子。</p>\n<p>安装ghooks。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D ghooks</span><br></pre></td></tr></table></figure>\n\n<p>在package.json之中，配置<code>pre-commit</code>钩子。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"config\": &#123;</span><br><span class=\"line\">  \"ghooks\": &#123;</span><br><span class=\"line\">    \"pre-commit\": \"npm run test:cover &amp;&amp; npm run check-coverage\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以把覆盖率检查，加入<code>.travis.yml</code>文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">test:cover</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">check-coverage</span></span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本使用ES6，<code>scripts</code>字段还需要加入Babel转码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"mocha src/index.test.js -w --compilers js:babel/register\",</span><br><span class=\"line\">  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js --compilers js:babel/register\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>覆盖率报告可以上传到<a href=\"https://codecov.io/\" target=\"_blank\" rel=\"noopener\">codecov.io</a>。先安装这个模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D codecov.io</span><br></pre></td></tr></table></figure>\n\n<p>然后在package.json增加一个字段。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"report-coverage\": \"cat ./coverage/lcov.info | codecov\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在CI的配置文件<code>.travis.yml</code>之中，增加运行这个命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">after_success:</span><br><span class=\"line\">  - npm run report-coverage</span><br><span class=\"line\">  - npm run semantic-release</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"WebDriver\"><a href=\"#WebDriver\" class=\"headerlink\" title=\"WebDriver\"></a>WebDriver</h2><p>WebDriver是一个浏览器的自动化框架。它在各种浏览器的基础上，提供一个统一接口，将接收到的指令转为浏览器的原生指令，驱动浏览器。</p>\n<p>WebDriver由Selenium项目演变而来。Selenium是一个测试自动化框架，它的1.0版叫做Selenium RC，通过一个代理服务器，将测试脚本转为JavaScript脚本，注入不同的浏览器，再由浏览器执行这些脚本后返回结果。WebDriver就是Selenium 2.0，它对每个浏览器提供一个驱动，测试脚本通过驱动转换为浏览器原生命令，在浏览器中执行。</p>\n<h3 id=\"定制测试环境\"><a href=\"#定制测试环境\" class=\"headerlink\" title=\"定制测试环境\"></a>定制测试环境</h3><p>DesiredCapabilities对象用于定制测试环境。</p>\n<ul>\n<li>定制DesiredCapabilities对象的各个属性</li>\n<li>创建DesiredCapabilities实例</li>\n<li>将DesiredCapabilities实例作为参数，新建一个WebDriver实例</li>\n</ul>\n<h3 id=\"操作浏览器的方法\"><a href=\"#操作浏览器的方法\" class=\"headerlink\" title=\"操作浏览器的方法\"></a>操作浏览器的方法</h3><p>WebDriver提供以下方法操作浏览器。</p>\n<p>close()：退出或关闭当前浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.close();</span><br></pre></td></tr></table></figure>\n\n<p>quit()：关闭所有浏览器窗口，中止当前浏览器driver和session。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.quit();</span><br></pre></td></tr></table></figure>\n\n<p>getTitle()：返回当前网页的标题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.getTitle();</span><br></pre></td></tr></table></figure>\n\n<p>getCurrentUrl()：返回当前网页的网址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.getCurrentUrl();</span><br></pre></td></tr></table></figure>\n\n<p>getPageSource()：返回当前网页的源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 断言是否含有指定文本</span></span><br><span class=\"line\">assert(driver.getPageSource().contains(<span class=\"string\">\"Hello World\"</span>),</span><br><span class=\"line\">  <span class=\"string\">\"预期含有文本Hello World\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>click()：模拟鼠标点击。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webDriver\"</span>);</span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"sblsbb\"</span>))</span><br><span class=\"line\">  .click();</span><br></pre></td></tr></table></figure>\n\n<p>clear()：清空文本输入框。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).clear();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webDriver\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .clear();</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"testing\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>sendKeys()：在文本输入框输入文本。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"your text\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>submit()：提交表单，或者用来模拟按下回车键。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .submit();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webdriver\"</span>);</span><br><span class=\"line\">element.submit();</span><br></pre></td></tr></table></figure>\n\n<p>findElement()：返回选中的第一个元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"lst-ib\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>findElements()：返回选中的所有元素（0个或多个）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"searchbox\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webdriver\"</span>);</span><br><span class=\"line\">driver.findElements(By.xpath(<span class=\"string\">\"//div[3]/ul/li\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.findElements(By.tagName(<span class=\"string\">\"select\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .findElements(By.tagName(<span class=\"string\">\"option\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">3</span>)</span><br><span class=\"line\">  .click()</span><br><span class=\"line\">  .get(<span class=\"number\">4</span>)</span><br><span class=\"line\">  .click()</span><br><span class=\"line\">  .get(<span class=\"number\">5</span>)</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三：获取页面所有链接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> links = driver</span><br><span class=\"line\">  .get(<span class=\"string\">\"https://www.google.com\"</span>)</span><br><span class=\"line\">  .findElements(By.tagName(<span class=\"string\">\"a\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> linkSize = links.size();</span><br><span class=\"line\"><span class=\"keyword\">var</span> linksSrc = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(linkSize);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;linkSize;i++) &#123;</span><br><span class=\"line\">  linksSrc[i] = links.get(i).getAttribute(<span class=\"string\">\"href\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>;i&lt;linkSize;i++)&#123;</span><br><span class=\"line\">  driver.navigate().to(linksSrc[i]);</span><br><span class=\"line\">  Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用<code>size()</code>，查看到底选中了多少个元素。</p>\n<h3 id=\"网页元素的定位\"><a href=\"#网页元素的定位\" class=\"headerlink\" title=\"网页元素的定位\"></a>网页元素的定位</h3><p>WebDriver提供8种定位器，用于定位网页元素。</p>\n<ul>\n<li>By.id：HTML元素的id属性</li>\n<li>By.name：HTML元素的name属性</li>\n<li>By.xpath：使用XPath语法选中HTML元素</li>\n<li>By.cssSelector：使用CSS选择器语法</li>\n<li>By.className：HTML元素的class属性</li>\n<li>By.linkText：链接文本（只用于选中链接）</li>\n<li>By.tagName：HTML元素的标签名</li>\n<li>By.partialLinkText：部分链接文本（只用于选中链接）</li>\n</ul>\n<p>下面是一个使用id定位器，选中网页元素的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"sblsbb\"</span>)).click();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"网页元素的方法\"><a href=\"#网页元素的方法\" class=\"headerlink\" title=\"网页元素的方法\"></a>网页元素的方法</h3><p>以下方法属于网页元素的方法，而不是webDriver实例的方法。需要注意的是，有些方法是某些元素特有的，比如只有文本框才能输入文字。如果在网页元素上调用不支持的方法，WebDriver不会报错，也不会给出给出任何提示，只会静静地忽略。</p>\n<p>getAttribute()：返回网页元素指定属性的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//div[@id='lst-ib']\"</span>))</span><br><span class=\"line\">  .getAttribute(<span class=\"string\">\"class\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>getText()：返回网页元素的内部文本。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).getText();</span><br></pre></td></tr></table></figure>\n\n<p>getTagName()：返回指定元素的标签名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//div[@class='sbib_b']\"</span>))</span><br><span class=\"line\">  .getTagName();</span><br></pre></td></tr></table></figure>\n\n<p>isDisplayed()：返回一个布尔值，表示元素是否可见。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">assert(driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .isDisplayed(),</span><br><span class=\"line\">  <span class=\"string\">'搜索框应该可选择'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>isEnabled()：返回一个布尔值，表示文本框是否可编辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Element = driver.findElement(By.name(<span class=\"string\">\"q\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (Element.isEnabled()) &#123;</span><br><span class=\"line\">  driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">    .sendKeys(<span class=\"string\">\"Selenium Essentials\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isSelected()：返回一个布尔值，表示一个元素是否可选择。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//select[@name='jump']/option[1]\"</span>))</span><br><span class=\"line\">  .isSelected()</span><br></pre></td></tr></table></figure>\n\n<p>getSize()：返回一个网页元素的宽度和高度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dimensions=driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .getSize(); </span><br><span class=\"line\">dimensions.width;</span><br><span class=\"line\">dimensions.height;</span><br></pre></td></tr></table></figure>\n\n<p>getLocation()：返回网页元素左上角的x坐标和y坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).getLocation();</span><br><span class=\"line\">point.x; <span class=\"comment\">// 等同于 point.getX();</span></span><br><span class=\"line\">point.y; <span class=\"comment\">// 等同于 point.getY();</span></span><br></pre></td></tr></table></figure>\n\n<p>getCssValue()：返回网页元素指定的CSS属性的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> element = driver.findElement(By.xpath(<span class=\"string\">\"//div[@id='hplogo']\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"font-size\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"font-weight\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"color\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"background-size\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页面跳转的方法\"><a href=\"#页面跳转的方法\" class=\"headerlink\" title=\"页面跳转的方法\"></a>页面跳转的方法</h3><p>以下方法用来跳转到某一个页面。</p>\n<p>get()：要求浏览器跳到某个网址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"URL\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>navigate().back()：浏览器回退。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().back();</span><br></pre></td></tr></table></figure>\n\n<p>navigate().forward()：浏览器前进。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().forward();</span><br></pre></td></tr></table></figure>\n\n<p>navigate().to()：跳转到浏览器历史中的某个页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().to(<span class=\"string\">\"URL\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>navigate().refresh()：刷新当前页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().refresh();</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">driver.navigate()</span><br><span class=\"line\">  .to(driver.getCurrentUrl());</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .sendKeys(Keys.F5);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"cookie的方法\"><a href=\"#cookie的方法\" class=\"headerlink\" title=\"cookie的方法\"></a>cookie的方法</h3><p>getCookies()：获取cookie</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.manage().getCookies();</span><br></pre></td></tr></table></figure>\n\n<p>getCookieNamed() ：返回指定名称的cookie。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driver.manage().getCookieNamed(<span class=\"string\">\"NID\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>addCookie()：将cookie加入当前页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.manage().addCookie(cookie0);</span><br></pre></td></tr></table></figure>\n\n<p>deleteCookie()：删除指定的cookie。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.co.in\"</span>);</span><br><span class=\"line\">driver.manage().deleteCookieNamed(<span class=\"string\">\"NID\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"浏览器窗口的方法\"><a href=\"#浏览器窗口的方法\" class=\"headerlink\" title=\"浏览器窗口的方法\"></a>浏览器窗口的方法</h3><p>maximize()：最大化浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> driver = <span class=\"keyword\">new</span> FirefoxDriver();</span><br><span class=\"line\">driver.manage().window().maximize();</span><br></pre></td></tr></table></figure>\n\n<p>getSize()：返回浏览器窗口、图像、网页元素的宽和高。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.manage().window().getSize();</span><br></pre></td></tr></table></figure>\n\n<p>getPosition()：返回浏览器窗口左上角的x坐标和y坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position X: \"</span> + driver.manage().window().getPosition().x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position Y: \"</span> + driver.manage().window().getPosition().y);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position X: \"</span> + driver.manage().window().getPosition().getX());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position Y: \"</span> + driver.manage().window().getPosition().getY());</span><br></pre></td></tr></table></figure>\n\n<p>setSize()：定制浏览器窗口的大小。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> Dimension(<span class=\"number\">320</span>, <span class=\"number\">480</span>);</span><br><span class=\"line\">driver.manage().window().setSize(d);</span><br><span class=\"line\">driver.manage().window().setSize(<span class=\"keyword\">new</span> Dimension(<span class=\"number\">320</span>, <span class=\"number\">480</span>));</span><br></pre></td></tr></table></figure>\n\n<p>setPosition()：移动浏览器左上角到指定位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">driver.manage().window().setPosition(p);</span><br><span class=\"line\">driver.manage().window().setPosition(<span class=\"keyword\">new</span> Point(<span class=\"number\">300</span>, <span class=\"number\">150</span>));</span><br></pre></td></tr></table></figure>\n\n<p>getWindowHandle()：返回当前浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentwindow = driver.getWindowHandle();</span><br><span class=\"line\">driver.switchTo().window(parentwindow);</span><br></pre></td></tr></table></figure>\n\n<p>getWindowHandles()：返回所有浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> childwindows =  driver.getWindowHandles();</span><br><span class=\"line\">driver.switchTo().window(childwindow);</span><br></pre></td></tr></table></figure>\n\n<p>switchTo.window()：在浏览器窗口之间切换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.SwitchTo().Window(childwindow);</span><br><span class=\"line\">driver.close();</span><br><span class=\"line\">driver.SwitchTo().Window(parentWindow);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"弹出窗口\"><a href=\"#弹出窗口\" class=\"headerlink\" title=\"弹出窗口\"></a>弹出窗口</h3><p>以下方法处理浏览器的弹出窗口。</p>\n<p>dismiss() ：关闭弹出窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.dismiss();</span><br></pre></td></tr></table></figure>\n\n<p>accept()：接受弹出窗口，相当于按下接受OK按钮。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.accept();</span><br></pre></td></tr></table></figure>\n\n<p>getText()：返回弹出窗口的文本值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.getText();</span><br></pre></td></tr></table></figure>\n\n<p>sendKeys()：向弹出窗口发送文本字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.sendKeys(<span class=\"string\">\"Text to be passed\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>authenticateUsing()：处理HTTP认证。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> UserAndPassword(<span class=\"string\">\"USERNAME\"</span>, <span class=\"string\">\"PASSWORD\"</span>);</span><br><span class=\"line\">alert.authenticateUsing(user);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"鼠标和键盘的方法\"><a href=\"#鼠标和键盘的方法\" class=\"headerlink\" title=\"鼠标和键盘的方法\"></a>鼠标和键盘的方法</h3><p>以下方法模拟鼠标和键盘的动作。</p>\n<ul>\n<li>click()：鼠标在当前位置点击。</li>\n<li>clickAndHold()：按下鼠标不放</li>\n<li>contextClick()：右击鼠标</li>\n<li>doubleClick()：双击鼠标</li>\n<li>dragAndDrop()：鼠标拖放到目标元素</li>\n<li>dragAndDropBy()：鼠标拖放到目标坐标</li>\n<li>keyDown()：按下某个键</li>\n<li>keyUp()：从按下状态释放某个键</li>\n<li>moveByOffset()：移动鼠标到另一个坐标位置</li>\n<li>moveToElement()：移动鼠标到另一个网页元素</li>\n<li>release()：释放拖拉的元素</li>\n<li>sendKeys()：控制键盘输出</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>Jani Hartikainen, <a href=\"http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/\" target=\"_blank\" rel=\"noopener\">http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/</a></li>\n</ul>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>来源：<a href=\"https://javascript.ruanyifeng.com/tool/testing.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n<h2 id=\"为什么要写测试？\"><a href=\"#为什么要写测试？\" class=\"headerlink\" title=\"为什么要写测试？\"></a>为什么要写测试？</h2><p>Web应用程序越来越复杂，这意味着有更多的可能出错。测试是帮助我们提高代码质量、降低错误的最好方法和工具之一。</p>\n<ul>\n<li>测试可以确保得到预期结果。</li>\n<li>加快开发速度。</li>\n<li>方便维护。</li>\n<li>提供用法的文档。</li>\n</ul>\n<p>通过测试提供软件的质量，在开始的时候，可能会降低开发速度。但是从长期看，尤其是那种代码需要长期维护、不断开发的情况，测试会大大加快开发速度，减轻维护难度。</p>\n<h2 id=\"测试的类型\"><a href=\"#测试的类型\" class=\"headerlink\" title=\"测试的类型\"></a>测试的类型</h2><h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>单元测试（unit testing）指的是以软件的单元（unit）为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或组件。它的基本特征就是，只要输入不变，必定返回同样的输出。</p>\n<p>“单元测试”这个词，本身就暗示，软件应该以模块化结构存在。每个模块的运作，是独立于其他模块的。一个软件越容易写单元测试，往往暗示着它的模块化结构越好，各模块之间的耦合就越弱；越难写单元测试，或者每次单元测试，不得不模拟大量的外部条件，很可能暗示软件的模块化结构越差，模块之间存在较强的耦合。</p>\n<p>单元测试的要求是，每个模块都必须有单元测试，而软件由模块组成。</p>\n<p>单元测试通常采取断言（assertion）的形式，也就是测试某个功能的返回结果，是否与预期结果一致。如果与预期不一致，就表示测试失败。</p>\n<p>单元测试是函数正常工作、不出错的最基本、最有效的方法之一。 每一个单元测试发出一个特定的输入到所要测试的函数，看看函数是否返回预期的输出，或者采取了预期的行动。单元测试证明了所测试的代码行为符合预期。</p>\n<p>单元测试有助于代码的模块化，因此有助于长期的重用。因为有了测试，你就知道代码是可靠的，可以按照预期运行。从这个角度说，测试可以节省开发时间。单元测试的另一个好处是，有了测试，就等于就有了代码功能的文档，有助于其他开发者了解代码的意图。</p>\n<p>单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。</p>\n<p>一般来说，单元测试的步骤如下。</p>\n<ul>\n<li>准备所有的测试条件</li>\n<li>调用（触发）所要测试的函数</li>\n<li>验证运行结果是否正确</li>\n<li>还原被修改的记录</li>\n</ul>\n<h3 id=\"其他测试类型\"><a href=\"#其他测试类型\" class=\"headerlink\" title=\"其他测试类型\"></a>其他测试类型</h3><p>（1）集成测试</p>\n<p>集成测试（Integration test）指的是多个部分在一起测试，比如测试一个数据库连接模块，是否能够连接数据库。</p>\n<p>（2）功能测试</p>\n<p>功能测试（Functional test）指的是，自动测试整个应用程序的某个功能，比如使用Selenium工具自动打开浏览器运行程序。</p>\n<p>（3）端对端测试</p>\n<p>端对端测试（End-to-End testing）指的是全链路测试，即从开始端到终止端的测试，比如测试从用户界面、通过网络、经过应用程序处理、到达数据库，是否能够返回正确结果。端对端测试的目的是，确保整个系统能够正常运行，各个子系统之间依赖关系正常，数据能够在子系统之间、模块之间正确传递。</p>\n<p>（4）冒烟测试</p>\n<p>冒烟测试（smoke testing）指的是，正式的全面测试开始之前，对主要功能进行的预测试。它的主要目的是，确认主要功能能否满足需要，软件是否能运行。冒烟测试可以是手工测试，也可以是自动化测试。</p>\n<p>这个名字最早来自对电子元件的测试，第一次对电子元件通电，看看它是否会冒烟。如果没有冒烟，说明通过了测试；如果电流达到某个临界点之后，才出现冒烟，这时可以评估是否能够接受这个临界点。</p>\n<h2 id=\"开发模式\"><a href=\"#开发模式\" class=\"headerlink\" title=\"开发模式\"></a>开发模式</h2><p>测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。</p>\n<h3 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h3><p>TDD是“测试驱动的开发”（Test-Driven Development）的简称，指的是先写好测试，然后再根据测试完成开发。使用这种开发方式，会有很高的测试覆盖率。</p>\n<p>TDD的开发步骤如下。</p>\n<ul>\n<li>先写一个测试。</li>\n<li>写出最小数量的代码，使其能够通过测试。</li>\n<li>优化代码。</li>\n<li>重复前面三步。</li>\n</ul>\n<p>TDD开发的测试覆盖率通常在90%以上，这意味着维护代码和新增特性会非常容易。因为测试保证了你可以信任这些代码，修改它们不会破坏其他代码的运行。</p>\n<p>TDD接口提供以下四个方法。</p>\n<ul>\n<li>suite()</li>\n<li>test()</li>\n<li>setup()</li>\n<li>teardown()</li>\n</ul>\n<p>下面代码是测试计数器是否加1。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suite(<span class=\"string\">'Counter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  test(<span class=\"string\">'tick increases count to 1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">    counter.tick();</span><br><span class=\"line\">    assert.equal(counter.count, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BDD\"><a href=\"#BDD\" class=\"headerlink\" title=\"BDD\"></a>BDD</h3><p>BDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。</p>\n<p>BDD认为，<strong>不应该针对代码的实现细节写测试，而是要针对行为写测试</strong>。BDD测试的是行为，即软件应该怎样运行。</p>\n<p>BDD接口提供以下六个方法。</p>\n<ul>\n<li>describe()</li>\n<li>it()</li>\n<li>before()</li>\n<li>after()</li>\n<li>beforeEach()</li>\n<li>afterEach()</li>\n</ul>\n<p>下面是测试计数器是否加1的BDD写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Counter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'should increase count by 1 after calling tick'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> expectedCount = counter.count + <span class=\"number\">1</span>;</span><br><span class=\"line\">    counter.tick();</span><br><span class=\"line\">    assert.equal(counter.count, expectedCount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个BDD开发的示例。现在，需要开发一个<code>Foo</code>类，该类的实例有一个<code>sayHi</code>方法，会对类参数说“Hi”。这就是<code>Foo</code>类的规格，根据这个规格，我们可以写出测试用例文件<code>foo.spec.js</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Simple object'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo(<span class=\"string\">'John'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'should say hi'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(foo.sayHi()).toEqual(<span class=\"string\">'John says hi!'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有了测试用例以后，我们再写出实际的脚本文件<code>foo.js</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' says hi!'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>为了把测试用例与脚本文件分开，我们通常把测试用例放在<code>test</code>子目录之中。然后，我们就可以使用Mocha、Jasmine等测试框架，执行测试用例，看看脚本文件是否通过测试。</p>\n<h3 id=\"BDD术语\"><a href=\"#BDD术语\" class=\"headerlink\" title=\"BDD术语\"></a>BDD术语</h3><p>（1）测试套件</p>\n<p>测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。</p>\n<p>测试套件由一个<code>describe</code>函数构成，它接受两个参数：第一个参数是字符串，表示测试套件的名字或标题，表示将要测试什么；第二个参数是函数，用来实现这个测试套件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（2）测试用例</p>\n<p>测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。测试用例由<code>it</code>函数构成，它与<code>describe</code>函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"contains spec with an expectation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（3）断言</p>\n<p>断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。</p>\n<p>断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为<code>true</code>，测试用例才会通过。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"A suite\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"contains spec with an expectation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(<span class=\"literal\">true</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>断言是判断实际值与预期值是否相等的工具。</p>\n<p>断言有assert、expect、should三种风格，或者称为三种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assert风格</span></span><br><span class=\"line\">assert.equal(event.detail.item, <span class=\"string\">'(item)‘);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// expect风格</span></span><br><span class=\"line\"><span class=\"string\">expect(event.detail.item).to.equal('</span>(item)<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// should风格</span></span><br><span class=\"line\"><span class=\"string\">event.detail.item.should.equal('</span>(item)<span class=\"string\">');</span></span><br></pre></td></tr></table></figure>\n\n<p>Chai.js是一个很流行的断言库，同时支持上面三种风格。</p>\n<p>（1） assert风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).assert;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">assert.typeOf(foo, <span class=\"string\">'string'</span>, <span class=\"string\">'foo is a string'</span>);</span><br><span class=\"line\">assert.equal(foo, <span class=\"string\">'bar'</span>, <span class=\"string\">'foo equal `bar`'</span>);</span><br><span class=\"line\">assert.lengthOf(foo, <span class=\"number\">3</span>, <span class=\"string\">'foo`s value has a length of 3'</span>);</span><br><span class=\"line\">assert.lengthOf(beverages.tea, <span class=\"number\">3</span>, <span class=\"string\">'beverages has 3 types of tea'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，assert方法的最后一个参数是错误提示信息，只有测试没有通过时，才会显示。</p>\n<p>（2）expect风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">expect(foo).to.be.a(<span class=\"string\">'string'</span>);</span><br><span class=\"line\">expect(foo).to.equal(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">expect(foo).to.have.length(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(beverages).to.have.property(<span class=\"string\">'tea'</span>).with.length(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（3）should风格</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).should();</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> beverages = &#123; <span class=\"attr\">tea</span>: [ <span class=\"string\">'chai'</span>, <span class=\"string\">'matcha'</span>, <span class=\"string\">'oolong'</span> ] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.should.be.a(<span class=\"string\">'string'</span>);</span><br><span class=\"line\">foo.should.equal(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">foo.should.have.length(<span class=\"number\">3</span>);</span><br><span class=\"line\">beverages.should.have.property(<span class=\"string\">'tea'</span>).with.length(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mocha-js\"><a href=\"#Mocha-js\" class=\"headerlink\" title=\"Mocha.js\"></a>Mocha.js</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Mocha（发音“摩卡”）是现在最流行的前端测试框架之一，此外常用的测试框架还有<a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>、<a href=\"https://github.com/substack/tape/\" target=\"_blank\" rel=\"noopener\">Tape</a>、<a href=\"https://github.com/defunctzombie/zuul/\" target=\"_blank\" rel=\"noopener\">zuul</a>等。所谓“测试框架”，就是运行测试的工具。</p>\n<p>Mocha使用下面的命令安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 全局安装</span><br><span class=\"line\">$ npm install -g mocha chai</span><br><span class=\"line\"></span><br><span class=\"line\"># 项目内安装</span><br><span class=\"line\">$ npm i -D mocha chai</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，除了安装Mocha以外，还安装了断言库<code>chai</code>，这是因为Mocha自身不带断言库，必须安装外部断言库。</p>\n<p>测试套件文件一般放在<code>test</code>子目录下面，配置文件<code>mocha.opts</code>也放在这个目录里面。</p>\n<h3 id=\"浏览器测试\"><a href=\"#浏览器测试\" class=\"headerlink\" title=\"浏览器测试\"></a>浏览器测试</h3><p>使用浏览器测试时，先用<code>mocha init</code>命令在指定目录生成初始化文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha init &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面命令，就会在该目录下生成一个<code>index.html</code>文件，以及配套的脚本和样式表。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Unit.js tests <span class=\"keyword\">in</span> the browser <span class=\"keyword\">with</span> Mocha&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;meta http-equiv=\"Content-Type\" content=\"text/</span>html; charset=UTF<span class=\"number\">-8</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;meta name=\"</span>viewport<span class=\"string\">\" content=\"</span>width=device-width, initial-scale=<span class=\"number\">1.0</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>mocha.css<span class=\"string\">\" /&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h1&gt;Unit.js tests in the browser with Mocha&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=\"</span>mocha<span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>mocha.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      mocha.setup('bdd');</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>tests.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      mocha.run();</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在该文件中，加入你要测试的文件（比如<code>app.js</code>）、测试脚本（<code>app.spec.js</code>）和断言库（<code>chai.js</code>）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"http:/</span><span class=\"regexp\">/chaijs.com/</span>chai.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;script src=\"</span>app.spec.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>各个文件的内容如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.spec.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> expect = chai.expect;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'测试add函数'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'1加1应该等于2'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)).to.equal(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令行测试\"><a href=\"#命令行测试\" class=\"headerlink\" title=\"命令行测试\"></a>命令行测试</h3><p>Mocha除了在浏览器运行，还可以在命令行运行。</p>\n<p>还是使用上面的文件，作为例子，但是要改成CommonJS格式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.spec.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"built_in\">require</span>(<span class=\"string\">'../app'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'测试add函数'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'1加1应该等于2'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    expect(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)).to.equal(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后，在命令行下执行<code>mocha</code>，就会执行测试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令等同于下面的形式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span> --reporter spec --recursive --growl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mocha-opts\"><a href=\"#mocha-opts\" class=\"headerlink\" title=\"mocha.opts\"></a>mocha.opts</h3><p>所有Mocha的命令行参数，都可以写在<code>test</code>目录下的配置文件<code>mocha.opts</code>之中。</p>\n<p>下面是一个典型的配置文件。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">--reporter</span> <span class=\"string\">spec</span></span><br><span class=\"line\"><span class=\"attr\">--recursive</span></span><br><span class=\"line\"><span class=\"attr\">--growl</span></span><br></pre></td></tr></table></figure>\n\n<p>上面三个设置的含义如下。</p>\n<ul>\n<li>使用spec报告模板</li>\n<li>包括子目录</li>\n<li>打开桌面通知插件growl</li>\n</ul>\n<p>如果希望测试非存放于test子目录的测试用例，可以在<code>mocha.opts</code>写入以下内容。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server-tests</span></span><br><span class=\"line\"><span class=\"attr\">--recursive</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定运行<code>server-tests</code>目录及其子目录之中的测试脚本。</p>\n<h3 id=\"生成规格文件\"><a href=\"#生成规格文件\" class=\"headerlink\" title=\"生成规格文件\"></a>生成规格文件</h3><p>Mocha支持从测试用例生成规格文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/app.spec.js -R markdown &gt; spec.md</span><br></pre></td></tr></table></figure>\n\n<p>上面命令生成单个<code>app.spec.js</code>规格。</p>\n<p>生成HTML格式的报告，使用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/app.spec.js -R doc &gt; spec.html</span><br></pre></td></tr></table></figure>\n\n<p>如果要生成整个<code>test</code>目录，对应的规格文件，使用下面的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span> -R markdown &gt; spec.md --recursive</span><br></pre></td></tr></table></figure>\n\n<p>只要提供测试脚本的路径，Mocha就可以运行这个测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha -w src/index.test.js</span><br></pre></td></tr></table></figure>\n\n<p>上面命令运行测试脚本<code>src/index.test.js</code>，参数<code>-w</code>表示watch，即当这个脚本一有变动，就会运行。</p>\n<p>指定测试脚本时，可以使用通配符，同时指定多个文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --reporter spec spec/&#123;my,awesome&#125;.js</span><br><span class=\"line\">$ mocha --ui tdd <span class=\"built_in\">test</span>/unit/*.js etc</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，参数<code>--reporter</code>指定生成的报告格式（上面代码是spec格式），<code>-ui</code>指定采用哪一种测试模式（上面代码是tdd模式）。</p>\n<p>除了使用shell通配符，还可以使用node通配符。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel-core/register <span class=\"string\">'test/**/*.@(js|jsx)'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定运行<code>test</code>目录下面任何子目录中，文件后缀名为<code>js</code>或<code>jsx</code>的测试脚本。注意，Node的通配符要放在单引号之中，因为否则星号（<code>*</code>）会先被shell解释。</p>\n<p>如果要改用shell通配符，执行<code>test</code>目录下面任何子目录的测试脚本，要写成下面这样。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha <span class=\"built_in\">test</span>/**.js</span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本不止一个，最好将它们放在专门的目录当中。Mocha默认执行<code>test</code>目录的测试脚本，所以可以将所有测试脚本放在<code>test</code>子目录。<code>--recursive</code>参数可以指定运行子目录之中的测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --recursive</span><br></pre></td></tr></table></figure>\n\n<p>上面命令会运行<code>test</code>子目录之中的所有测试脚本。</p>\n<p><code>--grep</code>参数用于搜索测试用例的名称（即it方法的第一个参数），然后只执行匹配的测试用例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --reporter spec --grep <span class=\"string\">\"Fnord:\"</span> server-test/*.js</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只测试名称中包含“Fnord：”的测试用例。</p>\n<p><code>--invert</code>参数表示只运行不符合条件的测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --grep auth --invert</span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本用到了ES6语法，还需要用<code>--compiler</code>参数指定babel进行转码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel/register --recursive</span><br></pre></td></tr></table></figure>\n\n<p>上面命令会在运行测试脚本之前，先用Babel进行转码。<code>--compilers</code>参数的值是用冒号分隔的一个字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用<code>babel/register</code>模块，处理一下JS文件。</p>\n<p><code>--require</code>参数指定测试脚本默认包含的文件。下面是一个<code>test_helper.js</code>文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test/test_helper.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> chai <span class=\"keyword\">from</span> <span class=\"string\">'chai'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>--require</code>参数，将上面这个脚本包含进所有测试脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha --compilers js:babel/register --require ./<span class=\"built_in\">test</span>/test_helper.js  --recursive</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试脚本的写法\"><a href=\"#测试脚本的写法\" class=\"headerlink\" title=\"测试脚本的写法\"></a>测试脚本的写法</h3><p>测试脚本中，describe方法和it方法都允许调用only方法，表示只运行某个测试套件或测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">describe(<span class=\"string\">'Array'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  describe.only(<span class=\"string\">'#indexOf()'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">describe(<span class=\"string\">\"using only\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it.only(<span class=\"string\">\"this is the only test to be run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">\"this is not run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只有带有<code>only</code>方法的测试套件或测试用例会运行。</p>\n<p>describe方法和it方法还可以调用skip方法，表示跳过指定的测试套件或测试用例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">describe.skip(<span class=\"string\">'Article'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">describe(<span class=\"string\">\"using only\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it.skip(<span class=\"string\">\"this is the only test to be run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">\"this is not run\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，带有<code>skip</code>方法的测试套件或测试用例会被忽略。</p>\n<p>如果测试用例包含异步操作，可以done方法显式指定测试用例的运行结束时间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'logs a'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'logs a'</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  setTimeout(f, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，正常情况下，函数f还没有执行，Mocha就已经结束运行了。为了保证Mocha等到测试用例跑完再结束运行，可以手动调用done方法</p>\n<h2 id=\"Promise的测试\"><a href=\"#Promise的测试\" class=\"headerlink\" title=\"Promise的测试\"></a>Promise的测试</h2><p>对于异步的测试，测试用例之中，通常必须调用<code>done</code>方法，显式表明异步操作的结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should do something with promises'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = asyncTest();</span><br><span class=\"line\"></span><br><span class=\"line\">  result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    expect(data).to.equal(<span class=\"string\">'foobar'</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    assert.fail(error);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，Promise对象的<code>then</code>方法之中，必须指定<code>reject</code>时的回调函数，并且使用<code>assert.fail</code>方法抛出错误，否则这个错误就不会被外界感知。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  expect(data).to.equal(blah);</span><br><span class=\"line\">  done();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，如果Promise被<code>reject</code>，是不会被捕获的，因为Promise之中的错误，不会”泄漏“到外界。</p>\n<p>Mocha内置了对Promise的支持。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'should fail the test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'Promise被reject'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Mocha能够捕获<code>reject</code>的Promise。</p>\n<p>因此，使用Mocha时，Promise的测试可以简化成下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'chai'</span>).expect;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should do something with promises'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = asyncTest();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    expect(data).to.equal(<span class=\"string\">'foobar'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模拟数据\"><a href=\"#模拟数据\" class=\"headerlink\" title=\"模拟数据\"></a>模拟数据</h2><p>单元测试时，很多时候，测试的代码会请求HTTP服务器。这时，我们就需要模拟服务器的回应，不能在单元测试时去请求真实服务器数据，否则就不叫单元测试了，而是连同服务器一起测试了。</p>\n<p>一些工具库可以模拟服务器回应。</p>\n<ul>\n<li><a href=\"https://github.com/pgte/nock\" target=\"_blank\" rel=\"noopener\">nock</a></li>\n<li><a href=\"http://sinonjs.org/docs/#server\" target=\"_blank\" rel=\"noopener\">sinon</a></li>\n<li><a href=\"https://github.com/algolia/faux-jax\" target=\"_blank\" rel=\"noopener\">faux-jax</a></li>\n<li><a href=\"https://github.com/moll/node-mitm\" target=\"_blank\" rel=\"noopener\">MITM</a></li>\n</ul>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的覆盖率需要安装istanbul模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D istanbul</span><br></pre></td></tr></table></figure>\n\n<p>然后，在package.json设置运行覆盖率检查的命令。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js\",</span><br><span class=\"line\">  \"check-coverage\": \"istanbul check-coverage --statements 100 --branches 100 --functions 100 --lines 100\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>test:cover</code>是生成覆盖率报告，<code>check-coverage</code>是设置覆盖率通过的门槛。</p>\n<p>然后，将<code>coverage</code>目录写入<code>.gitignore</code>防止连这个目录一起提交。</p>\n<p>如果希望在<code>git commit</code>提交之前，先运行一次测试，可以安装ghooks模块，配置<code>pre-commit</code>钩子。</p>\n<p>安装ghooks。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D ghooks</span><br></pre></td></tr></table></figure>\n\n<p>在package.json之中，配置<code>pre-commit</code>钩子。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"config\": &#123;</span><br><span class=\"line\">  \"ghooks\": &#123;</span><br><span class=\"line\">    \"pre-commit\": \"npm run test:cover &amp;&amp; npm run check-coverage\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以把覆盖率检查，加入<code>.travis.yml</code>文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">test:cover</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">check-coverage</span></span><br></pre></td></tr></table></figure>\n\n<p>如果测试脚本使用ES6，<code>scripts</code>字段还需要加入Babel转码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"mocha src/index.test.js -w --compilers js:babel/register\",</span><br><span class=\"line\">  \"test:cover\": \"istanbul cover -x *.test.js _mocha -- -R spec src/index.test.js --compilers js:babel/register\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>覆盖率报告可以上传到<a href=\"https://codecov.io/\" target=\"_blank\" rel=\"noopener\">codecov.io</a>。先安装这个模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -D codecov.io</span><br></pre></td></tr></table></figure>\n\n<p>然后在package.json增加一个字段。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"report-coverage\": \"cat ./coverage/lcov.info | codecov\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在CI的配置文件<code>.travis.yml</code>之中，增加运行这个命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">after_success:</span><br><span class=\"line\">  - npm run report-coverage</span><br><span class=\"line\">  - npm run semantic-release</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"WebDriver\"><a href=\"#WebDriver\" class=\"headerlink\" title=\"WebDriver\"></a>WebDriver</h2><p>WebDriver是一个浏览器的自动化框架。它在各种浏览器的基础上，提供一个统一接口，将接收到的指令转为浏览器的原生指令，驱动浏览器。</p>\n<p>WebDriver由Selenium项目演变而来。Selenium是一个测试自动化框架，它的1.0版叫做Selenium RC，通过一个代理服务器，将测试脚本转为JavaScript脚本，注入不同的浏览器，再由浏览器执行这些脚本后返回结果。WebDriver就是Selenium 2.0，它对每个浏览器提供一个驱动，测试脚本通过驱动转换为浏览器原生命令，在浏览器中执行。</p>\n<h3 id=\"定制测试环境\"><a href=\"#定制测试环境\" class=\"headerlink\" title=\"定制测试环境\"></a>定制测试环境</h3><p>DesiredCapabilities对象用于定制测试环境。</p>\n<ul>\n<li>定制DesiredCapabilities对象的各个属性</li>\n<li>创建DesiredCapabilities实例</li>\n<li>将DesiredCapabilities实例作为参数，新建一个WebDriver实例</li>\n</ul>\n<h3 id=\"操作浏览器的方法\"><a href=\"#操作浏览器的方法\" class=\"headerlink\" title=\"操作浏览器的方法\"></a>操作浏览器的方法</h3><p>WebDriver提供以下方法操作浏览器。</p>\n<p>close()：退出或关闭当前浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.close();</span><br></pre></td></tr></table></figure>\n\n<p>quit()：关闭所有浏览器窗口，中止当前浏览器driver和session。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.quit();</span><br></pre></td></tr></table></figure>\n\n<p>getTitle()：返回当前网页的标题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.getTitle();</span><br></pre></td></tr></table></figure>\n\n<p>getCurrentUrl()：返回当前网页的网址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.getCurrentUrl();</span><br></pre></td></tr></table></figure>\n\n<p>getPageSource()：返回当前网页的源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 断言是否含有指定文本</span></span><br><span class=\"line\">assert(driver.getPageSource().contains(<span class=\"string\">\"Hello World\"</span>),</span><br><span class=\"line\">  <span class=\"string\">\"预期含有文本Hello World\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>click()：模拟鼠标点击。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webDriver\"</span>);</span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"sblsbb\"</span>))</span><br><span class=\"line\">  .click();</span><br></pre></td></tr></table></figure>\n\n<p>clear()：清空文本输入框。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).clear();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webDriver\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .clear();</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"testing\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>sendKeys()：在文本输入框输入文本。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"your text\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>submit()：提交表单，或者用来模拟按下回车键。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .submit();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webdriver\"</span>);</span><br><span class=\"line\">element.submit();</span><br></pre></td></tr></table></figure>\n\n<p>findElement()：返回选中的第一个元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"lst-ib\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>findElements()：返回选中的所有元素（0个或多个）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"searchbox\"</span>))</span><br><span class=\"line\">  .sendKeys(<span class=\"string\">\"webdriver\"</span>);</span><br><span class=\"line\">driver.findElements(By.xpath(<span class=\"string\">\"//div[3]/ul/li\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\">driver.findElements(By.tagName(<span class=\"string\">\"select\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .findElements(By.tagName(<span class=\"string\">\"option\"</span>))</span><br><span class=\"line\">  .get(<span class=\"number\">3</span>)</span><br><span class=\"line\">  .click()</span><br><span class=\"line\">  .get(<span class=\"number\">4</span>)</span><br><span class=\"line\">  .click()</span><br><span class=\"line\">  .get(<span class=\"number\">5</span>)</span><br><span class=\"line\">  .click();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三：获取页面所有链接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> links = driver</span><br><span class=\"line\">  .get(<span class=\"string\">\"https://www.google.com\"</span>)</span><br><span class=\"line\">  .findElements(By.tagName(<span class=\"string\">\"a\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> linkSize = links.size();</span><br><span class=\"line\"><span class=\"keyword\">var</span> linksSrc = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(linkSize);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;linkSize;i++) &#123;</span><br><span class=\"line\">  linksSrc[i] = links.get(i).getAttribute(<span class=\"string\">\"href\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>;i&lt;linkSize;i++)&#123;</span><br><span class=\"line\">  driver.navigate().to(linksSrc[i]);</span><br><span class=\"line\">  Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用<code>size()</code>，查看到底选中了多少个元素。</p>\n<h3 id=\"网页元素的定位\"><a href=\"#网页元素的定位\" class=\"headerlink\" title=\"网页元素的定位\"></a>网页元素的定位</h3><p>WebDriver提供8种定位器，用于定位网页元素。</p>\n<ul>\n<li>By.id：HTML元素的id属性</li>\n<li>By.name：HTML元素的name属性</li>\n<li>By.xpath：使用XPath语法选中HTML元素</li>\n<li>By.cssSelector：使用CSS选择器语法</li>\n<li>By.className：HTML元素的class属性</li>\n<li>By.linkText：链接文本（只用于选中链接）</li>\n<li>By.tagName：HTML元素的标签名</li>\n<li>By.partialLinkText：部分链接文本（只用于选中链接）</li>\n</ul>\n<p>下面是一个使用id定位器，选中网页元素的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.id(<span class=\"string\">\"sblsbb\"</span>)).click();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"网页元素的方法\"><a href=\"#网页元素的方法\" class=\"headerlink\" title=\"网页元素的方法\"></a>网页元素的方法</h3><p>以下方法属于网页元素的方法，而不是webDriver实例的方法。需要注意的是，有些方法是某些元素特有的，比如只有文本框才能输入文字。如果在网页元素上调用不支持的方法，WebDriver不会报错，也不会给出给出任何提示，只会静静地忽略。</p>\n<p>getAttribute()：返回网页元素指定属性的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//div[@id='lst-ib']\"</span>))</span><br><span class=\"line\">  .getAttribute(<span class=\"string\">\"class\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>getText()：返回网页元素的内部文本。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).getText();</span><br></pre></td></tr></table></figure>\n\n<p>getTagName()：返回指定元素的标签名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//div[@class='sbib_b']\"</span>))</span><br><span class=\"line\">  .getTagName();</span><br></pre></td></tr></table></figure>\n\n<p>isDisplayed()：返回一个布尔值，表示元素是否可见。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">assert(driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">  .isDisplayed(),</span><br><span class=\"line\">  <span class=\"string\">'搜索框应该可选择'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>isEnabled()：返回一个布尔值，表示文本框是否可编辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Element = driver.findElement(By.name(<span class=\"string\">\"q\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (Element.isEnabled()) &#123;</span><br><span class=\"line\">  driver.findElement(By.name(<span class=\"string\">\"q\"</span>))</span><br><span class=\"line\">    .sendKeys(<span class=\"string\">\"Selenium Essentials\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isSelected()：返回一个布尔值，表示一个元素是否可选择。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.findElement(By.xpath(<span class=\"string\">\"//select[@name='jump']/option[1]\"</span>))</span><br><span class=\"line\">  .isSelected()</span><br></pre></td></tr></table></figure>\n\n<p>getSize()：返回一个网页元素的宽度和高度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dimensions=driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .getSize(); </span><br><span class=\"line\">dimensions.width;</span><br><span class=\"line\">dimensions.height;</span><br></pre></td></tr></table></figure>\n\n<p>getLocation()：返回网页元素左上角的x坐标和y坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>)).getLocation();</span><br><span class=\"line\">point.x; <span class=\"comment\">// 等同于 point.getX();</span></span><br><span class=\"line\">point.y; <span class=\"comment\">// 等同于 point.getY();</span></span><br></pre></td></tr></table></figure>\n\n<p>getCssValue()：返回网页元素指定的CSS属性的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> element = driver.findElement(By.xpath(<span class=\"string\">\"//div[@id='hplogo']\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"font-size\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"font-weight\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"color\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element.getCssValue(<span class=\"string\">\"background-size\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页面跳转的方法\"><a href=\"#页面跳转的方法\" class=\"headerlink\" title=\"页面跳转的方法\"></a>页面跳转的方法</h3><p>以下方法用来跳转到某一个页面。</p>\n<p>get()：要求浏览器跳到某个网址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"URL\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>navigate().back()：浏览器回退。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().back();</span><br></pre></td></tr></table></figure>\n\n<p>navigate().forward()：浏览器前进。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().forward();</span><br></pre></td></tr></table></figure>\n\n<p>navigate().to()：跳转到浏览器历史中的某个页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().to(<span class=\"string\">\"URL\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>navigate().refresh()：刷新当前页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.navigate().refresh();</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">driver.navigate()</span><br><span class=\"line\">  .to(driver.getCurrentUrl());</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">driver.findElement(By.locatorType(<span class=\"string\">\"path\"</span>))</span><br><span class=\"line\">  .sendKeys(Keys.F5);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"cookie的方法\"><a href=\"#cookie的方法\" class=\"headerlink\" title=\"cookie的方法\"></a>cookie的方法</h3><p>getCookies()：获取cookie</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.manage().getCookies();</span><br></pre></td></tr></table></figure>\n\n<p>getCookieNamed() ：返回指定名称的cookie。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driver.manage().getCookieNamed(<span class=\"string\">\"NID\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>addCookie()：将cookie加入当前页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.com\"</span>);</span><br><span class=\"line\">driver.manage().addCookie(cookie0);</span><br></pre></td></tr></table></figure>\n\n<p>deleteCookie()：删除指定的cookie。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">\"https://www.google.co.in\"</span>);</span><br><span class=\"line\">driver.manage().deleteCookieNamed(<span class=\"string\">\"NID\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"浏览器窗口的方法\"><a href=\"#浏览器窗口的方法\" class=\"headerlink\" title=\"浏览器窗口的方法\"></a>浏览器窗口的方法</h3><p>maximize()：最大化浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> driver = <span class=\"keyword\">new</span> FirefoxDriver();</span><br><span class=\"line\">driver.manage().window().maximize();</span><br></pre></td></tr></table></figure>\n\n<p>getSize()：返回浏览器窗口、图像、网页元素的宽和高。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.manage().window().getSize();</span><br></pre></td></tr></table></figure>\n\n<p>getPosition()：返回浏览器窗口左上角的x坐标和y坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position X: \"</span> + driver.manage().window().getPosition().x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position Y: \"</span> + driver.manage().window().getPosition().y);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position X: \"</span> + driver.manage().window().getPosition().getX());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Position Y: \"</span> + driver.manage().window().getPosition().getY());</span><br></pre></td></tr></table></figure>\n\n<p>setSize()：定制浏览器窗口的大小。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> Dimension(<span class=\"number\">320</span>, <span class=\"number\">480</span>);</span><br><span class=\"line\">driver.manage().window().setSize(d);</span><br><span class=\"line\">driver.manage().window().setSize(<span class=\"keyword\">new</span> Dimension(<span class=\"number\">320</span>, <span class=\"number\">480</span>));</span><br></pre></td></tr></table></figure>\n\n<p>setPosition()：移动浏览器左上角到指定位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">driver.manage().window().setPosition(p);</span><br><span class=\"line\">driver.manage().window().setPosition(<span class=\"keyword\">new</span> Point(<span class=\"number\">300</span>, <span class=\"number\">150</span>));</span><br></pre></td></tr></table></figure>\n\n<p>getWindowHandle()：返回当前浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentwindow = driver.getWindowHandle();</span><br><span class=\"line\">driver.switchTo().window(parentwindow);</span><br></pre></td></tr></table></figure>\n\n<p>getWindowHandles()：返回所有浏览器窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> childwindows =  driver.getWindowHandles();</span><br><span class=\"line\">driver.switchTo().window(childwindow);</span><br></pre></td></tr></table></figure>\n\n<p>switchTo.window()：在浏览器窗口之间切换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.SwitchTo().Window(childwindow);</span><br><span class=\"line\">driver.close();</span><br><span class=\"line\">driver.SwitchTo().Window(parentWindow);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"弹出窗口\"><a href=\"#弹出窗口\" class=\"headerlink\" title=\"弹出窗口\"></a>弹出窗口</h3><p>以下方法处理浏览器的弹出窗口。</p>\n<p>dismiss() ：关闭弹出窗口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.dismiss();</span><br></pre></td></tr></table></figure>\n\n<p>accept()：接受弹出窗口，相当于按下接受OK按钮。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.accept();</span><br></pre></td></tr></table></figure>\n\n<p>getText()：返回弹出窗口的文本值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.getText();</span><br></pre></td></tr></table></figure>\n\n<p>sendKeys()：向弹出窗口发送文本字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> alert = driver.switchTo().alert();</span><br><span class=\"line\">alert.sendKeys(<span class=\"string\">\"Text to be passed\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>authenticateUsing()：处理HTTP认证。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> UserAndPassword(<span class=\"string\">\"USERNAME\"</span>, <span class=\"string\">\"PASSWORD\"</span>);</span><br><span class=\"line\">alert.authenticateUsing(user);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"鼠标和键盘的方法\"><a href=\"#鼠标和键盘的方法\" class=\"headerlink\" title=\"鼠标和键盘的方法\"></a>鼠标和键盘的方法</h3><p>以下方法模拟鼠标和键盘的动作。</p>\n<ul>\n<li>click()：鼠标在当前位置点击。</li>\n<li>clickAndHold()：按下鼠标不放</li>\n<li>contextClick()：右击鼠标</li>\n<li>doubleClick()：双击鼠标</li>\n<li>dragAndDrop()：鼠标拖放到目标元素</li>\n<li>dragAndDropBy()：鼠标拖放到目标坐标</li>\n<li>keyDown()：按下某个键</li>\n<li>keyUp()：从按下状态释放某个键</li>\n<li>moveByOffset()：移动鼠标到另一个坐标位置</li>\n<li>moveToElement()：移动鼠标到另一个网页元素</li>\n<li>release()：释放拖拉的元素</li>\n<li>sendKeys()：控制键盘输出</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>Jani Hartikainen, <a href=\"http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/\" target=\"_blank\" rel=\"noopener\">http://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/</a></li>\n</ul>\n"},{"title":"罗技MX Master 3简评","comments":1,"toc":true,"toc_number":false,"copyright":true,"mathjax":false,"katex":false,"hide":false,"date":"2020-03-29T07:08:21.000Z","description":"或许是最强无线商务鼠标？","cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200329014124.png","top_img":null,"keywords":null,"_content":"\n## 开箱\n\n我的MX Master第一代在搬家的时候丢失了，我一度很难过。难过倒不是因为它有多好用，还是因为它不便宜。之后我买了个罗技M535，随便用用，觉得手感不行，便将它扔一边积灰了。\n\n说起来还是因为平日里工作量变大，我是触摸板达人，但是触摸板在双屏之间划来划去实在是太累了，只好又把积灰的M535捡起来用。可惜这小鼠标的精确度实在太大了，用得我好多次想要砸鼠标。没办法，还是决定去买一只新鼠标。看来看去实在没什么可以买的了，最终还是选择了MX Master系列的第三代，就指望着它能有些改进。\n\n作为罗技MX Master第一代的用户，我对这款鼠标并没有什么好感。或许正是因为它在网上好评如潮，我才会更对它失望，因为它跟我的心理预期实在是差太多了。随便列几个我不喜欢第一代mx master的理由：\n\n1. 价格昂贵：原价99刀，我在打折期间60刀入手的，但是这个价格仍旧算是非常高昂，因为60刀的游戏鼠标操控性，定位和手感都远远强于MX Master\n2. 定位一般：作为一个CS:GO玩家，鼠标定位的精准与否，几乎是一上手便知。我之前常使用的鼠标是G703，一用MX Master立刻感觉到了手感和定位的降级。我明白它是商务鼠标，有其他侧重点，但是我仍然觉得这部分罗技缩水过多\n3. 机身笨重：假如你习惯抓握鼠标，那这款鼠标更是你的噩梦，它有足足145g。作为一款商务无线鼠标，它竟然完全不便携。可怕的是它不只是宽，它的背部也高高拱起，非常难以携带\n\n说完了它的缺点，我先暂时不提它的优点了，因为MX Master3几乎完美继承了它所有的优点。\n\n现在买到了MX Master 3，真的让我庆幸，还好我当时把那旧的MX Master丢了，要不然现在我绝对不会去买这只新的。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/8739F928-F1CC-4175-8215-F3D0171BAAE9_1_105_c.jpeg)\n\n我买的是灰白色的版本。拆开包装之后一共三个物品，一个是鼠标本体，一个是信号接收的USB头，最后是一根usb-c的充电器。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E8F71A26-CC1B-4F37-8993-2FD088766C34_1_105_c.jpeg)\n\n这里就要说到它的第一个优点：它是用type-c接口充电的。作为一个电子产品大户，我衷心希望所有的电子产品都统一接口，不要搞花里胡哨的玩意，不然插座上得插满不同种类的充电线。我上次买的打碟机还是mini-USB接口，让我瞬间以为回到初中。mini-USB接口的设备我都不知道埋了几年了，咋还能有厂商在用呢？\n\nMX Master 3本身是支持蓝牙连接的，也就是说无需USB头就能连上你的电脑。用USB头的话延迟更低，反应更灵敏。其实个人单纯认为这个是没多大意义的，有低延迟需求的人估计都是打游戏的，没人会用你打游戏啊兄弟。不过有总比没有强。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/A01C1E91-35FD-460A-98C7-80B1E8D07137_1_105_c.jpeg)\n\n鼠标背面贴了个简单的说明书，就是告诉你MX Master 3支持同时匹配三台设备。没用过的兄弟可能不了解，这只鼠标长按可以进行匹配电脑，然后短按可以切换连接的电脑。一般来说我们蓝牙只能连一台设备，想连接第二台的话需要重新匹配，第一台和鼠标的连接就会断开，想要再连回去的时候需要重新匹配。而这只鼠标则不需要，只需要在2号位3号位匹配其他机器就行了，要用的时候可以在机器之间切换来切换去。这也是从第一代就有的优点。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3A54E2AC-64EA-45FF-A6D6-75EB41D3D179_1_201_a.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/09683B04-976B-4EBC-992B-3BDAF1E147D2_1_102_o.jpeg)\n\n刚才也说过了，这只鼠标的体积很大，适合大手选手。这是它跟G703放在一起的时候的体积对比。\n\n罗技商务键鼠系列用的软件都是Logi Options，你从设置界面上就能看到所有的自定义按键\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%2012.54.15%20AM.png)\n\n这里我要介绍一下罗技的自定义按键了，重头戏是最左边那块扁平的按键，它是个向下按压的按键。在我们的日常使用中，你的大拇指会放在这个按键上。我们暂时称这个按键为按键A。它支持手势操作，你可以设置的鼠标宏有，按下A后的鼠标宏，和按下A以后上/下/左/右移动鼠标后引发的鼠标宏。\n\n这个按键在MX Master第一代中的体验并不是十分理想，其一是MX Master整体手感较重，其二是一代的A键比较重，大拇指按下去需要发点力，久而久之手就容易累。\n\n三代我整体使用下来觉得这个按键还行，主要还是因为你不再需要用力去按它了。当然，如你所见，A键是一片区域，所以我也不太确定我之前用一代的时候觉得这个键很重，是不是因为我按的地方不对。\n\n用A键，你可以轻松的在Mac的多窗口之间滑动，操作多任务，打开launch pad。A键的手势操作可以说是鼠标中少有的。\n\n第二个需要强调的键是图左俯视图中滚轮下方的按键。这个按键的默认设定是SmartShift切换。那么首先要说明下什么是SmartShift。从第一代开始，MX Master就有电磁滚轮，它的滚轮相当与众不同。我们日常见到的鼠标滚轮，一般分为两类，一类是滚动很流畅的滚轮，你一滚可以滚老远的，在看长篇大论的时候很方便；另一类是有强烈阻力的滚轮，你在滚动的时候会有类似被齿轮卡住的阻塞感，它能帮助你精准定位。MX Master的电磁滚轮可以让你两者都有（我全都要.jpg），而且提供了SmartShift。只要开启了这个功能，你就能在用力推滚轮的时候进入流畅模式，慢慢推滚轮的时候进入齿轮模式。这个滚轮下方的按键，默认控制着smartshift的开关。\n\n第三代的金属滚轮相较前几代体验更好了，没有了第一代电磁滚轮的生硬，在阻塞模式的时候略微平滑了一些。它的滚动速度比普通鼠标能高出90%，而在精准度上能比第二代MX更精准87%\n\n其他键我就不多说了，基本都是单击键，设置返回前进，tab之间切换什么的，你可以自定义。罗技还帮你做了一些软件适配，在部分软件中有预设鼠标宏。\n\n我有一个强烈推荐的自定义，就是将中间的滚轮绑定为look up，也就是mac自带的查字典。对着不会的词，一向下按鼠标中键，直接就帮你查了。相信我，绑定了查字典，看document你的效率会直线飞升。\n\nLogi Option还有一个很人性化的设置就是你能在Logitech自己的界面更改滚轮滚动模式。你可以单独为它选择标准模式或自然模式。大家都知道苹果全系列的触控都是自然模式的触控，这实际上和微软系列的产品都是相反的。微软的触控模式被称为标准（双指向下滑动是让页面向下走，滚轮向下滚是让页面向下翻），而苹果的触控模式被称为自然。但我们假如习惯使用了智能手机，你就会习惯自然模式的触控板思维。可又由于你常年在微软系统下使用鼠标，你的滚轮思维还是标准思维。\n\n苹果系统允许你切换自然或标准滚动，可是一切，你的触控板和鼠标滚轮会同时被改变。Logi Options就解决了这个问题，你能继续在触控板上使用自然触控，同时你能在鼠标上使用标准滚轮。（我全都要.jpg x 2）\n\n大概介绍完了鼠标，我来做个使用后的使用体验\n\n## 使用体验\n\n### 优点\n\n1. 更轻\n\n   从数字上来看，MX Master 3并没有比一代轻多少（3代是141g，一代145g），但是整体握感却有明显提升。你会感觉这只鼠标变轻了。你可能会奇怪，才少了3g咋能变轻？或许这就是人体工学的魅力吧……（尽管滚轮变成金属的了）当然这都是我的猜测，毕竟我的第一代已经丢了……\n\n2. 金属滚轮体验很好\n\n   能随意在快速和慢速间切换的滚轮为阅读长文的你提供了方便\n\n3. 更精准，4000DPI下DarkField追踪技术传感器，高分辨率也无所畏惧\n\n4. 抓握感更好\n\n5. 续航时间长\n\n6. 能同时连接三台电脑，还有USB连接头\n\n7. 自定义扩展能力强\n\n8. 材质舒适\n\n### 缺点\n\n1. 体积大，不适合小手\n2. 侧部的滚轮比较鸡肋，滚动速度过低\n3. 价格不菲，100刀+，目前折扣最低价也要90刀\n\n## 总结\n\n买！","source":"_posts/2020-03-29-罗技MX Master 3简评.md","raw":"---\ntitle: 罗技MX Master 3简评\ncomments: true\ntoc: true\ntoc_number: false\ncopyright: true\nmathjax: false\nkatex: false\nhide: false\ndate: 2020-03-29 00:08:21\ntags: \n  - review\n  - tech\n  - mouse\n  - life\ncategories: review\ndescription: 或许是最强无线商务鼠标？\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200329014124.png\ntop_img:\nkeywords:\n---\n\n## 开箱\n\n我的MX Master第一代在搬家的时候丢失了，我一度很难过。难过倒不是因为它有多好用，还是因为它不便宜。之后我买了个罗技M535，随便用用，觉得手感不行，便将它扔一边积灰了。\n\n说起来还是因为平日里工作量变大，我是触摸板达人，但是触摸板在双屏之间划来划去实在是太累了，只好又把积灰的M535捡起来用。可惜这小鼠标的精确度实在太大了，用得我好多次想要砸鼠标。没办法，还是决定去买一只新鼠标。看来看去实在没什么可以买的了，最终还是选择了MX Master系列的第三代，就指望着它能有些改进。\n\n作为罗技MX Master第一代的用户，我对这款鼠标并没有什么好感。或许正是因为它在网上好评如潮，我才会更对它失望，因为它跟我的心理预期实在是差太多了。随便列几个我不喜欢第一代mx master的理由：\n\n1. 价格昂贵：原价99刀，我在打折期间60刀入手的，但是这个价格仍旧算是非常高昂，因为60刀的游戏鼠标操控性，定位和手感都远远强于MX Master\n2. 定位一般：作为一个CS:GO玩家，鼠标定位的精准与否，几乎是一上手便知。我之前常使用的鼠标是G703，一用MX Master立刻感觉到了手感和定位的降级。我明白它是商务鼠标，有其他侧重点，但是我仍然觉得这部分罗技缩水过多\n3. 机身笨重：假如你习惯抓握鼠标，那这款鼠标更是你的噩梦，它有足足145g。作为一款商务无线鼠标，它竟然完全不便携。可怕的是它不只是宽，它的背部也高高拱起，非常难以携带\n\n说完了它的缺点，我先暂时不提它的优点了，因为MX Master3几乎完美继承了它所有的优点。\n\n现在买到了MX Master 3，真的让我庆幸，还好我当时把那旧的MX Master丢了，要不然现在我绝对不会去买这只新的。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/8739F928-F1CC-4175-8215-F3D0171BAAE9_1_105_c.jpeg)\n\n我买的是灰白色的版本。拆开包装之后一共三个物品，一个是鼠标本体，一个是信号接收的USB头，最后是一根usb-c的充电器。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/E8F71A26-CC1B-4F37-8993-2FD088766C34_1_105_c.jpeg)\n\n这里就要说到它的第一个优点：它是用type-c接口充电的。作为一个电子产品大户，我衷心希望所有的电子产品都统一接口，不要搞花里胡哨的玩意，不然插座上得插满不同种类的充电线。我上次买的打碟机还是mini-USB接口，让我瞬间以为回到初中。mini-USB接口的设备我都不知道埋了几年了，咋还能有厂商在用呢？\n\nMX Master 3本身是支持蓝牙连接的，也就是说无需USB头就能连上你的电脑。用USB头的话延迟更低，反应更灵敏。其实个人单纯认为这个是没多大意义的，有低延迟需求的人估计都是打游戏的，没人会用你打游戏啊兄弟。不过有总比没有强。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/A01C1E91-35FD-460A-98C7-80B1E8D07137_1_105_c.jpeg)\n\n鼠标背面贴了个简单的说明书，就是告诉你MX Master 3支持同时匹配三台设备。没用过的兄弟可能不了解，这只鼠标长按可以进行匹配电脑，然后短按可以切换连接的电脑。一般来说我们蓝牙只能连一台设备，想连接第二台的话需要重新匹配，第一台和鼠标的连接就会断开，想要再连回去的时候需要重新匹配。而这只鼠标则不需要，只需要在2号位3号位匹配其他机器就行了，要用的时候可以在机器之间切换来切换去。这也是从第一代就有的优点。\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/3A54E2AC-64EA-45FF-A6D6-75EB41D3D179_1_201_a.jpeg)\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/09683B04-976B-4EBC-992B-3BDAF1E147D2_1_102_o.jpeg)\n\n刚才也说过了，这只鼠标的体积很大，适合大手选手。这是它跟G703放在一起的时候的体积对比。\n\n罗技商务键鼠系列用的软件都是Logi Options，你从设置界面上就能看到所有的自定义按键\n\n![](https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%2012.54.15%20AM.png)\n\n这里我要介绍一下罗技的自定义按键了，重头戏是最左边那块扁平的按键，它是个向下按压的按键。在我们的日常使用中，你的大拇指会放在这个按键上。我们暂时称这个按键为按键A。它支持手势操作，你可以设置的鼠标宏有，按下A后的鼠标宏，和按下A以后上/下/左/右移动鼠标后引发的鼠标宏。\n\n这个按键在MX Master第一代中的体验并不是十分理想，其一是MX Master整体手感较重，其二是一代的A键比较重，大拇指按下去需要发点力，久而久之手就容易累。\n\n三代我整体使用下来觉得这个按键还行，主要还是因为你不再需要用力去按它了。当然，如你所见，A键是一片区域，所以我也不太确定我之前用一代的时候觉得这个键很重，是不是因为我按的地方不对。\n\n用A键，你可以轻松的在Mac的多窗口之间滑动，操作多任务，打开launch pad。A键的手势操作可以说是鼠标中少有的。\n\n第二个需要强调的键是图左俯视图中滚轮下方的按键。这个按键的默认设定是SmartShift切换。那么首先要说明下什么是SmartShift。从第一代开始，MX Master就有电磁滚轮，它的滚轮相当与众不同。我们日常见到的鼠标滚轮，一般分为两类，一类是滚动很流畅的滚轮，你一滚可以滚老远的，在看长篇大论的时候很方便；另一类是有强烈阻力的滚轮，你在滚动的时候会有类似被齿轮卡住的阻塞感，它能帮助你精准定位。MX Master的电磁滚轮可以让你两者都有（我全都要.jpg），而且提供了SmartShift。只要开启了这个功能，你就能在用力推滚轮的时候进入流畅模式，慢慢推滚轮的时候进入齿轮模式。这个滚轮下方的按键，默认控制着smartshift的开关。\n\n第三代的金属滚轮相较前几代体验更好了，没有了第一代电磁滚轮的生硬，在阻塞模式的时候略微平滑了一些。它的滚动速度比普通鼠标能高出90%，而在精准度上能比第二代MX更精准87%\n\n其他键我就不多说了，基本都是单击键，设置返回前进，tab之间切换什么的，你可以自定义。罗技还帮你做了一些软件适配，在部分软件中有预设鼠标宏。\n\n我有一个强烈推荐的自定义，就是将中间的滚轮绑定为look up，也就是mac自带的查字典。对着不会的词，一向下按鼠标中键，直接就帮你查了。相信我，绑定了查字典，看document你的效率会直线飞升。\n\nLogi Option还有一个很人性化的设置就是你能在Logitech自己的界面更改滚轮滚动模式。你可以单独为它选择标准模式或自然模式。大家都知道苹果全系列的触控都是自然模式的触控，这实际上和微软系列的产品都是相反的。微软的触控模式被称为标准（双指向下滑动是让页面向下走，滚轮向下滚是让页面向下翻），而苹果的触控模式被称为自然。但我们假如习惯使用了智能手机，你就会习惯自然模式的触控板思维。可又由于你常年在微软系统下使用鼠标，你的滚轮思维还是标准思维。\n\n苹果系统允许你切换自然或标准滚动，可是一切，你的触控板和鼠标滚轮会同时被改变。Logi Options就解决了这个问题，你能继续在触控板上使用自然触控，同时你能在鼠标上使用标准滚轮。（我全都要.jpg x 2）\n\n大概介绍完了鼠标，我来做个使用后的使用体验\n\n## 使用体验\n\n### 优点\n\n1. 更轻\n\n   从数字上来看，MX Master 3并没有比一代轻多少（3代是141g，一代145g），但是整体握感却有明显提升。你会感觉这只鼠标变轻了。你可能会奇怪，才少了3g咋能变轻？或许这就是人体工学的魅力吧……（尽管滚轮变成金属的了）当然这都是我的猜测，毕竟我的第一代已经丢了……\n\n2. 金属滚轮体验很好\n\n   能随意在快速和慢速间切换的滚轮为阅读长文的你提供了方便\n\n3. 更精准，4000DPI下DarkField追踪技术传感器，高分辨率也无所畏惧\n\n4. 抓握感更好\n\n5. 续航时间长\n\n6. 能同时连接三台电脑，还有USB连接头\n\n7. 自定义扩展能力强\n\n8. 材质舒适\n\n### 缺点\n\n1. 体积大，不适合小手\n2. 侧部的滚轮比较鸡肋，滚动速度过低\n3. 价格不菲，100刀+，目前折扣最低价也要90刀\n\n## 总结\n\n买！","slug":"罗技MX Master 3简评","published":1,"updated":"2020-03-29T08:42:39.618Z","layout":"post","photos":[],"link":"","_id":"ck8ct7kgy003lgtvi3zut29bc","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"开箱\"><a href=\"#开箱\" class=\"headerlink\" title=\"开箱\"></a>开箱</h2><p>我的MX Master第一代在搬家的时候丢失了，我一度很难过。难过倒不是因为它有多好用，还是因为它不便宜。之后我买了个罗技M535，随便用用，觉得手感不行，便将它扔一边积灰了。</p>\n<p>说起来还是因为平日里工作量变大，我是触摸板达人，但是触摸板在双屏之间划来划去实在是太累了，只好又把积灰的M535捡起来用。可惜这小鼠标的精确度实在太大了，用得我好多次想要砸鼠标。没办法，还是决定去买一只新鼠标。看来看去实在没什么可以买的了，最终还是选择了MX Master系列的第三代，就指望着它能有些改进。</p>\n<p>作为罗技MX Master第一代的用户，我对这款鼠标并没有什么好感。或许正是因为它在网上好评如潮，我才会更对它失望，因为它跟我的心理预期实在是差太多了。随便列几个我不喜欢第一代mx master的理由：</p>\n<ol>\n<li>价格昂贵：原价99刀，我在打折期间60刀入手的，但是这个价格仍旧算是非常高昂，因为60刀的游戏鼠标操控性，定位和手感都远远强于MX Master</li>\n<li>定位一般：作为一个CS:GO玩家，鼠标定位的精准与否，几乎是一上手便知。我之前常使用的鼠标是G703，一用MX Master立刻感觉到了手感和定位的降级。我明白它是商务鼠标，有其他侧重点，但是我仍然觉得这部分罗技缩水过多</li>\n<li>机身笨重：假如你习惯抓握鼠标，那这款鼠标更是你的噩梦，它有足足145g。作为一款商务无线鼠标，它竟然完全不便携。可怕的是它不只是宽，它的背部也高高拱起，非常难以携带</li>\n</ol>\n<p>说完了它的缺点，我先暂时不提它的优点了，因为MX Master3几乎完美继承了它所有的优点。</p>\n<p>现在买到了MX Master 3，真的让我庆幸，还好我当时把那旧的MX Master丢了，要不然现在我绝对不会去买这只新的。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/8739F928-F1CC-4175-8215-F3D0171BAAE9_1_105_c.jpeg\"  alt=\"\"></p>\n<p>我买的是灰白色的版本。拆开包装之后一共三个物品，一个是鼠标本体，一个是信号接收的USB头，最后是一根usb-c的充电器。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/E8F71A26-CC1B-4F37-8993-2FD088766C34_1_105_c.jpeg\"  alt=\"\"></p>\n<p>这里就要说到它的第一个优点：它是用type-c接口充电的。作为一个电子产品大户，我衷心希望所有的电子产品都统一接口，不要搞花里胡哨的玩意，不然插座上得插满不同种类的充电线。我上次买的打碟机还是mini-USB接口，让我瞬间以为回到初中。mini-USB接口的设备我都不知道埋了几年了，咋还能有厂商在用呢？</p>\n<p>MX Master 3本身是支持蓝牙连接的，也就是说无需USB头就能连上你的电脑。用USB头的话延迟更低，反应更灵敏。其实个人单纯认为这个是没多大意义的，有低延迟需求的人估计都是打游戏的，没人会用你打游戏啊兄弟。不过有总比没有强。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/A01C1E91-35FD-460A-98C7-80B1E8D07137_1_105_c.jpeg\"  alt=\"\"></p>\n<p>鼠标背面贴了个简单的说明书，就是告诉你MX Master 3支持同时匹配三台设备。没用过的兄弟可能不了解，这只鼠标长按可以进行匹配电脑，然后短按可以切换连接的电脑。一般来说我们蓝牙只能连一台设备，想连接第二台的话需要重新匹配，第一台和鼠标的连接就会断开，想要再连回去的时候需要重新匹配。而这只鼠标则不需要，只需要在2号位3号位匹配其他机器就行了，要用的时候可以在机器之间切换来切换去。这也是从第一代就有的优点。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/3A54E2AC-64EA-45FF-A6D6-75EB41D3D179_1_201_a.jpeg\"  alt=\"\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/09683B04-976B-4EBC-992B-3BDAF1E147D2_1_102_o.jpeg\"  alt=\"\"></p>\n<p>刚才也说过了，这只鼠标的体积很大，适合大手选手。这是它跟G703放在一起的时候的体积对比。</p>\n<p>罗技商务键鼠系列用的软件都是Logi Options，你从设置界面上就能看到所有的自定义按键</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%2012.54.15%20AM.png\"  alt=\"\"></p>\n<p>这里我要介绍一下罗技的自定义按键了，重头戏是最左边那块扁平的按键，它是个向下按压的按键。在我们的日常使用中，你的大拇指会放在这个按键上。我们暂时称这个按键为按键A。它支持手势操作，你可以设置的鼠标宏有，按下A后的鼠标宏，和按下A以后上/下/左/右移动鼠标后引发的鼠标宏。</p>\n<p>这个按键在MX Master第一代中的体验并不是十分理想，其一是MX Master整体手感较重，其二是一代的A键比较重，大拇指按下去需要发点力，久而久之手就容易累。</p>\n<p>三代我整体使用下来觉得这个按键还行，主要还是因为你不再需要用力去按它了。当然，如你所见，A键是一片区域，所以我也不太确定我之前用一代的时候觉得这个键很重，是不是因为我按的地方不对。</p>\n<p>用A键，你可以轻松的在Mac的多窗口之间滑动，操作多任务，打开launch pad。A键的手势操作可以说是鼠标中少有的。</p>\n<p>第二个需要强调的键是图左俯视图中滚轮下方的按键。这个按键的默认设定是SmartShift切换。那么首先要说明下什么是SmartShift。从第一代开始，MX Master就有电磁滚轮，它的滚轮相当与众不同。我们日常见到的鼠标滚轮，一般分为两类，一类是滚动很流畅的滚轮，你一滚可以滚老远的，在看长篇大论的时候很方便；另一类是有强烈阻力的滚轮，你在滚动的时候会有类似被齿轮卡住的阻塞感，它能帮助你精准定位。MX Master的电磁滚轮可以让你两者都有（我全都要.jpg），而且提供了SmartShift。只要开启了这个功能，你就能在用力推滚轮的时候进入流畅模式，慢慢推滚轮的时候进入齿轮模式。这个滚轮下方的按键，默认控制着smartshift的开关。</p>\n<p>第三代的金属滚轮相较前几代体验更好了，没有了第一代电磁滚轮的生硬，在阻塞模式的时候略微平滑了一些。它的滚动速度比普通鼠标能高出90%，而在精准度上能比第二代MX更精准87%</p>\n<p>其他键我就不多说了，基本都是单击键，设置返回前进，tab之间切换什么的，你可以自定义。罗技还帮你做了一些软件适配，在部分软件中有预设鼠标宏。</p>\n<p>我有一个强烈推荐的自定义，就是将中间的滚轮绑定为look up，也就是mac自带的查字典。对着不会的词，一向下按鼠标中键，直接就帮你查了。相信我，绑定了查字典，看document你的效率会直线飞升。</p>\n<p>Logi Option还有一个很人性化的设置就是你能在Logitech自己的界面更改滚轮滚动模式。你可以单独为它选择标准模式或自然模式。大家都知道苹果全系列的触控都是自然模式的触控，这实际上和微软系列的产品都是相反的。微软的触控模式被称为标准（双指向下滑动是让页面向下走，滚轮向下滚是让页面向下翻），而苹果的触控模式被称为自然。但我们假如习惯使用了智能手机，你就会习惯自然模式的触控板思维。可又由于你常年在微软系统下使用鼠标，你的滚轮思维还是标准思维。</p>\n<p>苹果系统允许你切换自然或标准滚动，可是一切，你的触控板和鼠标滚轮会同时被改变。Logi Options就解决了这个问题，你能继续在触控板上使用自然触控，同时你能在鼠标上使用标准滚轮。（我全都要.jpg x 2）</p>\n<p>大概介绍完了鼠标，我来做个使用后的使用体验</p>\n<h2 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li><p>更轻</p>\n<p>从数字上来看，MX Master 3并没有比一代轻多少（3代是141g，一代145g），但是整体握感却有明显提升。你会感觉这只鼠标变轻了。你可能会奇怪，才少了3g咋能变轻？或许这就是人体工学的魅力吧……（尽管滚轮变成金属的了）当然这都是我的猜测，毕竟我的第一代已经丢了……</p>\n</li>\n<li><p>金属滚轮体验很好</p>\n<p>能随意在快速和慢速间切换的滚轮为阅读长文的你提供了方便</p>\n</li>\n<li><p>更精准，4000DPI下DarkField追踪技术传感器，高分辨率也无所畏惧</p>\n</li>\n<li><p>抓握感更好</p>\n</li>\n<li><p>续航时间长</p>\n</li>\n<li><p>能同时连接三台电脑，还有USB连接头</p>\n</li>\n<li><p>自定义扩展能力强</p>\n</li>\n<li><p>材质舒适</p>\n</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>体积大，不适合小手</li>\n<li>侧部的滚轮比较鸡肋，滚动速度过低</li>\n<li>价格不菲，100刀+，目前折扣最低价也要90刀</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>买！</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<h2 id=\"开箱\"><a href=\"#开箱\" class=\"headerlink\" title=\"开箱\"></a>开箱</h2><p>我的MX Master第一代在搬家的时候丢失了，我一度很难过。难过倒不是因为它有多好用，还是因为它不便宜。之后我买了个罗技M535，随便用用，觉得手感不行，便将它扔一边积灰了。</p>\n<p>说起来还是因为平日里工作量变大，我是触摸板达人，但是触摸板在双屏之间划来划去实在是太累了，只好又把积灰的M535捡起来用。可惜这小鼠标的精确度实在太大了，用得我好多次想要砸鼠标。没办法，还是决定去买一只新鼠标。看来看去实在没什么可以买的了，最终还是选择了MX Master系列的第三代，就指望着它能有些改进。</p>\n<p>作为罗技MX Master第一代的用户，我对这款鼠标并没有什么好感。或许正是因为它在网上好评如潮，我才会更对它失望，因为它跟我的心理预期实在是差太多了。随便列几个我不喜欢第一代mx master的理由：</p>\n<ol>\n<li>价格昂贵：原价99刀，我在打折期间60刀入手的，但是这个价格仍旧算是非常高昂，因为60刀的游戏鼠标操控性，定位和手感都远远强于MX Master</li>\n<li>定位一般：作为一个CS:GO玩家，鼠标定位的精准与否，几乎是一上手便知。我之前常使用的鼠标是G703，一用MX Master立刻感觉到了手感和定位的降级。我明白它是商务鼠标，有其他侧重点，但是我仍然觉得这部分罗技缩水过多</li>\n<li>机身笨重：假如你习惯抓握鼠标，那这款鼠标更是你的噩梦，它有足足145g。作为一款商务无线鼠标，它竟然完全不便携。可怕的是它不只是宽，它的背部也高高拱起，非常难以携带</li>\n</ol>\n<p>说完了它的缺点，我先暂时不提它的优点了，因为MX Master3几乎完美继承了它所有的优点。</p>\n<p>现在买到了MX Master 3，真的让我庆幸，还好我当时把那旧的MX Master丢了，要不然现在我绝对不会去买这只新的。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/8739F928-F1CC-4175-8215-F3D0171BAAE9_1_105_c.jpeg\" alt=\"\"></p>\n<p>我买的是灰白色的版本。拆开包装之后一共三个物品，一个是鼠标本体，一个是信号接收的USB头，最后是一根usb-c的充电器。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/E8F71A26-CC1B-4F37-8993-2FD088766C34_1_105_c.jpeg\" alt=\"\"></p>\n<p>这里就要说到它的第一个优点：它是用type-c接口充电的。作为一个电子产品大户，我衷心希望所有的电子产品都统一接口，不要搞花里胡哨的玩意，不然插座上得插满不同种类的充电线。我上次买的打碟机还是mini-USB接口，让我瞬间以为回到初中。mini-USB接口的设备我都不知道埋了几年了，咋还能有厂商在用呢？</p>\n<p>MX Master 3本身是支持蓝牙连接的，也就是说无需USB头就能连上你的电脑。用USB头的话延迟更低，反应更灵敏。其实个人单纯认为这个是没多大意义的，有低延迟需求的人估计都是打游戏的，没人会用你打游戏啊兄弟。不过有总比没有强。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/A01C1E91-35FD-460A-98C7-80B1E8D07137_1_105_c.jpeg\" alt=\"\"></p>\n<p>鼠标背面贴了个简单的说明书，就是告诉你MX Master 3支持同时匹配三台设备。没用过的兄弟可能不了解，这只鼠标长按可以进行匹配电脑，然后短按可以切换连接的电脑。一般来说我们蓝牙只能连一台设备，想连接第二台的话需要重新匹配，第一台和鼠标的连接就会断开，想要再连回去的时候需要重新匹配。而这只鼠标则不需要，只需要在2号位3号位匹配其他机器就行了，要用的时候可以在机器之间切换来切换去。这也是从第一代就有的优点。</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/3A54E2AC-64EA-45FF-A6D6-75EB41D3D179_1_201_a.jpeg\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/09683B04-976B-4EBC-992B-3BDAF1E147D2_1_102_o.jpeg\" alt=\"\"></p>\n<p>刚才也说过了，这只鼠标的体积很大，适合大手选手。这是它跟G703放在一起的时候的体积对比。</p>\n<p>罗技商务键鼠系列用的软件都是Logi Options，你从设置界面上就能看到所有的自定义按键</p>\n<p><img src=\"https://raw.githubusercontent.com/8128/PicGo/master/Screen%20Shot%202020-03-29%20at%2012.54.15%20AM.png\" alt=\"\"></p>\n<p>这里我要介绍一下罗技的自定义按键了，重头戏是最左边那块扁平的按键，它是个向下按压的按键。在我们的日常使用中，你的大拇指会放在这个按键上。我们暂时称这个按键为按键A。它支持手势操作，你可以设置的鼠标宏有，按下A后的鼠标宏，和按下A以后上/下/左/右移动鼠标后引发的鼠标宏。</p>\n<p>这个按键在MX Master第一代中的体验并不是十分理想，其一是MX Master整体手感较重，其二是一代的A键比较重，大拇指按下去需要发点力，久而久之手就容易累。</p>\n<p>三代我整体使用下来觉得这个按键还行，主要还是因为你不再需要用力去按它了。当然，如你所见，A键是一片区域，所以我也不太确定我之前用一代的时候觉得这个键很重，是不是因为我按的地方不对。</p>\n<p>用A键，你可以轻松的在Mac的多窗口之间滑动，操作多任务，打开launch pad。A键的手势操作可以说是鼠标中少有的。</p>\n<p>第二个需要强调的键是图左俯视图中滚轮下方的按键。这个按键的默认设定是SmartShift切换。那么首先要说明下什么是SmartShift。从第一代开始，MX Master就有电磁滚轮，它的滚轮相当与众不同。我们日常见到的鼠标滚轮，一般分为两类，一类是滚动很流畅的滚轮，你一滚可以滚老远的，在看长篇大论的时候很方便；另一类是有强烈阻力的滚轮，你在滚动的时候会有类似被齿轮卡住的阻塞感，它能帮助你精准定位。MX Master的电磁滚轮可以让你两者都有（我全都要.jpg），而且提供了SmartShift。只要开启了这个功能，你就能在用力推滚轮的时候进入流畅模式，慢慢推滚轮的时候进入齿轮模式。这个滚轮下方的按键，默认控制着smartshift的开关。</p>\n<p>第三代的金属滚轮相较前几代体验更好了，没有了第一代电磁滚轮的生硬，在阻塞模式的时候略微平滑了一些。它的滚动速度比普通鼠标能高出90%，而在精准度上能比第二代MX更精准87%</p>\n<p>其他键我就不多说了，基本都是单击键，设置返回前进，tab之间切换什么的，你可以自定义。罗技还帮你做了一些软件适配，在部分软件中有预设鼠标宏。</p>\n<p>我有一个强烈推荐的自定义，就是将中间的滚轮绑定为look up，也就是mac自带的查字典。对着不会的词，一向下按鼠标中键，直接就帮你查了。相信我，绑定了查字典，看document你的效率会直线飞升。</p>\n<p>Logi Option还有一个很人性化的设置就是你能在Logitech自己的界面更改滚轮滚动模式。你可以单独为它选择标准模式或自然模式。大家都知道苹果全系列的触控都是自然模式的触控，这实际上和微软系列的产品都是相反的。微软的触控模式被称为标准（双指向下滑动是让页面向下走，滚轮向下滚是让页面向下翻），而苹果的触控模式被称为自然。但我们假如习惯使用了智能手机，你就会习惯自然模式的触控板思维。可又由于你常年在微软系统下使用鼠标，你的滚轮思维还是标准思维。</p>\n<p>苹果系统允许你切换自然或标准滚动，可是一切，你的触控板和鼠标滚轮会同时被改变。Logi Options就解决了这个问题，你能继续在触控板上使用自然触控，同时你能在鼠标上使用标准滚轮。（我全都要.jpg x 2）</p>\n<p>大概介绍完了鼠标，我来做个使用后的使用体验</p>\n<h2 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li><p>更轻</p>\n<p>从数字上来看，MX Master 3并没有比一代轻多少（3代是141g，一代145g），但是整体握感却有明显提升。你会感觉这只鼠标变轻了。你可能会奇怪，才少了3g咋能变轻？或许这就是人体工学的魅力吧……（尽管滚轮变成金属的了）当然这都是我的猜测，毕竟我的第一代已经丢了……</p>\n</li>\n<li><p>金属滚轮体验很好</p>\n<p>能随意在快速和慢速间切换的滚轮为阅读长文的你提供了方便</p>\n</li>\n<li><p>更精准，4000DPI下DarkField追踪技术传感器，高分辨率也无所畏惧</p>\n</li>\n<li><p>抓握感更好</p>\n</li>\n<li><p>续航时间长</p>\n</li>\n<li><p>能同时连接三台电脑，还有USB连接头</p>\n</li>\n<li><p>自定义扩展能力强</p>\n</li>\n<li><p>材质舒适</p>\n</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>体积大，不适合小手</li>\n<li>侧部的滚轮比较鸡肋，滚动速度过低</li>\n<li>价格不菲，100刀+，目前折扣最低价也要90刀</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>买！</p>\n"},{"layout":"post","title":"入门JavaScript笔记","date":"2020-03-23T03:20:00.000Z","description":"前端入门之路","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200322203138.png","optimized_image":null,"author":"tty","_content":"\n因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。\n\n本笔记基于udemy课程JavaScript basics for beginners，你可以在YouTube上看到相关试听视频\n\n部分基于udemy课程Modern JavaScript From The Beginning\n\n部分笔记来源：[JavaScript](https://wangdoc.com/javascript/index.html) [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)\n\n关于ES6：[ES6](https://es6.ruanyifeng.com/)\n\n## Prerequisite\n\n1. 安装live server 插件 in vscode\n2. 在项目新建一个hello world的html，右键你的html然后用live server打开\n3. 假如你html有改动，在html中的内容会自动刷新到live server\n\n推荐：bracket pair colorizer、JavaScript (ES6) code snippets\n\n基础：\n\n- js脚本可以添加到head或添加到body，建议添加到body的末尾\n\n- chrome中alt+command+i打开console\n\n## Variables\n\n在ES6之前，js常常用var来定义变量，但在ES6之后var不再被推荐，建议使用let来定义变量\n\n在JavaScript中假如你没有define一个变量则其值为undefined\n\n在JavaScript中一般用单引号来括起string\n\nVariable不能是保留字（reserved keyword），最好有意义，并且不以数字开头，不能有空格和短杠-（hyphen），命名方式同样遵循camel notation（驼峰命名法），variable都是case-sensitive的\n\n可以同时initialize多个变量，用逗号隔开\n\n### constants\n\n假如你使用的是const而不是var，那么你的变量不能被修改\n\n## Primitive types\n\nJavaScript共有两种value可以assign给variable，一种是primitives(aka. value types)，一种是reference type，\n\n### Primitives\n\n- String\n- Number（在JavaScript中没有float，double这种类型，只有统一的number）\n- Boolean\n- undefined（是一种type，同时是一个value）\n- null\n\n假如当前我们有一个变量，我们没有它的值，但是知晓这个variable将来是什么type，这时候我们就将它设为null，而不是设为undefined\n\n### Dynamic typing\n\n编程语言有两种，一种是static，一种是dynamic。在static language里，变量设置了type之后就不能再更改。但是在JavaScript中，变量能被修改为其他数据类型。\n\n## Reference types\n\n### Objects\n\n```javascript\nlet name = 'Mosh';\nlet age = 30;\nlet person = {\n  name = 'Mosh', //value pair, key is called properties\n  age = 30\n}; // this is an object literal\n\n// Two way to access the properties\n// 1. Dot notation\nperson.name = 'John';\n\n// 2. Bracket notation\nperson['name'] = 'Mary';\n```\n\nDot notation is more concise and shorter, and it should be your default notation\n\nBut sometimes the variable you wanna use might be dynamic, like\n\n```javascript\nlet selection = 'name';\nperson[selection] = 'Mary'\n```\n\nIn this case the second notation would be better\n\n### Arrays\n\n```javascript\nlet  selectedColors = ['red','blue']; // these square brackets are called array literal\nselectedColors[2] = 1; // we can store different types of data into the array\n```\n\nType of the array is object\n\n## Functions\n\n```javascript\nfunction greet(parameter) {\n\tconsole.log('Hello ') + name;\n}\n\ngreet(Your argument);\n```\n\n## Operators\n\nI will ignore the basic common stuff\n\n### Arithmetic Operators\n\n- Addition + (increment ++)\n- Subtraction - (decrement --)\n- Multiplication *\n- Division /\n- Remainder of division %\n- exponentiation **\n\n### Assignment Operators\n\n- +=\n- -=\n- =\n\n### Comparasion Operators\n\n- \\>=\n- <=\n- ==\n- ===(strict equality operator, have the same type and the same value)\n- !==\n- ==(loose equality operator)\n\n=== 判断规则:\n\n1. 如果类型不同，就[不相等]\n2. 如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）\n3. 如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。\n4. 如果两个值都是true，或者都是false，那么[相等]。\n5. 如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。\n6. 如果两个值都是null，或者都是undefined，那么[相等]。\n\n== 判断规则：\n\n1. 如果两个值类型相同，进行 === 比较。\n2. 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：\n3. 如果一个是null、一个是undefined，那么[相等]。\n4. 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。\n5. 如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。\n6. 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）\n7. 任何其他组合，都[不相等]。\n\n### Ternary Operators\n\n: ? 三元运算符\n\n### Logic Operators\n\n- : ?\n\n- &&\n- `||`\n\nthe result of a logic operators is not always a boolean value. Eg, false \\|\\| 'Mosh' === 'Mosh'\n\n#### Falsy\n\n1. undefined\n2. null\n3. 0\n4. false\n5. ''\n6. NaN\n\nAnything else is truthy\n\nit will return the first truthy value in the`||`, eg, false `||` 1 `||` 2, it returns 1\n\n### Bitwise Operators\n\n- `|` bitwise or\n- `&` bitwise and\n\n\n\n## Control flow\n\nI will ignore the parts which is the same as Java (if...else..., while, do...while, switch)\n\n### for loop\n\n```javascript\nconst person = {\n\tname: 'Mosh';\n  age: 30\n};\n\nfor (let key in person)\n\tconsole.log(key, person[key]);\n\nconst colors = ['red','green','blue'];\n//get you the index with 'in'\nfor (let index in colors)\n  console.log(index, colors[index]);\n\n//get you the data inside of the array with 'of'\nfor (let color of colors)\n  console.log(color);\n\n// in 和 of的区别就在于，in是在iterate key，而of在iterate value\n```\n\n## Object\n\n```javascript\n// an example of object\nconst circle = {\n  radius: 1,\n  loaction: {\n  \tx: 1;\n  \ty: 1\n\t},\n  isVisible: true,\n  draw: function() {\n    console.log('draw');\n  }\n};\n\ncircle.draw();\n```\n\n### Factory Function\n\n```javascript\nfunction createCircle(radius) {\n  return {\n    radius,\n    draw() {\n      console.log('draw');\n    }\n  };\n}\n```\n\nusing this way to create object, the object.constructor will shows you Object()\n\n### Constructor Function\n\n```javascript\nfunction Circle(radius) {\n\tthis.radius = radius;\n  this.draw = function() {\n    console.log('draw');\n  }\n}\n```\n\nThis one looks like a class, but the factory function looks like a function\n\n构造函数一般首字母大写\n\n### Dynamic Nature\n\n```javascript\nconst circle = {\n  radius: 1\n};\n\ncircle.color = 'yello'; // add properties\ncircle.draw = function() {}\n\ndelete circle.color; // remove properties\ndelete circle.draw;\n```\n\n### Cloning an object\n\n```javascript\nconst another = Object.assign(newObj, oldObj);\n\nconst another = {...target}; // three dots means all the properties inside of the old object\n```\n\n### Garbage Collection\n\nAll the process is automatic and you cannot clean the memory mannualy.\n\n### String\n\nThere is primitive string and object String, primitive string can also use functions, and they will be wrapped as String object\n\nEscape character(转义字符)\n\n在JavaScript中，引号间的换行会被记录\n\n```javascript\nconst message = 'hello';\nconst another =\n‘This is my ${message}\n'first' message';\n```\n\n输出会是\n\n```\nThis is my hello\n'first' message\n```\n\n### 继承\n\n#### 原型对象概述\n\n##### 构造函数的缺点\n\nJavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。\n\n```javascript\nfunction Cat (name, color) {\n  this.name = name;\n  this.color = color;\n}\n\nvar cat1 = new Cat('大毛', '白色');\n\ncat1.name // '大毛'\ncat1.color // '白色'\n```\n\n上面代码中，`Cat`函数是一个构造函数，函数内部定义了`name`属性和`color`属性，所有实例对象（上例是`cat1`）都会生成这两个属性，即这两个属性会定义在实例对象上面。\n\n通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\n\n```javascript\nfunction Cat(name, color) {\n  this.name = name;\n  this.color = color;\n  this.meow = function () {\n    console.log('喵喵');\n  };\n}\n\nvar cat1 = new Cat('大毛', '白色');\nvar cat2 = new Cat('二毛', '黑色');\n\ncat1.meow === cat2.meow\n// false\n```\n\n上面代码中，`cat1`和`cat2`是同一个构造函数的两个实例，它们都具有`meow`方法。由于`meow`方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个`meow`方法。这既没有必要，又浪费系统资源，因为所有`meow`方法都是同样的行为，完全应该共享。\n\n这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。\n\n##### prototype 属性的作用\n\nJavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。\n\n下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个`prototype`属性，指向一个对象。\n\n```javascript\nfunction f() {}\ntypeof f.prototype // \"object\"\n```\n\n上面代码中，函数`f`默认具有`prototype`属性，指向一个对象。\n\n对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。\n\n```javascript\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.color = 'white';\n\nvar cat1 = new Animal('大毛');\nvar cat2 = new Animal('二毛');\n\ncat1.color // 'white'\ncat2.color // 'white'\n```\n\n上面代码中，构造函数`Animal`的`prototype`属性，就是实例对象`cat1`和`cat2`的原型对象。原型对象上添加一个`color`属性，结果，实例对象都共享了该属性。\n\n原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在**所有**实例对象上。\n\n```javascript\nAnimal.prototype.color = 'yellow';\n\ncat1.color // \"yellow\"\ncat2.color // \"yellow\"\n```\n\n上面代码中，原型对象的`color`属性的值变为`yellow`，两个实例对象的`color`属性立刻跟着变了。这是因为实例对象其实没有`color`属性，都是读取原型对象的`color`属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。\n\n如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\n\n```javascript\ncat1.color = 'black';\n\ncat1.color // 'black'\ncat2.color // 'yellow'\nAnimal.prototype.color // 'yellow';\n```\n\n上面代码中，实例对象`cat1`的`color`属性改为`black`，就使得它不再去原型对象读取`color`属性，后者的值依然为`yellow`。\n\n总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\n\n```javascript\nAnimal.prototype.walk = function () {\n  console.log(this.name + ' is walking');\n};\n```\n\n上面代码中，`Animal.prototype`对象上面定义了一个`walk`方法，这个方法将可以在所有`Animal`实例对象上面调用。\n\n##### 原型链\n\nJavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……\n\n如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。\n\n那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。\n\n```javascript\nObject.getPrototypeOf(Object.prototype)\n// null\n```\n\n上面代码表示，`Object.prototype`对象的原型是`null`，由于`null`没有任何属性，所以原型链到此为止。`Object.getPrototypeOf`方法返回参数对象的原型，具体介绍请看后文。\n\n读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的`Object.prototype`还是找不到，则返回`undefined`。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。\n\n注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\n\n举例来说，如果让构造函数的`prototype`属性指向一个数组，就意味着实例对象可以调用数组方法。\n\n```javascript\nvar MyArray = function () {};\n\nMyArray.prototype = new Array();\nMyArray.prototype.constructor = MyArray;\n\nvar mine = new MyArray();\nmine.push(1, 2, 3);\nmine.length // 3\nmine instanceof Array // true\n```\n\n上面代码中，`mine`是构造函数`MyArray`的实例对象，由于`MyArray.prototype`指向一个数组实例，使得`mine`可以调用数组方法（这些方法定义在数组实例的`prototype`对象上面）。最后那行`instanceof`表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明`mine`为`Array`的实例，`instanceof`运算符的详细解释详见后文。\n\n上面代码还出现了原型对象的`constructor`属性，这个属性的含义下一节就来解释。\n\n##### constructor 属性\n\n`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数。\n\n```javascript\nfunction P() {}\nP.prototype.constructor === P // true\n```\n\n由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。\n\n```javascript\nfunction P() {}\nvar p = new P();\n\np.constructor === P // true\np.constructor === P.prototype.constructor // true\np.hasOwnProperty('constructor') // false\n```\n\n上面代码中，`p`是构造函数`P`的实例对象，但是`p`自身没有`constructor`属性，该属性其实是读取原型链上面的`P.prototype.constructor`属性。\n\n`constructor`属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\n\n```javascript\nfunction F() {};\nvar f = new F();\n\nf.constructor === F // true\nf.constructor === RegExp // false\n```\n\n上面代码中，`constructor`属性确定了实例对象`f`的构造函数是`F`，而不是`RegExp`。\n\n另一方面，有了`constructor`属性，就可以从一个实例对象新建另一个实例。\n\n```javascript\nfunction Constr() {}\nvar x = new Constr();\n\nvar y = new x.constructor();\ny instanceof Constr // true\n```\n\n上面代码中，`x`是构造函数`Constr`的实例，可以从`x.constructor`间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。\n\n```javascript\nConstr.prototype.createCopy = function () {\n  return new this.constructor();\n};\n```\n\n上面代码中，`createCopy`方法调用构造函数，新建另一个实例。\n\n`constructor`属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改`constructor`属性，防止引用的时候出错。\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.constructor === Person // true\n\nPerson.prototype = {\n  method: function () {}\n};\n\nPerson.prototype.constructor === Person // false\nPerson.prototype.constructor === Object // true\n```\n\n上面代码中，构造函数`Person`的原型对象改掉了，但是没有修改`constructor`属性，导致这个属性不再指向`Person`。由于`Person`的新原型是一个普通对象，而普通对象的`constructor`属性指向`Object`构造函数，导致`Person.prototype.constructor`变成了`Object`。\n\n所以，修改原型对象时，一般要同时修改`constructor`属性的指向。\n\n```javascript\n// 坏的写法\nC.prototype = {\n  method1: function (...) { ... },\n  // ...\n};\n\n// 好的写法\nC.prototype = {\n  constructor: C,\n  method1: function (...) { ... },\n  // ...\n};\n\n// 更好的写法\nC.prototype.method1 = function (...) { ... };\n```\n\n上面代码中，要么将`constructor`属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证`instanceof`运算符不会失真。\n\n如果不能确定`constructor`属性是什么函数，还有一个办法：通过`name`属性，从实例得到构造函数的名称。\n\n```javascript\nfunction Foo() {}\nvar f = new Foo();\nf.constructor.name // \"Foo\"\n```\n\n#### instanceof 运算符\n\n`instanceof`运算符返回一个布尔值，表示对象是否为某个构造函数的实例。\n\n```javascript\nvar v = new Vehicle();\nv instanceof Vehicle // true\n```\n\n上面代码中，对象`v`是构造函数`Vehicle`的实例，所以返回`true`。\n\n`instanceof`运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。\n\n```javascript\nv instanceof Vehicle\n// 等同于\nVehicle.prototype.isPrototypeOf(v)\n```\n\n上面代码中，`Object.prototype.isPrototypeOf`的详细解释见后文。\n\n由于`instanceof`检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回`true`。\n\n```javascript\nvar d = new Date();\nd instanceof Date // true\nd instanceof Object // true\n```\n\n上面代码中，`d`同时是`Date`和`Object`的实例，因此对这两个构造函数都返回`true`。\n\n由于任意对象（除了`null`）都是`Object`的实例，所以`instanceof`运算符可以判断一个值是否为非`null`的对象。\n\n```javascript\nvar obj = { foo: 123 };\nobj instanceof Object // true\n\nnull instanceof Object // false\n```\n\n上面代码中，除了`null`，其他对象的`instanceOf Object`的运算结果都是`true`。\n\n`instanceof`的原理是检查右边构造函数的`prototype`属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有`null`对象。这时，`instanceof`判断会失真。\n\n```javascript\nvar obj = Object.create(null);\ntypeof obj // \"object\"\nObject.create(null) instanceof Object // false\n```\n\n上面代码中，`Object.create(null)`返回一个新对象`obj`，它的原型是`null`（`Object.create`的详细介绍见后文）。右边的构造函数`Object`的`prototype`属性，不在左边的原型链上，因此`instanceof`就认为`obj`不是`Object`的实例。但是，只要一个对象的原型不是`null`，`instanceof`运算符的判断就不会失真。\n\n`instanceof`运算符的一个用处，是判断值的类型。\n\n```javascript\nvar x = [1, 2, 3];\nvar y = {};\nx instanceof Array // true\ny instanceof Object // true\n```\n\n上面代码中，`instanceof`运算符判断，变量`x`是数组，变量`y`是对象。\n\n注意，`instanceof`运算符只能用于对象，不适用原始类型的值。\n\n```javascript\nvar s = 'hello';\ns instanceof String // false\n```\n\n上面代码中，字符串不是`String`对象的实例（因为字符串不是对象），所以返回`false`。\n\n此外，对于`undefined`和`null`，`instanceof`运算符总是返回`false`。\n\n```javascript\nundefined instanceof Object // false\nnull instanceof Object // false\n```\n\n利用`instanceof`运算符，还可以巧妙地解决，调用构造函数时，忘了加`new`命令的问题。\n\n```javascript\nfunction Fubar (foo, bar) {\n  if (this instanceof Fubar) {\n    this._foo = foo;\n    this._bar = bar;\n  } else {\n    return new Fubar(foo, bar);\n  }\n}\n```\n\n上面代码使用`instanceof`运算符，在函数体内部判断`this`关键字是否为构造函数`Fubar`的实例。如果不是，就表明忘了加`new`命令。\n\n#### 构造函数的继承\n\n让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。\n\n```javascript\nfunction Sub(value) {\n  Super.call(this);\n  this.prop = value;\n}\n```\n\n上面代码中，`Sub`是子类的构造函数，`this`是子类的实例。在实例上调用父类的构造函数`Super`，就会让子类实例具有父类实例的属性。\n\n第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。\n\n```javascript\nSub.prototype = Object.create(Super.prototype);\nSub.prototype.constructor = Sub;\nSub.prototype.method = '...';\n```\n\n上面代码中，`Sub.prototype`是子类的原型，要将它赋值为`Object.create(Super.prototype)`，而不是直接等于`Super.prototype`。否则后面两行对`Sub.prototype`的操作，会连父类的原型`Super.prototype`一起修改掉。\n\n另外一种写法是`Sub.prototype`等于一个父类实例。\n\n```javascript\nSub.prototype = new Super();\n```\n\n上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。\n\n举例来说，下面是一个`Shape`构造函数。\n\n```javascript\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function (x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n```\n\n我们需要让`Rectangle`构造函数继承`Shape`。\n\n```javascript\n// 第一步，子类继承父类的实例\nfunction Rectangle() {\n  Shape.call(this); // 调用父类构造函数\n}\n// 另一种写法\nfunction Rectangle() {\n  this.base = Shape;\n  this.base();\n}\n\n// 第二步，子类继承父类的原型\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n```\n\n采用这样的写法以后，`instanceof`运算符会对子类和父类的构造函数，都返回`true`。\n\n```javascript\nvar rect = new Rectangle();\n\nrect instanceof Rectangle  // true\nrect instanceof Shape  // true\n```\n\n上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。\n\n```javascript\nClassB.prototype.print = function() {\n  ClassA.prototype.print.call(this);\n  // some code\n}\n```\n\n上面代码中，子类`B`的`print`方法先调用父类`A`的`print`方法，再部署自己的代码。这就等于继承了父类`A`的`print`方法。\n\n#### 多重继承\n\nJavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。\n\n```javascript\nfunction M1() {\n  this.hello = 'hello';\n}\n\nfunction M2() {\n  this.world = 'world';\n}\n\nfunction S() {\n  M1.call(this);\n  M2.call(this);\n}\n\n// 继承 M1\nS.prototype = Object.create(M1.prototype);\n// 继承链上加入 M2\nObject.assign(S.prototype, M2.prototype);\n\n// 指定构造函数\nS.prototype.constructor = S;\n\nvar s = new S();\ns.hello // 'hello'\ns.world // 'world'\n```\n\n上面代码中，子类`S`同时继承了父类`M1`和`M2`。这种模式又称为 Mixin（混入）。\n\n#### 模块\n\n随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。\n\nJavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。\n\n但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。\n\n##### 基本的实现方法\n\n模块是实现特定功能的一组属性和方法的封装。\n\n简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。\n\n```javascript\nvar module1 = new Object({\n　_count : 0,\n　m1 : function (){\n　　//...\n　},\n　m2 : function (){\n  　//...\n　}\n});\n```\n\n上面的函数`m1`和`m2`，都封装在`module1`对象里。使用的时候，就是调用这个对象的属性。\n\n```javascript\nmodule1.m1();\n```\n\n但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\n\n```javascript\nmodule1._count = 5;\n```\n\n##### 封装私有变量：构造函数的写法\n\n我们可以利用构造函数，封装私有变量。\n\n```javascript\nfunction StringBuilder() {\n  var buffer = [];\n\n  this.add = function (str) {\n     buffer.push(str);\n  };\n\n  this.toString = function () {\n    return buffer.join('');\n  };\n\n}\n```\n\n上面代码中，`buffer`是模块的私有变量。一旦生成实例对象，外部是无法直接访问`buffer`的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。\n\n```javascript\nfunction StringBuilder() {\n  this._buffer = [];\n}\n\nStringBuilder.prototype = {\n  constructor: StringBuilder,\n  add: function (str) {\n    this._buffer.push(str);\n  },\n  toString: function () {\n    return this._buffer.join('');\n  }\n};\n```\n\n这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。\n\n##### 封装私有变量：立即执行函数的写法\n\n另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。\n\n```javascript\nvar module1 = (function () {\n　var _count = 0;\n　var m1 = function () {\n　  //...\n　};\n　var m2 = function () {\n　　//...\n　};\n　return {\n　　m1 : m1,\n　　m2 : m2\n　};\n})();\n```\n\n使用上面的写法，外部代码无法读取内部的`_count`变量。\n\n```javascript\nconsole.info(module1._count); //undefined\n```\n\n上面的`module1`就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。\n\n##### 模块的放大模式\n\n如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。\n\n```javascript\nvar module1 = (function (mod){\n　mod.m3 = function () {\n　　//...\n　};\n　return mod;\n})(module1);\n```\n\n上面的代码为`module1`模块添加了一个新方法`m3()`，然后返回新的`module1`模块。\n\n在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用\"宽放大模式\"（Loose augmentation）。\n\n```javascript\nvar module1 = (function (mod) {\n　//...\n　return mod;\n})(window.module1 || {});\n```\n\n与\"放大模式\"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。\n\n##### 输入全局变量\n\n独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\n\n为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\n\n```javascript\nvar module1 = (function ($, YAHOO) {\n　//...\n})(jQuery, YAHOO);\n```\n\n上面的`module1`模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入`module1`。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\n\n立即执行函数还可以起到命名空间的作用。\n\n```javascript\n(function($, window, document) {\n\n  function go(num) {\n  }\n\n  function handleEvents() {\n  }\n\n  function initialize() {\n  }\n\n  function dieCarouselDie() {\n  }\n\n  //attach to the global scope\n  window.finalCarousel = {\n    init : initialize,\n    destroy : dieCarouselDie\n  }\n\n})( jQuery, window, document );\n```\n\n上面代码中，`finalCarousel`对象输出到全局，对外暴露`init`和`destroy`接口，内部方法`go`、`handleEvents`、`initialize`、`dieCarouselDie`都是外部无法调用的。\n\n## Array\n\n### adding element\n\n及时你使用了const来作为array，你虽然不能reassign this array to something else，但是你可以增加删除其中的元素。\n\n```javascript\nconst numbers = [3,4];\n//add at the end\nnumbers.push(5,6);\n//add at the beginning\nnumbers.unshift(1,2);\n//middle\n//第一个：位置，第二：删除的元素数量，第三以及之后：添加的内容\nnumbers.splice(2,0,'a','b');\n\n```\n\n### Find element\n\n```javascript\n// it is easy to find a primitive type\nnumbers.includes(1);\nnumbers.indexOf(1);\nnumbers.lastIndexOf(1);\n\n// to find an object\nconst course = courses.find(function(course) {\n  return course.name === 'xyz';\n});\n```\n\n### Arrow functions\n\nlooks like java lambda\n\n```javascript\nconst course = courses.find(course => course.name === 'a');\n```\n\n### Removing Element\n\n```javascript\nconst numbers = [1,2,3,4];\n\n//end\nnumbers.pop();\n\n//beginning\nnumbers.shift();\n\n//middle\nnumbers.splice(2, 3); //first is offset, second is the number of elements you want to delete\n```\n\n### Empty an array\n\n```javascript\n//Solution 1\nlet num = [1,2,3];\nlet num1 = num;\n\nnum = []; //in this solution, num is reassigned but num1 is still pointing to the num, so the info of num will not be garbage collected\n\n//Solution 2\nnumbers.length = 0;\n\n//Solution 3\nnumbers.splice(0, numbers.length);\n\n//Solution 4\nwhile (numbers.length > 0) {\n  numbers.pop();\n}\n```\n\n### Combing Arrays\n\n```javascript\nconst first = [1,2,3];\nconst second = [4,5,6];\nconst combined = first.concat(second);\nconst sllice = combined.slice(2,4);\n```\n\n### Iterate Array\n\n```javascript\nfor (let num of nums) {\n\tconsole.log(num);\n}\nnums.forEach(function(number){\n  console.log(number);\n});\n// after es6\nnums.forEach(number => console.log(number));\nnums.forEach((number, index) => console.log(index, number)); // the second value is index, the first is the value\n```\n\n### Join array\n\n```javascript\nconst numbers = [1,2,3]\nconst joined = numbers.join('-');//default is comma\n// result is 1-2-3\n```\n\n### Sort\n\n```javascript\nconst numbers = [1,2,3]\nnumbers.sort();\nnumbers.reverse();\n```\n\n### Every and some\n\n```javascript\nconst numbers = [1,2,3]\nconst k = numbers.every(function(value){\n  return value >= 0;\n});// all passed then return true, else return false\n\nconst k = numbers.some(function(value){\n  return value >= 0;\n});// at leaset one match then return true, else return false\n```\n\n### Filter an array\n\n```javascript\nconst filtered = numbers.filter(function(value){\n  return value >= 0;\n});\n\nconst filtered = numbers.filter(value => value >= 0);\n```\n\n### Mapping\n\n```javascript\nconst items = filtered.map(n => ({value : n}));\n```\n\n### Reduce\n\n```javascript\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n\nconst sum = numbers.reduce((accumulator, currentValue) => {\n  return accumulator + currentValue;\n});\n```\n\n## Function\n\n```javascript\ncalcRectArea(3,4); // run it before the declaration is okay\n\n// this is a function declaration\nfunction calcRectArea(width, height) {\n  return width * height;\n}\n\ngetRectArea(3,4); // run it before the expression then there will be error\n\n// this is a function expression, and is an anonymous(there is also named) function expression\nconst getRectArea = function(width, height) {\n  return width * height;\n}\n```\n\nHoisting: JavaScript engine will automatically move the function declaration to the top of the file\n\nArguments: all the input elemments will be shown as argument in the function with there index. For a funtion who needs 2 elements, if you input 5 elements, that doesn't matter, the function will only use the first two number\n\nDefault Value: same like python, define it in the parameters\n\n### Getter and Setter\n\n```javascript\nvar person = {\n  firstName: \"John\",\n  lastName : \"Doe\",\n  language : \"en\",\n  get lang() {\n    return this.language;\n  }\n  set lang(lang) {\n    this.language = lang;\n  }\n};\n\n// Set an object property using a setter:\nperson.lang = \"en\";\n// Display data from the object using a getter:\ndocument.getElementById(\"demo\").innerHTML = person.lang;\n\n```\n\n### Try and catch\n\n#### The throw Statement\n\nThe `throw` statement allows you to create a custom error.\n\nTechnically you can **throw an exception (throw an error)**.\n\n```javascript\nthrow \"Too big\";    // throw a text\nthrow 500;          // throw a number\nthrow new Error('value is invalid');\n```\n\n\n\nIf you use `throw` together with `try` and `catch`, you can control program flow and generate custom error messages.\n\n#### Try catch finally\n\n```javascript\nfunction myFunction() {\n  var message, x;\n  message = document.getElementById(\"p01\");\n  message.innerHTML = \"\";\n  x = document.getElementById(\"demo\").value;\n  try {\n    if(x == \"\") throw \"empty\";\n    if(isNaN(x)) throw \"not a number\";\n    x = Number(x);\n    if(x < 5) throw \"too low\";\n    if(x > 10) throw \"too high\";\n  }\n  catch(e) {\n    message.innerHTML = \"Input is \" + e;\n    alert(e);\n  }\n  finally {\n    document.getElementById(\"demo\").value = \"\";\n  }\n}\n```\n\n## Let and Var\n\n### ES6可以用let定义块级作用域变量\n\n在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以`{}`限定不了var声明变量的访问范围。\n例如：\n\n```javascript\n{\n  var i = 9;\n}\nconsole.log(i);  // 9\n```\n\nES6新增的`let`，可以声明块级作用域的变量。\n\n```javascript\n{\n  let i = 9;     // i变量只在 花括号内有效！！！\n}\nconsole.log(i);  // Uncaught ReferenceError: i is not defined\n```\n\n### let 配合for循环的独特应用\n\n`let`非常适合用于 `for`循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：\n\n```javascript\nfor (var i = 0; i <10; i++) {  \n  setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列。\n    console.log(i);        // 执行此代码时，同步代码for循环已经执行完成\n  }, 0);\n}\n// 输出结果\n10   共10个\n// 这里面的知识点： JS的事件循环机制，setTimeout的机制等\n```\n\n如果把 `var`改成 `let`声明：\n\n```javascript\n// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i);    //  i 是循环体内局部作用域，不受外界影响。\n  }, 0);\n}\n// 输出结果：\n0  1  2  3  4  5  6  7  8 9\n```\n\n### let没有变量提升与暂时性死区\n\n用`let`声明的变量，不存在变量提升。而且要求必须 等`let`声明语句执行完之后，变量才能使用，不然会报`Uncaught ReferenceError`错误。\n例如：\n\n```javascript\nconsole.log(aicoder);    // 错误：Uncaught ReferenceError ...\nlet aicoder = 'aicoder.com';\n// 这里就可以安全使用aicoder\n```\n\n> ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n> 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n### let变量不能重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。否则报错：`Uncaught SyntaxError: Identifier 'XXX' has already been declared`\n\n例如：\n\n```javascript\nlet a = 0;\nlet a = 'sss';\n// Uncaught SyntaxError: Identifier 'a' has already been declared\n```\n\n## 错误处理机制\n\n### Error 实例对象\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n```javascript\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n\n上面代码中，我们调用`Error`构造函数，生成一个实例对象`err`。`Error`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\n\nJavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n- **message**：错误提示信息\n- **name**：错误名称（非标准属性）\n- **stack**：错误的堆栈（非标准属性）\n\n使用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。\n\n```javascript\nif (error.name) {\n  console.log(error.name + ': ' + error.message);\n}\n```\n\n`stack`属性用来查看错误发生时的堆栈。\n\n```javascript\nfunction throwit() {\n  throw new Error('');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n```\n\n上面代码中，错误堆栈的最内层是`throwit`函数，然后是`catchit`函数，最后是函数的运行环境。\n\n### 原生错误类型\n\n`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个派生对象。\n\n#### SyntaxError 对象\n\n`SyntaxError`对象是解析代码时发生的语法错误。\n\n```javascript\n// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log 'hello');\n// Uncaught SyntaxError: Unexpected string\n```\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n#### ReferenceError 对象\n\n`ReferenceError`对象是引用一个不存在的变量时发生的错误。\n\n```javascript\n// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n```\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。\n\n```javascript\n// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n```\n\n上面代码对函数`console.log`的运行结果赋值，结果引发了`ReferenceError`错误。\n\n#### RangeError 对象\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n```javascript\n// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n```\n\n#### TypeError 对象\n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。\n\n```javascript\nnew 123\n// Uncaught TypeError: number is not a func\n\nvar obj = {};\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n```\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。\n\n#### URIError 对象\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n```javascript\ndecodeURI('%2')\n// URIError: URI malformed\n```\n\n#### EvalError 对象\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n#### 总结\n\n以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\n```javascript\nvar err1 = new Error('出错了！');\nvar err2 = new RangeError('出错了，变量超出有效范围！');\nvar err3 = new TypeError('出错了，变量类型无效！');\n\nerr1.message // \"出错了！\"\nerr2.message // \"出错了，变量超出有效范围！\"\nerr3.message // \"出错了，变量类型无效！\"\n```\n\n### 自定义错误\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n\n上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。\n\n```javascript\nnew UserError('这是自定义的错误！');\n```\n\n### throw 语句\n\n`throw`语句的作用是手动中断程序执行，抛出一个错误。\n\n```javascript\nif (x <= 0) {\n  throw new Error('x 必须为正数');\n}\n// Uncaught ReferenceError: x is not defined\n```\n\n上面代码中，如果变量`x`小于等于`0`，就手动抛出一个错误，告诉用户`x`的值不正确，整个程序就会在这里中断执行。可以看到，`throw`抛出的错误就是它的参数，这里是一个`Error`实例。\n\n`throw`也可以抛出自定义错误。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nthrow new UserError('出错了！');\n// Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n```\n\n上面代码中，`throw`抛出的是一个`UserError`实例。\n\n实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n```javascript\n// 抛出一个字符串\nthrow 'Error！';\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow {\n  toString: function () {\n    return 'Error!';\n  }\n};\n// Uncaught {toString: ƒ}\n```\n\n对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\n### try...catch 结构\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n```javascript\ntry {\n  throw new Error('出错了!');\n} catch (e) {\n  console.log(e.name + \": \" + e.message);\n  console.log(e.stack);\n}\n// Error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n```\n\n上面代码中，`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。\n\n如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。\n\n```javascript\ntry {\n  f();\n} catch(e) {\n  // 处理错误\n}\n```\n\n上面代码中，如果函数`f`执行报错，就会进行`catch`代码块，接着对错误进行处理。\n\n`catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\n```javascript\ntry {\n  throw \"出错了\";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n```\n\n上面代码中，`try`代码块抛出的错误，被`catch`代码块捕获后，程序会继续向下执行。\n\n`catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。\n\n```javascript\nvar n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// Uncaught 100\n```\n\n上面代码中，`catch`代码之中又抛出了一个错误。\n\n为了捕捉不同类型的错误，`catch`代码块之中可以加入判断语句。\n\n```javascript\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n```\n\n上面代码中，`catch`捕获错误之后，会判断错误类型（`EvalError`还是`RangeError`），进行不同的处理。\n\n### finally 代码块\n\n`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n```javascript\nfunction cleansUp() {\n  try {\n    throw new Error('出错了……');\n    console.log('此行不会执行');\n  } finally {\n    console.log('完成清理工作');\n  }\n}\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (<anonymous>:3:11)\n//    at <anonymous>:10:1\n```\n\n上面代码中，由于没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。\n\n```javascript\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log('FINALLY');\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n```\n\n上面代码中，`try`代码块没有发生错误，而且里面还包括`return`语句，但是`finally`代码块依然会执行。而且，这个函数的返回值还是`result`。\n\n下面的例子说明，`return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。\n\n```javascript\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n```\n\n上面代码说明，`return`语句里面的`count`的值，是在`finally`代码块运行之前就获取了。\n\n下面是`finally`代码块用法的典型场景。\n\n```javascript\nopenFile();\n\ntry {\n  writeFile(Data);\n} catch(e) {\n  handleError(e);\n} finally {\n  closeFile();\n}\n```\n\n上面代码首先打开一个文件，然后在`try`代码块中写入文件，如果没有发生错误，则运行`finally`代码块关闭文件；一旦发生错误，则先使用`catch`代码块处理错误，再使用`finally`代码块关闭文件。\n\n下面的例子充分反映了`try...catch...finally`这三者之间的执行顺序。\n\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw 'bug';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n```\n\n上面代码中，`catch`代码块结束执行之前，会先执行`finally`代码块。\n\n`catch`代码块之中，触发转入`finally`代码块的标志，不仅有`return`语句，还有`throw`语句。\n\n```javascript\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n```\n\n上面代码中，进入`catch`代码块之后，一遇到`throw`语句，就会去执行`finally`代码块，其中有`return false`语句，因此就直接返回了，不再会回去执行`catch`代码块剩下的部分了。\n\n`try`代码块内部，还可以再使用`try`代码块。\n\n```javascript\ntry {\n  try {\n    consle.log('Hello world!'); // 报错\n  }\n  finally {\n    console.log('Finally');\n  }\n  console.log('Will I run?');\n} catch(error) {\n  console.error(error.message);\n}\n// Finally\n// consle is not defined\n```\n\n上面代码中，`try`里面还有一个`try`。内层的`try`报错（`console`拼错了），这时会执行内层的`finally`代码块，然后抛出错误，被外层的`catch`捕获。\n\n## Console对象与控制台\n\n### console 对象\n\n`console`对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出`stdout`和标准错误`stderr`，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。\n\n`console`的常见用途有两个。\n\n- 调试程序，显示网页代码运行时的错误信息。\n- 提供了一个命令行接口，用来与网页代码互动。\n\n`console`对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。\n\n1. 按 F12 或者`Control + Shift + i`（PC）/ `Command + Option + i`（Mac）。\n2. 浏览器菜单选择“工具/开发者工具”。\n3. 在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。\n\n打开开发者工具以后，顶端有多个面板。\n\n- **Elements**：查看网页的 HTML 源码和 CSS 代码。\n- **Resources**：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\n- **Network**：查看网页的 HTTP 通信情况。\n- **Sources**：查看网页加载的脚本源码。\n- **Timeline**：查看各种网页行为随时间变化的情况。\n- **Performance**：查看网页的性能情况，比如 CPU 和内存消耗。\n- **Console**：用来运行 JavaScript 命令。\n\n这些面板都有各自的用途，以下只介绍`Console`面板（又称为控制台）。\n\n`Console`面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。\n\n### console 对象的静态方法\n\n`console`对象提供的各种静态方法，用来与控制台窗口互动。\n\n#### console.log()，console.info()，console.debug()\n\n`console.log`方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。\n\n```javascript\nconsole.log('Hello World')\n// Hello World\nconsole.log('a', 'b', 'c')\n// a b c\n```\n\n`console.log`方法会自动在每次输出的结尾，添加换行符。\n\n```javascript\nconsole.log(1);\nconsole.log(2);\nconsole.log(3);\n// 1\n// 2\n// 3\n```\n\n如果第一个参数是格式字符串（使用了格式占位符），`console.log`方法将依次用后面的参数替换占位符，然后再进行输出。\n\n```javascript\nconsole.log(' %s + %s = %s', 1, 1, 2)\n//  1 + 1 = 2\n```\n\n上面代码中，`console.log`方法的第一个参数有三个占位符（`%s`），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。\n\n`console.log`方法支持以下占位符，不同类型的数据必须使用对应的占位符。\n\n- `%s` 字符串\n- `%d` 整数\n- `%i` 整数\n- `%f` 浮点数\n- `%o` 对象的链接\n- `%c` CSS 格式字符串\n\n```javascript\nvar number = 11 * 9;\nvar color = 'red';\n\nconsole.log('%d %s balloons', number, color);\n// 99 red balloons\n```\n\n上面代码中，第二个参数是数值，对应的占位符是`%d`，第三个参数是字符串，对应的占位符是`%s`。\n\n使用`%c`占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。\n\n```javascript\nconsole.log(\n  '%cThis text is styled!',\n  'color: red; background: yellow; font-size: 24px;'\n)\n```\n\n上面代码运行后，输出的内容将显示为黄底红字。\n\n`console.log`方法的两种参数格式，可以结合在一起使用。\n\n```javascript\nconsole.log(' %s + %s ', 1, 1, '= 2')\n// 1 + 1  = 2\n```\n\n如果参数是一个对象，`console.log`会显示该对象的值。\n\n```javascript\nconsole.log({foo: 'bar'})\n// Object {foo: \"bar\"}\nconsole.log(Date)\n// function Date() { [native code] }\n```\n\n上面代码输出`Date`对象的值，结果为一个构造函数。\n\n`console.info`是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。\n\n`console.debug`方法与`console.log`方法类似，会在控制台输出调试信息。但是，默认情况下，`console.debug`输出的信息不会显示，只有在打开显示级别在`verbose`的情况下，才会显示。\n\n`console`对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义`console.log`方法。\n\n```javascript\n['log', 'info', 'warn', 'error'].forEach(function(method) {\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n});\n\nconsole.log(\"出错了！\");\n// 2014-05-18T09:00.000Z 出错了！\n```\n\n上面代码表示，使用自定义的`console.log`方法，可以在显示结果添加当前时间。\n\n#### console.warn()，console.error()\n\n`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。\n\n```javascript\nconsole.error('Error: %s (%i)', 'Server is not responding', 500)\n// Error: Server is not responding (500)\nconsole.warn('Warning! Too few nodes (%d)', document.childNodes.length)\n// Warning! Too few nodes (1)\n```\n\n可以这样理解，`log`方法是写入标准输出（`stdout`），`warn`方法和`error`方法是写入标准错误（`stderr`）。\n\n#### console.table()\n\n对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。\n\n```javascript\nvar languages = [\n  { name: \"JavaScript\", fileExtension: \".js\" },\n  { name: \"TypeScript\", fileExtension: \".ts\" },\n  { name: \"CoffeeScript\", fileExtension: \".coffee\" }\n];\n\nconsole.table(languages);\n```\n\n上面代码的`language`变量，转为表格显示如下。\n\n| (index) | name           | fileExtension |\n| :------ | :------------- | :------------ |\n| 0       | \"JavaScript\"   | \".js\"         |\n| 1       | \"TypeScript\"   | \".ts\"         |\n| 2       | \"CoffeeScript\" | \".coffee\"     |\n\n下面是显示表格内容的例子。\n\n```javascript\nvar languages = {\n  csharp: { name: \"C#\", paradigm: \"object-oriented\" },\n  fsharp: { name: \"F#\", paradigm: \"functional\" }\n};\n\nconsole.table(languages);\n```\n\n上面代码的`language`，转为表格显示如下。\n\n| (index) | name | paradigm          |\n| :------ | :--- | :---------------- |\n| csharp  | \"C#\" | \"object-oriented\" |\n| fsharp  | \"F#\" | \"functional\"      |\n\n#### console.count()\n\n`count`方法用于计数，输出它被调用了多少次。\n\n```javascript\nfunction greet(user) {\n  console.count();\n  return 'hi ' + user;\n}\n\ngreet('bob')\n//  : 1\n// \"hi bob\"\n\ngreet('alice')\n//  : 2\n// \"hi alice\"\n\ngreet('bob')\n//  : 3\n// \"hi bob\"\n```\n\n上面代码每次调用`greet`函数，内部的`console.count`方法就输出执行次数。\n\n该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\n\n```javascript\nfunction greet(user) {\n  console.count(user);\n  return \"hi \" + user;\n}\n\ngreet('bob')\n// bob: 1\n// \"hi bob\"\n\ngreet('alice')\n// alice: 1\n// \"hi alice\"\n\ngreet('bob')\n// bob: 2\n// \"hi bob\"\n```\n\n上面代码根据参数的不同，显示`bob`执行了两次，`alice`执行了一次。\n\n#### console.dir()，console.dirxml()\n\n`dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n```javascript\nconsole.log({f1: 'foo', f2: 'bar'})\n// Object {f1: \"foo\", f2: \"bar\"}\n\nconsole.dir({f1: 'foo', f2: 'bar'})\n// Object\n//   f1: \"foo\"\n//   f2: \"bar\"\n//   __proto__: Object\n```\n\n上面代码显示`dir`方法的输出结果，比`log`方法更易读，信息也更丰富。\n\n该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。\n\n```javascript\nconsole.dir(document.body)\n```\n\nNode 环境之中，还可以指定以代码高亮的形式输出。\n\n```javascript\nconsole.dir(obj, {colors: true})\n```\n\n`dirxml`方法主要用于以目录树的形式，显示 DOM 节点。\n\n```javascript\nconsole.dirxml(document.body)\n```\n\n如果参数不是 DOM 节点，而是普通的 JavaScript 对象，`console.dirxml`等同于`console.dir`。\n\n```javascript\nconsole.dirxml([1, 2, 3])\n// 等同于\nconsole.dir([1, 2, 3])\n```\n\n#### console.assert()\n\n`console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。\n\n它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。\n\n```javascript\nconsole.assert(false, '判断条件不成立')\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry {\n  if (!false) {\n    throw new Error('判断条件不成立');\n  }\n} catch(e) {\n  console.error(e);\n}\n```\n\n下面是一个例子，判断子节点的个数是否大于等于500。\n\n```javascript\nconsole.assert(list.childNodes.length < 500, '节点个数大于等于500')\n```\n\n上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。\n\n#### console.time()，console.timeEnd()\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\n```javascript\nconsole.time('Array initialize');\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n  array[i] = new Object();\n};\n\nconsole.timeEnd('Array initialize');\n// Array initialize: 1914.481ms\n```\n\n`time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n#### console.group()，console.groupEnd()，console.groupCollapsed()\n\n`console.group`和`console.groupEnd`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。\n\n```javascript\nconsole.group('一级分组');\nconsole.log('一级分组的内容');\n\nconsole.group('二级分组');\nconsole.log('二级分组的内容');\n\nconsole.groupEnd(); // 二级分组结束\nconsole.groupEnd(); // 一级分组结束\n```\n\n上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。\n\n`console.groupCollapsed`方法与`console.group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\n\n```javascript\nconsole.groupCollapsed('Fetching Data');\n\nconsole.log('Request Sent');\nconsole.error('Error: Server not responding (500)');\n\nconsole.groupEnd();\n```\n\n上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。\n\n#### console.trace()，console.clear()\n\n`console.trace`方法显示当前执行的代码在堆栈中的调用路径。\n\n```javascript\nconsole.trace()\n// console.trace()\n//   (anonymous function)\n//   InjectedScript._evaluateOn\n//   InjectedScript._evaluateAndWrap\n//   InjectedScript.evaluate\n```\n\n`console.clear`方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，`console.clear`方法将不起作用。\n\n### 控制台命令行 API\n\n浏览器控制台中，除了使用`console`对象，还可以使用一些控制台自带的命令行方法。\n\n（1）`$_`\n\n`$_`属性返回上一个表达式的值。\n\n```javascript\n2 + 2\n// 4\n$_\n// 4\n```\n\n（2）`$0` - `$4`\n\n控制台保存了最近5个在 Elements 面板选中的 DOM 元素，`$0`代表倒数第一个（最近一个），`$1`代表倒数第二个，以此类推直到`$4`。\n\n（3）`$(selector)`\n\n`$(selector)`返回第一个匹配的元素，等同于`document.querySelector()`。注意，如果页面脚本对`$`有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行`$(selector)`就会采用 jQuery 的实现，返回一个数组。\n\n（4）`$$(selector)`\n\n`$$(selector)`返回选中的 DOM 对象，等同于`document.querySelectorAll`。\n\n（5）`$x(path)`\n\n`$x(path)`方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。\n\n```javascript\n$x(\"//p[a]\")\n```\n\n上面代码返回所有包含`a`元素的`p`元素。\n\n（6）`inspect(object)`\n\n`inspect(object)`方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在`Elements`面板中显示，比如`inspect(document)`会在 Elements 面板显示`document`元素。JavaScript 对象在控制台面板`Profiles`面板中显示，比如`inspect(window)`。\n\n（7）`getEventListeners(object)`\n\n`getEventListeners(object)`方法返回一个对象，该对象的成员为`object`登记了回调函数的各种事件（比如`click`或`keydown`），每个事件对应一个数组，数组的成员为该事件的回调函数。\n\n（8）`keys(object)`，`values(object)`\n\n`keys(object)`方法返回一个数组，包含`object`的所有键名。\n\n`values(object)`方法返回一个数组，包含`object`的所有键值。\n\n```javascript\nvar o = {'p1': 'a', 'p2': 'b'};\n\nkeys(o)\n// [\"p1\", \"p2\"]\nvalues(o)\n// [\"a\", \"b\"]\n```\n\n（9）`monitorEvents(object[, events]) ，unmonitorEvents(object[, events])`\n\n`monitorEvents(object[, events])`方法监听特定对象上发生的特定事件。事件发生时，会返回一个`Event`对象，包含该事件的相关信息。`unmonitorEvents`方法用于停止监听。\n\n```javascript\nmonitorEvents(window, \"resize\");\nmonitorEvents(window, [\"resize\", \"scroll\"])\n```\n\n上面代码分别表示单个事件和多个事件的监听方法。\n\n```javascript\nmonitorEvents($0, 'mouse');\nunmonitorEvents($0, 'mousemove');\n```\n\n上面代码表示如何停止监听。\n\n`monitorEvents`允许监听同一大类的事件。所有事件可以分成四个大类。\n\n- mouse：\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"mousemove\", \"mouseover\", \"mouseout\", \"mousewheel\"\n- key：\"keydown\", \"keyup\", \"keypress\", \"textInput\"\n- touch：\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"\n- control：\"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"change\", \"submit\", \"reset\"\n\n```javascript\nmonitorEvents($(\"#msg\"), \"key\");\n```\n\n上面代码表示监听所有`key`大类的事件。\n\n（10）其他方法\n\n命令行 API 还提供以下方法。\n\n- `clear()`：清除控制台的历史。\n- `copy(object)`：复制特定 DOM 元素到剪贴板。\n- `dir(object)`：显示特定对象的所有属性，是`console.dir`方法的别名。\n- `dirxml(object)`：显示特定对象的 XML 形式，是`console.dirxml`方法的别名。\n\n### debugger 语句\n\n`debugger`语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到`debugger`语句时会自动停下。如果没有除错工具，`debugger`语句不会产生任何结果，JavaScript 引擎自动跳过这一句。\n\nChrome 浏览器中，当代码运行到`debugger`语句时，就会暂停运行，自动打开脚本源码界面。\n\n```javascript\nfor(var i = 0; i < 5; i++){\n  console.log(i);\n  if (i === 2) debugger;\n}\n```\n\n上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。\n\n## 异步操作概述\n\n### 单线程模型\n\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\n\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\n\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\n\n如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。\n\n单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。\n\n为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。\n\n### 同步任务和异步任务\n\n程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。\n\n同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。\n\n异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。\n\n举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。\n\n### 任务队列和事件循环\n\nJavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）\n\n首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。\n\n异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。\n\nJavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。[维基百科](https://en.wikipedia.org/wiki/Event_loop)的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。\n\n### 异步操作的模式\n\n下面总结一下异步操作的几种模式。\n\n#### 回调函数\n\n回调函数是异步操作最基本的方法。\n\n下面是两个函数`f1`和`f2`，编程的意图是`f2`必须等到`f1`执行完成，才能执行。\n\n```javascript\nfunction f1() {\n  // ...\n}\n\nfunction f2() {\n  // ...\n}\n\nf1();\nf2();\n```\n\n上面代码的问题在于，如果`f1`是异步操作，`f2`会立即执行，不会等到`f1`结束再执行。\n\n这时，可以考虑改写`f1`，把`f2`写成`f1`的回调函数。\n\n```javascript\nfunction f1(callback) {\n  // ...\n  callback();\n}\n\nfunction f2() {\n  // ...\n}\n\nf1(f2);\n```\n\n回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](https://en.wikipedia.org/wiki/Coupling_(computer_programming))（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\n\n#### 事件监听\n\n另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n\n还是以`f1`和`f2`为例。首先，为`f1`绑定一个事件（这里采用的 jQuery 的[写法](https://api.jquery.com/on/)）。\n\n```javascript\nf1.on('done', f2);\n```\n\n上面这行代码的意思是，当`f1`发生`done`事件，就执行`f2`。然后，对`f1`进行改写：\n\n```javascript\nfunction f1() {\n  setTimeout(function () {\n    // ...\n    f1.trigger('done');\n  }, 1000);\n}\n```\n\n上面代码中，`f1.trigger('done')`表示，执行完成后，立即触发`done`事件，从而开始执行`f2`。\n\n这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“[去耦合](https://en.wikipedia.org/wiki/Decoupling)”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。\n\n#### 发布/订阅\n\n事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](https://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。\n\n这个模式有多种[实现](https://msdn.microsoft.com/en-us/magazine/hh201955.aspx)，下面采用的是 Ben Alman 的 [Tiny Pub/Sub](https://gist.github.com/661855)，这是 jQuery 的一个插件。\n\n首先，`f2`向信号中心`jQuery`订阅`done`信号。\n\n```javascript\njQuery.subscribe('done', f2);\n```\n\n然后，`f1`进行如下改写。\n\n```javascript\nfunction f1() {\n  setTimeout(function () {\n    // ...\n    jQuery.publish('done');\n  }, 1000);\n}\n```\n\n上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。\n\n`f2`完成执行后，可以取消订阅（unsubscribe）。\n\n```javascript\njQuery.unsubscribe('done', f2);\n```\n\n这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n### 异步操作的流程控制\n\n如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。\n\n```javascript\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n```\n\n上面代码的`async`函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。\n\n如果有六个这样的异步任务，需要全部完成后，才能执行最后的`final`函数。请问应该如何安排操作流程？\n\n```javascript\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nasync(1, function (value) {\n  async(2, function (value) {\n    async(3, function (value) {\n      async(4, function (value) {\n        async(5, function (value) {\n          async(6, final);\n        });\n      });\n    });\n  });\n});\n// 参数为 1 , 1秒后返回结果\n// 参数为 2 , 1秒后返回结果\n// 参数为 3 , 1秒后返回结果\n// 参数为 4 , 1秒后返回结果\n// 参数为 5 , 1秒后返回结果\n// 参数为 6 , 1秒后返回结果\n// 完成:  12\n```\n\n上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。\n\n#### 串行执行\n\n我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction series(item) {\n  if(item) {\n    async( item, function(result) {\n      results.push(result);\n      return series(items.shift());\n    });\n  } else {\n    return final(results[results.length - 1]);\n  }\n}\n\nseries(items.shift());\n```\n\n上面代码中，函数`series`就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行`final`函数。`items`数组保存每一个异步任务的参数，`results`数组保存每一个异步任务的运行结果。\n\n注意，上面的写法需要六秒，才能完成整个脚本。\n\n#### 并行执行\n\n流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行`final`函数。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nitems.forEach(function(item) {\n  async(item, function(result){\n    results.push(result);\n    if(results.length === items.length) {\n      final(results[results.length - 1]);\n    }\n  })\n});\n```\n\n上面代码中，`forEach`方法会同时发起六个异步任务，等到它们全部完成以后，才会执行`final`函数。\n\n相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。\n\n#### 并行与串行的结合\n\n所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行`n`个异步任务，这样就避免了过分占用系统资源。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\nvar running = 0;\nvar limit = 2;\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction launcher() {\n  while(running < limit && items.length > 0) {\n    var item = items.shift();\n    async(item, function(result) {\n      results.push(result);\n      running--;\n      if(items.length > 0) {\n        launcher();\n      } else if(running == 0) {\n        final(results);\n      }\n    });\n    running++;\n  }\n}\n\nlauncher();\n```\n\n上面代码中，最多只能同时运行两个异步任务。变量`running`记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于`0`，就表示所有任务都执行完了，这时就执行`final`函数。\n\n这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节`limit`变量，达到效率和资源的最佳平衡。\n","source":"_posts/2020-03-22-入门JavaScript笔记.md","raw":"---\nlayout: post\ntitle:  入门JavaScript笔记\ndate:   2020-03-22 20:20:00\ndescription: 前端入门之路\nsubtitle:\ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200322203138.png\noptimized_image:\ncategory: tutorial\ntags:\n  - tutorial\n  - code\n  - javascript\nauthor: tty\n---\n\n因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。\n\n本笔记基于udemy课程JavaScript basics for beginners，你可以在YouTube上看到相关试听视频\n\n部分基于udemy课程Modern JavaScript From The Beginning\n\n部分笔记来源：[JavaScript](https://wangdoc.com/javascript/index.html) [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)\n\n关于ES6：[ES6](https://es6.ruanyifeng.com/)\n\n## Prerequisite\n\n1. 安装live server 插件 in vscode\n2. 在项目新建一个hello world的html，右键你的html然后用live server打开\n3. 假如你html有改动，在html中的内容会自动刷新到live server\n\n推荐：bracket pair colorizer、JavaScript (ES6) code snippets\n\n基础：\n\n- js脚本可以添加到head或添加到body，建议添加到body的末尾\n\n- chrome中alt+command+i打开console\n\n## Variables\n\n在ES6之前，js常常用var来定义变量，但在ES6之后var不再被推荐，建议使用let来定义变量\n\n在JavaScript中假如你没有define一个变量则其值为undefined\n\n在JavaScript中一般用单引号来括起string\n\nVariable不能是保留字（reserved keyword），最好有意义，并且不以数字开头，不能有空格和短杠-（hyphen），命名方式同样遵循camel notation（驼峰命名法），variable都是case-sensitive的\n\n可以同时initialize多个变量，用逗号隔开\n\n### constants\n\n假如你使用的是const而不是var，那么你的变量不能被修改\n\n## Primitive types\n\nJavaScript共有两种value可以assign给variable，一种是primitives(aka. value types)，一种是reference type，\n\n### Primitives\n\n- String\n- Number（在JavaScript中没有float，double这种类型，只有统一的number）\n- Boolean\n- undefined（是一种type，同时是一个value）\n- null\n\n假如当前我们有一个变量，我们没有它的值，但是知晓这个variable将来是什么type，这时候我们就将它设为null，而不是设为undefined\n\n### Dynamic typing\n\n编程语言有两种，一种是static，一种是dynamic。在static language里，变量设置了type之后就不能再更改。但是在JavaScript中，变量能被修改为其他数据类型。\n\n## Reference types\n\n### Objects\n\n```javascript\nlet name = 'Mosh';\nlet age = 30;\nlet person = {\n  name = 'Mosh', //value pair, key is called properties\n  age = 30\n}; // this is an object literal\n\n// Two way to access the properties\n// 1. Dot notation\nperson.name = 'John';\n\n// 2. Bracket notation\nperson['name'] = 'Mary';\n```\n\nDot notation is more concise and shorter, and it should be your default notation\n\nBut sometimes the variable you wanna use might be dynamic, like\n\n```javascript\nlet selection = 'name';\nperson[selection] = 'Mary'\n```\n\nIn this case the second notation would be better\n\n### Arrays\n\n```javascript\nlet  selectedColors = ['red','blue']; // these square brackets are called array literal\nselectedColors[2] = 1; // we can store different types of data into the array\n```\n\nType of the array is object\n\n## Functions\n\n```javascript\nfunction greet(parameter) {\n\tconsole.log('Hello ') + name;\n}\n\ngreet(Your argument);\n```\n\n## Operators\n\nI will ignore the basic common stuff\n\n### Arithmetic Operators\n\n- Addition + (increment ++)\n- Subtraction - (decrement --)\n- Multiplication *\n- Division /\n- Remainder of division %\n- exponentiation **\n\n### Assignment Operators\n\n- +=\n- -=\n- =\n\n### Comparasion Operators\n\n- \\>=\n- <=\n- ==\n- ===(strict equality operator, have the same type and the same value)\n- !==\n- ==(loose equality operator)\n\n=== 判断规则:\n\n1. 如果类型不同，就[不相等]\n2. 如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）\n3. 如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。\n4. 如果两个值都是true，或者都是false，那么[相等]。\n5. 如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。\n6. 如果两个值都是null，或者都是undefined，那么[相等]。\n\n== 判断规则：\n\n1. 如果两个值类型相同，进行 === 比较。\n2. 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：\n3. 如果一个是null、一个是undefined，那么[相等]。\n4. 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。\n5. 如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。\n6. 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）\n7. 任何其他组合，都[不相等]。\n\n### Ternary Operators\n\n: ? 三元运算符\n\n### Logic Operators\n\n- : ?\n\n- &&\n- `||`\n\nthe result of a logic operators is not always a boolean value. Eg, false \\|\\| 'Mosh' === 'Mosh'\n\n#### Falsy\n\n1. undefined\n2. null\n3. 0\n4. false\n5. ''\n6. NaN\n\nAnything else is truthy\n\nit will return the first truthy value in the`||`, eg, false `||` 1 `||` 2, it returns 1\n\n### Bitwise Operators\n\n- `|` bitwise or\n- `&` bitwise and\n\n\n\n## Control flow\n\nI will ignore the parts which is the same as Java (if...else..., while, do...while, switch)\n\n### for loop\n\n```javascript\nconst person = {\n\tname: 'Mosh';\n  age: 30\n};\n\nfor (let key in person)\n\tconsole.log(key, person[key]);\n\nconst colors = ['red','green','blue'];\n//get you the index with 'in'\nfor (let index in colors)\n  console.log(index, colors[index]);\n\n//get you the data inside of the array with 'of'\nfor (let color of colors)\n  console.log(color);\n\n// in 和 of的区别就在于，in是在iterate key，而of在iterate value\n```\n\n## Object\n\n```javascript\n// an example of object\nconst circle = {\n  radius: 1,\n  loaction: {\n  \tx: 1;\n  \ty: 1\n\t},\n  isVisible: true,\n  draw: function() {\n    console.log('draw');\n  }\n};\n\ncircle.draw();\n```\n\n### Factory Function\n\n```javascript\nfunction createCircle(radius) {\n  return {\n    radius,\n    draw() {\n      console.log('draw');\n    }\n  };\n}\n```\n\nusing this way to create object, the object.constructor will shows you Object()\n\n### Constructor Function\n\n```javascript\nfunction Circle(radius) {\n\tthis.radius = radius;\n  this.draw = function() {\n    console.log('draw');\n  }\n}\n```\n\nThis one looks like a class, but the factory function looks like a function\n\n构造函数一般首字母大写\n\n### Dynamic Nature\n\n```javascript\nconst circle = {\n  radius: 1\n};\n\ncircle.color = 'yello'; // add properties\ncircle.draw = function() {}\n\ndelete circle.color; // remove properties\ndelete circle.draw;\n```\n\n### Cloning an object\n\n```javascript\nconst another = Object.assign(newObj, oldObj);\n\nconst another = {...target}; // three dots means all the properties inside of the old object\n```\n\n### Garbage Collection\n\nAll the process is automatic and you cannot clean the memory mannualy.\n\n### String\n\nThere is primitive string and object String, primitive string can also use functions, and they will be wrapped as String object\n\nEscape character(转义字符)\n\n在JavaScript中，引号间的换行会被记录\n\n```javascript\nconst message = 'hello';\nconst another =\n‘This is my ${message}\n'first' message';\n```\n\n输出会是\n\n```\nThis is my hello\n'first' message\n```\n\n### 继承\n\n#### 原型对象概述\n\n##### 构造函数的缺点\n\nJavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。\n\n```javascript\nfunction Cat (name, color) {\n  this.name = name;\n  this.color = color;\n}\n\nvar cat1 = new Cat('大毛', '白色');\n\ncat1.name // '大毛'\ncat1.color // '白色'\n```\n\n上面代码中，`Cat`函数是一个构造函数，函数内部定义了`name`属性和`color`属性，所有实例对象（上例是`cat1`）都会生成这两个属性，即这两个属性会定义在实例对象上面。\n\n通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\n\n```javascript\nfunction Cat(name, color) {\n  this.name = name;\n  this.color = color;\n  this.meow = function () {\n    console.log('喵喵');\n  };\n}\n\nvar cat1 = new Cat('大毛', '白色');\nvar cat2 = new Cat('二毛', '黑色');\n\ncat1.meow === cat2.meow\n// false\n```\n\n上面代码中，`cat1`和`cat2`是同一个构造函数的两个实例，它们都具有`meow`方法。由于`meow`方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个`meow`方法。这既没有必要，又浪费系统资源，因为所有`meow`方法都是同样的行为，完全应该共享。\n\n这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。\n\n##### prototype 属性的作用\n\nJavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。\n\n下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个`prototype`属性，指向一个对象。\n\n```javascript\nfunction f() {}\ntypeof f.prototype // \"object\"\n```\n\n上面代码中，函数`f`默认具有`prototype`属性，指向一个对象。\n\n对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。\n\n```javascript\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.color = 'white';\n\nvar cat1 = new Animal('大毛');\nvar cat2 = new Animal('二毛');\n\ncat1.color // 'white'\ncat2.color // 'white'\n```\n\n上面代码中，构造函数`Animal`的`prototype`属性，就是实例对象`cat1`和`cat2`的原型对象。原型对象上添加一个`color`属性，结果，实例对象都共享了该属性。\n\n原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在**所有**实例对象上。\n\n```javascript\nAnimal.prototype.color = 'yellow';\n\ncat1.color // \"yellow\"\ncat2.color // \"yellow\"\n```\n\n上面代码中，原型对象的`color`属性的值变为`yellow`，两个实例对象的`color`属性立刻跟着变了。这是因为实例对象其实没有`color`属性，都是读取原型对象的`color`属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。\n\n如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\n\n```javascript\ncat1.color = 'black';\n\ncat1.color // 'black'\ncat2.color // 'yellow'\nAnimal.prototype.color // 'yellow';\n```\n\n上面代码中，实例对象`cat1`的`color`属性改为`black`，就使得它不再去原型对象读取`color`属性，后者的值依然为`yellow`。\n\n总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\n\n```javascript\nAnimal.prototype.walk = function () {\n  console.log(this.name + ' is walking');\n};\n```\n\n上面代码中，`Animal.prototype`对象上面定义了一个`walk`方法，这个方法将可以在所有`Animal`实例对象上面调用。\n\n##### 原型链\n\nJavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……\n\n如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。\n\n那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。\n\n```javascript\nObject.getPrototypeOf(Object.prototype)\n// null\n```\n\n上面代码表示，`Object.prototype`对象的原型是`null`，由于`null`没有任何属性，所以原型链到此为止。`Object.getPrototypeOf`方法返回参数对象的原型，具体介绍请看后文。\n\n读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的`Object.prototype`还是找不到，则返回`undefined`。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。\n\n注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\n\n举例来说，如果让构造函数的`prototype`属性指向一个数组，就意味着实例对象可以调用数组方法。\n\n```javascript\nvar MyArray = function () {};\n\nMyArray.prototype = new Array();\nMyArray.prototype.constructor = MyArray;\n\nvar mine = new MyArray();\nmine.push(1, 2, 3);\nmine.length // 3\nmine instanceof Array // true\n```\n\n上面代码中，`mine`是构造函数`MyArray`的实例对象，由于`MyArray.prototype`指向一个数组实例，使得`mine`可以调用数组方法（这些方法定义在数组实例的`prototype`对象上面）。最后那行`instanceof`表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明`mine`为`Array`的实例，`instanceof`运算符的详细解释详见后文。\n\n上面代码还出现了原型对象的`constructor`属性，这个属性的含义下一节就来解释。\n\n##### constructor 属性\n\n`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数。\n\n```javascript\nfunction P() {}\nP.prototype.constructor === P // true\n```\n\n由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。\n\n```javascript\nfunction P() {}\nvar p = new P();\n\np.constructor === P // true\np.constructor === P.prototype.constructor // true\np.hasOwnProperty('constructor') // false\n```\n\n上面代码中，`p`是构造函数`P`的实例对象，但是`p`自身没有`constructor`属性，该属性其实是读取原型链上面的`P.prototype.constructor`属性。\n\n`constructor`属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\n\n```javascript\nfunction F() {};\nvar f = new F();\n\nf.constructor === F // true\nf.constructor === RegExp // false\n```\n\n上面代码中，`constructor`属性确定了实例对象`f`的构造函数是`F`，而不是`RegExp`。\n\n另一方面，有了`constructor`属性，就可以从一个实例对象新建另一个实例。\n\n```javascript\nfunction Constr() {}\nvar x = new Constr();\n\nvar y = new x.constructor();\ny instanceof Constr // true\n```\n\n上面代码中，`x`是构造函数`Constr`的实例，可以从`x.constructor`间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。\n\n```javascript\nConstr.prototype.createCopy = function () {\n  return new this.constructor();\n};\n```\n\n上面代码中，`createCopy`方法调用构造函数，新建另一个实例。\n\n`constructor`属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改`constructor`属性，防止引用的时候出错。\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.constructor === Person // true\n\nPerson.prototype = {\n  method: function () {}\n};\n\nPerson.prototype.constructor === Person // false\nPerson.prototype.constructor === Object // true\n```\n\n上面代码中，构造函数`Person`的原型对象改掉了，但是没有修改`constructor`属性，导致这个属性不再指向`Person`。由于`Person`的新原型是一个普通对象，而普通对象的`constructor`属性指向`Object`构造函数，导致`Person.prototype.constructor`变成了`Object`。\n\n所以，修改原型对象时，一般要同时修改`constructor`属性的指向。\n\n```javascript\n// 坏的写法\nC.prototype = {\n  method1: function (...) { ... },\n  // ...\n};\n\n// 好的写法\nC.prototype = {\n  constructor: C,\n  method1: function (...) { ... },\n  // ...\n};\n\n// 更好的写法\nC.prototype.method1 = function (...) { ... };\n```\n\n上面代码中，要么将`constructor`属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证`instanceof`运算符不会失真。\n\n如果不能确定`constructor`属性是什么函数，还有一个办法：通过`name`属性，从实例得到构造函数的名称。\n\n```javascript\nfunction Foo() {}\nvar f = new Foo();\nf.constructor.name // \"Foo\"\n```\n\n#### instanceof 运算符\n\n`instanceof`运算符返回一个布尔值，表示对象是否为某个构造函数的实例。\n\n```javascript\nvar v = new Vehicle();\nv instanceof Vehicle // true\n```\n\n上面代码中，对象`v`是构造函数`Vehicle`的实例，所以返回`true`。\n\n`instanceof`运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。\n\n```javascript\nv instanceof Vehicle\n// 等同于\nVehicle.prototype.isPrototypeOf(v)\n```\n\n上面代码中，`Object.prototype.isPrototypeOf`的详细解释见后文。\n\n由于`instanceof`检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回`true`。\n\n```javascript\nvar d = new Date();\nd instanceof Date // true\nd instanceof Object // true\n```\n\n上面代码中，`d`同时是`Date`和`Object`的实例，因此对这两个构造函数都返回`true`。\n\n由于任意对象（除了`null`）都是`Object`的实例，所以`instanceof`运算符可以判断一个值是否为非`null`的对象。\n\n```javascript\nvar obj = { foo: 123 };\nobj instanceof Object // true\n\nnull instanceof Object // false\n```\n\n上面代码中，除了`null`，其他对象的`instanceOf Object`的运算结果都是`true`。\n\n`instanceof`的原理是检查右边构造函数的`prototype`属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有`null`对象。这时，`instanceof`判断会失真。\n\n```javascript\nvar obj = Object.create(null);\ntypeof obj // \"object\"\nObject.create(null) instanceof Object // false\n```\n\n上面代码中，`Object.create(null)`返回一个新对象`obj`，它的原型是`null`（`Object.create`的详细介绍见后文）。右边的构造函数`Object`的`prototype`属性，不在左边的原型链上，因此`instanceof`就认为`obj`不是`Object`的实例。但是，只要一个对象的原型不是`null`，`instanceof`运算符的判断就不会失真。\n\n`instanceof`运算符的一个用处，是判断值的类型。\n\n```javascript\nvar x = [1, 2, 3];\nvar y = {};\nx instanceof Array // true\ny instanceof Object // true\n```\n\n上面代码中，`instanceof`运算符判断，变量`x`是数组，变量`y`是对象。\n\n注意，`instanceof`运算符只能用于对象，不适用原始类型的值。\n\n```javascript\nvar s = 'hello';\ns instanceof String // false\n```\n\n上面代码中，字符串不是`String`对象的实例（因为字符串不是对象），所以返回`false`。\n\n此外，对于`undefined`和`null`，`instanceof`运算符总是返回`false`。\n\n```javascript\nundefined instanceof Object // false\nnull instanceof Object // false\n```\n\n利用`instanceof`运算符，还可以巧妙地解决，调用构造函数时，忘了加`new`命令的问题。\n\n```javascript\nfunction Fubar (foo, bar) {\n  if (this instanceof Fubar) {\n    this._foo = foo;\n    this._bar = bar;\n  } else {\n    return new Fubar(foo, bar);\n  }\n}\n```\n\n上面代码使用`instanceof`运算符，在函数体内部判断`this`关键字是否为构造函数`Fubar`的实例。如果不是，就表明忘了加`new`命令。\n\n#### 构造函数的继承\n\n让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。\n\n```javascript\nfunction Sub(value) {\n  Super.call(this);\n  this.prop = value;\n}\n```\n\n上面代码中，`Sub`是子类的构造函数，`this`是子类的实例。在实例上调用父类的构造函数`Super`，就会让子类实例具有父类实例的属性。\n\n第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。\n\n```javascript\nSub.prototype = Object.create(Super.prototype);\nSub.prototype.constructor = Sub;\nSub.prototype.method = '...';\n```\n\n上面代码中，`Sub.prototype`是子类的原型，要将它赋值为`Object.create(Super.prototype)`，而不是直接等于`Super.prototype`。否则后面两行对`Sub.prototype`的操作，会连父类的原型`Super.prototype`一起修改掉。\n\n另外一种写法是`Sub.prototype`等于一个父类实例。\n\n```javascript\nSub.prototype = new Super();\n```\n\n上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。\n\n举例来说，下面是一个`Shape`构造函数。\n\n```javascript\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function (x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n```\n\n我们需要让`Rectangle`构造函数继承`Shape`。\n\n```javascript\n// 第一步，子类继承父类的实例\nfunction Rectangle() {\n  Shape.call(this); // 调用父类构造函数\n}\n// 另一种写法\nfunction Rectangle() {\n  this.base = Shape;\n  this.base();\n}\n\n// 第二步，子类继承父类的原型\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n```\n\n采用这样的写法以后，`instanceof`运算符会对子类和父类的构造函数，都返回`true`。\n\n```javascript\nvar rect = new Rectangle();\n\nrect instanceof Rectangle  // true\nrect instanceof Shape  // true\n```\n\n上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。\n\n```javascript\nClassB.prototype.print = function() {\n  ClassA.prototype.print.call(this);\n  // some code\n}\n```\n\n上面代码中，子类`B`的`print`方法先调用父类`A`的`print`方法，再部署自己的代码。这就等于继承了父类`A`的`print`方法。\n\n#### 多重继承\n\nJavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。\n\n```javascript\nfunction M1() {\n  this.hello = 'hello';\n}\n\nfunction M2() {\n  this.world = 'world';\n}\n\nfunction S() {\n  M1.call(this);\n  M2.call(this);\n}\n\n// 继承 M1\nS.prototype = Object.create(M1.prototype);\n// 继承链上加入 M2\nObject.assign(S.prototype, M2.prototype);\n\n// 指定构造函数\nS.prototype.constructor = S;\n\nvar s = new S();\ns.hello // 'hello'\ns.world // 'world'\n```\n\n上面代码中，子类`S`同时继承了父类`M1`和`M2`。这种模式又称为 Mixin（混入）。\n\n#### 模块\n\n随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。\n\nJavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。\n\n但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。\n\n##### 基本的实现方法\n\n模块是实现特定功能的一组属性和方法的封装。\n\n简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。\n\n```javascript\nvar module1 = new Object({\n　_count : 0,\n　m1 : function (){\n　　//...\n　},\n　m2 : function (){\n  　//...\n　}\n});\n```\n\n上面的函数`m1`和`m2`，都封装在`module1`对象里。使用的时候，就是调用这个对象的属性。\n\n```javascript\nmodule1.m1();\n```\n\n但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\n\n```javascript\nmodule1._count = 5;\n```\n\n##### 封装私有变量：构造函数的写法\n\n我们可以利用构造函数，封装私有变量。\n\n```javascript\nfunction StringBuilder() {\n  var buffer = [];\n\n  this.add = function (str) {\n     buffer.push(str);\n  };\n\n  this.toString = function () {\n    return buffer.join('');\n  };\n\n}\n```\n\n上面代码中，`buffer`是模块的私有变量。一旦生成实例对象，外部是无法直接访问`buffer`的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。\n\n```javascript\nfunction StringBuilder() {\n  this._buffer = [];\n}\n\nStringBuilder.prototype = {\n  constructor: StringBuilder,\n  add: function (str) {\n    this._buffer.push(str);\n  },\n  toString: function () {\n    return this._buffer.join('');\n  }\n};\n```\n\n这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。\n\n##### 封装私有变量：立即执行函数的写法\n\n另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。\n\n```javascript\nvar module1 = (function () {\n　var _count = 0;\n　var m1 = function () {\n　  //...\n　};\n　var m2 = function () {\n　　//...\n　};\n　return {\n　　m1 : m1,\n　　m2 : m2\n　};\n})();\n```\n\n使用上面的写法，外部代码无法读取内部的`_count`变量。\n\n```javascript\nconsole.info(module1._count); //undefined\n```\n\n上面的`module1`就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。\n\n##### 模块的放大模式\n\n如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。\n\n```javascript\nvar module1 = (function (mod){\n　mod.m3 = function () {\n　　//...\n　};\n　return mod;\n})(module1);\n```\n\n上面的代码为`module1`模块添加了一个新方法`m3()`，然后返回新的`module1`模块。\n\n在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用\"宽放大模式\"（Loose augmentation）。\n\n```javascript\nvar module1 = (function (mod) {\n　//...\n　return mod;\n})(window.module1 || {});\n```\n\n与\"放大模式\"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。\n\n##### 输入全局变量\n\n独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\n\n为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\n\n```javascript\nvar module1 = (function ($, YAHOO) {\n　//...\n})(jQuery, YAHOO);\n```\n\n上面的`module1`模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入`module1`。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\n\n立即执行函数还可以起到命名空间的作用。\n\n```javascript\n(function($, window, document) {\n\n  function go(num) {\n  }\n\n  function handleEvents() {\n  }\n\n  function initialize() {\n  }\n\n  function dieCarouselDie() {\n  }\n\n  //attach to the global scope\n  window.finalCarousel = {\n    init : initialize,\n    destroy : dieCarouselDie\n  }\n\n})( jQuery, window, document );\n```\n\n上面代码中，`finalCarousel`对象输出到全局，对外暴露`init`和`destroy`接口，内部方法`go`、`handleEvents`、`initialize`、`dieCarouselDie`都是外部无法调用的。\n\n## Array\n\n### adding element\n\n及时你使用了const来作为array，你虽然不能reassign this array to something else，但是你可以增加删除其中的元素。\n\n```javascript\nconst numbers = [3,4];\n//add at the end\nnumbers.push(5,6);\n//add at the beginning\nnumbers.unshift(1,2);\n//middle\n//第一个：位置，第二：删除的元素数量，第三以及之后：添加的内容\nnumbers.splice(2,0,'a','b');\n\n```\n\n### Find element\n\n```javascript\n// it is easy to find a primitive type\nnumbers.includes(1);\nnumbers.indexOf(1);\nnumbers.lastIndexOf(1);\n\n// to find an object\nconst course = courses.find(function(course) {\n  return course.name === 'xyz';\n});\n```\n\n### Arrow functions\n\nlooks like java lambda\n\n```javascript\nconst course = courses.find(course => course.name === 'a');\n```\n\n### Removing Element\n\n```javascript\nconst numbers = [1,2,3,4];\n\n//end\nnumbers.pop();\n\n//beginning\nnumbers.shift();\n\n//middle\nnumbers.splice(2, 3); //first is offset, second is the number of elements you want to delete\n```\n\n### Empty an array\n\n```javascript\n//Solution 1\nlet num = [1,2,3];\nlet num1 = num;\n\nnum = []; //in this solution, num is reassigned but num1 is still pointing to the num, so the info of num will not be garbage collected\n\n//Solution 2\nnumbers.length = 0;\n\n//Solution 3\nnumbers.splice(0, numbers.length);\n\n//Solution 4\nwhile (numbers.length > 0) {\n  numbers.pop();\n}\n```\n\n### Combing Arrays\n\n```javascript\nconst first = [1,2,3];\nconst second = [4,5,6];\nconst combined = first.concat(second);\nconst sllice = combined.slice(2,4);\n```\n\n### Iterate Array\n\n```javascript\nfor (let num of nums) {\n\tconsole.log(num);\n}\nnums.forEach(function(number){\n  console.log(number);\n});\n// after es6\nnums.forEach(number => console.log(number));\nnums.forEach((number, index) => console.log(index, number)); // the second value is index, the first is the value\n```\n\n### Join array\n\n```javascript\nconst numbers = [1,2,3]\nconst joined = numbers.join('-');//default is comma\n// result is 1-2-3\n```\n\n### Sort\n\n```javascript\nconst numbers = [1,2,3]\nnumbers.sort();\nnumbers.reverse();\n```\n\n### Every and some\n\n```javascript\nconst numbers = [1,2,3]\nconst k = numbers.every(function(value){\n  return value >= 0;\n});// all passed then return true, else return false\n\nconst k = numbers.some(function(value){\n  return value >= 0;\n});// at leaset one match then return true, else return false\n```\n\n### Filter an array\n\n```javascript\nconst filtered = numbers.filter(function(value){\n  return value >= 0;\n});\n\nconst filtered = numbers.filter(value => value >= 0);\n```\n\n### Mapping\n\n```javascript\nconst items = filtered.map(n => ({value : n}));\n```\n\n### Reduce\n\n```javascript\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n\nconst sum = numbers.reduce((accumulator, currentValue) => {\n  return accumulator + currentValue;\n});\n```\n\n## Function\n\n```javascript\ncalcRectArea(3,4); // run it before the declaration is okay\n\n// this is a function declaration\nfunction calcRectArea(width, height) {\n  return width * height;\n}\n\ngetRectArea(3,4); // run it before the expression then there will be error\n\n// this is a function expression, and is an anonymous(there is also named) function expression\nconst getRectArea = function(width, height) {\n  return width * height;\n}\n```\n\nHoisting: JavaScript engine will automatically move the function declaration to the top of the file\n\nArguments: all the input elemments will be shown as argument in the function with there index. For a funtion who needs 2 elements, if you input 5 elements, that doesn't matter, the function will only use the first two number\n\nDefault Value: same like python, define it in the parameters\n\n### Getter and Setter\n\n```javascript\nvar person = {\n  firstName: \"John\",\n  lastName : \"Doe\",\n  language : \"en\",\n  get lang() {\n    return this.language;\n  }\n  set lang(lang) {\n    this.language = lang;\n  }\n};\n\n// Set an object property using a setter:\nperson.lang = \"en\";\n// Display data from the object using a getter:\ndocument.getElementById(\"demo\").innerHTML = person.lang;\n\n```\n\n### Try and catch\n\n#### The throw Statement\n\nThe `throw` statement allows you to create a custom error.\n\nTechnically you can **throw an exception (throw an error)**.\n\n```javascript\nthrow \"Too big\";    // throw a text\nthrow 500;          // throw a number\nthrow new Error('value is invalid');\n```\n\n\n\nIf you use `throw` together with `try` and `catch`, you can control program flow and generate custom error messages.\n\n#### Try catch finally\n\n```javascript\nfunction myFunction() {\n  var message, x;\n  message = document.getElementById(\"p01\");\n  message.innerHTML = \"\";\n  x = document.getElementById(\"demo\").value;\n  try {\n    if(x == \"\") throw \"empty\";\n    if(isNaN(x)) throw \"not a number\";\n    x = Number(x);\n    if(x < 5) throw \"too low\";\n    if(x > 10) throw \"too high\";\n  }\n  catch(e) {\n    message.innerHTML = \"Input is \" + e;\n    alert(e);\n  }\n  finally {\n    document.getElementById(\"demo\").value = \"\";\n  }\n}\n```\n\n## Let and Var\n\n### ES6可以用let定义块级作用域变量\n\n在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以`{}`限定不了var声明变量的访问范围。\n例如：\n\n```javascript\n{\n  var i = 9;\n}\nconsole.log(i);  // 9\n```\n\nES6新增的`let`，可以声明块级作用域的变量。\n\n```javascript\n{\n  let i = 9;     // i变量只在 花括号内有效！！！\n}\nconsole.log(i);  // Uncaught ReferenceError: i is not defined\n```\n\n### let 配合for循环的独特应用\n\n`let`非常适合用于 `for`循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：\n\n```javascript\nfor (var i = 0; i <10; i++) {  \n  setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列。\n    console.log(i);        // 执行此代码时，同步代码for循环已经执行完成\n  }, 0);\n}\n// 输出结果\n10   共10个\n// 这里面的知识点： JS的事件循环机制，setTimeout的机制等\n```\n\n如果把 `var`改成 `let`声明：\n\n```javascript\n// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i);    //  i 是循环体内局部作用域，不受外界影响。\n  }, 0);\n}\n// 输出结果：\n0  1  2  3  4  5  6  7  8 9\n```\n\n### let没有变量提升与暂时性死区\n\n用`let`声明的变量，不存在变量提升。而且要求必须 等`let`声明语句执行完之后，变量才能使用，不然会报`Uncaught ReferenceError`错误。\n例如：\n\n```javascript\nconsole.log(aicoder);    // 错误：Uncaught ReferenceError ...\nlet aicoder = 'aicoder.com';\n// 这里就可以安全使用aicoder\n```\n\n> ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n> 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n### let变量不能重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。否则报错：`Uncaught SyntaxError: Identifier 'XXX' has already been declared`\n\n例如：\n\n```javascript\nlet a = 0;\nlet a = 'sss';\n// Uncaught SyntaxError: Identifier 'a' has already been declared\n```\n\n## 错误处理机制\n\n### Error 实例对象\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n```javascript\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n\n上面代码中，我们调用`Error`构造函数，生成一个实例对象`err`。`Error`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\n\nJavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n- **message**：错误提示信息\n- **name**：错误名称（非标准属性）\n- **stack**：错误的堆栈（非标准属性）\n\n使用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。\n\n```javascript\nif (error.name) {\n  console.log(error.name + ': ' + error.message);\n}\n```\n\n`stack`属性用来查看错误发生时的堆栈。\n\n```javascript\nfunction throwit() {\n  throw new Error('');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n```\n\n上面代码中，错误堆栈的最内层是`throwit`函数，然后是`catchit`函数，最后是函数的运行环境。\n\n### 原生错误类型\n\n`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个派生对象。\n\n#### SyntaxError 对象\n\n`SyntaxError`对象是解析代码时发生的语法错误。\n\n```javascript\n// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log 'hello');\n// Uncaught SyntaxError: Unexpected string\n```\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n#### ReferenceError 对象\n\n`ReferenceError`对象是引用一个不存在的变量时发生的错误。\n\n```javascript\n// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n```\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。\n\n```javascript\n// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n```\n\n上面代码对函数`console.log`的运行结果赋值，结果引发了`ReferenceError`错误。\n\n#### RangeError 对象\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n```javascript\n// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n```\n\n#### TypeError 对象\n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。\n\n```javascript\nnew 123\n// Uncaught TypeError: number is not a func\n\nvar obj = {};\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n```\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。\n\n#### URIError 对象\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n```javascript\ndecodeURI('%2')\n// URIError: URI malformed\n```\n\n#### EvalError 对象\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n#### 总结\n\n以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\n```javascript\nvar err1 = new Error('出错了！');\nvar err2 = new RangeError('出错了，变量超出有效范围！');\nvar err3 = new TypeError('出错了，变量类型无效！');\n\nerr1.message // \"出错了！\"\nerr2.message // \"出错了，变量超出有效范围！\"\nerr3.message // \"出错了，变量类型无效！\"\n```\n\n### 自定义错误\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n\n上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。\n\n```javascript\nnew UserError('这是自定义的错误！');\n```\n\n### throw 语句\n\n`throw`语句的作用是手动中断程序执行，抛出一个错误。\n\n```javascript\nif (x <= 0) {\n  throw new Error('x 必须为正数');\n}\n// Uncaught ReferenceError: x is not defined\n```\n\n上面代码中，如果变量`x`小于等于`0`，就手动抛出一个错误，告诉用户`x`的值不正确，整个程序就会在这里中断执行。可以看到，`throw`抛出的错误就是它的参数，这里是一个`Error`实例。\n\n`throw`也可以抛出自定义错误。\n\n```javascript\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nthrow new UserError('出错了！');\n// Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n```\n\n上面代码中，`throw`抛出的是一个`UserError`实例。\n\n实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n```javascript\n// 抛出一个字符串\nthrow 'Error！';\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow {\n  toString: function () {\n    return 'Error!';\n  }\n};\n// Uncaught {toString: ƒ}\n```\n\n对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\n### try...catch 结构\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n```javascript\ntry {\n  throw new Error('出错了!');\n} catch (e) {\n  console.log(e.name + \": \" + e.message);\n  console.log(e.stack);\n}\n// Error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n```\n\n上面代码中，`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。\n\n如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。\n\n```javascript\ntry {\n  f();\n} catch(e) {\n  // 处理错误\n}\n```\n\n上面代码中，如果函数`f`执行报错，就会进行`catch`代码块，接着对错误进行处理。\n\n`catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\n```javascript\ntry {\n  throw \"出错了\";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n```\n\n上面代码中，`try`代码块抛出的错误，被`catch`代码块捕获后，程序会继续向下执行。\n\n`catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。\n\n```javascript\nvar n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// Uncaught 100\n```\n\n上面代码中，`catch`代码之中又抛出了一个错误。\n\n为了捕捉不同类型的错误，`catch`代码块之中可以加入判断语句。\n\n```javascript\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n```\n\n上面代码中，`catch`捕获错误之后，会判断错误类型（`EvalError`还是`RangeError`），进行不同的处理。\n\n### finally 代码块\n\n`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n```javascript\nfunction cleansUp() {\n  try {\n    throw new Error('出错了……');\n    console.log('此行不会执行');\n  } finally {\n    console.log('完成清理工作');\n  }\n}\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (<anonymous>:3:11)\n//    at <anonymous>:10:1\n```\n\n上面代码中，由于没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。\n\n```javascript\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log('FINALLY');\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n```\n\n上面代码中，`try`代码块没有发生错误，而且里面还包括`return`语句，但是`finally`代码块依然会执行。而且，这个函数的返回值还是`result`。\n\n下面的例子说明，`return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。\n\n```javascript\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n```\n\n上面代码说明，`return`语句里面的`count`的值，是在`finally`代码块运行之前就获取了。\n\n下面是`finally`代码块用法的典型场景。\n\n```javascript\nopenFile();\n\ntry {\n  writeFile(Data);\n} catch(e) {\n  handleError(e);\n} finally {\n  closeFile();\n}\n```\n\n上面代码首先打开一个文件，然后在`try`代码块中写入文件，如果没有发生错误，则运行`finally`代码块关闭文件；一旦发生错误，则先使用`catch`代码块处理错误，再使用`finally`代码块关闭文件。\n\n下面的例子充分反映了`try...catch...finally`这三者之间的执行顺序。\n\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw 'bug';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n```\n\n上面代码中，`catch`代码块结束执行之前，会先执行`finally`代码块。\n\n`catch`代码块之中，触发转入`finally`代码块的标志，不仅有`return`语句，还有`throw`语句。\n\n```javascript\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n```\n\n上面代码中，进入`catch`代码块之后，一遇到`throw`语句，就会去执行`finally`代码块，其中有`return false`语句，因此就直接返回了，不再会回去执行`catch`代码块剩下的部分了。\n\n`try`代码块内部，还可以再使用`try`代码块。\n\n```javascript\ntry {\n  try {\n    consle.log('Hello world!'); // 报错\n  }\n  finally {\n    console.log('Finally');\n  }\n  console.log('Will I run?');\n} catch(error) {\n  console.error(error.message);\n}\n// Finally\n// consle is not defined\n```\n\n上面代码中，`try`里面还有一个`try`。内层的`try`报错（`console`拼错了），这时会执行内层的`finally`代码块，然后抛出错误，被外层的`catch`捕获。\n\n## Console对象与控制台\n\n### console 对象\n\n`console`对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出`stdout`和标准错误`stderr`，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。\n\n`console`的常见用途有两个。\n\n- 调试程序，显示网页代码运行时的错误信息。\n- 提供了一个命令行接口，用来与网页代码互动。\n\n`console`对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。\n\n1. 按 F12 或者`Control + Shift + i`（PC）/ `Command + Option + i`（Mac）。\n2. 浏览器菜单选择“工具/开发者工具”。\n3. 在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。\n\n打开开发者工具以后，顶端有多个面板。\n\n- **Elements**：查看网页的 HTML 源码和 CSS 代码。\n- **Resources**：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\n- **Network**：查看网页的 HTTP 通信情况。\n- **Sources**：查看网页加载的脚本源码。\n- **Timeline**：查看各种网页行为随时间变化的情况。\n- **Performance**：查看网页的性能情况，比如 CPU 和内存消耗。\n- **Console**：用来运行 JavaScript 命令。\n\n这些面板都有各自的用途，以下只介绍`Console`面板（又称为控制台）。\n\n`Console`面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。\n\n### console 对象的静态方法\n\n`console`对象提供的各种静态方法，用来与控制台窗口互动。\n\n#### console.log()，console.info()，console.debug()\n\n`console.log`方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。\n\n```javascript\nconsole.log('Hello World')\n// Hello World\nconsole.log('a', 'b', 'c')\n// a b c\n```\n\n`console.log`方法会自动在每次输出的结尾，添加换行符。\n\n```javascript\nconsole.log(1);\nconsole.log(2);\nconsole.log(3);\n// 1\n// 2\n// 3\n```\n\n如果第一个参数是格式字符串（使用了格式占位符），`console.log`方法将依次用后面的参数替换占位符，然后再进行输出。\n\n```javascript\nconsole.log(' %s + %s = %s', 1, 1, 2)\n//  1 + 1 = 2\n```\n\n上面代码中，`console.log`方法的第一个参数有三个占位符（`%s`），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。\n\n`console.log`方法支持以下占位符，不同类型的数据必须使用对应的占位符。\n\n- `%s` 字符串\n- `%d` 整数\n- `%i` 整数\n- `%f` 浮点数\n- `%o` 对象的链接\n- `%c` CSS 格式字符串\n\n```javascript\nvar number = 11 * 9;\nvar color = 'red';\n\nconsole.log('%d %s balloons', number, color);\n// 99 red balloons\n```\n\n上面代码中，第二个参数是数值，对应的占位符是`%d`，第三个参数是字符串，对应的占位符是`%s`。\n\n使用`%c`占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。\n\n```javascript\nconsole.log(\n  '%cThis text is styled!',\n  'color: red; background: yellow; font-size: 24px;'\n)\n```\n\n上面代码运行后，输出的内容将显示为黄底红字。\n\n`console.log`方法的两种参数格式，可以结合在一起使用。\n\n```javascript\nconsole.log(' %s + %s ', 1, 1, '= 2')\n// 1 + 1  = 2\n```\n\n如果参数是一个对象，`console.log`会显示该对象的值。\n\n```javascript\nconsole.log({foo: 'bar'})\n// Object {foo: \"bar\"}\nconsole.log(Date)\n// function Date() { [native code] }\n```\n\n上面代码输出`Date`对象的值，结果为一个构造函数。\n\n`console.info`是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。\n\n`console.debug`方法与`console.log`方法类似，会在控制台输出调试信息。但是，默认情况下，`console.debug`输出的信息不会显示，只有在打开显示级别在`verbose`的情况下，才会显示。\n\n`console`对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义`console.log`方法。\n\n```javascript\n['log', 'info', 'warn', 'error'].forEach(function(method) {\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n});\n\nconsole.log(\"出错了！\");\n// 2014-05-18T09:00.000Z 出错了！\n```\n\n上面代码表示，使用自定义的`console.log`方法，可以在显示结果添加当前时间。\n\n#### console.warn()，console.error()\n\n`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。\n\n```javascript\nconsole.error('Error: %s (%i)', 'Server is not responding', 500)\n// Error: Server is not responding (500)\nconsole.warn('Warning! Too few nodes (%d)', document.childNodes.length)\n// Warning! Too few nodes (1)\n```\n\n可以这样理解，`log`方法是写入标准输出（`stdout`），`warn`方法和`error`方法是写入标准错误（`stderr`）。\n\n#### console.table()\n\n对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。\n\n```javascript\nvar languages = [\n  { name: \"JavaScript\", fileExtension: \".js\" },\n  { name: \"TypeScript\", fileExtension: \".ts\" },\n  { name: \"CoffeeScript\", fileExtension: \".coffee\" }\n];\n\nconsole.table(languages);\n```\n\n上面代码的`language`变量，转为表格显示如下。\n\n| (index) | name           | fileExtension |\n| :------ | :------------- | :------------ |\n| 0       | \"JavaScript\"   | \".js\"         |\n| 1       | \"TypeScript\"   | \".ts\"         |\n| 2       | \"CoffeeScript\" | \".coffee\"     |\n\n下面是显示表格内容的例子。\n\n```javascript\nvar languages = {\n  csharp: { name: \"C#\", paradigm: \"object-oriented\" },\n  fsharp: { name: \"F#\", paradigm: \"functional\" }\n};\n\nconsole.table(languages);\n```\n\n上面代码的`language`，转为表格显示如下。\n\n| (index) | name | paradigm          |\n| :------ | :--- | :---------------- |\n| csharp  | \"C#\" | \"object-oriented\" |\n| fsharp  | \"F#\" | \"functional\"      |\n\n#### console.count()\n\n`count`方法用于计数，输出它被调用了多少次。\n\n```javascript\nfunction greet(user) {\n  console.count();\n  return 'hi ' + user;\n}\n\ngreet('bob')\n//  : 1\n// \"hi bob\"\n\ngreet('alice')\n//  : 2\n// \"hi alice\"\n\ngreet('bob')\n//  : 3\n// \"hi bob\"\n```\n\n上面代码每次调用`greet`函数，内部的`console.count`方法就输出执行次数。\n\n该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\n\n```javascript\nfunction greet(user) {\n  console.count(user);\n  return \"hi \" + user;\n}\n\ngreet('bob')\n// bob: 1\n// \"hi bob\"\n\ngreet('alice')\n// alice: 1\n// \"hi alice\"\n\ngreet('bob')\n// bob: 2\n// \"hi bob\"\n```\n\n上面代码根据参数的不同，显示`bob`执行了两次，`alice`执行了一次。\n\n#### console.dir()，console.dirxml()\n\n`dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n```javascript\nconsole.log({f1: 'foo', f2: 'bar'})\n// Object {f1: \"foo\", f2: \"bar\"}\n\nconsole.dir({f1: 'foo', f2: 'bar'})\n// Object\n//   f1: \"foo\"\n//   f2: \"bar\"\n//   __proto__: Object\n```\n\n上面代码显示`dir`方法的输出结果，比`log`方法更易读，信息也更丰富。\n\n该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。\n\n```javascript\nconsole.dir(document.body)\n```\n\nNode 环境之中，还可以指定以代码高亮的形式输出。\n\n```javascript\nconsole.dir(obj, {colors: true})\n```\n\n`dirxml`方法主要用于以目录树的形式，显示 DOM 节点。\n\n```javascript\nconsole.dirxml(document.body)\n```\n\n如果参数不是 DOM 节点，而是普通的 JavaScript 对象，`console.dirxml`等同于`console.dir`。\n\n```javascript\nconsole.dirxml([1, 2, 3])\n// 等同于\nconsole.dir([1, 2, 3])\n```\n\n#### console.assert()\n\n`console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。\n\n它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。\n\n```javascript\nconsole.assert(false, '判断条件不成立')\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry {\n  if (!false) {\n    throw new Error('判断条件不成立');\n  }\n} catch(e) {\n  console.error(e);\n}\n```\n\n下面是一个例子，判断子节点的个数是否大于等于500。\n\n```javascript\nconsole.assert(list.childNodes.length < 500, '节点个数大于等于500')\n```\n\n上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。\n\n#### console.time()，console.timeEnd()\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\n```javascript\nconsole.time('Array initialize');\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n  array[i] = new Object();\n};\n\nconsole.timeEnd('Array initialize');\n// Array initialize: 1914.481ms\n```\n\n`time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n#### console.group()，console.groupEnd()，console.groupCollapsed()\n\n`console.group`和`console.groupEnd`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。\n\n```javascript\nconsole.group('一级分组');\nconsole.log('一级分组的内容');\n\nconsole.group('二级分组');\nconsole.log('二级分组的内容');\n\nconsole.groupEnd(); // 二级分组结束\nconsole.groupEnd(); // 一级分组结束\n```\n\n上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。\n\n`console.groupCollapsed`方法与`console.group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\n\n```javascript\nconsole.groupCollapsed('Fetching Data');\n\nconsole.log('Request Sent');\nconsole.error('Error: Server not responding (500)');\n\nconsole.groupEnd();\n```\n\n上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。\n\n#### console.trace()，console.clear()\n\n`console.trace`方法显示当前执行的代码在堆栈中的调用路径。\n\n```javascript\nconsole.trace()\n// console.trace()\n//   (anonymous function)\n//   InjectedScript._evaluateOn\n//   InjectedScript._evaluateAndWrap\n//   InjectedScript.evaluate\n```\n\n`console.clear`方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，`console.clear`方法将不起作用。\n\n### 控制台命令行 API\n\n浏览器控制台中，除了使用`console`对象，还可以使用一些控制台自带的命令行方法。\n\n（1）`$_`\n\n`$_`属性返回上一个表达式的值。\n\n```javascript\n2 + 2\n// 4\n$_\n// 4\n```\n\n（2）`$0` - `$4`\n\n控制台保存了最近5个在 Elements 面板选中的 DOM 元素，`$0`代表倒数第一个（最近一个），`$1`代表倒数第二个，以此类推直到`$4`。\n\n（3）`$(selector)`\n\n`$(selector)`返回第一个匹配的元素，等同于`document.querySelector()`。注意，如果页面脚本对`$`有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行`$(selector)`就会采用 jQuery 的实现，返回一个数组。\n\n（4）`$$(selector)`\n\n`$$(selector)`返回选中的 DOM 对象，等同于`document.querySelectorAll`。\n\n（5）`$x(path)`\n\n`$x(path)`方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。\n\n```javascript\n$x(\"//p[a]\")\n```\n\n上面代码返回所有包含`a`元素的`p`元素。\n\n（6）`inspect(object)`\n\n`inspect(object)`方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在`Elements`面板中显示，比如`inspect(document)`会在 Elements 面板显示`document`元素。JavaScript 对象在控制台面板`Profiles`面板中显示，比如`inspect(window)`。\n\n（7）`getEventListeners(object)`\n\n`getEventListeners(object)`方法返回一个对象，该对象的成员为`object`登记了回调函数的各种事件（比如`click`或`keydown`），每个事件对应一个数组，数组的成员为该事件的回调函数。\n\n（8）`keys(object)`，`values(object)`\n\n`keys(object)`方法返回一个数组，包含`object`的所有键名。\n\n`values(object)`方法返回一个数组，包含`object`的所有键值。\n\n```javascript\nvar o = {'p1': 'a', 'p2': 'b'};\n\nkeys(o)\n// [\"p1\", \"p2\"]\nvalues(o)\n// [\"a\", \"b\"]\n```\n\n（9）`monitorEvents(object[, events]) ，unmonitorEvents(object[, events])`\n\n`monitorEvents(object[, events])`方法监听特定对象上发生的特定事件。事件发生时，会返回一个`Event`对象，包含该事件的相关信息。`unmonitorEvents`方法用于停止监听。\n\n```javascript\nmonitorEvents(window, \"resize\");\nmonitorEvents(window, [\"resize\", \"scroll\"])\n```\n\n上面代码分别表示单个事件和多个事件的监听方法。\n\n```javascript\nmonitorEvents($0, 'mouse');\nunmonitorEvents($0, 'mousemove');\n```\n\n上面代码表示如何停止监听。\n\n`monitorEvents`允许监听同一大类的事件。所有事件可以分成四个大类。\n\n- mouse：\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"mousemove\", \"mouseover\", \"mouseout\", \"mousewheel\"\n- key：\"keydown\", \"keyup\", \"keypress\", \"textInput\"\n- touch：\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"\n- control：\"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"change\", \"submit\", \"reset\"\n\n```javascript\nmonitorEvents($(\"#msg\"), \"key\");\n```\n\n上面代码表示监听所有`key`大类的事件。\n\n（10）其他方法\n\n命令行 API 还提供以下方法。\n\n- `clear()`：清除控制台的历史。\n- `copy(object)`：复制特定 DOM 元素到剪贴板。\n- `dir(object)`：显示特定对象的所有属性，是`console.dir`方法的别名。\n- `dirxml(object)`：显示特定对象的 XML 形式，是`console.dirxml`方法的别名。\n\n### debugger 语句\n\n`debugger`语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到`debugger`语句时会自动停下。如果没有除错工具，`debugger`语句不会产生任何结果，JavaScript 引擎自动跳过这一句。\n\nChrome 浏览器中，当代码运行到`debugger`语句时，就会暂停运行，自动打开脚本源码界面。\n\n```javascript\nfor(var i = 0; i < 5; i++){\n  console.log(i);\n  if (i === 2) debugger;\n}\n```\n\n上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。\n\n## 异步操作概述\n\n### 单线程模型\n\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\n\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\n\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\n\n如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。\n\n单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。\n\n为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。\n\n### 同步任务和异步任务\n\n程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。\n\n同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。\n\n异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。\n\n举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。\n\n### 任务队列和事件循环\n\nJavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）\n\n首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。\n\n异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。\n\nJavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。[维基百科](https://en.wikipedia.org/wiki/Event_loop)的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。\n\n### 异步操作的模式\n\n下面总结一下异步操作的几种模式。\n\n#### 回调函数\n\n回调函数是异步操作最基本的方法。\n\n下面是两个函数`f1`和`f2`，编程的意图是`f2`必须等到`f1`执行完成，才能执行。\n\n```javascript\nfunction f1() {\n  // ...\n}\n\nfunction f2() {\n  // ...\n}\n\nf1();\nf2();\n```\n\n上面代码的问题在于，如果`f1`是异步操作，`f2`会立即执行，不会等到`f1`结束再执行。\n\n这时，可以考虑改写`f1`，把`f2`写成`f1`的回调函数。\n\n```javascript\nfunction f1(callback) {\n  // ...\n  callback();\n}\n\nfunction f2() {\n  // ...\n}\n\nf1(f2);\n```\n\n回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](https://en.wikipedia.org/wiki/Coupling_(computer_programming))（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\n\n#### 事件监听\n\n另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n\n还是以`f1`和`f2`为例。首先，为`f1`绑定一个事件（这里采用的 jQuery 的[写法](https://api.jquery.com/on/)）。\n\n```javascript\nf1.on('done', f2);\n```\n\n上面这行代码的意思是，当`f1`发生`done`事件，就执行`f2`。然后，对`f1`进行改写：\n\n```javascript\nfunction f1() {\n  setTimeout(function () {\n    // ...\n    f1.trigger('done');\n  }, 1000);\n}\n```\n\n上面代码中，`f1.trigger('done')`表示，执行完成后，立即触发`done`事件，从而开始执行`f2`。\n\n这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“[去耦合](https://en.wikipedia.org/wiki/Decoupling)”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。\n\n#### 发布/订阅\n\n事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](https://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。\n\n这个模式有多种[实现](https://msdn.microsoft.com/en-us/magazine/hh201955.aspx)，下面采用的是 Ben Alman 的 [Tiny Pub/Sub](https://gist.github.com/661855)，这是 jQuery 的一个插件。\n\n首先，`f2`向信号中心`jQuery`订阅`done`信号。\n\n```javascript\njQuery.subscribe('done', f2);\n```\n\n然后，`f1`进行如下改写。\n\n```javascript\nfunction f1() {\n  setTimeout(function () {\n    // ...\n    jQuery.publish('done');\n  }, 1000);\n}\n```\n\n上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。\n\n`f2`完成执行后，可以取消订阅（unsubscribe）。\n\n```javascript\njQuery.unsubscribe('done', f2);\n```\n\n这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n### 异步操作的流程控制\n\n如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。\n\n```javascript\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n```\n\n上面代码的`async`函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。\n\n如果有六个这样的异步任务，需要全部完成后，才能执行最后的`final`函数。请问应该如何安排操作流程？\n\n```javascript\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nasync(1, function (value) {\n  async(2, function (value) {\n    async(3, function (value) {\n      async(4, function (value) {\n        async(5, function (value) {\n          async(6, final);\n        });\n      });\n    });\n  });\n});\n// 参数为 1 , 1秒后返回结果\n// 参数为 2 , 1秒后返回结果\n// 参数为 3 , 1秒后返回结果\n// 参数为 4 , 1秒后返回结果\n// 参数为 5 , 1秒后返回结果\n// 参数为 6 , 1秒后返回结果\n// 完成:  12\n```\n\n上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。\n\n#### 串行执行\n\n我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction series(item) {\n  if(item) {\n    async( item, function(result) {\n      results.push(result);\n      return series(items.shift());\n    });\n  } else {\n    return final(results[results.length - 1]);\n  }\n}\n\nseries(items.shift());\n```\n\n上面代码中，函数`series`就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行`final`函数。`items`数组保存每一个异步任务的参数，`results`数组保存每一个异步任务的运行结果。\n\n注意，上面的写法需要六秒，才能完成整个脚本。\n\n#### 并行执行\n\n流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行`final`函数。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nitems.forEach(function(item) {\n  async(item, function(result){\n    results.push(result);\n    if(results.length === items.length) {\n      final(results[results.length - 1]);\n    }\n  })\n});\n```\n\n上面代码中，`forEach`方法会同时发起六个异步任务，等到它们全部完成以后，才会执行`final`函数。\n\n相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。\n\n#### 并行与串行的结合\n\n所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行`n`个异步任务，这样就避免了过分占用系统资源。\n\n```javascript\nvar items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\nvar running = 0;\nvar limit = 2;\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction launcher() {\n  while(running < limit && items.length > 0) {\n    var item = items.shift();\n    async(item, function(result) {\n      results.push(result);\n      running--;\n      if(items.length > 0) {\n        launcher();\n      } else if(running == 0) {\n        final(results);\n      }\n    });\n    running++;\n  }\n}\n\nlauncher();\n```\n\n上面代码中，最多只能同时运行两个异步任务。变量`running`记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于`0`，就表示所有任务都执行完了，这时就执行`final`函数。\n\n这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节`limit`变量，达到效率和资源的最佳平衡。\n","slug":"入门JavaScript笔记","published":1,"updated":"2020-03-29T06:59:20.716Z","photos":[],"link":"","_id":"ck8ct7kgz003ngtvi7lfge1by","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p>\n<p>本笔记基于udemy课程JavaScript basics for beginners，你可以在YouTube上看到相关试听视频</p>\n<p>部分基于udemy课程Modern JavaScript From The Beginning</p>\n<p>部分笔记来源：<a href=\"https://wangdoc.com/javascript/index.html\" target=\"_blank\" rel=\"noopener\">JavaScript</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>关于ES6：<a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6</a></p>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><ol>\n<li>安装live server 插件 in vscode</li>\n<li>在项目新建一个hello world的html，右键你的html然后用live server打开</li>\n<li>假如你html有改动，在html中的内容会自动刷新到live server</li>\n</ol>\n<p>推荐：bracket pair colorizer、JavaScript (ES6) code snippets</p>\n<p>基础：</p>\n<ul>\n<li><p>js脚本可以添加到head或添加到body，建议添加到body的末尾</p>\n</li>\n<li><p>chrome中alt+command+i打开console</p>\n</li>\n</ul>\n<h2 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2><p>在ES6之前，js常常用var来定义变量，但在ES6之后var不再被推荐，建议使用let来定义变量</p>\n<p>在JavaScript中假如你没有define一个变量则其值为undefined</p>\n<p>在JavaScript中一般用单引号来括起string</p>\n<p>Variable不能是保留字（reserved keyword），最好有意义，并且不以数字开头，不能有空格和短杠-（hyphen），命名方式同样遵循camel notation（驼峰命名法），variable都是case-sensitive的</p>\n<p>可以同时initialize多个变量，用逗号隔开</p>\n<h3 id=\"constants\"><a href=\"#constants\" class=\"headerlink\" title=\"constants\"></a>constants</h3><p>假如你使用的是const而不是var，那么你的变量不能被修改</p>\n<h2 id=\"Primitive-types\"><a href=\"#Primitive-types\" class=\"headerlink\" title=\"Primitive types\"></a>Primitive types</h2><p>JavaScript共有两种value可以assign给variable，一种是primitives(aka. value types)，一种是reference type，</p>\n<h3 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h3><ul>\n<li>String</li>\n<li>Number（在JavaScript中没有float，double这种类型，只有统一的number）</li>\n<li>Boolean</li>\n<li>undefined（是一种type，同时是一个value）</li>\n<li>null</li>\n</ul>\n<p>假如当前我们有一个变量，我们没有它的值，但是知晓这个variable将来是什么type，这时候我们就将它设为null，而不是设为undefined</p>\n<h3 id=\"Dynamic-typing\"><a href=\"#Dynamic-typing\" class=\"headerlink\" title=\"Dynamic typing\"></a>Dynamic typing</h3><p>编程语言有两种，一种是static，一种是dynamic。在static language里，变量设置了type之后就不能再更改。但是在JavaScript中，变量能被修改为其他数据类型。</p>\n<h2 id=\"Reference-types\"><a href=\"#Reference-types\" class=\"headerlink\" title=\"Reference types\"></a>Reference types</h2><h3 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'Mosh'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  name = <span class=\"string\">'Mosh'</span>, <span class=\"comment\">//value pair, key is called properties</span></span><br><span class=\"line\">  age = <span class=\"number\">30</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// this is an object literal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two way to access the properties</span></span><br><span class=\"line\"><span class=\"comment\">// 1. Dot notation</span></span><br><span class=\"line\">person.name = <span class=\"string\">'John'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Bracket notation</span></span><br><span class=\"line\">person[<span class=\"string\">'name'</span>] = <span class=\"string\">'Mary'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Dot notation is more concise and shorter, and it should be your default notation</p>\n<p>But sometimes the variable you wanna use might be dynamic, like</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> selection = <span class=\"string\">'name'</span>;</span><br><span class=\"line\">person[selection] = <span class=\"string\">'Mary'</span></span><br></pre></td></tr></table></figure>\n\n<p>In this case the second notation would be better</p>\n<h3 id=\"Arrays\"><a href=\"#Arrays\" class=\"headerlink\" title=\"Arrays\"></a>Arrays</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span>  selectedColors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>]; <span class=\"comment\">// these square brackets are called array literal</span></span><br><span class=\"line\">selectedColors[<span class=\"number\">2</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// we can store different types of data into the array</span></span><br></pre></td></tr></table></figure>\n\n<p>Type of the array is object</p>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">parameter</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span>) + name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(Your argument);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h2><p>I will ignore the basic common stuff</p>\n<h3 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h3><ul>\n<li>Addition + (increment ++)</li>\n<li>Subtraction - (decrement –)</li>\n<li>Multiplication *</li>\n<li>Division /</li>\n<li>Remainder of division %</li>\n<li>exponentiation **</li>\n</ul>\n<h3 id=\"Assignment-Operators\"><a href=\"#Assignment-Operators\" class=\"headerlink\" title=\"Assignment Operators\"></a>Assignment Operators</h3><ul>\n<li>+=</li>\n<li>-=</li>\n<li>=</li>\n</ul>\n<h3 id=\"Comparasion-Operators\"><a href=\"#Comparasion-Operators\" class=\"headerlink\" title=\"Comparasion Operators\"></a>Comparasion Operators</h3><ul>\n<li>&gt;=</li>\n<li>&lt;=</li>\n<li>==</li>\n<li>===(strict equality operator, have the same type and the same value)</li>\n<li>!==</li>\n<li>==(loose equality operator)</li>\n</ul>\n<p>=== 判断规则:</p>\n<ol>\n<li>如果类型不同，就[不相等]</li>\n<li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）</li>\n<li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。</li>\n<li>如果两个值都是true，或者都是false，那么[相等]。</li>\n<li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。</li>\n<li>如果两个值都是null，或者都是undefined，那么[相等]。</li>\n</ol>\n<p>== 判断规则：</p>\n<ol>\n<li>如果两个值类型相同，进行 === 比较。</li>\n<li>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：</li>\n<li>如果一个是null、一个是undefined，那么[相等]。</li>\n<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。</li>\n<li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。</li>\n<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）</li>\n<li>任何其他组合，都[不相等]。</li>\n</ol>\n<h3 id=\"Ternary-Operators\"><a href=\"#Ternary-Operators\" class=\"headerlink\" title=\"Ternary Operators\"></a>Ternary Operators</h3><p>: ? 三元运算符</p>\n<h3 id=\"Logic-Operators\"><a href=\"#Logic-Operators\" class=\"headerlink\" title=\"Logic Operators\"></a>Logic Operators</h3><ul>\n<li><p>: ?</p>\n</li>\n<li><p>&amp;&amp;</p>\n</li>\n<li><p><code>||</code></p>\n</li>\n</ul>\n<p>the result of a logic operators is not always a boolean value. Eg, false || ‘Mosh’ === ‘Mosh’</p>\n<h4 id=\"Falsy\"><a href=\"#Falsy\" class=\"headerlink\" title=\"Falsy\"></a>Falsy</h4><ol>\n<li>undefined</li>\n<li>null</li>\n<li>0</li>\n<li>false</li>\n<li>‘’</li>\n<li>NaN</li>\n</ol>\n<p>Anything else is truthy</p>\n<p>it will return the first truthy value in the<code>||</code>, eg, false <code>||</code> 1 <code>||</code> 2, it returns 1</p>\n<h3 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h3><ul>\n<li><code>|</code> bitwise or</li>\n<li><code>&amp;</code> bitwise and</li>\n</ul>\n<h2 id=\"Control-flow\"><a href=\"#Control-flow\" class=\"headerlink\" title=\"Control flow\"></a>Control flow</h2><p>I will ignore the parts which is the same as Java (if…else…, while, do…while, switch)</p>\n<h3 id=\"for-loop\"><a href=\"#for-loop\" class=\"headerlink\" title=\"for loop\"></a>for loop</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'Mosh'</span>;</span><br><span class=\"line\">  age: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> person)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(key, person[key]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'green'</span>,<span class=\"string\">'blue'</span>];</span><br><span class=\"line\"><span class=\"comment\">//get you the index with 'in'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> colors)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, colors[index]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//get you the data inside of the array with 'of'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> color <span class=\"keyword\">of</span> colors)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in 和 of的区别就在于，in是在iterate key，而of在iterate value</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// an example of object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = &#123;</span><br><span class=\"line\">  radius: <span class=\"number\">1</span>,</span><br><span class=\"line\">  loaction: &#123;</span><br><span class=\"line\">  \tx: <span class=\"number\">1</span>;</span><br><span class=\"line\">  \ty: <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  isVisible: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  draw: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">circle.draw();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Factory-Function\"><a href=\"#Factory-Function\" class=\"headerlink\" title=\"Factory Function\"></a>Factory Function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircle</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    radius,</span><br><span class=\"line\">    draw() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>using this way to create object, the object.constructor will shows you Object()</p>\n<h3 id=\"Constructor-Function\"><a href=\"#Constructor-Function\" class=\"headerlink\" title=\"Constructor Function\"></a>Constructor Function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Circle</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.radius = radius;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This one looks like a class, but the factory function looks like a function</p>\n<p>构造函数一般首字母大写</p>\n<h3 id=\"Dynamic-Nature\"><a href=\"#Dynamic-Nature\" class=\"headerlink\" title=\"Dynamic Nature\"></a>Dynamic Nature</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> circle = &#123;</span><br><span class=\"line\">  radius: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">circle.color = <span class=\"string\">'yello'</span>; <span class=\"comment\">// add properties</span></span><br><span class=\"line\">circle.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> circle.color; <span class=\"comment\">// remove properties</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> circle.draw;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cloning-an-object\"><a href=\"#Cloning-an-object\" class=\"headerlink\" title=\"Cloning an object\"></a>Cloning an object</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> another = <span class=\"built_in\">Object</span>.assign(newObj, oldObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> another = &#123;...target&#125;; <span class=\"comment\">// three dots means all the properties inside of the old object</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Garbage-Collection\"><a href=\"#Garbage-Collection\" class=\"headerlink\" title=\"Garbage Collection\"></a>Garbage Collection</h3><p>All the process is automatic and you cannot clean the memory mannualy.</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>There is primitive string and object String, primitive string can also use functions, and they will be wrapped as String object</p>\n<p>Escape character(转义字符)</p>\n<p>在JavaScript中，引号间的换行会被记录</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> another =</span><br><span class=\"line\">‘This is my $&#123;message&#125;</span><br><span class=\"line\"><span class=\"string\">'first'</span> message<span class=\"string\">';</span></span><br></pre></td></tr></table></figure>\n\n<p>输出会是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is my hello</span><br><span class=\"line\">&#39;first&#39; message</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><h4 id=\"原型对象概述\"><a href=\"#原型对象概述\" class=\"headerlink\" title=\"原型对象概述\"></a>原型对象概述</h4><h5 id=\"构造函数的缺点\"><a href=\"#构造函数的缺点\" class=\"headerlink\" title=\"构造函数的缺点\"></a>构造函数的缺点</h5><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span> (<span class=\"params\">name, color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'大毛'</span>, <span class=\"string\">'白色'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.name <span class=\"comment\">// '大毛'</span></span><br><span class=\"line\">cat1.color <span class=\"comment\">// '白色'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>\n<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name, color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.meow = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵'</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'大毛'</span>, <span class=\"string\">'白色'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'二毛'</span>, <span class=\"string\">'黑色'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.meow === cat2.meow</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>\n<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>\n<h5 id=\"prototype-属性的作用\"><a href=\"#prototype-属性的作用\" class=\"headerlink\" title=\"prototype 属性的作用\"></a>prototype 属性的作用</h5><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>\n<p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> f.prototype <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>\n<p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.color = <span class=\"string\">'white'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'大毛'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'二毛'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// 'white'</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// 'white'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>\n<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.color = <span class=\"string\">'yellow'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// \"yellow\"</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// \"yellow\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p>\n<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat1.color = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// 'black'</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// 'yellow'</span></span><br><span class=\"line\">Animal.prototype.color <span class=\"comment\">// 'yellow';</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>\n<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.walk = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is walking'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>\n<h5 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h5><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>\n<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>\n<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>\n<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>\n<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>\n<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyArray.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">MyArray.prototype.constructor = MyArray;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mine = <span class=\"keyword\">new</span> MyArray();</span><br><span class=\"line\">mine.push(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">mine.length <span class=\"comment\">// 3</span></span><br><span class=\"line\">mine <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>\n<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>\n<h5 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">P</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">P.prototype.constructor === P <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">P</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> P();</span><br><span class=\"line\"></span><br><span class=\"line\">p.constructor === P <span class=\"comment\">// true</span></span><br><span class=\"line\">p.constructor === P.prototype.constructor <span class=\"comment\">// true</span></span><br><span class=\"line\">p.hasOwnProperty(<span class=\"string\">'constructor'</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>\n<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"></span><br><span class=\"line\">f.constructor === F <span class=\"comment\">// true</span></span><br><span class=\"line\">f.constructor === <span class=\"built_in\">RegExp</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>\n<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Constr</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> Constr();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> x.constructor();</span><br><span class=\"line\">y <span class=\"keyword\">instanceof</span> Constr <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constr.prototype.createCopy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>.constructor();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>\n<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.constructor === Person <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.constructor === Person <span class=\"comment\">// false</span></span><br><span class=\"line\">Person.prototype.constructor === <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>\n<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 坏的写法</span></span><br><span class=\"line\">C.prototype = &#123;</span><br><span class=\"line\">  method1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 好的写法</span></span><br><span class=\"line\">C.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: C,</span><br><span class=\"line\">  method1: function (...) &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更好的写法</span></span><br><span class=\"line\">C.prototype.method1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>\n<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">f.constructor.name <span class=\"comment\">// \"Foo\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"instanceof-运算符\"><a href=\"#instanceof-运算符\" class=\"headerlink\" title=\"instanceof 运算符\"></a>instanceof 运算符</h4><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">v <span class=\"keyword\">instanceof</span> Vehicle <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>\n<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v <span class=\"keyword\">instanceof</span> Vehicle</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p>\n<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">d <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">d <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>\n<p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\">obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>\n<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> obj <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p>\n<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">y <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>\n<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">s <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>\n<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fubar</span> (<span class=\"params\">foo, bar</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Fubar) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._foo = foo;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._bar = bar;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fubar(foo, bar);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>\n<h4 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h4><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  Super.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.prop = value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p>\n<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sub.prototype = <span class=\"built_in\">Object</span>.create(Super.prototype);</span><br><span class=\"line\">Sub.prototype.constructor = Sub;</span><br><span class=\"line\">Sub.prototype.method = <span class=\"string\">'...'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>\n<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>\n<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Shape</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Shape.prototype.move = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x += x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y += y;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'Shape moved.'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步，子类继承父类的实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Shape.call(<span class=\"keyword\">this</span>); <span class=\"comment\">// 调用父类构造函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.base = Shape;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.base();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二步，子类继承父类的原型</span></span><br><span class=\"line\">Rectangle.prototype = <span class=\"built_in\">Object</span>.create(Shape.prototype);</span><br><span class=\"line\">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure>\n\n<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rect = <span class=\"keyword\">new</span> Rectangle();</span><br><span class=\"line\"></span><br><span class=\"line\">rect <span class=\"keyword\">instanceof</span> Rectangle  <span class=\"comment\">// true</span></span><br><span class=\"line\">rect <span class=\"keyword\">instanceof</span> Shape  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassB.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ClassA.prototype.print.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">M1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.hello = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">M2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.world = <span class=\"string\">'world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">S</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  M1.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  M2.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承 M1</span></span><br><span class=\"line\">S.prototype = <span class=\"built_in\">Object</span>.create(M1.prototype);</span><br><span class=\"line\"><span class=\"comment\">// 继承链上加入 M2</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定构造函数</span></span><br><span class=\"line\">S.prototype.constructor = S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> S();</span><br><span class=\"line\">s.hello <span class=\"comment\">// 'hello'</span></span><br><span class=\"line\">s.world <span class=\"comment\">// 'world'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>\n<h4 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h4><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>\n<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>\n<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>\n<h5 id=\"基本的实现方法\"><a href=\"#基本的实现方法\" class=\"headerlink\" title=\"基本的实现方法\"></a>基本的实现方法</h5><p>模块是实现特定功能的一组属性和方法的封装。</p>\n<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;</span><br><span class=\"line\">　_count : <span class=\"number\">0</span>,</span><br><span class=\"line\">　m1 : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;,</span><br><span class=\"line\">　m2 : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module1.m1();</span><br></pre></td></tr></table></figure>\n\n<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module1._count = <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"封装私有变量：构造函数的写法\"><a href=\"#封装私有变量：构造函数的写法\" class=\"headerlink\" title=\"封装私有变量：构造函数的写法\"></a>封装私有变量：构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StringBuilder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">     buffer.push(str);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buffer.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StringBuilder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._buffer = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuilder.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: StringBuilder,</span><br><span class=\"line\">  add: function (str) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._buffer.push(str);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._buffer.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>\n<h5 id=\"封装私有变量：立即执行函数的写法\"><a href=\"#封装私有变量：立即执行函数的写法\" class=\"headerlink\" title=\"封装私有变量：立即执行函数的写法\"></a>封装私有变量：立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> m1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　  <span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> m2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">　　m1 : m1,</span><br><span class=\"line\">　　m2 : m2</span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.info(module1._count); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>\n<h5 id=\"模块的放大模式\"><a href=\"#模块的放大模式\" class=\"headerlink\" title=\"模块的放大模式\"></a>模块的放大模式</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod</span>)</span>&#123;</span><br><span class=\"line\">　mod.m3 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;)(module1);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>\n<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod</span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"comment\">//...</span></span><br><span class=\"line\">　<span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>\n<h5 id=\"输入全局变量\"><a href=\"#输入全局变量\" class=\"headerlink\" title=\"输入全局变量\"></a>输入全局变量</h5><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>\n<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$, YAHOO</span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>\n<p>立即执行函数还可以起到命名空间的作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, window, document</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleEvents</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initialize</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dieCarouselDie</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//attach to the global scope</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.finalCarousel = &#123;</span><br><span class=\"line\">    init : initialize,</span><br><span class=\"line\">    destroy : dieCarouselDie</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)( jQuery, <span class=\"built_in\">window</span>, <span class=\"built_in\">document</span> );</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的。</p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"adding-element\"><a href=\"#adding-element\" class=\"headerlink\" title=\"adding element\"></a>adding element</h3><p>及时你使用了const来作为array，你虽然不能reassign this array to something else，但是你可以增加删除其中的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">//add at the end</span></span><br><span class=\"line\">numbers.push(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//add at the beginning</span></span><br><span class=\"line\">numbers.unshift(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">//middle</span></span><br><span class=\"line\"><span class=\"comment\">//第一个：位置，第二：删除的元素数量，第三以及之后：添加的内容</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Find-element\"><a href=\"#Find-element\" class=\"headerlink\" title=\"Find element\"></a>Find element</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// it is easy to find a primitive type</span></span><br><span class=\"line\">numbers.includes(<span class=\"number\">1</span>);</span><br><span class=\"line\">numbers.indexOf(<span class=\"number\">1</span>);</span><br><span class=\"line\">numbers.lastIndexOf(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// to find an object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> course = courses.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">course</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> course.name === <span class=\"string\">'xyz'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrow-functions\"><a href=\"#Arrow-functions\" class=\"headerlink\" title=\"Arrow functions\"></a>Arrow functions</h3><p>looks like java lambda</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> course = courses.find(<span class=\"function\"><span class=\"params\">course</span> =&gt;</span> course.name === <span class=\"string\">'a'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Removing-Element\"><a href=\"#Removing-Element\" class=\"headerlink\" title=\"Removing Element\"></a>Removing Element</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//end</span></span><br><span class=\"line\">numbers.pop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//beginning</span></span><br><span class=\"line\">numbers.shift();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//middle</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">//first is offset, second is the number of elements you want to delete</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Empty-an-array\"><a href=\"#Empty-an-array\" class=\"headerlink\" title=\"Empty an array\"></a>Empty an array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = num;</span><br><span class=\"line\"></span><br><span class=\"line\">num = []; <span class=\"comment\">//in this solution, num is reassigned but num1 is still pointing to the num, so the info of num will not be garbage collected</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 2</span></span><br><span class=\"line\">numbers.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 3</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 4</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (numbers.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  numbers.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Combing-Arrays\"><a href=\"#Combing-Arrays\" class=\"headerlink\" title=\"Combing Arrays\"></a>Combing Arrays</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> first = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> second = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> combined = first.concat(second);</span><br><span class=\"line\"><span class=\"keyword\">const</span> sllice = combined.slice(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Iterate-Array\"><a href=\"#Iterate-Array\" class=\"headerlink\" title=\"Iterate Array\"></a>Iterate Array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nums.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// after es6</span></span><br><span class=\"line\">nums.forEach(<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> <span class=\"built_in\">console</span>.log(number));</span><br><span class=\"line\">nums.forEach(<span class=\"function\">(<span class=\"params\">number, index</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(index, number)); <span class=\"comment\">// the second value is index, the first is the value</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Join-array\"><a href=\"#Join-array\" class=\"headerlink\" title=\"Join array\"></a>Join array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> joined = numbers.join(<span class=\"string\">'-'</span>);<span class=\"comment\">//default is comma</span></span><br><span class=\"line\"><span class=\"comment\">// result is 1-2-3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sort\"><a href=\"#Sort\" class=\"headerlink\" title=\"Sort\"></a>Sort</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">numbers.sort();</span><br><span class=\"line\">numbers.reverse();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Every-and-some\"><a href=\"#Every-and-some\" class=\"headerlink\" title=\"Every and some\"></a>Every and some</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> k = numbers.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);<span class=\"comment\">// all passed then return true, else return false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> k = numbers.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);<span class=\"comment\">// at leaset one match then return true, else return false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Filter-an-array\"><a href=\"#Filter-an-array\" class=\"headerlink\" title=\"Filter an array\"></a>Filter an array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filtered = numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filtered = numbers.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt;= <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = filtered.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123;<span class=\"attr\">value</span> : n&#125;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reduce\"><a href=\"#Reduce\" class=\"headerlink\" title=\"Reduce\"></a>Reduce</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">total, currentValue, currentIndex, arr</span>), <span class=\"title\">initialValue</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">sum</span> = <span class=\"title\">numbers</span>.<span class=\"title\">reduce</span>(<span class=\"params\">(accumulator, currentValue</span>) =&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accumulator + currentValue;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcRectArea(<span class=\"number\">3</span>,<span class=\"number\">4</span>); <span class=\"comment\">// run it before the declaration is okay</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a function declaration</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calcRectArea</span>(<span class=\"params\">width, height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getRectArea(<span class=\"number\">3</span>,<span class=\"number\">4</span>); <span class=\"comment\">// run it before the expression then there will be error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a function expression, and is an anonymous(there is also named) function expression</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getRectArea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">width, height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Hoisting: JavaScript engine will automatically move the function declaration to the top of the file</p>\n<p>Arguments: all the input elemments will be shown as argument in the function with there index. For a funtion who needs 2 elements, if you input 5 elements, that doesn’t matter, the function will only use the first two number</p>\n<p>Default Value: same like python, define it in the parameters</p>\n<h3 id=\"Getter-and-Setter\"><a href=\"#Getter-and-Setter\" class=\"headerlink\" title=\"Getter and Setter\"></a>Getter and Setter</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">  lastName : <span class=\"string\">\"Doe\"</span>,</span><br><span class=\"line\">  language : <span class=\"string\">\"en\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> lang() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.language;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> lang(lang) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.language = lang;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set an object property using a setter:</span></span><br><span class=\"line\">person.lang = <span class=\"string\">\"en\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// Display data from the object using a getter:</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = person.lang;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Try-and-catch\"><a href=\"#Try-and-catch\" class=\"headerlink\" title=\"Try and catch\"></a>Try and catch</h3><h4 id=\"The-throw-Statement\"><a href=\"#The-throw-Statement\" class=\"headerlink\" title=\"The throw Statement\"></a>The throw Statement</h4><p>The <code>throw</code> statement allows you to create a custom error.</p>\n<p>Technically you can <strong>throw an exception (throw an error)</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">\"Too big\"</span>;    <span class=\"comment\">// throw a text</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"number\">500</span>;          <span class=\"comment\">// throw a number</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'value is invalid'</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>If you use <code>throw</code> together with <code>try</code> and <code>catch</code>, you can control program flow and generate custom error messages.</p>\n<h4 id=\"Try-catch-finally\"><a href=\"#Try-catch-finally\" class=\"headerlink\" title=\"Try catch finally\"></a>Try catch finally</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message, x;</span><br><span class=\"line\">  message = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"p01\"</span>);</span><br><span class=\"line\">  message.innerHTML = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  x = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).value;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == <span class=\"string\">\"\"</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"empty\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isNaN</span>(x)) <span class=\"keyword\">throw</span> <span class=\"string\">\"not a number\"</span>;</span><br><span class=\"line\">    x = <span class=\"built_in\">Number</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">5</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"too low\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &gt; <span class=\"number\">10</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"too high\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    message.innerHTML = <span class=\"string\">\"Input is \"</span> + e;</span><br><span class=\"line\">    alert(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).value = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Let-and-Var\"><a href=\"#Let-and-Var\" class=\"headerlink\" title=\"Let and Var\"></a>Let and Var</h2><h3 id=\"ES6可以用let定义块级作用域变量\"><a href=\"#ES6可以用let定义块级作用域变量\" class=\"headerlink\" title=\"ES6可以用let定义块级作用域变量\"></a>ES6可以用let定义块级作用域变量</h3><p>在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以<code>{}</code>限定不了var声明变量的访问范围。<br>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6新增的<code>let</code>，可以声明块级作用域的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">9</span>;     <span class=\"comment\">// i变量只在 花括号内有效！！！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"let-配合for循环的独特应用\"><a href=\"#let-配合for循环的独特应用\" class=\"headerlink\" title=\"let 配合for循环的独特应用\"></a>let 配合for循环的独特应用</h3><p><code>let</code>非常适合用于 <code>for</code>循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">10</span>; i++) &#123;  </span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// 同步注册回调函数到 异步的 宏任务队列。</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);        <span class=\"comment\">// 执行此代码时，同步代码for循环已经执行完成</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"number\">10</span>   共<span class=\"number\">10</span>个</span><br><span class=\"line\"><span class=\"comment\">// 这里面的知识点： JS的事件循环机制，setTimeout的机制等</span></span><br></pre></td></tr></table></figure>\n\n<p>如果把 <code>var</code>改成 <code>let</code>声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);    <span class=\"comment\">//  i 是循环体内局部作用域，不受外界影响。</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"number\">0</span>  <span class=\"number\">1</span>  <span class=\"number\">2</span>  <span class=\"number\">3</span>  <span class=\"number\">4</span>  <span class=\"number\">5</span>  <span class=\"number\">6</span>  <span class=\"number\">7</span>  <span class=\"number\">8</span> <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"let没有变量提升与暂时性死区\"><a href=\"#let没有变量提升与暂时性死区\" class=\"headerlink\" title=\"let没有变量提升与暂时性死区\"></a>let没有变量提升与暂时性死区</h3><p>用<code>let</code>声明的变量，不存在变量提升。而且要求必须 等<code>let</code>声明语句执行完之后，变量才能使用，不然会报<code>Uncaught ReferenceError</code>错误。<br>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(aicoder);    <span class=\"comment\">// 错误：Uncaught ReferenceError ...</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aicoder = <span class=\"string\">'aicoder.com'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里就可以安全使用aicoder</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n</blockquote>\n<h3 id=\"let变量不能重复声明\"><a href=\"#let变量不能重复声明\" class=\"headerlink\" title=\"let变量不能重复声明\"></a>let变量不能重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。否则报错：<code>Uncaught SyntaxError: Identifier &#39;XXX&#39; has already been declared</code></p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"string\">'sss'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"错误处理机制\"><a href=\"#错误处理机制\" class=\"headerlink\" title=\"错误处理机制\"></a>错误处理机制</h2><h3 id=\"Error-实例对象\"><a href=\"#Error-实例对象\" class=\"headerlink\" title=\"Error 实例对象\"></a>Error 实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">err.message <span class=\"comment\">// \"出错了\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>\n<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<ul>\n<li><strong>message</strong>：错误提示信息</li>\n<li><strong>name</strong>：错误名称（非标准属性）</li>\n<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>\n</ul>\n<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (error.name) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(error.name + <span class=\"string\">': '</span> + error.message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throwit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">catchit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    throwit();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.stack); <span class=\"comment\">// print stack trace</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">catchit()</span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"comment\">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class=\"line\"><span class=\"comment\">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class=\"line\"><span class=\"comment\">//    at repl:1:5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>\n<h3 id=\"原生错误类型\"><a href=\"#原生错误类型\" class=\"headerlink\" title=\"原生错误类型\"></a>原生错误类型</h3><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>\n<h4 id=\"SyntaxError-对象\"><a href=\"#SyntaxError-对象\" class=\"headerlink\" title=\"SyntaxError 对象\"></a>SyntaxError 对象</h4><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 变量名错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"number\">1</span>a;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺少括号</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log <span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>\n<h4 id=\"ReferenceError-对象\"><a href=\"#ReferenceError-对象\" class=\"headerlink\" title=\"ReferenceError 对象\"></a>ReferenceError 对象</h4><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用一个不存在的变量</span></span><br><span class=\"line\">unknownVariable</span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等号左侧不是变量</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log() = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误。</p>\n<h4 id=\"RangeError-对象\"><a href=\"#RangeError-对象\" class=\"headerlink\" title=\"RangeError 对象\"></a>RangeError 对象</h4><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组长度不得为负数</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TypeError-对象\"><a href=\"#TypeError-对象\" class=\"headerlink\" title=\"TypeError 对象\"></a>TypeError 对象</h4><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: number is not a func</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.unknownMethod()</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>\n<h4 id=\"URIError-对象\"><a href=\"#URIError-对象\" class=\"headerlink\" title=\"URIError 对象\"></a>URIError 对象</h4><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">decodeURI</span>(<span class=\"string\">'%2'</span>)</span><br><span class=\"line\"><span class=\"comment\">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EvalError-对象\"><a href=\"#EvalError-对象\" class=\"headerlink\" title=\"EvalError 对象\"></a>EvalError 对象</h4><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了！'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> err2 = <span class=\"keyword\">new</span> <span class=\"built_in\">RangeError</span>(<span class=\"string\">'出错了，变量超出有效范围！'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> err3 = <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'出错了，变量类型无效！'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">err1.message <span class=\"comment\">// \"出错了！\"</span></span><br><span class=\"line\">err2.message <span class=\"comment\">// \"出错了，变量超出有效范围！\"</span></span><br><span class=\"line\">err3.message <span class=\"comment\">// \"出错了，变量类型无效！\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义错误\"><a href=\"#自定义错误\" class=\"headerlink\" title=\"自定义错误\"></a>自定义错误</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">'默认信息'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'UserError'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> UserError(<span class=\"string\">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throw-语句\"><a href=\"#throw-语句\" class=\"headerlink\" title=\"throw 语句\"></a>throw 语句</h3><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'x 必须为正数'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>\n<p><code>throw</code>也可以抛出自定义错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">'默认信息'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'UserError'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserError(<span class=\"string\">'出错了！'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught UserError &#123;message: \"出错了！\", name: \"UserError\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>\n<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抛出一个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Error！'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught Error！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个数值</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught 42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个对象</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> &#123;</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Error!'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>\n<h3 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了!'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.stack);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了!</span></span><br><span class=\"line\"><span class=\"comment\">//   at &lt;anonymous&gt;:3:9</span></span><br><span class=\"line\"><span class=\"comment\">//   ...</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>\n<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>\n<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">\"出错了\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">111</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">222</span>);</span><br><span class=\"line\"><span class=\"comment\">// 111</span></span><br><span class=\"line\"><span class=\"comment\">// 222</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>\n<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> n;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e &lt;= <span class=\"number\">50</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught 100</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>\n<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">EvalError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RangeError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>\n<h3 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h3><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cleansUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了……'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'此行不会执行'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成清理工作'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cleansUp()</span><br><span class=\"line\"><span class=\"comment\">// 完成清理工作</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught Error: 出错了……</span></span><br><span class=\"line\"><span class=\"comment\">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class=\"line\"><span class=\"comment\">//    at &lt;anonymous&gt;:10:1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">idle</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'FINALLY'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">idle(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// FINALLY</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p>\n<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">countUp()</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\">count</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>\n<p>下面是<code>finally</code>代码块用法的典型场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openFile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  writeFile(Data);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  handleError(e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  closeFile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>\n<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'bug'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 这句会覆盖掉前面那句 return</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f();</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>\n<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'出错了！'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'捕捉到内部错误'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e; <span class=\"comment\">// 这句原本会等到finally结束再执行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处不会执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'caught outer \"bogus\"'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>\n<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    consle.log(<span class=\"string\">'Hello world!'</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Finally'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Will I run?'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(error.message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Finally</span></span><br><span class=\"line\"><span class=\"comment\">// consle is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>\n<h2 id=\"Console对象与控制台\"><a href=\"#Console对象与控制台\" class=\"headerlink\" title=\"Console对象与控制台\"></a>Console对象与控制台</h2><h3 id=\"console-对象\"><a href=\"#console-对象\" class=\"headerlink\" title=\"console 对象\"></a>console 对象</h3><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p>\n<p><code>console</code>的常见用途有两个。</p>\n<ul>\n<li>调试程序，显示网页代码运行时的错误信息。</li>\n<li>提供了一个命令行接口，用来与网页代码互动。</li>\n</ul>\n<p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p>\n<ol>\n<li>按 F12 或者<code>Control + Shift + i</code>（PC）/ <code>Command + Option + i</code>（Mac）。</li>\n<li>浏览器菜单选择“工具/开发者工具”。</li>\n<li>在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>\n</ol>\n<p>打开开发者工具以后，顶端有多个面板。</p>\n<ul>\n<li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>\n<li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>\n<li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li>\n<li><strong>Sources</strong>：查看网页加载的脚本源码。</li>\n<li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>\n<li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>\n<li><strong>Console</strong>：用来运行 JavaScript 命令。</li>\n</ul>\n<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。</p>\n<p><code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p>\n<h3 id=\"console-对象的静态方法\"><a href=\"#console-对象的静态方法\" class=\"headerlink\" title=\"console 对象的静态方法\"></a>console 对象的静态方法</h3><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>\n<h4 id=\"console-log-，console-info-，console-debug\"><a href=\"#console-log-，console-info-，console-debug\" class=\"headerlink\" title=\"console.log()，console.info()，console.debug()\"></a>console.log()，console.info()，console.debug()</h4><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hello World</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"comment\">// a b c</span></span><br></pre></td></tr></table></figure>\n\n<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">' %s + %s = %s'</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//  1 + 1 = 2</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p>\n<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>\n<ul>\n<li><code>%s</code> 字符串</li>\n<li><code>%d</code> 整数</li>\n<li><code>%i</code> 整数</li>\n<li><code>%f</code> 浮点数</li>\n<li><code>%o</code> 对象的链接</li>\n<li><code>%c</code> CSS 格式字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">11</span> * <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'%d %s balloons'</span>, number, color);</span><br><span class=\"line\"><span class=\"comment\">// 99 red balloons</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。</p>\n<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">'%cThis text is styled!'</span>,</span><br><span class=\"line\">  <span class=\"string\">'color: red; background: yellow; font-size: 24px;'</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码运行后，输出的内容将显示为黄底红字。</p>\n<p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">' %s + %s '</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"string\">'= 2'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 1 + 1  = 2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object &#123;foo: \"bar\"&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>)</span><br><span class=\"line\"><span class=\"comment\">// function Date() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。</p>\n<p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。</p>\n<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p>\n<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'log'</span>, <span class=\"string\">'info'</span>, <span class=\"string\">'warn'</span>, <span class=\"string\">'error'</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>[method] = <span class=\"built_in\">console</span>[method].bind(</span><br><span class=\"line\">    <span class=\"built_in\">console</span>,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toISOString()</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"出错了！\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2014-05-18T09:00.000Z 出错了！</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h4 id=\"console-warn-，console-error\"><a href=\"#console-warn-，console-error\" class=\"headerlink\" title=\"console.warn()，console.error()\"></a>console.warn()，console.error()</h4><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: %s (%i)'</span>, <span class=\"string\">'Server is not responding'</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\"><span class=\"comment\">// Error: Server is not responding (500)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(<span class=\"string\">'Warning! Too few nodes (%d)'</span>, <span class=\"built_in\">document</span>.childNodes.length)</span><br><span class=\"line\"><span class=\"comment\">// Warning! Too few nodes (1)</span></span><br></pre></td></tr></table></figure>\n\n<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>\n<h4 id=\"console-table\"><a href=\"#console-table\" class=\"headerlink\" title=\"console.table()\"></a>console.table()</h4><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> languages = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"JavaScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".js\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"TypeScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".ts\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"CoffeeScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".coffee\"</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(languages);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>language</code>变量，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">(index)</th>\n<th align=\"left\">name</th>\n<th align=\"left\">fileExtension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">“JavaScript”</td>\n<td align=\"left\">“.js”</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">“TypeScript”</td>\n<td align=\"left\">“.ts”</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">“CoffeeScript”</td>\n<td align=\"left\">“.coffee”</td>\n</tr>\n</tbody></table>\n<p>下面是显示表格内容的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> languages = &#123;</span><br><span class=\"line\">  csharp: &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"C#\"</span>, <span class=\"attr\">paradigm</span>: <span class=\"string\">\"object-oriented\"</span> &#125;,</span><br><span class=\"line\">  fsharp: &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"F#\"</span>, <span class=\"attr\">paradigm</span>: <span class=\"string\">\"functional\"</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(languages);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>language</code>，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">(index)</th>\n<th align=\"left\">name</th>\n<th align=\"left\">paradigm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">csharp</td>\n<td align=\"left\">“C#”</td>\n<td align=\"left\">“object-oriented”</td>\n</tr>\n<tr>\n<td align=\"left\">fsharp</td>\n<td align=\"left\">“F#”</td>\n<td align=\"left\">“functional”</td>\n</tr>\n</tbody></table>\n<h4 id=\"console-count\"><a href=\"#console-count\" class=\"headerlink\" title=\"console.count()\"></a>console.count()</h4><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.count();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hi '</span> + user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'alice'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 2</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi alice\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 3</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p>\n<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.count(user);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"hi \"</span> + user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">// bob: 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'alice'</span>)</span><br><span class=\"line\"><span class=\"comment\">// alice: 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi alice\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">// bob: 2</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>\n<h4 id=\"console-dir-，console-dirxml\"><a href=\"#console-dir-，console-dirxml\" class=\"headerlink\" title=\"console.dir()，console.dirxml()\"></a>console.dir()，console.dirxml()</h4><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">f1</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">f2</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object &#123;f1: \"foo\", f2: \"bar\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(&#123;<span class=\"attr\">f1</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">f2</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object</span></span><br><span class=\"line\"><span class=\"comment\">//   f1: \"foo\"</span></span><br><span class=\"line\"><span class=\"comment\">//   f2: \"bar\"</span></span><br><span class=\"line\"><span class=\"comment\">//   __proto__: Object</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p>\n<p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dir(obj, &#123;<span class=\"attr\">colors</span>: <span class=\"literal\">true</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dirxml(<span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dirxml([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"console-assert\"><a href=\"#console-assert\" class=\"headerlink\" title=\"console.assert()\"></a>console.assert()</h4><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>\n<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">'判断条件不成立'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Assertion failed: 判断条件不成立</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'判断条件不成立'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(list.childNodes.length &lt; <span class=\"number\">500</span>, <span class=\"string\">'节点个数大于等于500'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>\n<h4 id=\"console-time-，console-timeEnd\"><a href=\"#console-time-，console-timeEnd\" class=\"headerlink\" title=\"console.time()，console.timeEnd()\"></a>console.time()，console.timeEnd()</h4><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'Array initialize'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> array= <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">  array[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'Array initialize'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure>\n\n<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>\n<h4 id=\"console-group-，console-groupEnd-，console-groupCollapsed\"><a href=\"#console-group-，console-groupEnd-，console-groupCollapsed\" class=\"headerlink\" title=\"console.group()，console.groupEnd()，console.groupCollapsed()\"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h4><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.group(<span class=\"string\">'一级分组'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'一级分组的内容'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.group(<span class=\"string\">'二级分组'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'二级分组的内容'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd(); <span class=\"comment\">// 二级分组结束</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd(); <span class=\"comment\">// 一级分组结束</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p>\n<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.groupCollapsed(<span class=\"string\">'Fetching Data'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Request Sent'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: Server not responding (500)'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>\n<h4 id=\"console-trace-，console-clear\"><a href=\"#console-trace-，console-clear\" class=\"headerlink\" title=\"console.trace()，console.clear()\"></a>console.trace()，console.clear()</h4><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.trace()</span><br><span class=\"line\"><span class=\"comment\">// console.trace()</span></span><br><span class=\"line\"><span class=\"comment\">//   (anonymous function)</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript._evaluateOn</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript._evaluateAndWrap</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure>\n\n<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>\n<h3 id=\"控制台命令行-API\"><a href=\"#控制台命令行-API\" class=\"headerlink\" title=\"控制台命令行 API\"></a>控制台命令行 API</h3><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p>\n<p>（1）<code>$_</code></p>\n<p><code>$_</code>属性返回上一个表达式的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\">$_</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）<code>$0</code> - <code>$4</code></p>\n<p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>\n<p>（3）<code>$(selector)</code></p>\n<p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>\n<p>（4）<code>$$(selector)</code></p>\n<p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>\n<p>（5）<code>$x(path)</code></p>\n<p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$x(<span class=\"string\">\"//p[a]\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>\n<p>（6）<code>inspect(object)</code></p>\n<p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p>\n<p>（7）<code>getEventListeners(object)</code></p>\n<p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p>\n<p>（8）<code>keys(object)</code>，<code>values(object)</code></p>\n<p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>\n<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"string\">'p1'</span>: <span class=\"string\">'a'</span>, <span class=\"string\">'p2'</span>: <span class=\"string\">'b'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">keys(o)</span><br><span class=\"line\"><span class=\"comment\">// [\"p1\", \"p2\"]</span></span><br><span class=\"line\">values(o)</span><br><span class=\"line\"><span class=\"comment\">// [\"a\", \"b\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p>\n<p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents(<span class=\"built_in\">window</span>, <span class=\"string\">\"resize\"</span>);</span><br><span class=\"line\">monitorEvents(<span class=\"built_in\">window</span>, [<span class=\"string\">\"resize\"</span>, <span class=\"string\">\"scroll\"</span>])</span><br></pre></td></tr></table></figure>\n\n<p>上面代码分别表示单个事件和多个事件的监听方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents($<span class=\"number\">0</span>, <span class=\"string\">'mouse'</span>);</span><br><span class=\"line\">unmonitorEvents($<span class=\"number\">0</span>, <span class=\"string\">'mousemove'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示如何停止监听。</p>\n<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>\n<ul>\n<li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li>\n<li>key：”keydown”, “keyup”, “keypress”, “textInput”</li>\n<li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li>\n<li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents($(<span class=\"string\">\"#msg\"</span>), <span class=\"string\">\"key\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示监听所有<code>key</code>大类的事件。</p>\n<p>（10）其他方法</p>\n<p>命令行 API 还提供以下方法。</p>\n<ul>\n<li><code>clear()</code>：清除控制台的历史。</li>\n<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>\n<li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>\n<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>\n</ul>\n<h3 id=\"debugger-语句\"><a href=\"#debugger-语句\" class=\"headerlink\" title=\"debugger 语句\"></a>debugger 语句</h3><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>\n<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === <span class=\"number\">2</span>) <span class=\"keyword\">debugger</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>\n<h2 id=\"异步操作概述\"><a href=\"#异步操作概述\" class=\"headerlink\" title=\"异步操作概述\"></a>异步操作概述</h2><h3 id=\"单线程模型\"><a href=\"#单线程模型\" class=\"headerlink\" title=\"单线程模型\"></a>单线程模型</h3><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>\n<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>\n<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>\n<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>\n<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>\n<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>\n<h3 id=\"同步任务和异步任务\"><a href=\"#同步任务和异步任务\" class=\"headerlink\" title=\"同步任务和异步任务\"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>\n<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>\n<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>\n<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>\n<h3 id=\"任务队列和事件循环\"><a href=\"#任务队列和事件循环\" class=\"headerlink\" title=\"任务队列和事件循环\"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>\n<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>\n<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>\n<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href=\"https://en.wikipedia.org/wiki/Event_loop\" target=\"_blank\" rel=\"noopener\">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>\n<h3 id=\"异步操作的模式\"><a href=\"#异步操作的模式\" class=\"headerlink\" title=\"异步操作的模式\"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p>\n<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1();</span><br><span class=\"line\">f2();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>\n<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2);</span><br></pre></td></tr></table></figure>\n\n<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href=\"https://en.wikipedia.org/wiki/Coupling_(computer_programming)\" target=\"_blank\" rel=\"noopener\">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>\n<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href=\"https://api.jquery.com/on/\" target=\"_blank\" rel=\"noopener\">写法</a>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    f1.trigger(<span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>\n<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href=\"https://en.wikipedia.org/wiki/Decoupling\" target=\"_blank\" rel=\"noopener\">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>\n<h4 id=\"发布-订阅\"><a href=\"#发布-订阅\" class=\"headerlink\" title=\"发布/订阅\"></a>发布/订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href=\"https://en.wikipedia.org/wiki/Publish-subscribe_pattern\" target=\"_blank\" rel=\"noopener\">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href=\"https://en.wikipedia.org/wiki/Observer_pattern\" target=\"_blank\" rel=\"noopener\">观察者模式</a>”（observer pattern）。</p>\n<p>这个模式有多种<a href=\"https://msdn.microsoft.com/en-us/magazine/hh201955.aspx\" target=\"_blank\" rel=\"noopener\">实现</a>，下面采用的是 Ben Alman 的 <a href=\"https://gist.github.com/661855\" target=\"_blank\" rel=\"noopener\">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p>\n<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>然后，<code>f1</code>进行如下改写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    jQuery.publish(<span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>\n<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<h3 id=\"异步操作的流程控制\"><a href=\"#异步操作的流程控制\" class=\"headerlink\" title=\"异步操作的流程控制\"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>\n<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"number\">1</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span>(<span class=\"number\">2</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span>(<span class=\"number\">3</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">async</span>(<span class=\"number\">4</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span>(<span class=\"number\">5</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">async</span>(<span class=\"number\">6</span>, final);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 参数为 1 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 2 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 3 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 4 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 5 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 6 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 完成:  12</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>\n<h4 id=\"串行执行\"><a href=\"#串行执行\" class=\"headerlink\" title=\"串行执行\"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">series</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(item) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span>( item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      results.push(result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> series(items.shift());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> final(results[results.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">series(items.shift());</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>\n<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>\n<h4 id=\"并行执行\"><a href=\"#并行执行\" class=\"headerlink\" title=\"并行执行\"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">items.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span>(item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">    results.push(result);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(results.length === items.length) &#123;</span><br><span class=\"line\">      final(results[results.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>\n<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>\n<h4 id=\"并行与串行的结合\"><a href=\"#并行与串行的结合\" class=\"headerlink\" title=\"并行与串行的结合\"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> running = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> limit = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">launcher</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = items.shift();</span><br><span class=\"line\">    <span class=\"keyword\">async</span>(item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      results.push(result);</span><br><span class=\"line\">      running--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(items.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        launcher();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(running == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        final(results);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    running++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">launcher();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>\n<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>因为工作原因，我需要学习Node.JS。作为一个在JavaScript上毫无建树的人，我只能从头学起。这是我的学习笔记。</p>\n<p>本笔记基于udemy课程JavaScript basics for beginners，你可以在YouTube上看到相关试听视频</p>\n<p>部分基于udemy课程Modern JavaScript From The Beginning</p>\n<p>部分笔记来源：<a href=\"https://wangdoc.com/javascript/index.html\" target=\"_blank\" rel=\"noopener\">JavaScript</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>关于ES6：<a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6</a></p>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><ol>\n<li>安装live server 插件 in vscode</li>\n<li>在项目新建一个hello world的html，右键你的html然后用live server打开</li>\n<li>假如你html有改动，在html中的内容会自动刷新到live server</li>\n</ol>\n<p>推荐：bracket pair colorizer、JavaScript (ES6) code snippets</p>\n<p>基础：</p>\n<ul>\n<li><p>js脚本可以添加到head或添加到body，建议添加到body的末尾</p>\n</li>\n<li><p>chrome中alt+command+i打开console</p>\n</li>\n</ul>\n<h2 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2><p>在ES6之前，js常常用var来定义变量，但在ES6之后var不再被推荐，建议使用let来定义变量</p>\n<p>在JavaScript中假如你没有define一个变量则其值为undefined</p>\n<p>在JavaScript中一般用单引号来括起string</p>\n<p>Variable不能是保留字（reserved keyword），最好有意义，并且不以数字开头，不能有空格和短杠-（hyphen），命名方式同样遵循camel notation（驼峰命名法），variable都是case-sensitive的</p>\n<p>可以同时initialize多个变量，用逗号隔开</p>\n<h3 id=\"constants\"><a href=\"#constants\" class=\"headerlink\" title=\"constants\"></a>constants</h3><p>假如你使用的是const而不是var，那么你的变量不能被修改</p>\n<h2 id=\"Primitive-types\"><a href=\"#Primitive-types\" class=\"headerlink\" title=\"Primitive types\"></a>Primitive types</h2><p>JavaScript共有两种value可以assign给variable，一种是primitives(aka. value types)，一种是reference type，</p>\n<h3 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h3><ul>\n<li>String</li>\n<li>Number（在JavaScript中没有float，double这种类型，只有统一的number）</li>\n<li>Boolean</li>\n<li>undefined（是一种type，同时是一个value）</li>\n<li>null</li>\n</ul>\n<p>假如当前我们有一个变量，我们没有它的值，但是知晓这个variable将来是什么type，这时候我们就将它设为null，而不是设为undefined</p>\n<h3 id=\"Dynamic-typing\"><a href=\"#Dynamic-typing\" class=\"headerlink\" title=\"Dynamic typing\"></a>Dynamic typing</h3><p>编程语言有两种，一种是static，一种是dynamic。在static language里，变量设置了type之后就不能再更改。但是在JavaScript中，变量能被修改为其他数据类型。</p>\n<h2 id=\"Reference-types\"><a href=\"#Reference-types\" class=\"headerlink\" title=\"Reference types\"></a>Reference types</h2><h3 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'Mosh'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  name = <span class=\"string\">'Mosh'</span>, <span class=\"comment\">//value pair, key is called properties</span></span><br><span class=\"line\">  age = <span class=\"number\">30</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// this is an object literal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two way to access the properties</span></span><br><span class=\"line\"><span class=\"comment\">// 1. Dot notation</span></span><br><span class=\"line\">person.name = <span class=\"string\">'John'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Bracket notation</span></span><br><span class=\"line\">person[<span class=\"string\">'name'</span>] = <span class=\"string\">'Mary'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Dot notation is more concise and shorter, and it should be your default notation</p>\n<p>But sometimes the variable you wanna use might be dynamic, like</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> selection = <span class=\"string\">'name'</span>;</span><br><span class=\"line\">person[selection] = <span class=\"string\">'Mary'</span></span><br></pre></td></tr></table></figure>\n\n<p>In this case the second notation would be better</p>\n<h3 id=\"Arrays\"><a href=\"#Arrays\" class=\"headerlink\" title=\"Arrays\"></a>Arrays</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span>  selectedColors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>]; <span class=\"comment\">// these square brackets are called array literal</span></span><br><span class=\"line\">selectedColors[<span class=\"number\">2</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// we can store different types of data into the array</span></span><br></pre></td></tr></table></figure>\n\n<p>Type of the array is object</p>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">parameter</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span>) + name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(Your argument);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h2><p>I will ignore the basic common stuff</p>\n<h3 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h3><ul>\n<li>Addition + (increment ++)</li>\n<li>Subtraction - (decrement –)</li>\n<li>Multiplication *</li>\n<li>Division /</li>\n<li>Remainder of division %</li>\n<li>exponentiation **</li>\n</ul>\n<h3 id=\"Assignment-Operators\"><a href=\"#Assignment-Operators\" class=\"headerlink\" title=\"Assignment Operators\"></a>Assignment Operators</h3><ul>\n<li>+=</li>\n<li>-=</li>\n<li>=</li>\n</ul>\n<h3 id=\"Comparasion-Operators\"><a href=\"#Comparasion-Operators\" class=\"headerlink\" title=\"Comparasion Operators\"></a>Comparasion Operators</h3><ul>\n<li>&gt;=</li>\n<li>&lt;=</li>\n<li>==</li>\n<li>===(strict equality operator, have the same type and the same value)</li>\n<li>!==</li>\n<li>==(loose equality operator)</li>\n</ul>\n<p>=== 判断规则:</p>\n<ol>\n<li>如果类型不同，就[不相等]</li>\n<li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）</li>\n<li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。</li>\n<li>如果两个值都是true，或者都是false，那么[相等]。</li>\n<li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。</li>\n<li>如果两个值都是null，或者都是undefined，那么[相等]。</li>\n</ol>\n<p>== 判断规则：</p>\n<ol>\n<li>如果两个值类型相同，进行 === 比较。</li>\n<li>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：</li>\n<li>如果一个是null、一个是undefined，那么[相等]。</li>\n<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。</li>\n<li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。</li>\n<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）</li>\n<li>任何其他组合，都[不相等]。</li>\n</ol>\n<h3 id=\"Ternary-Operators\"><a href=\"#Ternary-Operators\" class=\"headerlink\" title=\"Ternary Operators\"></a>Ternary Operators</h3><p>: ? 三元运算符</p>\n<h3 id=\"Logic-Operators\"><a href=\"#Logic-Operators\" class=\"headerlink\" title=\"Logic Operators\"></a>Logic Operators</h3><ul>\n<li><p>: ?</p>\n</li>\n<li><p>&amp;&amp;</p>\n</li>\n<li><p><code>||</code></p>\n</li>\n</ul>\n<p>the result of a logic operators is not always a boolean value. Eg, false || ‘Mosh’ === ‘Mosh’</p>\n<h4 id=\"Falsy\"><a href=\"#Falsy\" class=\"headerlink\" title=\"Falsy\"></a>Falsy</h4><ol>\n<li>undefined</li>\n<li>null</li>\n<li>0</li>\n<li>false</li>\n<li>‘’</li>\n<li>NaN</li>\n</ol>\n<p>Anything else is truthy</p>\n<p>it will return the first truthy value in the<code>||</code>, eg, false <code>||</code> 1 <code>||</code> 2, it returns 1</p>\n<h3 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h3><ul>\n<li><code>|</code> bitwise or</li>\n<li><code>&amp;</code> bitwise and</li>\n</ul>\n<h2 id=\"Control-flow\"><a href=\"#Control-flow\" class=\"headerlink\" title=\"Control flow\"></a>Control flow</h2><p>I will ignore the parts which is the same as Java (if…else…, while, do…while, switch)</p>\n<h3 id=\"for-loop\"><a href=\"#for-loop\" class=\"headerlink\" title=\"for loop\"></a>for loop</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'Mosh'</span>;</span><br><span class=\"line\">  age: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> person)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(key, person[key]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'green'</span>,<span class=\"string\">'blue'</span>];</span><br><span class=\"line\"><span class=\"comment\">//get you the index with 'in'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> colors)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, colors[index]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//get you the data inside of the array with 'of'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> color <span class=\"keyword\">of</span> colors)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in 和 of的区别就在于，in是在iterate key，而of在iterate value</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// an example of object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = &#123;</span><br><span class=\"line\">  radius: <span class=\"number\">1</span>,</span><br><span class=\"line\">  loaction: &#123;</span><br><span class=\"line\">  \tx: <span class=\"number\">1</span>;</span><br><span class=\"line\">  \ty: <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  isVisible: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  draw: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">circle.draw();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Factory-Function\"><a href=\"#Factory-Function\" class=\"headerlink\" title=\"Factory Function\"></a>Factory Function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircle</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    radius,</span><br><span class=\"line\">    draw() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>using this way to create object, the object.constructor will shows you Object()</p>\n<h3 id=\"Constructor-Function\"><a href=\"#Constructor-Function\" class=\"headerlink\" title=\"Constructor Function\"></a>Constructor Function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Circle</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.radius = radius;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'draw'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This one looks like a class, but the factory function looks like a function</p>\n<p>构造函数一般首字母大写</p>\n<h3 id=\"Dynamic-Nature\"><a href=\"#Dynamic-Nature\" class=\"headerlink\" title=\"Dynamic Nature\"></a>Dynamic Nature</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> circle = &#123;</span><br><span class=\"line\">  radius: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">circle.color = <span class=\"string\">'yello'</span>; <span class=\"comment\">// add properties</span></span><br><span class=\"line\">circle.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> circle.color; <span class=\"comment\">// remove properties</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> circle.draw;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cloning-an-object\"><a href=\"#Cloning-an-object\" class=\"headerlink\" title=\"Cloning an object\"></a>Cloning an object</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> another = <span class=\"built_in\">Object</span>.assign(newObj, oldObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> another = &#123;...target&#125;; <span class=\"comment\">// three dots means all the properties inside of the old object</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Garbage-Collection\"><a href=\"#Garbage-Collection\" class=\"headerlink\" title=\"Garbage Collection\"></a>Garbage Collection</h3><p>All the process is automatic and you cannot clean the memory mannualy.</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>There is primitive string and object String, primitive string can also use functions, and they will be wrapped as String object</p>\n<p>Escape character(转义字符)</p>\n<p>在JavaScript中，引号间的换行会被记录</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> another =</span><br><span class=\"line\">‘This is my $&#123;message&#125;</span><br><span class=\"line\"><span class=\"string\">'first'</span> message<span class=\"string\">';</span></span><br></pre></td></tr></table></figure>\n\n<p>输出会是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is my hello</span><br><span class=\"line\">&#39;first&#39; message</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><h4 id=\"原型对象概述\"><a href=\"#原型对象概述\" class=\"headerlink\" title=\"原型对象概述\"></a>原型对象概述</h4><h5 id=\"构造函数的缺点\"><a href=\"#构造函数的缺点\" class=\"headerlink\" title=\"构造函数的缺点\"></a>构造函数的缺点</h5><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span> (<span class=\"params\">name, color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'大毛'</span>, <span class=\"string\">'白色'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.name <span class=\"comment\">// '大毛'</span></span><br><span class=\"line\">cat1.color <span class=\"comment\">// '白色'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>\n<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name, color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.meow = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵'</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'大毛'</span>, <span class=\"string\">'白色'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'二毛'</span>, <span class=\"string\">'黑色'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.meow === cat2.meow</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>\n<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>\n<h5 id=\"prototype-属性的作用\"><a href=\"#prototype-属性的作用\" class=\"headerlink\" title=\"prototype 属性的作用\"></a>prototype 属性的作用</h5><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>\n<p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> f.prototype <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>\n<p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.color = <span class=\"string\">'white'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'大毛'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'二毛'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// 'white'</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// 'white'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>\n<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.color = <span class=\"string\">'yellow'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// \"yellow\"</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// \"yellow\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p>\n<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat1.color = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color <span class=\"comment\">// 'black'</span></span><br><span class=\"line\">cat2.color <span class=\"comment\">// 'yellow'</span></span><br><span class=\"line\">Animal.prototype.color <span class=\"comment\">// 'yellow';</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>\n<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.walk = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is walking'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>\n<h5 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h5><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>\n<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>\n<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>\n<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>\n<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>\n<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyArray.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">MyArray.prototype.constructor = MyArray;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mine = <span class=\"keyword\">new</span> MyArray();</span><br><span class=\"line\">mine.push(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">mine.length <span class=\"comment\">// 3</span></span><br><span class=\"line\">mine <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>\n<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>\n<h5 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">P</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">P.prototype.constructor === P <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">P</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> P();</span><br><span class=\"line\"></span><br><span class=\"line\">p.constructor === P <span class=\"comment\">// true</span></span><br><span class=\"line\">p.constructor === P.prototype.constructor <span class=\"comment\">// true</span></span><br><span class=\"line\">p.hasOwnProperty(<span class=\"string\">'constructor'</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>\n<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\"></span><br><span class=\"line\">f.constructor === F <span class=\"comment\">// true</span></span><br><span class=\"line\">f.constructor === <span class=\"built_in\">RegExp</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>\n<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Constr</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> Constr();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> x.constructor();</span><br><span class=\"line\">y <span class=\"keyword\">instanceof</span> Constr <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constr.prototype.createCopy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>.constructor();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>\n<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.constructor === Person <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.constructor === Person <span class=\"comment\">// false</span></span><br><span class=\"line\">Person.prototype.constructor === <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>\n<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 坏的写法</span></span><br><span class=\"line\">C.prototype = &#123;</span><br><span class=\"line\">  method1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 好的写法</span></span><br><span class=\"line\">C.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: C,</span><br><span class=\"line\">  method1: function (...) &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更好的写法</span></span><br><span class=\"line\">C.prototype.method1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>\n<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">f.constructor.name <span class=\"comment\">// \"Foo\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"instanceof-运算符\"><a href=\"#instanceof-运算符\" class=\"headerlink\" title=\"instanceof 运算符\"></a>instanceof 运算符</h4><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">v <span class=\"keyword\">instanceof</span> Vehicle <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>\n<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v <span class=\"keyword\">instanceof</span> Vehicle</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p>\n<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">d <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">d <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>\n<p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\">obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>\n<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> obj <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p>\n<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">y <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>\n<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">s <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>\n<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fubar</span> (<span class=\"params\">foo, bar</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Fubar) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._foo = foo;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._bar = bar;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fubar(foo, bar);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>\n<h4 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h4><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  Super.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.prop = value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p>\n<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sub.prototype = <span class=\"built_in\">Object</span>.create(Super.prototype);</span><br><span class=\"line\">Sub.prototype.constructor = Sub;</span><br><span class=\"line\">Sub.prototype.method = <span class=\"string\">'...'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>\n<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>\n<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Shape</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Shape.prototype.move = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x += x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y += y;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'Shape moved.'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步，子类继承父类的实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Shape.call(<span class=\"keyword\">this</span>); <span class=\"comment\">// 调用父类构造函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.base = Shape;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.base();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二步，子类继承父类的原型</span></span><br><span class=\"line\">Rectangle.prototype = <span class=\"built_in\">Object</span>.create(Shape.prototype);</span><br><span class=\"line\">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure>\n\n<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rect = <span class=\"keyword\">new</span> Rectangle();</span><br><span class=\"line\"></span><br><span class=\"line\">rect <span class=\"keyword\">instanceof</span> Rectangle  <span class=\"comment\">// true</span></span><br><span class=\"line\">rect <span class=\"keyword\">instanceof</span> Shape  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassB.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ClassA.prototype.print.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">M1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.hello = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">M2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.world = <span class=\"string\">'world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">S</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  M1.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  M2.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承 M1</span></span><br><span class=\"line\">S.prototype = <span class=\"built_in\">Object</span>.create(M1.prototype);</span><br><span class=\"line\"><span class=\"comment\">// 继承链上加入 M2</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定构造函数</span></span><br><span class=\"line\">S.prototype.constructor = S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> S();</span><br><span class=\"line\">s.hello <span class=\"comment\">// 'hello'</span></span><br><span class=\"line\">s.world <span class=\"comment\">// 'world'</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>\n<h4 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h4><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>\n<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>\n<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>\n<h5 id=\"基本的实现方法\"><a href=\"#基本的实现方法\" class=\"headerlink\" title=\"基本的实现方法\"></a>基本的实现方法</h5><p>模块是实现特定功能的一组属性和方法的封装。</p>\n<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;</span><br><span class=\"line\">　_count : <span class=\"number\">0</span>,</span><br><span class=\"line\">　m1 : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;,</span><br><span class=\"line\">　m2 : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module1.m1();</span><br></pre></td></tr></table></figure>\n\n<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module1._count = <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"封装私有变量：构造函数的写法\"><a href=\"#封装私有变量：构造函数的写法\" class=\"headerlink\" title=\"封装私有变量：构造函数的写法\"></a>封装私有变量：构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StringBuilder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">     buffer.push(str);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buffer.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StringBuilder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._buffer = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuilder.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: StringBuilder,</span><br><span class=\"line\">  add: function (str) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._buffer.push(str);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._buffer.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>\n<h5 id=\"封装私有变量：立即执行函数的写法\"><a href=\"#封装私有变量：立即执行函数的写法\" class=\"headerlink\" title=\"封装私有变量：立即执行函数的写法\"></a>封装私有变量：立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> m1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　  <span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">var</span> m2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">　　m1 : m1,</span><br><span class=\"line\">　　m2 : m2</span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.info(module1._count); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>\n<h5 id=\"模块的放大模式\"><a href=\"#模块的放大模式\" class=\"headerlink\" title=\"模块的放大模式\"></a>模块的放大模式</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod</span>)</span>&#123;</span><br><span class=\"line\">　mod.m3 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"comment\">//...</span></span><br><span class=\"line\">　&#125;;</span><br><span class=\"line\">　<span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;)(module1);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>\n<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod</span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"comment\">//...</span></span><br><span class=\"line\">　<span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>\n<h5 id=\"输入全局变量\"><a href=\"#输入全局变量\" class=\"headerlink\" title=\"输入全局变量\"></a>输入全局变量</h5><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>\n<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> module1 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$, YAHOO</span>) </span>&#123;</span><br><span class=\"line\">　<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>\n<p>立即执行函数还可以起到命名空间的作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, window, document</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleEvents</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initialize</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dieCarouselDie</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//attach to the global scope</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.finalCarousel = &#123;</span><br><span class=\"line\">    init : initialize,</span><br><span class=\"line\">    destroy : dieCarouselDie</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)( jQuery, <span class=\"built_in\">window</span>, <span class=\"built_in\">document</span> );</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的。</p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"adding-element\"><a href=\"#adding-element\" class=\"headerlink\" title=\"adding element\"></a>adding element</h3><p>及时你使用了const来作为array，你虽然不能reassign this array to something else，但是你可以增加删除其中的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">//add at the end</span></span><br><span class=\"line\">numbers.push(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//add at the beginning</span></span><br><span class=\"line\">numbers.unshift(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">//middle</span></span><br><span class=\"line\"><span class=\"comment\">//第一个：位置，第二：删除的元素数量，第三以及之后：添加的内容</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Find-element\"><a href=\"#Find-element\" class=\"headerlink\" title=\"Find element\"></a>Find element</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// it is easy to find a primitive type</span></span><br><span class=\"line\">numbers.includes(<span class=\"number\">1</span>);</span><br><span class=\"line\">numbers.indexOf(<span class=\"number\">1</span>);</span><br><span class=\"line\">numbers.lastIndexOf(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// to find an object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> course = courses.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">course</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> course.name === <span class=\"string\">'xyz'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrow-functions\"><a href=\"#Arrow-functions\" class=\"headerlink\" title=\"Arrow functions\"></a>Arrow functions</h3><p>looks like java lambda</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> course = courses.find(<span class=\"function\"><span class=\"params\">course</span> =&gt;</span> course.name === <span class=\"string\">'a'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Removing-Element\"><a href=\"#Removing-Element\" class=\"headerlink\" title=\"Removing Element\"></a>Removing Element</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//end</span></span><br><span class=\"line\">numbers.pop();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//beginning</span></span><br><span class=\"line\">numbers.shift();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//middle</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">//first is offset, second is the number of elements you want to delete</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Empty-an-array\"><a href=\"#Empty-an-array\" class=\"headerlink\" title=\"Empty an array\"></a>Empty an array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = num;</span><br><span class=\"line\"></span><br><span class=\"line\">num = []; <span class=\"comment\">//in this solution, num is reassigned but num1 is still pointing to the num, so the info of num will not be garbage collected</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 2</span></span><br><span class=\"line\">numbers.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 3</span></span><br><span class=\"line\">numbers.splice(<span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Solution 4</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (numbers.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  numbers.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Combing-Arrays\"><a href=\"#Combing-Arrays\" class=\"headerlink\" title=\"Combing Arrays\"></a>Combing Arrays</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> first = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> second = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> combined = first.concat(second);</span><br><span class=\"line\"><span class=\"keyword\">const</span> sllice = combined.slice(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Iterate-Array\"><a href=\"#Iterate-Array\" class=\"headerlink\" title=\"Iterate Array\"></a>Iterate Array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nums.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(number);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// after es6</span></span><br><span class=\"line\">nums.forEach(<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> <span class=\"built_in\">console</span>.log(number));</span><br><span class=\"line\">nums.forEach(<span class=\"function\">(<span class=\"params\">number, index</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(index, number)); <span class=\"comment\">// the second value is index, the first is the value</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Join-array\"><a href=\"#Join-array\" class=\"headerlink\" title=\"Join array\"></a>Join array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> joined = numbers.join(<span class=\"string\">'-'</span>);<span class=\"comment\">//default is comma</span></span><br><span class=\"line\"><span class=\"comment\">// result is 1-2-3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sort\"><a href=\"#Sort\" class=\"headerlink\" title=\"Sort\"></a>Sort</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">numbers.sort();</span><br><span class=\"line\">numbers.reverse();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Every-and-some\"><a href=\"#Every-and-some\" class=\"headerlink\" title=\"Every and some\"></a>Every and some</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> k = numbers.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);<span class=\"comment\">// all passed then return true, else return false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> k = numbers.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);<span class=\"comment\">// at leaset one match then return true, else return false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Filter-an-array\"><a href=\"#Filter-an-array\" class=\"headerlink\" title=\"Filter an array\"></a>Filter an array</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filtered = numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filtered = numbers.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt;= <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = filtered.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123;<span class=\"attr\">value</span> : n&#125;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reduce\"><a href=\"#Reduce\" class=\"headerlink\" title=\"Reduce\"></a>Reduce</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">total, currentValue, currentIndex, arr</span>), <span class=\"title\">initialValue</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">sum</span> = <span class=\"title\">numbers</span>.<span class=\"title\">reduce</span>(<span class=\"params\">(accumulator, currentValue</span>) =&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accumulator + currentValue;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcRectArea(<span class=\"number\">3</span>,<span class=\"number\">4</span>); <span class=\"comment\">// run it before the declaration is okay</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a function declaration</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calcRectArea</span>(<span class=\"params\">width, height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getRectArea(<span class=\"number\">3</span>,<span class=\"number\">4</span>); <span class=\"comment\">// run it before the expression then there will be error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a function expression, and is an anonymous(there is also named) function expression</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getRectArea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">width, height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Hoisting: JavaScript engine will automatically move the function declaration to the top of the file</p>\n<p>Arguments: all the input elemments will be shown as argument in the function with there index. For a funtion who needs 2 elements, if you input 5 elements, that doesn’t matter, the function will only use the first two number</p>\n<p>Default Value: same like python, define it in the parameters</p>\n<h3 id=\"Getter-and-Setter\"><a href=\"#Getter-and-Setter\" class=\"headerlink\" title=\"Getter and Setter\"></a>Getter and Setter</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">  lastName : <span class=\"string\">\"Doe\"</span>,</span><br><span class=\"line\">  language : <span class=\"string\">\"en\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> lang() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.language;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> lang(lang) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.language = lang;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set an object property using a setter:</span></span><br><span class=\"line\">person.lang = <span class=\"string\">\"en\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// Display data from the object using a getter:</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = person.lang;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Try-and-catch\"><a href=\"#Try-and-catch\" class=\"headerlink\" title=\"Try and catch\"></a>Try and catch</h3><h4 id=\"The-throw-Statement\"><a href=\"#The-throw-Statement\" class=\"headerlink\" title=\"The throw Statement\"></a>The throw Statement</h4><p>The <code>throw</code> statement allows you to create a custom error.</p>\n<p>Technically you can <strong>throw an exception (throw an error)</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">\"Too big\"</span>;    <span class=\"comment\">// throw a text</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"number\">500</span>;          <span class=\"comment\">// throw a number</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'value is invalid'</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>If you use <code>throw</code> together with <code>try</code> and <code>catch</code>, you can control program flow and generate custom error messages.</p>\n<h4 id=\"Try-catch-finally\"><a href=\"#Try-catch-finally\" class=\"headerlink\" title=\"Try catch finally\"></a>Try catch finally</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message, x;</span><br><span class=\"line\">  message = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"p01\"</span>);</span><br><span class=\"line\">  message.innerHTML = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  x = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).value;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == <span class=\"string\">\"\"</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"empty\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isNaN</span>(x)) <span class=\"keyword\">throw</span> <span class=\"string\">\"not a number\"</span>;</span><br><span class=\"line\">    x = <span class=\"built_in\">Number</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">5</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"too low\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &gt; <span class=\"number\">10</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"too high\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    message.innerHTML = <span class=\"string\">\"Input is \"</span> + e;</span><br><span class=\"line\">    alert(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"demo\"</span>).value = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Let-and-Var\"><a href=\"#Let-and-Var\" class=\"headerlink\" title=\"Let and Var\"></a>Let and Var</h2><h3 id=\"ES6可以用let定义块级作用域变量\"><a href=\"#ES6可以用let定义块级作用域变量\" class=\"headerlink\" title=\"ES6可以用let定义块级作用域变量\"></a>ES6可以用let定义块级作用域变量</h3><p>在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以<code>{}</code>限定不了var声明变量的访问范围。<br>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6新增的<code>let</code>，可以声明块级作用域的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">9</span>;     <span class=\"comment\">// i变量只在 花括号内有效！！！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);  <span class=\"comment\">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"let-配合for循环的独特应用\"><a href=\"#let-配合for循环的独特应用\" class=\"headerlink\" title=\"let 配合for循环的独特应用\"></a>let 配合for循环的独特应用</h3><p><code>let</code>非常适合用于 <code>for</code>循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">10</span>; i++) &#123;  </span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// 同步注册回调函数到 异步的 宏任务队列。</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);        <span class=\"comment\">// 执行此代码时，同步代码for循环已经执行完成</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"number\">10</span>   共<span class=\"number\">10</span>个</span><br><span class=\"line\"><span class=\"comment\">// 这里面的知识点： JS的事件循环机制，setTimeout的机制等</span></span><br></pre></td></tr></table></figure>\n\n<p>如果把 <code>var</code>改成 <code>let</code>声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);    <span class=\"comment\">//  i 是循环体内局部作用域，不受外界影响。</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"number\">0</span>  <span class=\"number\">1</span>  <span class=\"number\">2</span>  <span class=\"number\">3</span>  <span class=\"number\">4</span>  <span class=\"number\">5</span>  <span class=\"number\">6</span>  <span class=\"number\">7</span>  <span class=\"number\">8</span> <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"let没有变量提升与暂时性死区\"><a href=\"#let没有变量提升与暂时性死区\" class=\"headerlink\" title=\"let没有变量提升与暂时性死区\"></a>let没有变量提升与暂时性死区</h3><p>用<code>let</code>声明的变量，不存在变量提升。而且要求必须 等<code>let</code>声明语句执行完之后，变量才能使用，不然会报<code>Uncaught ReferenceError</code>错误。<br>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(aicoder);    <span class=\"comment\">// 错误：Uncaught ReferenceError ...</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aicoder = <span class=\"string\">'aicoder.com'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里就可以安全使用aicoder</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n</blockquote>\n<h3 id=\"let变量不能重复声明\"><a href=\"#let变量不能重复声明\" class=\"headerlink\" title=\"let变量不能重复声明\"></a>let变量不能重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。否则报错：<code>Uncaught SyntaxError: Identifier &#39;XXX&#39; has already been declared</code></p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"string\">'sss'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"错误处理机制\"><a href=\"#错误处理机制\" class=\"headerlink\" title=\"错误处理机制\"></a>错误处理机制</h2><h3 id=\"Error-实例对象\"><a href=\"#Error-实例对象\" class=\"headerlink\" title=\"Error 实例对象\"></a>Error 实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">err.message <span class=\"comment\">// \"出错了\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>\n<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<ul>\n<li><strong>message</strong>：错误提示信息</li>\n<li><strong>name</strong>：错误名称（非标准属性）</li>\n<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>\n</ul>\n<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (error.name) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(error.name + <span class=\"string\">': '</span> + error.message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throwit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">catchit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    throwit();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.stack); <span class=\"comment\">// print stack trace</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">catchit()</span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"comment\">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class=\"line\"><span class=\"comment\">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class=\"line\"><span class=\"comment\">//    at repl:1:5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>\n<h3 id=\"原生错误类型\"><a href=\"#原生错误类型\" class=\"headerlink\" title=\"原生错误类型\"></a>原生错误类型</h3><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>\n<h4 id=\"SyntaxError-对象\"><a href=\"#SyntaxError-对象\" class=\"headerlink\" title=\"SyntaxError 对象\"></a>SyntaxError 对象</h4><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 变量名错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"number\">1</span>a;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺少括号</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log <span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>\n<h4 id=\"ReferenceError-对象\"><a href=\"#ReferenceError-对象\" class=\"headerlink\" title=\"ReferenceError 对象\"></a>ReferenceError 对象</h4><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用一个不存在的变量</span></span><br><span class=\"line\">unknownVariable</span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等号左侧不是变量</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log() = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误。</p>\n<h4 id=\"RangeError-对象\"><a href=\"#RangeError-对象\" class=\"headerlink\" title=\"RangeError 对象\"></a>RangeError 对象</h4><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组长度不得为负数</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TypeError-对象\"><a href=\"#TypeError-对象\" class=\"headerlink\" title=\"TypeError 对象\"></a>TypeError 对象</h4><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: number is not a func</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.unknownMethod()</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>\n<h4 id=\"URIError-对象\"><a href=\"#URIError-对象\" class=\"headerlink\" title=\"URIError 对象\"></a>URIError 对象</h4><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">decodeURI</span>(<span class=\"string\">'%2'</span>)</span><br><span class=\"line\"><span class=\"comment\">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EvalError-对象\"><a href=\"#EvalError-对象\" class=\"headerlink\" title=\"EvalError 对象\"></a>EvalError 对象</h4><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了！'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> err2 = <span class=\"keyword\">new</span> <span class=\"built_in\">RangeError</span>(<span class=\"string\">'出错了，变量超出有效范围！'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> err3 = <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'出错了，变量类型无效！'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">err1.message <span class=\"comment\">// \"出错了！\"</span></span><br><span class=\"line\">err2.message <span class=\"comment\">// \"出错了，变量超出有效范围！\"</span></span><br><span class=\"line\">err3.message <span class=\"comment\">// \"出错了，变量类型无效！\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义错误\"><a href=\"#自定义错误\" class=\"headerlink\" title=\"自定义错误\"></a>自定义错误</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">'默认信息'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'UserError'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> UserError(<span class=\"string\">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throw-语句\"><a href=\"#throw-语句\" class=\"headerlink\" title=\"throw 语句\"></a>throw 语句</h3><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'x 必须为正数'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>\n<p><code>throw</code>也可以抛出自定义错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">'默认信息'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'UserError'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserError(<span class=\"string\">'出错了！'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught UserError &#123;message: \"出错了！\", name: \"UserError\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>\n<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抛出一个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Error！'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught Error！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个数值</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught 42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抛出一个对象</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> &#123;</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Error!'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>\n<h3 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了!'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.stack);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了!</span></span><br><span class=\"line\"><span class=\"comment\">//   at &lt;anonymous&gt;:3:9</span></span><br><span class=\"line\"><span class=\"comment\">//   ...</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>\n<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>\n<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">\"出错了\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">111</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">222</span>);</span><br><span class=\"line\"><span class=\"comment\">// 111</span></span><br><span class=\"line\"><span class=\"comment\">// 222</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>\n<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> n;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e &lt;= <span class=\"number\">50</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught 100</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>\n<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">EvalError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RangeError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>\n<h3 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h3><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cleansUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了……'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'此行不会执行'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成清理工作'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cleansUp()</span><br><span class=\"line\"><span class=\"comment\">// 完成清理工作</span></span><br><span class=\"line\"><span class=\"comment\">// Uncaught Error: 出错了……</span></span><br><span class=\"line\"><span class=\"comment\">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class=\"line\"><span class=\"comment\">//    at &lt;anonymous&gt;:10:1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">idle</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'FINALLY'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">idle(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// FINALLY</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p>\n<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">countUp()</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\">count</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>\n<p>下面是<code>finally</code>代码块用法的典型场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openFile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  writeFile(Data);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  handleError(e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  closeFile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>\n<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'bug'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 这句会覆盖掉前面那句 return</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f();</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>\n<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'出错了！'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'捕捉到内部错误'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e; <span class=\"comment\">// 这句原本会等到finally结束再执行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处不会执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'caught outer \"bogus\"'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>\n<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    consle.log(<span class=\"string\">'Hello world!'</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Finally'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Will I run?'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(error.message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Finally</span></span><br><span class=\"line\"><span class=\"comment\">// consle is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>\n<h2 id=\"Console对象与控制台\"><a href=\"#Console对象与控制台\" class=\"headerlink\" title=\"Console对象与控制台\"></a>Console对象与控制台</h2><h3 id=\"console-对象\"><a href=\"#console-对象\" class=\"headerlink\" title=\"console 对象\"></a>console 对象</h3><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p>\n<p><code>console</code>的常见用途有两个。</p>\n<ul>\n<li>调试程序，显示网页代码运行时的错误信息。</li>\n<li>提供了一个命令行接口，用来与网页代码互动。</li>\n</ul>\n<p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p>\n<ol>\n<li>按 F12 或者<code>Control + Shift + i</code>（PC）/ <code>Command + Option + i</code>（Mac）。</li>\n<li>浏览器菜单选择“工具/开发者工具”。</li>\n<li>在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>\n</ol>\n<p>打开开发者工具以后，顶端有多个面板。</p>\n<ul>\n<li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>\n<li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>\n<li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li>\n<li><strong>Sources</strong>：查看网页加载的脚本源码。</li>\n<li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>\n<li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>\n<li><strong>Console</strong>：用来运行 JavaScript 命令。</li>\n</ul>\n<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。</p>\n<p><code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p>\n<h3 id=\"console-对象的静态方法\"><a href=\"#console-对象的静态方法\" class=\"headerlink\" title=\"console 对象的静态方法\"></a>console 对象的静态方法</h3><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>\n<h4 id=\"console-log-，console-info-，console-debug\"><a href=\"#console-log-，console-info-，console-debug\" class=\"headerlink\" title=\"console.log()，console.info()，console.debug()\"></a>console.log()，console.info()，console.debug()</h4><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hello World</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"comment\">// a b c</span></span><br></pre></td></tr></table></figure>\n\n<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">' %s + %s = %s'</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//  1 + 1 = 2</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p>\n<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>\n<ul>\n<li><code>%s</code> 字符串</li>\n<li><code>%d</code> 整数</li>\n<li><code>%i</code> 整数</li>\n<li><code>%f</code> 浮点数</li>\n<li><code>%o</code> 对象的链接</li>\n<li><code>%c</code> CSS 格式字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">11</span> * <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'%d %s balloons'</span>, number, color);</span><br><span class=\"line\"><span class=\"comment\">// 99 red balloons</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。</p>\n<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">'%cThis text is styled!'</span>,</span><br><span class=\"line\">  <span class=\"string\">'color: red; background: yellow; font-size: 24px;'</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码运行后，输出的内容将显示为黄底红字。</p>\n<p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">' %s + %s '</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"string\">'= 2'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 1 + 1  = 2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object &#123;foo: \"bar\"&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>)</span><br><span class=\"line\"><span class=\"comment\">// function Date() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。</p>\n<p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。</p>\n<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p>\n<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'log'</span>, <span class=\"string\">'info'</span>, <span class=\"string\">'warn'</span>, <span class=\"string\">'error'</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>[method] = <span class=\"built_in\">console</span>[method].bind(</span><br><span class=\"line\">    <span class=\"built_in\">console</span>,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toISOString()</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"出错了！\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2014-05-18T09:00.000Z 出错了！</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h4 id=\"console-warn-，console-error\"><a href=\"#console-warn-，console-error\" class=\"headerlink\" title=\"console.warn()，console.error()\"></a>console.warn()，console.error()</h4><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: %s (%i)'</span>, <span class=\"string\">'Server is not responding'</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\"><span class=\"comment\">// Error: Server is not responding (500)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(<span class=\"string\">'Warning! Too few nodes (%d)'</span>, <span class=\"built_in\">document</span>.childNodes.length)</span><br><span class=\"line\"><span class=\"comment\">// Warning! Too few nodes (1)</span></span><br></pre></td></tr></table></figure>\n\n<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>\n<h4 id=\"console-table\"><a href=\"#console-table\" class=\"headerlink\" title=\"console.table()\"></a>console.table()</h4><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> languages = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"JavaScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".js\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"TypeScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".ts\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"CoffeeScript\"</span>, <span class=\"attr\">fileExtension</span>: <span class=\"string\">\".coffee\"</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(languages);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>language</code>变量，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">(index)</th>\n<th align=\"left\">name</th>\n<th align=\"left\">fileExtension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">“JavaScript”</td>\n<td align=\"left\">“.js”</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">“TypeScript”</td>\n<td align=\"left\">“.ts”</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">“CoffeeScript”</td>\n<td align=\"left\">“.coffee”</td>\n</tr>\n</tbody></table>\n<p>下面是显示表格内容的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> languages = &#123;</span><br><span class=\"line\">  csharp: &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"C#\"</span>, <span class=\"attr\">paradigm</span>: <span class=\"string\">\"object-oriented\"</span> &#125;,</span><br><span class=\"line\">  fsharp: &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"F#\"</span>, <span class=\"attr\">paradigm</span>: <span class=\"string\">\"functional\"</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(languages);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>language</code>，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">(index)</th>\n<th align=\"left\">name</th>\n<th align=\"left\">paradigm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">csharp</td>\n<td align=\"left\">“C#”</td>\n<td align=\"left\">“object-oriented”</td>\n</tr>\n<tr>\n<td align=\"left\">fsharp</td>\n<td align=\"left\">“F#”</td>\n<td align=\"left\">“functional”</td>\n</tr>\n</tbody></table>\n<h4 id=\"console-count\"><a href=\"#console-count\" class=\"headerlink\" title=\"console.count()\"></a>console.count()</h4><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.count();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hi '</span> + user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'alice'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 2</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi alice\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  : 3</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p>\n<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.count(user);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"hi \"</span> + user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">// bob: 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'alice'</span>)</span><br><span class=\"line\"><span class=\"comment\">// alice: 1</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi alice\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(<span class=\"string\">'bob'</span>)</span><br><span class=\"line\"><span class=\"comment\">// bob: 2</span></span><br><span class=\"line\"><span class=\"comment\">// \"hi bob\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>\n<h4 id=\"console-dir-，console-dirxml\"><a href=\"#console-dir-，console-dirxml\" class=\"headerlink\" title=\"console.dir()，console.dirxml()\"></a>console.dir()，console.dirxml()</h4><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">f1</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">f2</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object &#123;f1: \"foo\", f2: \"bar\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(&#123;<span class=\"attr\">f1</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">f2</span>: <span class=\"string\">'bar'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object</span></span><br><span class=\"line\"><span class=\"comment\">//   f1: \"foo\"</span></span><br><span class=\"line\"><span class=\"comment\">//   f2: \"bar\"</span></span><br><span class=\"line\"><span class=\"comment\">//   __proto__: Object</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p>\n<p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dir(obj, &#123;<span class=\"attr\">colors</span>: <span class=\"literal\">true</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dirxml(<span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.dirxml([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"console-assert\"><a href=\"#console-assert\" class=\"headerlink\" title=\"console.assert()\"></a>console.assert()</h4><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>\n<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">'判断条件不成立'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Assertion failed: 判断条件不成立</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'判断条件不成立'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(list.childNodes.length &lt; <span class=\"number\">500</span>, <span class=\"string\">'节点个数大于等于500'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>\n<h4 id=\"console-time-，console-timeEnd\"><a href=\"#console-time-，console-timeEnd\" class=\"headerlink\" title=\"console.time()，console.timeEnd()\"></a>console.time()，console.timeEnd()</h4><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'Array initialize'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> array= <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">  array[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'Array initialize'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure>\n\n<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>\n<h4 id=\"console-group-，console-groupEnd-，console-groupCollapsed\"><a href=\"#console-group-，console-groupEnd-，console-groupCollapsed\" class=\"headerlink\" title=\"console.group()，console.groupEnd()，console.groupCollapsed()\"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h4><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.group(<span class=\"string\">'一级分组'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'一级分组的内容'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.group(<span class=\"string\">'二级分组'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'二级分组的内容'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd(); <span class=\"comment\">// 二级分组结束</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd(); <span class=\"comment\">// 一级分组结束</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p>\n<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.groupCollapsed(<span class=\"string\">'Fetching Data'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Request Sent'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: Server not responding (500)'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>\n<h4 id=\"console-trace-，console-clear\"><a href=\"#console-trace-，console-clear\" class=\"headerlink\" title=\"console.trace()，console.clear()\"></a>console.trace()，console.clear()</h4><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.trace()</span><br><span class=\"line\"><span class=\"comment\">// console.trace()</span></span><br><span class=\"line\"><span class=\"comment\">//   (anonymous function)</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript._evaluateOn</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript._evaluateAndWrap</span></span><br><span class=\"line\"><span class=\"comment\">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure>\n\n<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>\n<h3 id=\"控制台命令行-API\"><a href=\"#控制台命令行-API\" class=\"headerlink\" title=\"控制台命令行 API\"></a>控制台命令行 API</h3><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p>\n<p>（1）<code>$_</code></p>\n<p><code>$_</code>属性返回上一个表达式的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\">$_</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）<code>$0</code> - <code>$4</code></p>\n<p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>\n<p>（3）<code>$(selector)</code></p>\n<p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>\n<p>（4）<code>$$(selector)</code></p>\n<p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>\n<p>（5）<code>$x(path)</code></p>\n<p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$x(<span class=\"string\">\"//p[a]\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>\n<p>（6）<code>inspect(object)</code></p>\n<p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p>\n<p>（7）<code>getEventListeners(object)</code></p>\n<p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p>\n<p>（8）<code>keys(object)</code>，<code>values(object)</code></p>\n<p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>\n<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"string\">'p1'</span>: <span class=\"string\">'a'</span>, <span class=\"string\">'p2'</span>: <span class=\"string\">'b'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">keys(o)</span><br><span class=\"line\"><span class=\"comment\">// [\"p1\", \"p2\"]</span></span><br><span class=\"line\">values(o)</span><br><span class=\"line\"><span class=\"comment\">// [\"a\", \"b\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p>\n<p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents(<span class=\"built_in\">window</span>, <span class=\"string\">\"resize\"</span>);</span><br><span class=\"line\">monitorEvents(<span class=\"built_in\">window</span>, [<span class=\"string\">\"resize\"</span>, <span class=\"string\">\"scroll\"</span>])</span><br></pre></td></tr></table></figure>\n\n<p>上面代码分别表示单个事件和多个事件的监听方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents($<span class=\"number\">0</span>, <span class=\"string\">'mouse'</span>);</span><br><span class=\"line\">unmonitorEvents($<span class=\"number\">0</span>, <span class=\"string\">'mousemove'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示如何停止监听。</p>\n<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>\n<ul>\n<li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li>\n<li>key：”keydown”, “keyup”, “keypress”, “textInput”</li>\n<li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li>\n<li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitorEvents($(<span class=\"string\">\"#msg\"</span>), <span class=\"string\">\"key\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示监听所有<code>key</code>大类的事件。</p>\n<p>（10）其他方法</p>\n<p>命令行 API 还提供以下方法。</p>\n<ul>\n<li><code>clear()</code>：清除控制台的历史。</li>\n<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>\n<li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>\n<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>\n</ul>\n<h3 id=\"debugger-语句\"><a href=\"#debugger-语句\" class=\"headerlink\" title=\"debugger 语句\"></a>debugger 语句</h3><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>\n<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === <span class=\"number\">2</span>) <span class=\"keyword\">debugger</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>\n<h2 id=\"异步操作概述\"><a href=\"#异步操作概述\" class=\"headerlink\" title=\"异步操作概述\"></a>异步操作概述</h2><h3 id=\"单线程模型\"><a href=\"#单线程模型\" class=\"headerlink\" title=\"单线程模型\"></a>单线程模型</h3><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>\n<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>\n<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>\n<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>\n<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>\n<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>\n<h3 id=\"同步任务和异步任务\"><a href=\"#同步任务和异步任务\" class=\"headerlink\" title=\"同步任务和异步任务\"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>\n<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>\n<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>\n<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>\n<h3 id=\"任务队列和事件循环\"><a href=\"#任务队列和事件循环\" class=\"headerlink\" title=\"任务队列和事件循环\"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>\n<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>\n<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>\n<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href=\"https://en.wikipedia.org/wiki/Event_loop\" target=\"_blank\" rel=\"noopener\">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>\n<h3 id=\"异步操作的模式\"><a href=\"#异步操作的模式\" class=\"headerlink\" title=\"异步操作的模式\"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p>\n<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1();</span><br><span class=\"line\">f2();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>\n<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2);</span><br></pre></td></tr></table></figure>\n\n<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href=\"https://en.wikipedia.org/wiki/Coupling_(computer_programming)\" target=\"_blank\" rel=\"noopener\">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>\n<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href=\"https://api.jquery.com/on/\" target=\"_blank\" rel=\"noopener\">写法</a>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    f1.trigger(<span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>\n<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href=\"https://en.wikipedia.org/wiki/Decoupling\" target=\"_blank\" rel=\"noopener\">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>\n<h4 id=\"发布-订阅\"><a href=\"#发布-订阅\" class=\"headerlink\" title=\"发布/订阅\"></a>发布/订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href=\"https://en.wikipedia.org/wiki/Publish-subscribe_pattern\" target=\"_blank\" rel=\"noopener\">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href=\"https://en.wikipedia.org/wiki/Observer_pattern\" target=\"_blank\" rel=\"noopener\">观察者模式</a>”（observer pattern）。</p>\n<p>这个模式有多种<a href=\"https://msdn.microsoft.com/en-us/magazine/hh201955.aspx\" target=\"_blank\" rel=\"noopener\">实现</a>，下面采用的是 Ben Alman 的 <a href=\"https://gist.github.com/661855\" target=\"_blank\" rel=\"noopener\">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p>\n<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.subscribe(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>然后，<code>f1</code>进行如下改写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    jQuery.publish(<span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>\n<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.unsubscribe(<span class=\"string\">'done'</span>, f2);</span><br></pre></td></tr></table></figure>\n\n<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<h3 id=\"异步操作的流程控制\"><a href=\"#异步操作的流程控制\" class=\"headerlink\" title=\"异步操作的流程控制\"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>\n<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"number\">1</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span>(<span class=\"number\">2</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span>(<span class=\"number\">3</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">async</span>(<span class=\"number\">4</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span>(<span class=\"number\">5</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">async</span>(<span class=\"number\">6</span>, final);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 参数为 1 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 2 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 3 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 4 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 5 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 参数为 6 , 1秒后返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 完成:  12</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>\n<h4 id=\"串行执行\"><a href=\"#串行执行\" class=\"headerlink\" title=\"串行执行\"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">series</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(item) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span>( item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      results.push(result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> series(items.shift());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> final(results[results.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">series(items.shift());</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>\n<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>\n<h4 id=\"并行执行\"><a href=\"#并行执行\" class=\"headerlink\" title=\"并行执行\"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">items.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span>(item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">    results.push(result);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(results.length === items.length) &#123;</span><br><span class=\"line\">      final(results[results.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>\n<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>\n<h4 id=\"并行与串行的结合\"><a href=\"#并行与串行的结合\" class=\"headerlink\" title=\"并行与串行的结合\"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> running = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> limit = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async</span>(<span class=\"params\">arg, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'参数为 '</span> + arg +<span class=\"string\">' , 1秒后返回结果'</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; callback(arg * <span class=\"number\">2</span>); &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">final</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成: '</span>, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">launcher</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = items.shift();</span><br><span class=\"line\">    <span class=\"keyword\">async</span>(item, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      results.push(result);</span><br><span class=\"line\">      running--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(items.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        launcher();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(running == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        final(results);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    running++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">launcher();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>\n<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>\n"},{"layout":"post","title":"JS异步讲解-Asynchronous JavaScript","date":"2020-03-26T00:15:00.000Z","description":"promise到底是什么？await和async怎么用？","subtitle":null,"comments":1,"cover":"https://raw.githubusercontent.com/8128/PicGo/master/20200322203138.png","optimized_image":null,"author":"tty","_content":"\n头都被JavaScript的异步处理搞炸了，而且脑子不太好使，经常学一点忘一点。做个笔记记录一下几个学习JavaScript过程中的痛点\n\n部分笔记来源：udemy-modern JavaScript from the beginning\n\n[cnblog](https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html) & [dayTimeAffect](https://juejin.im/post/5d89844ae51d4561ff6668f3) & [Jiasm](https://juejin.im/post/5bc76ff56fb9a05cee1e14a9)\n\n## 什么是异步 Asynchronous\n\n要说清楚异步，需要先把同步说明清楚。所谓同步就是一步步向下走\n\n```javascript\nposts = loadPostsSync();\ndoTheNextThing();\n```\n\n如上所示，必须先把第一个函数执行完了，第二个函数才能执行。众所周知，JavaScript约等于没有多线程，那么node.js又是怎么实现高并发的呢？就是靠异步。现在的环境下一个工程往往会受制于读写时间，而不是真正的处理运算时间。假如我们遇到了读写瓶颈，我们就暂时先搁置手上的工作，优先去处理下一步的内容，随后等到读写完成，再次回来捡起过去仍在地上的工作，这就实现了异步。\n\n```javascript\nloadPostsAsync(function (){\n\t//wait til posts are fetched\n\t//do something with posts\n});\n\ndoTheNextThing();\n```\n\n## 回调函数\n\n首先要把callback说清楚，callback就我理解，就是在一个函数中call另外一个函数，避免在异步过程中出错。从简单的setTimeOut到匿名函数，都算callback。在JavaScript中，函数属于对象，是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。\n\n```javascript\n//可以这样创建函数\nvar fn = new Function(\"arg1\", \"arg2\", \"return arg1 * arg2;\");\nfn(2, 3);   //6\n```\n\n### 传递函数作为回调\n\n```javascript\nfunction fn(arg1, arg2, callback){\n    var num = Math.ceil(Math.random() * (arg1 - arg2) + arg2);\n    callback(num);　　//传递结果\n}\n\nfn(10, 20, function(num){\n   console.log(\"Callback called! Num: \" + num);\n});　　　　//结果为10和20之间的随机数\n```\n\n这里看到我们把function拿来当参数直接传入函数中，这其实就是回调\n\n传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。\n\n但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在JavaScript中使用异步调用，甚至在这里强烈推荐使用！\n\n下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。\n\n```javascript\nfunction fn(url, callback){\n    var httpRequest;　　　　//创建XHR\n    httpRequest = window.XMLHttpRequest ? new XMLHttpRequest() :　　　//针对IE进行功能性检测\n　　　　window.ActiveXObject ? new ActiveXObject(\"Microsoft.XMLHTTP\") : undefined;\n\n    httpRequest.onreadystatechange = function(){\n      if(httpRequest.readystate === 4 && httpRequest.status === 200){　　//状态判断\n          callback.call(httpRequest.responseXML);  \n       }\n    };\n    httpRequest.open(\"GET\", url);\n    httpRequest.send();\n}\n\nfn(\"text.xml\", function(){　　　　//调用函数\n   console.log(this); 　　//此语句后输出\n});\n\nconsole.log(\"this will run before the above callback.\");　　//此语句先输出\n```\n\n我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。\n\n最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。\n\n上述例子不太易于理解，那看看下面的示例：\n\n```javascript\nfunction foo(){\n    var a = 10;\n    return function(){\n        a *= 2;\n        return a;       \n    };   \n}\nvar f = foo();\nf(); //return 20.\nf(); //return 40.\n```\n\n函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。**函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。**只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。\n\n### 经典面试题\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log('i: ',i);\n    }, 1000);\n}\n```\n\n这道题的答案是五个五。那么为什么是五个五呢？\n\n1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）\n\n2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）\n\n那么，为什么我们最先输出的是5呢？\n\n非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。\n\n这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 [JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)，或者看 [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n\n我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。\n\n在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。\n\n那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？\n\n现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。\n\n在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。\n\n**注意，换作let的话那么输出结果就不一样了，let的结果会是0 1 2 3 4**\n\nES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。\n\n## Promises\n\n被叫做promise是因为当他们在处理async的任务时他们可以promise去做一些async结束后的事。一个简单的案例。其中resolve表示接下去要做的事，而reject表示出现error等问题后如何handle\n\n值得一提的是，你new一个promise后，这个promise会执行其中的所有内容直到出现回调函数（或到定义尾部）为止，随后进入pending状态\n\n### 状态\n\n`pending`: 初始状态, 非 `fulfilled` 或 `rejected`.\n\n`fulfilled`: 成功的操作.\n\n`rejected`: 失败的操作.\n\n### 基本用法\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\n```javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n### then()\n\n它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n### catch()\n\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n### finally()\n\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。\n\n```javascript\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n### all()\n\nPromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n\n```javascript\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时**第一个被reject的实例的**返回值，会传递给p的回调函数。\n\n```javascript\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n### race()\n\n```javascript\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n\n### resolve()\n\n有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n### reject()\n\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\n\n```javascript\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n```\n\n### 常见错误\n\n**使用其副作用而不是return** 下面的代码有什么问题？\n\n```javascript\nsomePromise().then(function () {\n  someOtherPromise();\n}).then(function () {\n  // Gee, I hope someOtherPromise() has resolved!\n  // Spoiler alert: it hasn't.\n});\n```\n\n每一个promise对象都会提供一个then方法或者是catch方法\n\n```javascript\nsomePromise().then(function () {\n  // I'm inside a then() function!\n});\n```\n\n我们在这里能做什么呢？有三种事可以做：\n\n1. 返回另一个promise；\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  return getUserAccountById(user.id);\n}).then(function (userAccount) {\n  // I got a user account!\n});\n```\n\n1. 返回一个同步值（或者undefined)\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  if (inMemoryCache[user.id]) {\n    return inMemoryCache[user.id];    // returning a synchronous value!\n  }\n  return getUserAccountById(user.id); // returning a promise!\n}).then(function (userAccount) {\n  // I got a user account!\n});\n```\n\n函数什么都不返回等于返回了 undefined 目前为止，我们看到给 .then() 传递的都是函数，但是其实它可以接受非函数值：\n\n```javascript\nlater(1000)\n  .then(later(2000))\n  .then(function(data) {\n    // data = later_1000\n  });\n```\n\n给 .then() 传递非函数值时，实际上会被解析成 .then(null)，从而导致上一个 promise 对象的结果被“穿透”。于是，上面的代码等价于：\n\n```javascript\nlater(1000)\n  .then(null)\n  .then(function(data) {\n    // data = later_1000\n  });\n```\n\n为了避免不必要的麻烦，建议总是给 .then() 传递函数。\n\n1. 抛出一个同步错误。\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  if (user.isLoggedOut()) {\n    throw new Error('user logged out!'); // throwing a synchronous error!\n  }\n  if (inMemoryCache[user.id]) {\n    return inMemoryCache[user.id];       // returning a synchronous value!\n  }\n  return getUserAccountById(user.id);    // returning a promise!\n}).then(function (userAccount) {\n  // I got a user account!\n}).catch(function (err) {\n  // Boo, I got an error!\n});\n```\n\n**cacth()和then(null, …)并不完全相同**\n\n下面两个代码是不等价的，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。\n\n```javascript\nsomePromise().then(function () {\n  return someOtherPromise();\n}).catch(function (err) {\n  // handle error\n});\n\nsomePromise().then(function () {\n  return someOtherPromise();\n}, function (err) {\n  // handle error\n});\n```\n\n对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了\n\n**promise坠落现象** 这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？\n\n```javascript\nPromise.resolve('foo').then(Promise.resolve('bar')).then(function (result) {\n  console.log(result);\n});\n```\n\n如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！\n\n产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：\n\n```javascript\nPromise.resolve('foo').then(null).then(function (result) {\n  console.log(result);\n});\n```\n\n让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：\n\n```javascript\nPromise.resolve('foo').then(function () {\n  return Promise.resolve('bar');\n}).then(function (result) {\n  console.log(result);\n});\n```\n\n### promise数组依次执行\n\n```javascript\nfunction fetch (api, ms, err = false) {\n  return new Promise(function (resolve, reject) {\n    console.log(`fetch-${api}-${ms} start`)\n    setTimeout(function () {\n      err ? reject(`reject-${api}-${ms}`) : resolve(`resolve-${api}-${ms}`)\n    }, ms)\n  })\n}\n\n解法一\nfunction loadData () {\n  const promises = [fetch('API1', 3000), fetch('API2', 2000), fetch('API3', 5000)]\n  promises.reduce((chain, promise) => {\n    return chain.then((res) => {\n      console.log(res)\n      return promise\n    })\n  }, Promise.resolve('haha')).then(res => {\n    console.log(res)\n  })\n}\n\nloadData()\n// 解法二\nasync function loadData () {\n  const promises = [fetch('API1', 3000), fetch('API2', 2000), fetch('API3', 5000)]\n  for (const promise of promises) {\n    try {\n      await promise.then(res => console.log(res))\n    } catch (err) {\n      console.error(err)\n    }\n  }\n}\n```\n\n### promise常见面试题\n\n1. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n    console.log(2);\n});\npromise.then(() => {\n    console.log(3);\n});\nconsole.log(4);\n```\n\n  输出结果为：1，2，4，3。\n\n  解题思路：then方法是异步执行的。\n\n2. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n    reject('error')\n  }, 1000)\n})\npromise.then((res)=>{\n  console.log(res)\n},(err)=>{\n  console.log(err)\n})\n```\n\n  输出结果：success\n\n  解题思路：Promise状态一旦改变，无法在发生变更。\n\n3. \n\n```javascript\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n```\n\n  输出结果：1\n\n  解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。\n\n4. \n\n```javascript\nsetTimeout(()=>{\n  console.log('setTimeout')\n})\nlet p1 = new Promise((resolve)=>{\n  console.log('Promise1')\n  resolve('Promise2')\n})\np1.then((res)=>{\n  console.log(res)\n})\nconsole.log(1)\n```\n\n输出结果：Promise1    1    Promise2    setTimeout\n\n解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列**microtask queue**中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有**microtask queue**顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考[www.zhihu.com/question/36…](https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36972010)）\n\n```javascript\nsetImmediate(function(){\n    console.log(1);\n},0);\nsetTimeout(function(){\n    console.log(2);\n},0);\nnew Promise(function(resolve){\n    console.log(3);\n    resolve();\n    console.log(4);\n}).then(function(){\n    console.log(5);\n});\nconsole.log(6);\nprocess.nextTick(function(){\n    console.log(7);\n});\nconsole.log(8);\n```\n\n结果是：3 4 6 8 7 5 2 1,优先级关系如下：\n\n```javascript\nprocess.nextTick > promise.then > setTimeout > setImmediate\n```\n\nV8实现中，两个队列各包含不同的任务：\n\n```javascript\nmacrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering\nmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver\n```\n\n**执行过程如下：\\**JavaScript引擎首先从macrotask queue中取出\\**第一个任务**，执行完毕后，将**microtask queue**中的**所有任务**取出，按顺序**全部执行**；然后再从macrotask queue中取**下一个**，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。\n\n**解释：\\**代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，\\*\\*放入到了另一个队列microtask queue\\*\\*。等整个execution context stack执行完后，下一步该取的是\\**microtask queue**中的任务了。因此promise.then的回调比setTimeout先执行。 \n\n5. \n\n```javascript\nPromise.resolve(1)\n    .then((res) => {\n        console.log(res);\n        return 2;\n    })\n    .catch((err) => {\n        return 3;\n    })\n    .then((res) => {\n        console.log(res);\n    });\n```\n\n输出结果：1  2\n\n解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。\n\n6. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\nsetTimeout(() => {\nconsole.log('开始');\nresolve('success');\n}, 5000);\n});\n \nconst start = Date.now();\npromise.then((res) => {\nconsole.log(res, Date.now() - start);\n});\n \npromise.then((res) => {\nconsole.log(res, Date.now() - start);\n});\n```\n\n输出结果：\n\n开始\n\nsuccess 5002\n\nsuccess 5002\n\n解题思路：promise 的**.then**或者**.catch**可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用**.then** 或者**.catch**都会直接拿到该值。\n\n7. \n\n```javascript\nlet p1 = new Promise((resolve,reject)=>{\n  let num = 6\n  if(num<5){\n    console.log('resolve1')\n    resolve(num)\n  }else{\n    console.log('reject1')\n    reject(num)\n  }\n})\np1.then((res)=>{\n  console.log('resolve2')\n  console.log(res)\n},(rej)=>{\n  console.log('reject2')\n  let p2 = new Promise((resolve,reject)=>{\n    if(rej*2>10){\n      console.log('resolve3')\n      resolve(rej*2)\n    }else{\n      console.log('reject3')\n      reject(rej*2)\n    }\n  })\n&emsp;&emsp;return p2\n}).then((res)=>{\n  console.log('resolve4')\n  console.log(res)\n},(rej)=>{\n  console.log('reject4')\n  console.log(rej)\n})\n```\n\n  输出结果：\n\n    reject1    reject2    resolve3    resolve4    12\n\n  解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。\n\n8. \n\n```javascript\nnew Promise(resolve => {\n  console.log(1);\n  resolve(3);\n  new Promise((resolve2 => {\n    resolve2(4)\n  })).then(res => {\n    console.log(res)\n  })\n}).then(num => {\n  console.log(num)\n});\nconsole.log(2)\n```\n\n输出1 2 4 3\n\n9. 重头戏！！！！实现一个简单的Promise\n\n```javascript\nfunction Promise(fn){\n  var status = 'pending'\n  function successNotify(){\n      status = 'fulfilled'//状态变为fulfilled\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function failNotify(){\n      status = 'rejected'//状态变为rejected\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function toDoThen(){\n      setTimeout(()=>{ // 保证回调是异步执行的\n          if(status === 'fulfilled'){\n              for(let i =0; i< successArray.length;i ++)    {\n                  successArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }else if(status === 'rejected'){\n              for(let i =0; i< failArray.length;i ++)    {\n                  failArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }\n      })\n  }\n  var successArray = []\n  var failArray = []\n  fn.call(undefined, successNotify, failNotify)\n  return {\n      then: function(successFn, failFn){\n          successArray.push(successFn)\n          failArray.push(failFn)\n          return undefined // 此处应该返回一个Promise\n      }\n  }\n}\n```\n\n  解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。\n\n## async await\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n前文有一个 Generator 函数，依次读取两个文件。\n\n```javascript\nvar fs = require('fs');\n\nvar readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n写成`async`函数，就是下面这样。\n\n```javascript\nvar asyncReadFile = async function () {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已。\n\n`async`函数对 Generator 函数的改进，体现在以下四点。\n\n（1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。\n\n```javascript\nvar result = asyncReadFile();\n```\n\n上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。\n\n（2）更好的语义。\n\n`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。\n\n（3）更广的适用性。\n\n`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，而`async`函数的`await`命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n（4）返回值是 Promise。\n\n`async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。\n\n进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。\n\n### 用法\n\n#### 基本用法\n\n`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会**先返回，等到异步操作完成，再接着执行函数体内后面的语句**。\n\n下面是一个例子。\n\n```js\nasync function getStockPriceByName(name) {\n  var symbol = await getStockSymbol(name);\n  var stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n上面代码是一个获取股票报价的函数，函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\n```js\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n上面代码指定50毫秒以后，输出`hello world`。\n\n由于`async`函数返回的是 Promise 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。\n\n```js\nasync function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\nasync 函数有多种使用形式。\n\n```js\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n```\n\n### 语法\n\n`async`函数的语法规则总体上比较简单，难点是错误处理机制。\n\n#### 返回 Promise 对象\n\n`async`函数返回一个 Promise 对象。\n\n**`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。**\n\n```js\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n```\n\n上面代码中，函数`f`内部`return`命令返回的值，会被`then`方法回调函数接收到。\n\n`async`函数内部抛出错误，会导致返回的 Promise 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。\n\n```js\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n```\n\n#### Promise 对象的状态变化\n\n`async`函数返回的 Promise 对象，必须等到内部所有`await`命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到`return`语句或者抛出错误。也就是说，只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。\n\n下面是一个例子。\n\n```js\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n```\n\n上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。\n\n#### await 命令\n\n正常情况下，**`await`命令后面是一个 Promise 对象。如果不是，会被转成一个立即`resolve`的 Promise 对象。**\n\n```js\nasync function f() {\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n```\n\n上面代码中，`await`命令的参数是数值`123`，它被转成 Promise 对象，并立即`resolve`。\n\n**`await`命令后面的 Promise 对象如果变为`reject`状态，则`reject`的参数会被`catch`方法的回调函数接收到。**也就是说假如async中有await函数被reject了，那么这段报错会出现在async的catch中\n\n```js\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n```\n\n注意，上面代码中，`await`语句前面没有`return`，但是`reject`方法的参数依然传入了`catch`方法的回调函数。这里如果在`await`前面加上`return`，效果是一样的。\n\n只要一个`await`语句后面的 Promise 变为`reject`，那么整个`async`函数都会中断执行。\n\n```js\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n```\n\n上面代码中，第二个`await`语句是不会执行的，因为第一个`await`语句状态变成了`reject`。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个`await`放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个`await`都会执行。\n\n```js\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n```\n\n另一种方法是`await`后面的 Promise 对象再跟一个`catch`方法，处理前面可能出现的错误。\n\n```js\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n```\n\n#### 错误处理\n\n如果`await`后面的异步操作出错，那么等同于`async`函数返回的 Promise 对象被`reject`。\n\n```js\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n```\n\n上面代码中，`async`函数`f`执行后，`await`后面的 Promise 对象会抛出一个错误对象，导致`catch`方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\n防止出错的方法，也是将其放在`try...catch`代码块之中。\n\n```js\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n```\n\n如果有多个`await`命令，可以统一放在`try...catch`结构中。\n\n```js\nasync function main() {\n  try {\n    var val1 = await firstStep();\n    var val2 = await secondStep(val1);\n    var val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n下面的例子使用`try...catch`结构，实现多次重复尝试。\n\n```js\nconst superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n```\n\n上面代码中，如果`await`操作成功，就会使用`break`语句退出循环；如果失败，会被`catch`语句捕捉，然后进入下一轮循环。\n\n#### 使用注意点\n\n第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  };\n}\n```\n\n第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n```js\nlet foo = await getFoo();\nlet bar = await getBar();\n```\n\n上面代码中，`getFoo`和`getBar`是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有`getFoo`完成以后，才会执行`getBar`，完全可以让它们同时触发。\n\n```js\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n上面两种写法，`getFoo`和`getBar`都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，`await`命令只能用在`async`函数之中，如果用在普通函数，就会报错。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码会报错，因为`await`用在普通函数之中了。但是，如果将`forEach`方法的参数改成`async`函数，也有问题。\n\n```js\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码可能不会正常工作，原因是这时三个`db.post`操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用`for`循环。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n```\n\n如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n### async 函数的实现原理\n\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n```js\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n```\n\n所有的`async`函数都可以写成上面的第二种形式，其中的`spawn`函数就是自动执行器。\n\n下面给出`spawn`函数的实现，基本就是前文自动执行器的翻版。\n\n```js\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n```\n\n### 与其他异步处理方法的比较\n\n我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n首先是 Promise 的写法。\n\n```js\nfunction chainAnimationsPromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  var ret = null;\n\n  // 新建一个空的Promise\n  var p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(var anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n```\n\n虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（`then`、`catch`等等），操作本身的语义反而不容易看出来。\n\n接着是 Generator 函数的写法。\n\n```js\nfunction chainAnimationsGenerator(elem, animations) {\n\n  return spawn(function*() {\n    var ret = null;\n    try {\n      for(var anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n```\n\n上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在`spawn`函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的`spawn`函数就是自动执行器，它返回一个 Promise 对象，而且必须保证`yield`语句后面的表达式，必须返回一个 Promise。\n\n最后是 async 函数的写法。\n\n```js\nasync function chainAnimationsAsync(elem, animations) {\n  var ret = null;\n  try {\n    for(var anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n```\n\n可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。\n\n### 实例：按顺序完成异步操作\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\nPromise 的写法如下。\n\n```js\nfunction logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) => {\n    return chain.then(() => textPromise)\n      .then(text => console.log(text));\n  }, Promise.resolve());\n}\n```\n\n上面代码使用`fetch`方法，同时远程读取一组 URL。每个`fetch`操作都返回一个 Promise 对象，放入`textPromises`数组。然后，`reduce`方法依次处理每个 Promise 对象，然后使用`then`，将所有 Promise 对象连起来，因此就可以依次输出结果。\n\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n\n```js\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n```\n\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n\n```js\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n\n上面代码中，虽然`map`方法的参数是`async`函数，但它是并发执行的，因为只有`async`函数内部是继发执行，外部不受影响。后面的`for..of`循环内部使用了`await`，因此实现了按顺序输出。\n\n### 异步遍历器\n\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\n\n这里隐含着一个规定，`next`方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行`next`方法，就必须同步地得到`value`和`done`这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即`value`属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而`done`属性则还是同步产生的。\n\n目前，有一个[提案](https://github.com/tc39/proposal-async-iteration)，为异步操作提供原生的遍历器接口，即`value`和`done`这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。\n\n#### 异步遍历的接口\n\n异步遍历器的最大的语法特点，就是调用遍历器的`next`方法，返回的是一个 Promise 对象。\n\n```js\nasyncIterator\n  .next()\n  .then(\n    ({ value, done }) => /* ... */\n  );\n```\n\n上面代码中，`asyncIterator`是一个异步遍历器，调用`next`方法以后，返回一个 Promise 对象。因此，可以使用`then`方法指定，这个 Promise 对象的状态变为`resolve`以后的回调函数。回调函数的参数，则是一个具有`value`和`done`两个属性的对象，这个跟同步遍历器是一样的。\n\n我们知道，一个对象的同步遍历器的接口，部署在`Symbol.iterator`属性上面。同样地，对象的异步遍历器接口，部署在`Symbol.asyncIterator`属性上面。不管是什么样的对象，只要它的`Symbol.asyncIterator`属性有值，就表示应该对它进行异步遍历。\n\n下面是一个异步遍历器的例子。\n\n```js\nconst asyncIterable = createAsyncIterable(['a', 'b']);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\nasyncIterator\n.next()\n.then(iterResult1 => {\n  console.log(iterResult1); // { value: 'a', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult2 => {\n  console.log(iterResult2); // { value: 'b', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult3 => {\n  console.log(iterResult3); // { value: undefined, done: true }\n});\n```\n\n上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象`resolve`了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。\n\n由于异步遍历器的`next`方法，返回的是一个 Promise 对象。因此，可以把它放在`await`命令后面。\n\n```js\nasync function f() {\n  const asyncIterable = createAsyncIterable(['a', 'b']);\n  const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\n  // { value: 'a', done: false }\n  console.log(await asyncIterator.next());\n  // { value: 'b', done: false }\n  console.log(await asyncIterator.next());\n  // { value: undefined, done: true }\n}\n```\n\n上面代码中，`next`方法用`await`处理以后，就不必使用`then`方法了。整个流程已经很接近同步处理了。\n\n注意，异步遍历器的`next`方法是可以连续调用的，不必等到上一步产生的Promise对象`resolve`以后再调用。这种情况下，`next`方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的`next`方法放在`Promise.all`方法里面。\n\n```js\nconst asyncGenObj = createAsyncIterable(['a', 'b']);\nconst [{value: v1}, {value: v2}] = await Promise.all([\n  asyncGenObj.next(), asyncGenObj.next()\n]);\n\nconsole.log(v1, v2); // a b\n```\n\n另一种用法是一次性调用所有的`next`方法，然后`await`最后一步操作。\n\n```js\nconst writer = openFile('someFile.txt');\nwriter.next('hello');\nwriter.next('world');\nawait writer.return();\n```\n\n#### for await...of\n\n前面介绍过，`for...of`循环用于遍历同步的 Iterator 接口。新引入的`for await...of`循环，则是用于遍历异步的 Iterator 接口。\n\n```js\nasync function f() {\n  for await (const x of createAsyncIterable(['a', 'b'])) {\n    console.log(x);\n  }\n}\n// a\n// b\n```\n\n上面代码中，`createAsyncIterable()`返回一个异步遍历器，`for...of`循环自动调用这个遍历器的`next`方法，会得到一个Promise对象。`await`用来处理这个Promise对象，一旦`resolve`，就把得到的值（`x`）传入`for...of`的循环体。\n\n`for await...of`循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。\n\n```js\nlet body = '';\nfor await(const data of req) body += data;\nconst parsed = JSON.parse(body);\nconsole.log('got', parsed);\n```\n\n上面代码中，`req`是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用`for await...of`循环以后，代码会非常简洁。\n\n如果`next`方法返回的Promise对象被`reject`，那么就要用`try...catch`捕捉。\n\n```js\nasync function () {\n  try {\n    for await (const x of createRejectingIterable()) {\n      console.log(x);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n```\n\n注意，`for await...of`循环也可以用于同步遍历器。\n\n```js\n(async function () {\n  for await (const x of ['a', 'b']) {\n    console.log(x);\n  }\n})();\n// a\n// b\n```\n\n#### 异步Generator函数\n\n就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。\n\n在语法上，异步 Generator 函数就是`async`函数与 Generator 函数的结合。\n\n```js\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n```\n\n上面代码中，异步操作前面使用`await`关键字标明，即`await`后面的操作，应该返回Promise对象。凡是使用`yield`关键字的地方，就是`next`方法的停下来的地方，它后面的表达式的值（即`await file.readLine()`的值），会作为`next()`返回对象的`value`属性，这一点是于同步Generator函数一致的。\n\n可以像下面这样，使用上面代码定义的异步Generator函数。\n\n```js\nfor await (const line of readLines(filePath)) {\n  console.log(line);\n}\n```\n\n异步 Generator 函数可以与`for await...of`循环结合起来使用。\n\n```js\nasync function* prefixLines(asyncIterable) {\n  for await (const line of asyncIterable) {\n    yield '> ' + line;\n  }\n}\n```\n\n`yield`命令依然是立刻返回的，但是返回的是一个Promise对象。\n\n```js\nasync function* asyncGenerator() {\n  console.log('Start');\n  const result = await doSomethingAsync(); // (A)\n  yield 'Result: '+ result; // (B)\n  console.log('Done');\n}\n```\n\n上面代码中，调用`next`方法以后，会在`B`处暂停执行，`yield`命令立刻返回一个Promise对象。这个Promise对象不同于`A`处`await`命令后面的那个 Promise 对象。主要有两点不同，一是`A`处的Promise对象`resolve`以后产生的值，会放入`result`变量；二是`B`处的Promise对象`resolve`以后产生的值，是表达式`'Result： ' + result`的值；二是`A`处的 Promise 对象一定先于`B`处的 Promise 对象`resolve`。\n\n如果异步 Generator 函数抛出错误，会被 Promise 对象`reject`，然后抛出的错误被`catch`方法捕获。\n\n```js\nasync function* asyncGenerator() {\n  throw new Error('Problem!');\n}\n\nasyncGenerator()\n.next()\n.catch(err => console.log(err)); // Error: Problem!\n```\n\n注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，`async`函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过`for await...of`执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。\n\n```js\nasync function takeAsync(asyncIterable, count=Infinity) {\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value,done} = await iterator.next();\n    if (done) break;\n    result.push(value);\n  }\n  return result;\n}\n```\n\n上面代码中，异步Generator函数产生的异步遍历器，会通过`while`循环自动执行，每当`await iterator.next()`完成，就会进入下一轮循环。\n\n下面是这个自动执行器的一个使用实例。\n\n```js\nasync function f() {\n  async function* gen() {\n    yield 'a';\n    yield 'b';\n    yield 'c';\n  }\n\n  return await takeAsync(gen());\n}\n\nf().then(function (result) {\n  console.log(result); // ['a', 'b', 'c']\n})\n```\n\n异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。\n\n最后，同步的数据结构，也可以使用异步 Generator 函数。\n\n```js\nasync function* createAsyncIterable(syncIterable) {\n  for (const elem of syncIterable) {\n    yield elem;\n  }\n}\n```\n\n上面代码中，由于没有异步操作，所以也就没有使用`await`关键字。\n\n#### yield* 语句\n\n`yield*`语句也可以跟一个异步遍历器。\n\n```js\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  const result = yield* gen1();\n}\n```\n\n上面代码中，`gen2`函数里面的`result`变量，最后的值是`2`。\n\n与同步Generator函数一样，`for await...of`循环会展开`yield*`。\n\n```js\n(async function () {\n  for await (const x of gen2()) {\n    console.log(x);\n  }\n})();\n// a\n// b\n```\n\n## Promisify\n\n`util.promisify`是在`node.js 8.x`版本中新增的一个工具，用于将老式的`Error first callback`转换为`Promise`对象，让老项目改造变得更为轻松。\n\n在官方推出这个工具之前，民间已经有很多类似的工具了，比如[es6-promisify](https://www.npmjs.com/package/es6-promisify)、[thenify](https://www.npmjs.com/package/thenify)、[bluebird.promisify](http://bluebirdjs.com/docs/api/promise.promisify.html)。\n\n以及很多其他优秀的工具，都是实现了这样的功能，帮助我们在处理老项目的时候，不必费神将各种代码使用`Promise`再重新实现一遍。\n\n### 工具实现的大致思路\n\n首先要解释一下这种工具大致的实现思路，因为在`Node`中异步回调有一个约定：`Error first`，也就是说回调函数中的第一个参数一定要是`Error`对象，其余参数才是正确时的数据。\n\n知道了这样的规律以后，工具就很好实现了，在匹配到第一个参数有值的情况下，触发`reject`，其余情况触发`resolve`，一个简单的示例代码：\n\n```javascript\nfunction util (func) {\n  return (...arg) => new Promise((resolve, reject) => {\n    func(...arg, (err, arg) => {\n      if (err) reject(err)\n      else resolve(arg)\n    })\n  })\n}\n```\n\n1. 调用工具函数返回一个匿名函数，匿名函数接收原函数的参数。\n2. 匿名函数被调用后根据这些参数来调用真实的函数，同时拼接一个用来处理结果的`callback`。\n3. 检测到`err`有值，触发`reject`，其他情况触发`resolve`\n\n**resolve 只能传入一个参数，所以`callback`中没有必要使用`...arg`获取所有的返回值**\n\n### 常规的使用方式\n\n> 拿一个官方文档中的示例\n\n```javascript\nconst { promisify } = require('util')\nconst fs = require('fs')\n\nconst statAsync = promisify(fs.stat)\n\nstatAsync('.').then(stats => {\n  // 拿到了正确的数据\n}, err => {\n  // 出现了异常\n})\n```\n\n以及因为是`Promise`，我们可以使用`await`来进一步简化代码：\n\n```javascript\nconst { promisify } = require('util')\nconst fs = require('fs')\n\nconst statAsync = promisify(fs.stat)\n\n// 假设在 async 函数中\ntry {\n  const stats = await statAsync('.')\n  // 拿到正确结果\n} catch (e) {\n  // 出现异常\n}\n```\n\n用法与其他工具并没有太大的区别，我们可以很轻易的将回调转换为`Promise`，然后应用于新的项目中。\n\n### 自定义的 Promise 化\n\n有那么一些场景，是不能够直接使用`promisify`来进行转换的，有大概这么两种情况：\n\n1. 没有遵循`Error first callback`约定的回调函数\n2. 返回多个参数的回调函数\n\n首先是第一个，如果没有遵循我们的约定，很可能导致`reject`的误判，得不到正确的反馈。\n而第二项呢，则是因为`Promise.resolve`只能接收一个参数，多余的参数会被忽略。\n\n所以为了实现正确的结果，我们可能需要手动实现对应的`Promise`函数，但是自己实现了以后并不能够确保使用方不会针对你的函数调用`promisify`。\n\n所以，`util.promisify`还提供了一个`Symbol`类型的`key`，`util.promisify.custom`。\n\n`Symbol`类型的大家应该都有了解，是一个唯一的值，这里是`util.prosimify`用来指定自定义的`Promise`化的结果的，使用方式如下：\n\n```javascript\nconst { promisify } = require('util')\n// 比如我们有一个对象，提供了一个返回多个参数的回调版本的函数\nconst obj = {\n  getData (callback) {\n    callback(null, 'Niko', 18) // 返回两个参数，姓名和年龄\n  }\n}\n\n// 这时使用promisify肯定是不行的\n// 因为Promise.resolve只接收一个参数，所以我们只会得到 Niko\n\npromisify(obj.getData)().then(console.log) // Niko\n\n// 所以我们需要使用 promisify.custom 来自定义处理方式\n\nobj.getData[promisify.custom] = async () => ({ name: 'Niko', age: 18 })\n\n// 当然了，这是一个曲线救国的方式，无论如何 Promise 不会返回多个参数过来的\npromisify(obj.getData)().then(console.log) // { name: 'Niko', age: 18 }\n复制代码\n```\n\n*关于`Promise`为什么不能`resolve`多个值，我有一个大胆的想法，一个没有经过考证，强行解释的理由：如果能`resolve`多个值，你让`async`函数怎么`return`（当个乐子看这句话就好，不要当真）*\n*不过应该确实跟`return`有关，因为`Promise`是可以链式调用的，每个`Promise`中执行`then`以后都会将其返回值作为一个新的`Promise`对象`resolve`的值，在`JavaScript`中并没有办法`return`多个参数，所以即便第一个`Promise`可以返回多个参数，只要经过`return`的处理就会丢失*\n\n在使用上就是很简单的针对可能会被调用`promisify`的函数上添加`promisify.custom`对应的处理即可。\n当后续代码调用`promisify`时就会进行判断：\n\n1. 如果目标函数存在\n\n   ```js\n   promisify.custom\n   ```\n\n   属性，则会判断其类型：\n\n   1. 如果不是一个可执行的函数，抛出异常\n   2. 如果是可执行的函数，则直接返回其对应的函数\n\n2. 如果目标函数不存在对应的属性，按照`Error first callback`的约定生成对应的处理函数然后返回\n\n添加了这个`custom`属性以后，就不用再担心使用方针对你的函数调用`promisify`了。\n而且可以验证，赋值给`custom`的函数与`promisify`返回的函数地址是一处：\n\n```js\nobj.getData[promisify.custom] = async () => ({ name: 'Niko', age: 18 })\n\n// 上边的赋值为 async 函数也可以改为普通函数，只要保证这个普通函数会返回 Promise 实例即可\n// 这两种方式与上边的 async 都是完全相等的\n\nobj.getData[promisify.custom] = () => Promise.resolve({ name: 'Niko', age: 18 })\nobj.getData[promisify.custom] = () => new Promise(resolve({ name: 'Niko', age: 18 }))\n\nconsole.log(obj.getData[promisify.custom] === promisify(obj.getData)) // true\n```\n\n#### 一些内置的 custom 处理\n\n在一些内置包中，也能够找到`promisify.custom`的踪迹，比如说最常用的`child_process.exec`就内置了`promisify.custom`的处理：\n\n```js\nconst { exec } = require('child_process')\nconst { promisify } = require('util')\n\nconsole.log(typeof exec[promisify.custom]) // function\n```\n\n因为就像前边示例中所提到的曲线救国的方案，官方的做法也是将函数签名中的参数名作为`key`，将其所有参数存放到一个`Object`对象中进行返回，比如`child_process.exec`的返回值抛开`error`以外会包含两个，`stdout`和`stderr`，一个是命令执行后的正确输出，一个是命令执行后的错误输出：\n\n```js\npromisify(exec)('ls').then(console.log)\n// -> { stdout: 'XXX', stderr: '' }\n```\n\n或者我们故意输入一些错误的命令，当然了，这个只能在`catch`模块下才能够捕捉到，一般命令正常执行`stderr`都会是一个空字符串：\n\n```js\npromisify(exec)('lss').then(console.log, console.error)\n// -> { ..., stdout: '', stderr: 'lss: command not found' }\n```\n\n包括像`setTimeout`、`setImmediate`也都实现了对应的`promisify.custom`。\n之前为了实现`sleep`的操作，还手动使用`Promise`封装了`setTimeout`：\n\n```js\nconst sleep = promisify(setTimeout)\n\nconsole.log(new Date())\n\nawait sleep(1000)\n\nconsole.log(new Date())\n```\n\n### 内置的 promisify 转换后函数\n\n如果你的`Node`版本使用`10.x`以上的，还可以从很多内置的模块中找到类似`.promises`的子模块，这里边包含了该模块中常用的回调函数的`Promise`版本（都是`async`函数），无需再手动进行`promisify`转换了。\n\n而且我本人觉得这是一个很好的指引方向，因为之前的工具实现，有的选择直接覆盖原有函数，有的则是在原有函数名后边增加`Async`进行区分，官方的这种在模块中单独引入一个子模块，在里边实现`Promise`版本的函数，其实这个在使用上是很方便的，就拿`fs`模块进行举例：\n\n```js\n// 之前引入一些 fs 相关的 API 是这样做的\nconst { readFile, stat } = require('fs')\n\n// 而现在可以很简单的改为\nconst { readFile, stat } = require('fs').promises\n// 或者\nconst { promises: { readFile, stat } } = require('fs')\n```\n\n后边要做的就是将调用`promisify`相关的代码删掉即可，对于其他使用`API`的代码来讲，这个改动是无感知的。\n所以如果你的`node`版本够高的话，可以在使用内置模块之前先去翻看文档，有没有对应的`promises`支持，如果有实现的话，就可以直接使用。\n\n### promisify 的一些注意事项\n\n1. 一定要符合`Error first callback`的约定\n2. 不能返回多个参数\n3. 注意进行转换的函数是否包含`this`的引用\n\n前两个问题，使用前边提到的`promisify.custom`都可以解决掉。\n但是第三项可能会在某些情况下被我们所忽视，这并不是`promisify`独有的问题，就一个很简单的例子：\n\n```js\nconst obj = {\n  name: 'Niko',\n  getName () {\n    return this.name\n  }\n}\n\nobj.getName() // Niko\n\nconst func = obj.getName\n\nfunc() // undefined\n```\n\n类似的，如果我们在进行`Promise`转换的时候，也是类似这样的操作，那么可能会导致生成后的函数`this`指向出现问题。\n修复这样的问题有两种途径：\n\n1. 使用箭头函数，也是推荐的做法\n2. 在调用`promisify`之前使用`bind`绑定对应的`this`\n\n不过这样的问题也是建立在`promisify`转换后的函数被赋值给其他变量的情况下会发生。\n如果是类似这样的代码，那么完全不必担心`this`指向的问题：\n\n```js\nconst obj = {\n  name: 'Niko',\n  getName (callback) {\n    callback(null, this.name)\n  }\n}\n\n// 这样的操作是不需要担心 this 指向问题的\nobj.XXX = promisify(obj.getName)\n\n// 如果赋值给了其他变量，那么这里就需要注意 this 的指向了\nconst func = promisify(obj.getName) // 错误的 this\n```\n\n### 小结\n\n个人认为`Promise`作为当代`javaScript`异步编程中最核心的一部分，了解如何将老旧代码转换为`Promise`是一件很有意思的事儿。\n而我去了解官方的这个工具，原因是在搜索`Redis`相关的`Promise`版本时看到了这个[readme](https://github.com/mjackson/then-redis)：\n\n> This package is no longer maintained. node_redis now includes support for promises in core, so this is no longer needed.\n\n然后跳到了`node_redis`里边的实现方案，里边提到了`util.promisify`，遂抓过来研究了一下，感觉还挺有意思，总结了下分享给大家。\n\n## Js异步执行顺序\n\n今天在重温promise的时候，突然发现了一个有趣的题目：\n\n```js\n(function() {\n    setTimeout(() => {\n        console.log(0);\n    });\n    new Promise(resolve => {\n        console.log(1);\n        setTimeout(() => {\n            resolve();\n            Promise.resolve().then(() => {\n                console.log(2);\n                setTimeout(() => console.log(3));\n                Promise.resolve().then(() => console.log(4));\n            });\n        });\n        Promise.resolve().then(() => console.log(5));\n    }).then(() => {\n        console.log(6);\n        Promise.resolve().then(() => console.log(7));\n        setTimeout(() => console.log(8));\n    });\n    console.log(9);\n})();\n```\n\n我们先放上结果：\n\n```js\n1 9 5 0 6 2 7 4 8 3\n```\n\n### 简要讲述\n\n首先我们知道JS分为了同步和异步，并且是顺序是先同步后异步，也就是同步代码执行完成后，哪怕异步代码到了它执行的时候，也会先让同步执行完。但是JS的执行顺序还可以分得更细，那就是异步的顺序。 我们知道很多异步任务，比如：\n\n```js\nsetTimeout, setInterval, setImmediate, Promises.then, Promise.catch\n```\n\n甚至还有nodejs中的process.nextTick等，就像我们知道process.nextTick比promise先执行一样。那么这些异步事件是谁先执行谁后执行呢。 这涉及到了事件循环(event loop)。事件循环也就是事件出入栈。 上面说了这么多异步任务，我们先把它们分为两类： **宏任务（macro-task）**：setTimeout, setInterval, setImmediate **微任务（micro-task）**：Promises.then, Promise.catch\n\n然后我们再明白一个概念：**先执行微任务，再执行宏任务**。这种执行是，**先执行清空微任务队列，再执行宏任务，当当前宏任务执行完后，微任务队列中又有微任务，再次将微任务队列执行完，再执行下一个宏任务**。\n\n在异步任务执行过程中遇到宏任务与微任务，将其依次放入当前事件循环队列中。\n\n### 例题描述\n\n首先执行主线程，也就是script（script是宏任务），因为此时没有微任务\n\n然后遇到`setTimeout(() => { console.log(0);});` 这是宏任务，将其放入宏任务队列中 记为 -- 宏任务1\n\npromise新建后会立即执行，输出`1`\n\n然后将\n\n```js\n        setTimeout(() => {\n            resolve();\n            Promise.resolve().then(() => {\n                console.log(2);\n                setTimeout(() => console.log(3));\n                Promise.resolve().then(() => console.log(4));\n            });\n        });\n```\n\n继续放入宏任务队列中 记为 -- 宏任务2\n\n将`Promise.resolve().then(() => console.log(5));`放入微任务队列中 记为 -- 微任务1\n\n继续往下走，输出`9`\n\n此时当前宏任务执行完毕，开始执行微任务队列，目前微任务队列中只有微任务1，执行，输出`5`\n\n微任务队列此时清空，然后执行宏任务1，输出`0`\n\n微任务队列依然没有任务，继续执行宏任务2，遇见 `resolve();`，于是将\n\n```js\n.then(() => {\n        console.log(6);\n        Promise.resolve().then(() => console.log(7));\n        setTimeout(() => console.log(8));\n    });\n    console.log(9);\n})\n```\n\n放入微任务队列中，记为 -- 微任务2，再将\n\n```js\nPromise.resolve().then(() => {\n      console.log(2);\n      setTimeout(() => console.log(3));\n      Promise.resolve().then(() => console.log(4));\n});\n```\n\n记为 -- 微任务3\n\n当前宏任务执行完毕，开始执行微任务，先执行微任务2，输出`6`；将`Promise.resolve().then(() => console.log(7));`记为 -- 微任务4；`setTimeout(() => console.log(8));`记为 -- 宏任务3\n\n执行微任务3，输出`2`；将`setTimeout(() => console.log(3));`记为 -- 宏任务4；将`Promise.resolve().then(() => console.log(4));`记为 -- 微任务5；\n\n此时队列中依然有微任务，执行微任务4，输出`7`；执行微任务5，输出`4`；微任务队列执行完毕\n\n执行宏任务3，输出`8`；执行宏任务4，输出`3`；全部执行完毕\n\n那么我们的结果为`1 9 5 0 6 2 7 4 8 3`\n\n\n\n","source":"_posts/2020-03-25-JS异步讲解-Asynchronous JavaScript.md","raw":"---\nlayout: post\ntitle:  JS异步讲解-Asynchronous JavaScript\ndate:   2020-03-25 17:15:00\ndescription: promise到底是什么？await和async怎么用？\nsubtitle:\ncomments: true\ncover: https://raw.githubusercontent.com/8128/PicGo/master/20200322203138.png\noptimized_image:\ncategory: javascript\ntags:\n  - tutorial\n  - code\n  - javascript\nauthor: tty\n---\n\n头都被JavaScript的异步处理搞炸了，而且脑子不太好使，经常学一点忘一点。做个笔记记录一下几个学习JavaScript过程中的痛点\n\n部分笔记来源：udemy-modern JavaScript from the beginning\n\n[cnblog](https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html) & [dayTimeAffect](https://juejin.im/post/5d89844ae51d4561ff6668f3) & [Jiasm](https://juejin.im/post/5bc76ff56fb9a05cee1e14a9)\n\n## 什么是异步 Asynchronous\n\n要说清楚异步，需要先把同步说明清楚。所谓同步就是一步步向下走\n\n```javascript\nposts = loadPostsSync();\ndoTheNextThing();\n```\n\n如上所示，必须先把第一个函数执行完了，第二个函数才能执行。众所周知，JavaScript约等于没有多线程，那么node.js又是怎么实现高并发的呢？就是靠异步。现在的环境下一个工程往往会受制于读写时间，而不是真正的处理运算时间。假如我们遇到了读写瓶颈，我们就暂时先搁置手上的工作，优先去处理下一步的内容，随后等到读写完成，再次回来捡起过去仍在地上的工作，这就实现了异步。\n\n```javascript\nloadPostsAsync(function (){\n\t//wait til posts are fetched\n\t//do something with posts\n});\n\ndoTheNextThing();\n```\n\n## 回调函数\n\n首先要把callback说清楚，callback就我理解，就是在一个函数中call另外一个函数，避免在异步过程中出错。从简单的setTimeOut到匿名函数，都算callback。在JavaScript中，函数属于对象，是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。\n\n```javascript\n//可以这样创建函数\nvar fn = new Function(\"arg1\", \"arg2\", \"return arg1 * arg2;\");\nfn(2, 3);   //6\n```\n\n### 传递函数作为回调\n\n```javascript\nfunction fn(arg1, arg2, callback){\n    var num = Math.ceil(Math.random() * (arg1 - arg2) + arg2);\n    callback(num);　　//传递结果\n}\n\nfn(10, 20, function(num){\n   console.log(\"Callback called! Num: \" + num);\n});　　　　//结果为10和20之间的随机数\n```\n\n这里看到我们把function拿来当参数直接传入函数中，这其实就是回调\n\n传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。\n\n但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在JavaScript中使用异步调用，甚至在这里强烈推荐使用！\n\n下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。\n\n```javascript\nfunction fn(url, callback){\n    var httpRequest;　　　　//创建XHR\n    httpRequest = window.XMLHttpRequest ? new XMLHttpRequest() :　　　//针对IE进行功能性检测\n　　　　window.ActiveXObject ? new ActiveXObject(\"Microsoft.XMLHTTP\") : undefined;\n\n    httpRequest.onreadystatechange = function(){\n      if(httpRequest.readystate === 4 && httpRequest.status === 200){　　//状态判断\n          callback.call(httpRequest.responseXML);  \n       }\n    };\n    httpRequest.open(\"GET\", url);\n    httpRequest.send();\n}\n\nfn(\"text.xml\", function(){　　　　//调用函数\n   console.log(this); 　　//此语句后输出\n});\n\nconsole.log(\"this will run before the above callback.\");　　//此语句先输出\n```\n\n我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。\n\n最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。\n\n上述例子不太易于理解，那看看下面的示例：\n\n```javascript\nfunction foo(){\n    var a = 10;\n    return function(){\n        a *= 2;\n        return a;       \n    };   \n}\nvar f = foo();\nf(); //return 20.\nf(); //return 40.\n```\n\n函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。**函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。**只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。\n\n### 经典面试题\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log('i: ',i);\n    }, 1000);\n}\n```\n\n这道题的答案是五个五。那么为什么是五个五呢？\n\n1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）\n\n2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）\n\n那么，为什么我们最先输出的是5呢？\n\n非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。\n\n这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 [JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)，或者看 [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n\n我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。\n\n在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。\n\n那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？\n\n现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。\n\n在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。\n\n**注意，换作let的话那么输出结果就不一样了，let的结果会是0 1 2 3 4**\n\nES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。\n\n## Promises\n\n被叫做promise是因为当他们在处理async的任务时他们可以promise去做一些async结束后的事。一个简单的案例。其中resolve表示接下去要做的事，而reject表示出现error等问题后如何handle\n\n值得一提的是，你new一个promise后，这个promise会执行其中的所有内容直到出现回调函数（或到定义尾部）为止，随后进入pending状态\n\n### 状态\n\n`pending`: 初始状态, 非 `fulfilled` 或 `rejected`.\n\n`fulfilled`: 成功的操作.\n\n`rejected`: 失败的操作.\n\n### 基本用法\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\n```javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n### then()\n\n它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n### catch()\n\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n### finally()\n\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。\n\n```javascript\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n### all()\n\nPromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n\n```javascript\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时**第一个被reject的实例的**返回值，会传递给p的回调函数。\n\n```javascript\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n### race()\n\n```javascript\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n\n### resolve()\n\n有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n### reject()\n\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\n\n```javascript\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n```\n\n### 常见错误\n\n**使用其副作用而不是return** 下面的代码有什么问题？\n\n```javascript\nsomePromise().then(function () {\n  someOtherPromise();\n}).then(function () {\n  // Gee, I hope someOtherPromise() has resolved!\n  // Spoiler alert: it hasn't.\n});\n```\n\n每一个promise对象都会提供一个then方法或者是catch方法\n\n```javascript\nsomePromise().then(function () {\n  // I'm inside a then() function!\n});\n```\n\n我们在这里能做什么呢？有三种事可以做：\n\n1. 返回另一个promise；\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  return getUserAccountById(user.id);\n}).then(function (userAccount) {\n  // I got a user account!\n});\n```\n\n1. 返回一个同步值（或者undefined)\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  if (inMemoryCache[user.id]) {\n    return inMemoryCache[user.id];    // returning a synchronous value!\n  }\n  return getUserAccountById(user.id); // returning a promise!\n}).then(function (userAccount) {\n  // I got a user account!\n});\n```\n\n函数什么都不返回等于返回了 undefined 目前为止，我们看到给 .then() 传递的都是函数，但是其实它可以接受非函数值：\n\n```javascript\nlater(1000)\n  .then(later(2000))\n  .then(function(data) {\n    // data = later_1000\n  });\n```\n\n给 .then() 传递非函数值时，实际上会被解析成 .then(null)，从而导致上一个 promise 对象的结果被“穿透”。于是，上面的代码等价于：\n\n```javascript\nlater(1000)\n  .then(null)\n  .then(function(data) {\n    // data = later_1000\n  });\n```\n\n为了避免不必要的麻烦，建议总是给 .then() 传递函数。\n\n1. 抛出一个同步错误。\n\n```javascript\ngetUserByName('nolan').then(function (user) {\n  if (user.isLoggedOut()) {\n    throw new Error('user logged out!'); // throwing a synchronous error!\n  }\n  if (inMemoryCache[user.id]) {\n    return inMemoryCache[user.id];       // returning a synchronous value!\n  }\n  return getUserAccountById(user.id);    // returning a promise!\n}).then(function (userAccount) {\n  // I got a user account!\n}).catch(function (err) {\n  // Boo, I got an error!\n});\n```\n\n**cacth()和then(null, …)并不完全相同**\n\n下面两个代码是不等价的，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。\n\n```javascript\nsomePromise().then(function () {\n  return someOtherPromise();\n}).catch(function (err) {\n  // handle error\n});\n\nsomePromise().then(function () {\n  return someOtherPromise();\n}, function (err) {\n  // handle error\n});\n```\n\n对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了\n\n**promise坠落现象** 这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？\n\n```javascript\nPromise.resolve('foo').then(Promise.resolve('bar')).then(function (result) {\n  console.log(result);\n});\n```\n\n如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！\n\n产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：\n\n```javascript\nPromise.resolve('foo').then(null).then(function (result) {\n  console.log(result);\n});\n```\n\n让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：\n\n```javascript\nPromise.resolve('foo').then(function () {\n  return Promise.resolve('bar');\n}).then(function (result) {\n  console.log(result);\n});\n```\n\n### promise数组依次执行\n\n```javascript\nfunction fetch (api, ms, err = false) {\n  return new Promise(function (resolve, reject) {\n    console.log(`fetch-${api}-${ms} start`)\n    setTimeout(function () {\n      err ? reject(`reject-${api}-${ms}`) : resolve(`resolve-${api}-${ms}`)\n    }, ms)\n  })\n}\n\n解法一\nfunction loadData () {\n  const promises = [fetch('API1', 3000), fetch('API2', 2000), fetch('API3', 5000)]\n  promises.reduce((chain, promise) => {\n    return chain.then((res) => {\n      console.log(res)\n      return promise\n    })\n  }, Promise.resolve('haha')).then(res => {\n    console.log(res)\n  })\n}\n\nloadData()\n// 解法二\nasync function loadData () {\n  const promises = [fetch('API1', 3000), fetch('API2', 2000), fetch('API3', 5000)]\n  for (const promise of promises) {\n    try {\n      await promise.then(res => console.log(res))\n    } catch (err) {\n      console.error(err)\n    }\n  }\n}\n```\n\n### promise常见面试题\n\n1. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n    console.log(2);\n});\npromise.then(() => {\n    console.log(3);\n});\nconsole.log(4);\n```\n\n  输出结果为：1，2，4，3。\n\n  解题思路：then方法是异步执行的。\n\n2. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n    reject('error')\n  }, 1000)\n})\npromise.then((res)=>{\n  console.log(res)\n},(err)=>{\n  console.log(err)\n})\n```\n\n  输出结果：success\n\n  解题思路：Promise状态一旦改变，无法在发生变更。\n\n3. \n\n```javascript\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n```\n\n  输出结果：1\n\n  解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。\n\n4. \n\n```javascript\nsetTimeout(()=>{\n  console.log('setTimeout')\n})\nlet p1 = new Promise((resolve)=>{\n  console.log('Promise1')\n  resolve('Promise2')\n})\np1.then((res)=>{\n  console.log(res)\n})\nconsole.log(1)\n```\n\n输出结果：Promise1    1    Promise2    setTimeout\n\n解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列**microtask queue**中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有**microtask queue**顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考[www.zhihu.com/question/36…](https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36972010)）\n\n```javascript\nsetImmediate(function(){\n    console.log(1);\n},0);\nsetTimeout(function(){\n    console.log(2);\n},0);\nnew Promise(function(resolve){\n    console.log(3);\n    resolve();\n    console.log(4);\n}).then(function(){\n    console.log(5);\n});\nconsole.log(6);\nprocess.nextTick(function(){\n    console.log(7);\n});\nconsole.log(8);\n```\n\n结果是：3 4 6 8 7 5 2 1,优先级关系如下：\n\n```javascript\nprocess.nextTick > promise.then > setTimeout > setImmediate\n```\n\nV8实现中，两个队列各包含不同的任务：\n\n```javascript\nmacrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering\nmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver\n```\n\n**执行过程如下：\\**JavaScript引擎首先从macrotask queue中取出\\**第一个任务**，执行完毕后，将**microtask queue**中的**所有任务**取出，按顺序**全部执行**；然后再从macrotask queue中取**下一个**，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。\n\n**解释：\\**代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，\\*\\*放入到了另一个队列microtask queue\\*\\*。等整个execution context stack执行完后，下一步该取的是\\**microtask queue**中的任务了。因此promise.then的回调比setTimeout先执行。 \n\n5. \n\n```javascript\nPromise.resolve(1)\n    .then((res) => {\n        console.log(res);\n        return 2;\n    })\n    .catch((err) => {\n        return 3;\n    })\n    .then((res) => {\n        console.log(res);\n    });\n```\n\n输出结果：1  2\n\n解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。\n\n6. \n\n```javascript\nconst promise = new Promise((resolve, reject) => {\nsetTimeout(() => {\nconsole.log('开始');\nresolve('success');\n}, 5000);\n});\n \nconst start = Date.now();\npromise.then((res) => {\nconsole.log(res, Date.now() - start);\n});\n \npromise.then((res) => {\nconsole.log(res, Date.now() - start);\n});\n```\n\n输出结果：\n\n开始\n\nsuccess 5002\n\nsuccess 5002\n\n解题思路：promise 的**.then**或者**.catch**可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用**.then** 或者**.catch**都会直接拿到该值。\n\n7. \n\n```javascript\nlet p1 = new Promise((resolve,reject)=>{\n  let num = 6\n  if(num<5){\n    console.log('resolve1')\n    resolve(num)\n  }else{\n    console.log('reject1')\n    reject(num)\n  }\n})\np1.then((res)=>{\n  console.log('resolve2')\n  console.log(res)\n},(rej)=>{\n  console.log('reject2')\n  let p2 = new Promise((resolve,reject)=>{\n    if(rej*2>10){\n      console.log('resolve3')\n      resolve(rej*2)\n    }else{\n      console.log('reject3')\n      reject(rej*2)\n    }\n  })\n&emsp;&emsp;return p2\n}).then((res)=>{\n  console.log('resolve4')\n  console.log(res)\n},(rej)=>{\n  console.log('reject4')\n  console.log(rej)\n})\n```\n\n  输出结果：\n\n    reject1    reject2    resolve3    resolve4    12\n\n  解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。\n\n8. \n\n```javascript\nnew Promise(resolve => {\n  console.log(1);\n  resolve(3);\n  new Promise((resolve2 => {\n    resolve2(4)\n  })).then(res => {\n    console.log(res)\n  })\n}).then(num => {\n  console.log(num)\n});\nconsole.log(2)\n```\n\n输出1 2 4 3\n\n9. 重头戏！！！！实现一个简单的Promise\n\n```javascript\nfunction Promise(fn){\n  var status = 'pending'\n  function successNotify(){\n      status = 'fulfilled'//状态变为fulfilled\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function failNotify(){\n      status = 'rejected'//状态变为rejected\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function toDoThen(){\n      setTimeout(()=>{ // 保证回调是异步执行的\n          if(status === 'fulfilled'){\n              for(let i =0; i< successArray.length;i ++)    {\n                  successArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }else if(status === 'rejected'){\n              for(let i =0; i< failArray.length;i ++)    {\n                  failArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }\n      })\n  }\n  var successArray = []\n  var failArray = []\n  fn.call(undefined, successNotify, failNotify)\n  return {\n      then: function(successFn, failFn){\n          successArray.push(successFn)\n          failArray.push(failFn)\n          return undefined // 此处应该返回一个Promise\n      }\n  }\n}\n```\n\n  解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。\n\n## async await\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n前文有一个 Generator 函数，依次读取两个文件。\n\n```javascript\nvar fs = require('fs');\n\nvar readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n写成`async`函数，就是下面这样。\n\n```javascript\nvar asyncReadFile = async function () {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已。\n\n`async`函数对 Generator 函数的改进，体现在以下四点。\n\n（1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。\n\n```javascript\nvar result = asyncReadFile();\n```\n\n上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。\n\n（2）更好的语义。\n\n`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。\n\n（3）更广的适用性。\n\n`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，而`async`函数的`await`命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n（4）返回值是 Promise。\n\n`async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。\n\n进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。\n\n### 用法\n\n#### 基本用法\n\n`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会**先返回，等到异步操作完成，再接着执行函数体内后面的语句**。\n\n下面是一个例子。\n\n```js\nasync function getStockPriceByName(name) {\n  var symbol = await getStockSymbol(name);\n  var stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n上面代码是一个获取股票报价的函数，函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\n```js\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n上面代码指定50毫秒以后，输出`hello world`。\n\n由于`async`函数返回的是 Promise 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。\n\n```js\nasync function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\nasync 函数有多种使用形式。\n\n```js\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n```\n\n### 语法\n\n`async`函数的语法规则总体上比较简单，难点是错误处理机制。\n\n#### 返回 Promise 对象\n\n`async`函数返回一个 Promise 对象。\n\n**`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。**\n\n```js\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n```\n\n上面代码中，函数`f`内部`return`命令返回的值，会被`then`方法回调函数接收到。\n\n`async`函数内部抛出错误，会导致返回的 Promise 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。\n\n```js\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n```\n\n#### Promise 对象的状态变化\n\n`async`函数返回的 Promise 对象，必须等到内部所有`await`命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到`return`语句或者抛出错误。也就是说，只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。\n\n下面是一个例子。\n\n```js\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n```\n\n上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。\n\n#### await 命令\n\n正常情况下，**`await`命令后面是一个 Promise 对象。如果不是，会被转成一个立即`resolve`的 Promise 对象。**\n\n```js\nasync function f() {\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n```\n\n上面代码中，`await`命令的参数是数值`123`，它被转成 Promise 对象，并立即`resolve`。\n\n**`await`命令后面的 Promise 对象如果变为`reject`状态，则`reject`的参数会被`catch`方法的回调函数接收到。**也就是说假如async中有await函数被reject了，那么这段报错会出现在async的catch中\n\n```js\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n```\n\n注意，上面代码中，`await`语句前面没有`return`，但是`reject`方法的参数依然传入了`catch`方法的回调函数。这里如果在`await`前面加上`return`，效果是一样的。\n\n只要一个`await`语句后面的 Promise 变为`reject`，那么整个`async`函数都会中断执行。\n\n```js\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n```\n\n上面代码中，第二个`await`语句是不会执行的，因为第一个`await`语句状态变成了`reject`。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个`await`放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个`await`都会执行。\n\n```js\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n```\n\n另一种方法是`await`后面的 Promise 对象再跟一个`catch`方法，处理前面可能出现的错误。\n\n```js\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n```\n\n#### 错误处理\n\n如果`await`后面的异步操作出错，那么等同于`async`函数返回的 Promise 对象被`reject`。\n\n```js\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n```\n\n上面代码中，`async`函数`f`执行后，`await`后面的 Promise 对象会抛出一个错误对象，导致`catch`方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\n防止出错的方法，也是将其放在`try...catch`代码块之中。\n\n```js\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n```\n\n如果有多个`await`命令，可以统一放在`try...catch`结构中。\n\n```js\nasync function main() {\n  try {\n    var val1 = await firstStep();\n    var val2 = await secondStep(val1);\n    var val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n下面的例子使用`try...catch`结构，实现多次重复尝试。\n\n```js\nconst superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n```\n\n上面代码中，如果`await`操作成功，就会使用`break`语句退出循环；如果失败，会被`catch`语句捕捉，然后进入下一轮循环。\n\n#### 使用注意点\n\n第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  };\n}\n```\n\n第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n```js\nlet foo = await getFoo();\nlet bar = await getBar();\n```\n\n上面代码中，`getFoo`和`getBar`是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有`getFoo`完成以后，才会执行`getBar`，完全可以让它们同时触发。\n\n```js\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n上面两种写法，`getFoo`和`getBar`都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，`await`命令只能用在`async`函数之中，如果用在普通函数，就会报错。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码会报错，因为`await`用在普通函数之中了。但是，如果将`forEach`方法的参数改成`async`函数，也有问题。\n\n```js\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码可能不会正常工作，原因是这时三个`db.post`操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用`for`循环。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n```\n\n如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n### async 函数的实现原理\n\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n```js\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n```\n\n所有的`async`函数都可以写成上面的第二种形式，其中的`spawn`函数就是自动执行器。\n\n下面给出`spawn`函数的实现，基本就是前文自动执行器的翻版。\n\n```js\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n```\n\n### 与其他异步处理方法的比较\n\n我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n首先是 Promise 的写法。\n\n```js\nfunction chainAnimationsPromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  var ret = null;\n\n  // 新建一个空的Promise\n  var p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(var anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n```\n\n虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（`then`、`catch`等等），操作本身的语义反而不容易看出来。\n\n接着是 Generator 函数的写法。\n\n```js\nfunction chainAnimationsGenerator(elem, animations) {\n\n  return spawn(function*() {\n    var ret = null;\n    try {\n      for(var anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n```\n\n上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在`spawn`函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的`spawn`函数就是自动执行器，它返回一个 Promise 对象，而且必须保证`yield`语句后面的表达式，必须返回一个 Promise。\n\n最后是 async 函数的写法。\n\n```js\nasync function chainAnimationsAsync(elem, animations) {\n  var ret = null;\n  try {\n    for(var anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n```\n\n可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。\n\n### 实例：按顺序完成异步操作\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\nPromise 的写法如下。\n\n```js\nfunction logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) => {\n    return chain.then(() => textPromise)\n      .then(text => console.log(text));\n  }, Promise.resolve());\n}\n```\n\n上面代码使用`fetch`方法，同时远程读取一组 URL。每个`fetch`操作都返回一个 Promise 对象，放入`textPromises`数组。然后，`reduce`方法依次处理每个 Promise 对象，然后使用`then`，将所有 Promise 对象连起来，因此就可以依次输出结果。\n\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n\n```js\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n```\n\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n\n```js\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n\n上面代码中，虽然`map`方法的参数是`async`函数，但它是并发执行的，因为只有`async`函数内部是继发执行，外部不受影响。后面的`for..of`循环内部使用了`await`，因此实现了按顺序输出。\n\n### 异步遍历器\n\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\n\n这里隐含着一个规定，`next`方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行`next`方法，就必须同步地得到`value`和`done`这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即`value`属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而`done`属性则还是同步产生的。\n\n目前，有一个[提案](https://github.com/tc39/proposal-async-iteration)，为异步操作提供原生的遍历器接口，即`value`和`done`这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。\n\n#### 异步遍历的接口\n\n异步遍历器的最大的语法特点，就是调用遍历器的`next`方法，返回的是一个 Promise 对象。\n\n```js\nasyncIterator\n  .next()\n  .then(\n    ({ value, done }) => /* ... */\n  );\n```\n\n上面代码中，`asyncIterator`是一个异步遍历器，调用`next`方法以后，返回一个 Promise 对象。因此，可以使用`then`方法指定，这个 Promise 对象的状态变为`resolve`以后的回调函数。回调函数的参数，则是一个具有`value`和`done`两个属性的对象，这个跟同步遍历器是一样的。\n\n我们知道，一个对象的同步遍历器的接口，部署在`Symbol.iterator`属性上面。同样地，对象的异步遍历器接口，部署在`Symbol.asyncIterator`属性上面。不管是什么样的对象，只要它的`Symbol.asyncIterator`属性有值，就表示应该对它进行异步遍历。\n\n下面是一个异步遍历器的例子。\n\n```js\nconst asyncIterable = createAsyncIterable(['a', 'b']);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\nasyncIterator\n.next()\n.then(iterResult1 => {\n  console.log(iterResult1); // { value: 'a', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult2 => {\n  console.log(iterResult2); // { value: 'b', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult3 => {\n  console.log(iterResult3); // { value: undefined, done: true }\n});\n```\n\n上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象`resolve`了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。\n\n由于异步遍历器的`next`方法，返回的是一个 Promise 对象。因此，可以把它放在`await`命令后面。\n\n```js\nasync function f() {\n  const asyncIterable = createAsyncIterable(['a', 'b']);\n  const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\n  // { value: 'a', done: false }\n  console.log(await asyncIterator.next());\n  // { value: 'b', done: false }\n  console.log(await asyncIterator.next());\n  // { value: undefined, done: true }\n}\n```\n\n上面代码中，`next`方法用`await`处理以后，就不必使用`then`方法了。整个流程已经很接近同步处理了。\n\n注意，异步遍历器的`next`方法是可以连续调用的，不必等到上一步产生的Promise对象`resolve`以后再调用。这种情况下，`next`方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的`next`方法放在`Promise.all`方法里面。\n\n```js\nconst asyncGenObj = createAsyncIterable(['a', 'b']);\nconst [{value: v1}, {value: v2}] = await Promise.all([\n  asyncGenObj.next(), asyncGenObj.next()\n]);\n\nconsole.log(v1, v2); // a b\n```\n\n另一种用法是一次性调用所有的`next`方法，然后`await`最后一步操作。\n\n```js\nconst writer = openFile('someFile.txt');\nwriter.next('hello');\nwriter.next('world');\nawait writer.return();\n```\n\n#### for await...of\n\n前面介绍过，`for...of`循环用于遍历同步的 Iterator 接口。新引入的`for await...of`循环，则是用于遍历异步的 Iterator 接口。\n\n```js\nasync function f() {\n  for await (const x of createAsyncIterable(['a', 'b'])) {\n    console.log(x);\n  }\n}\n// a\n// b\n```\n\n上面代码中，`createAsyncIterable()`返回一个异步遍历器，`for...of`循环自动调用这个遍历器的`next`方法，会得到一个Promise对象。`await`用来处理这个Promise对象，一旦`resolve`，就把得到的值（`x`）传入`for...of`的循环体。\n\n`for await...of`循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。\n\n```js\nlet body = '';\nfor await(const data of req) body += data;\nconst parsed = JSON.parse(body);\nconsole.log('got', parsed);\n```\n\n上面代码中，`req`是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用`for await...of`循环以后，代码会非常简洁。\n\n如果`next`方法返回的Promise对象被`reject`，那么就要用`try...catch`捕捉。\n\n```js\nasync function () {\n  try {\n    for await (const x of createRejectingIterable()) {\n      console.log(x);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n```\n\n注意，`for await...of`循环也可以用于同步遍历器。\n\n```js\n(async function () {\n  for await (const x of ['a', 'b']) {\n    console.log(x);\n  }\n})();\n// a\n// b\n```\n\n#### 异步Generator函数\n\n就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。\n\n在语法上，异步 Generator 函数就是`async`函数与 Generator 函数的结合。\n\n```js\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n```\n\n上面代码中，异步操作前面使用`await`关键字标明，即`await`后面的操作，应该返回Promise对象。凡是使用`yield`关键字的地方，就是`next`方法的停下来的地方，它后面的表达式的值（即`await file.readLine()`的值），会作为`next()`返回对象的`value`属性，这一点是于同步Generator函数一致的。\n\n可以像下面这样，使用上面代码定义的异步Generator函数。\n\n```js\nfor await (const line of readLines(filePath)) {\n  console.log(line);\n}\n```\n\n异步 Generator 函数可以与`for await...of`循环结合起来使用。\n\n```js\nasync function* prefixLines(asyncIterable) {\n  for await (const line of asyncIterable) {\n    yield '> ' + line;\n  }\n}\n```\n\n`yield`命令依然是立刻返回的，但是返回的是一个Promise对象。\n\n```js\nasync function* asyncGenerator() {\n  console.log('Start');\n  const result = await doSomethingAsync(); // (A)\n  yield 'Result: '+ result; // (B)\n  console.log('Done');\n}\n```\n\n上面代码中，调用`next`方法以后，会在`B`处暂停执行，`yield`命令立刻返回一个Promise对象。这个Promise对象不同于`A`处`await`命令后面的那个 Promise 对象。主要有两点不同，一是`A`处的Promise对象`resolve`以后产生的值，会放入`result`变量；二是`B`处的Promise对象`resolve`以后产生的值，是表达式`'Result： ' + result`的值；二是`A`处的 Promise 对象一定先于`B`处的 Promise 对象`resolve`。\n\n如果异步 Generator 函数抛出错误，会被 Promise 对象`reject`，然后抛出的错误被`catch`方法捕获。\n\n```js\nasync function* asyncGenerator() {\n  throw new Error('Problem!');\n}\n\nasyncGenerator()\n.next()\n.catch(err => console.log(err)); // Error: Problem!\n```\n\n注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，`async`函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过`for await...of`执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。\n\n```js\nasync function takeAsync(asyncIterable, count=Infinity) {\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value,done} = await iterator.next();\n    if (done) break;\n    result.push(value);\n  }\n  return result;\n}\n```\n\n上面代码中，异步Generator函数产生的异步遍历器，会通过`while`循环自动执行，每当`await iterator.next()`完成，就会进入下一轮循环。\n\n下面是这个自动执行器的一个使用实例。\n\n```js\nasync function f() {\n  async function* gen() {\n    yield 'a';\n    yield 'b';\n    yield 'c';\n  }\n\n  return await takeAsync(gen());\n}\n\nf().then(function (result) {\n  console.log(result); // ['a', 'b', 'c']\n})\n```\n\n异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。\n\n最后，同步的数据结构，也可以使用异步 Generator 函数。\n\n```js\nasync function* createAsyncIterable(syncIterable) {\n  for (const elem of syncIterable) {\n    yield elem;\n  }\n}\n```\n\n上面代码中，由于没有异步操作，所以也就没有使用`await`关键字。\n\n#### yield* 语句\n\n`yield*`语句也可以跟一个异步遍历器。\n\n```js\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  const result = yield* gen1();\n}\n```\n\n上面代码中，`gen2`函数里面的`result`变量，最后的值是`2`。\n\n与同步Generator函数一样，`for await...of`循环会展开`yield*`。\n\n```js\n(async function () {\n  for await (const x of gen2()) {\n    console.log(x);\n  }\n})();\n// a\n// b\n```\n\n## Promisify\n\n`util.promisify`是在`node.js 8.x`版本中新增的一个工具，用于将老式的`Error first callback`转换为`Promise`对象，让老项目改造变得更为轻松。\n\n在官方推出这个工具之前，民间已经有很多类似的工具了，比如[es6-promisify](https://www.npmjs.com/package/es6-promisify)、[thenify](https://www.npmjs.com/package/thenify)、[bluebird.promisify](http://bluebirdjs.com/docs/api/promise.promisify.html)。\n\n以及很多其他优秀的工具，都是实现了这样的功能，帮助我们在处理老项目的时候，不必费神将各种代码使用`Promise`再重新实现一遍。\n\n### 工具实现的大致思路\n\n首先要解释一下这种工具大致的实现思路，因为在`Node`中异步回调有一个约定：`Error first`，也就是说回调函数中的第一个参数一定要是`Error`对象，其余参数才是正确时的数据。\n\n知道了这样的规律以后，工具就很好实现了，在匹配到第一个参数有值的情况下，触发`reject`，其余情况触发`resolve`，一个简单的示例代码：\n\n```javascript\nfunction util (func) {\n  return (...arg) => new Promise((resolve, reject) => {\n    func(...arg, (err, arg) => {\n      if (err) reject(err)\n      else resolve(arg)\n    })\n  })\n}\n```\n\n1. 调用工具函数返回一个匿名函数，匿名函数接收原函数的参数。\n2. 匿名函数被调用后根据这些参数来调用真实的函数，同时拼接一个用来处理结果的`callback`。\n3. 检测到`err`有值，触发`reject`，其他情况触发`resolve`\n\n**resolve 只能传入一个参数，所以`callback`中没有必要使用`...arg`获取所有的返回值**\n\n### 常规的使用方式\n\n> 拿一个官方文档中的示例\n\n```javascript\nconst { promisify } = require('util')\nconst fs = require('fs')\n\nconst statAsync = promisify(fs.stat)\n\nstatAsync('.').then(stats => {\n  // 拿到了正确的数据\n}, err => {\n  // 出现了异常\n})\n```\n\n以及因为是`Promise`，我们可以使用`await`来进一步简化代码：\n\n```javascript\nconst { promisify } = require('util')\nconst fs = require('fs')\n\nconst statAsync = promisify(fs.stat)\n\n// 假设在 async 函数中\ntry {\n  const stats = await statAsync('.')\n  // 拿到正确结果\n} catch (e) {\n  // 出现异常\n}\n```\n\n用法与其他工具并没有太大的区别，我们可以很轻易的将回调转换为`Promise`，然后应用于新的项目中。\n\n### 自定义的 Promise 化\n\n有那么一些场景，是不能够直接使用`promisify`来进行转换的，有大概这么两种情况：\n\n1. 没有遵循`Error first callback`约定的回调函数\n2. 返回多个参数的回调函数\n\n首先是第一个，如果没有遵循我们的约定，很可能导致`reject`的误判，得不到正确的反馈。\n而第二项呢，则是因为`Promise.resolve`只能接收一个参数，多余的参数会被忽略。\n\n所以为了实现正确的结果，我们可能需要手动实现对应的`Promise`函数，但是自己实现了以后并不能够确保使用方不会针对你的函数调用`promisify`。\n\n所以，`util.promisify`还提供了一个`Symbol`类型的`key`，`util.promisify.custom`。\n\n`Symbol`类型的大家应该都有了解，是一个唯一的值，这里是`util.prosimify`用来指定自定义的`Promise`化的结果的，使用方式如下：\n\n```javascript\nconst { promisify } = require('util')\n// 比如我们有一个对象，提供了一个返回多个参数的回调版本的函数\nconst obj = {\n  getData (callback) {\n    callback(null, 'Niko', 18) // 返回两个参数，姓名和年龄\n  }\n}\n\n// 这时使用promisify肯定是不行的\n// 因为Promise.resolve只接收一个参数，所以我们只会得到 Niko\n\npromisify(obj.getData)().then(console.log) // Niko\n\n// 所以我们需要使用 promisify.custom 来自定义处理方式\n\nobj.getData[promisify.custom] = async () => ({ name: 'Niko', age: 18 })\n\n// 当然了，这是一个曲线救国的方式，无论如何 Promise 不会返回多个参数过来的\npromisify(obj.getData)().then(console.log) // { name: 'Niko', age: 18 }\n复制代码\n```\n\n*关于`Promise`为什么不能`resolve`多个值，我有一个大胆的想法，一个没有经过考证，强行解释的理由：如果能`resolve`多个值，你让`async`函数怎么`return`（当个乐子看这句话就好，不要当真）*\n*不过应该确实跟`return`有关，因为`Promise`是可以链式调用的，每个`Promise`中执行`then`以后都会将其返回值作为一个新的`Promise`对象`resolve`的值，在`JavaScript`中并没有办法`return`多个参数，所以即便第一个`Promise`可以返回多个参数，只要经过`return`的处理就会丢失*\n\n在使用上就是很简单的针对可能会被调用`promisify`的函数上添加`promisify.custom`对应的处理即可。\n当后续代码调用`promisify`时就会进行判断：\n\n1. 如果目标函数存在\n\n   ```js\n   promisify.custom\n   ```\n\n   属性，则会判断其类型：\n\n   1. 如果不是一个可执行的函数，抛出异常\n   2. 如果是可执行的函数，则直接返回其对应的函数\n\n2. 如果目标函数不存在对应的属性，按照`Error first callback`的约定生成对应的处理函数然后返回\n\n添加了这个`custom`属性以后，就不用再担心使用方针对你的函数调用`promisify`了。\n而且可以验证，赋值给`custom`的函数与`promisify`返回的函数地址是一处：\n\n```js\nobj.getData[promisify.custom] = async () => ({ name: 'Niko', age: 18 })\n\n// 上边的赋值为 async 函数也可以改为普通函数，只要保证这个普通函数会返回 Promise 实例即可\n// 这两种方式与上边的 async 都是完全相等的\n\nobj.getData[promisify.custom] = () => Promise.resolve({ name: 'Niko', age: 18 })\nobj.getData[promisify.custom] = () => new Promise(resolve({ name: 'Niko', age: 18 }))\n\nconsole.log(obj.getData[promisify.custom] === promisify(obj.getData)) // true\n```\n\n#### 一些内置的 custom 处理\n\n在一些内置包中，也能够找到`promisify.custom`的踪迹，比如说最常用的`child_process.exec`就内置了`promisify.custom`的处理：\n\n```js\nconst { exec } = require('child_process')\nconst { promisify } = require('util')\n\nconsole.log(typeof exec[promisify.custom]) // function\n```\n\n因为就像前边示例中所提到的曲线救国的方案，官方的做法也是将函数签名中的参数名作为`key`，将其所有参数存放到一个`Object`对象中进行返回，比如`child_process.exec`的返回值抛开`error`以外会包含两个，`stdout`和`stderr`，一个是命令执行后的正确输出，一个是命令执行后的错误输出：\n\n```js\npromisify(exec)('ls').then(console.log)\n// -> { stdout: 'XXX', stderr: '' }\n```\n\n或者我们故意输入一些错误的命令，当然了，这个只能在`catch`模块下才能够捕捉到，一般命令正常执行`stderr`都会是一个空字符串：\n\n```js\npromisify(exec)('lss').then(console.log, console.error)\n// -> { ..., stdout: '', stderr: 'lss: command not found' }\n```\n\n包括像`setTimeout`、`setImmediate`也都实现了对应的`promisify.custom`。\n之前为了实现`sleep`的操作，还手动使用`Promise`封装了`setTimeout`：\n\n```js\nconst sleep = promisify(setTimeout)\n\nconsole.log(new Date())\n\nawait sleep(1000)\n\nconsole.log(new Date())\n```\n\n### 内置的 promisify 转换后函数\n\n如果你的`Node`版本使用`10.x`以上的，还可以从很多内置的模块中找到类似`.promises`的子模块，这里边包含了该模块中常用的回调函数的`Promise`版本（都是`async`函数），无需再手动进行`promisify`转换了。\n\n而且我本人觉得这是一个很好的指引方向，因为之前的工具实现，有的选择直接覆盖原有函数，有的则是在原有函数名后边增加`Async`进行区分，官方的这种在模块中单独引入一个子模块，在里边实现`Promise`版本的函数，其实这个在使用上是很方便的，就拿`fs`模块进行举例：\n\n```js\n// 之前引入一些 fs 相关的 API 是这样做的\nconst { readFile, stat } = require('fs')\n\n// 而现在可以很简单的改为\nconst { readFile, stat } = require('fs').promises\n// 或者\nconst { promises: { readFile, stat } } = require('fs')\n```\n\n后边要做的就是将调用`promisify`相关的代码删掉即可，对于其他使用`API`的代码来讲，这个改动是无感知的。\n所以如果你的`node`版本够高的话，可以在使用内置模块之前先去翻看文档，有没有对应的`promises`支持，如果有实现的话，就可以直接使用。\n\n### promisify 的一些注意事项\n\n1. 一定要符合`Error first callback`的约定\n2. 不能返回多个参数\n3. 注意进行转换的函数是否包含`this`的引用\n\n前两个问题，使用前边提到的`promisify.custom`都可以解决掉。\n但是第三项可能会在某些情况下被我们所忽视，这并不是`promisify`独有的问题，就一个很简单的例子：\n\n```js\nconst obj = {\n  name: 'Niko',\n  getName () {\n    return this.name\n  }\n}\n\nobj.getName() // Niko\n\nconst func = obj.getName\n\nfunc() // undefined\n```\n\n类似的，如果我们在进行`Promise`转换的时候，也是类似这样的操作，那么可能会导致生成后的函数`this`指向出现问题。\n修复这样的问题有两种途径：\n\n1. 使用箭头函数，也是推荐的做法\n2. 在调用`promisify`之前使用`bind`绑定对应的`this`\n\n不过这样的问题也是建立在`promisify`转换后的函数被赋值给其他变量的情况下会发生。\n如果是类似这样的代码，那么完全不必担心`this`指向的问题：\n\n```js\nconst obj = {\n  name: 'Niko',\n  getName (callback) {\n    callback(null, this.name)\n  }\n}\n\n// 这样的操作是不需要担心 this 指向问题的\nobj.XXX = promisify(obj.getName)\n\n// 如果赋值给了其他变量，那么这里就需要注意 this 的指向了\nconst func = promisify(obj.getName) // 错误的 this\n```\n\n### 小结\n\n个人认为`Promise`作为当代`javaScript`异步编程中最核心的一部分，了解如何将老旧代码转换为`Promise`是一件很有意思的事儿。\n而我去了解官方的这个工具，原因是在搜索`Redis`相关的`Promise`版本时看到了这个[readme](https://github.com/mjackson/then-redis)：\n\n> This package is no longer maintained. node_redis now includes support for promises in core, so this is no longer needed.\n\n然后跳到了`node_redis`里边的实现方案，里边提到了`util.promisify`，遂抓过来研究了一下，感觉还挺有意思，总结了下分享给大家。\n\n## Js异步执行顺序\n\n今天在重温promise的时候，突然发现了一个有趣的题目：\n\n```js\n(function() {\n    setTimeout(() => {\n        console.log(0);\n    });\n    new Promise(resolve => {\n        console.log(1);\n        setTimeout(() => {\n            resolve();\n            Promise.resolve().then(() => {\n                console.log(2);\n                setTimeout(() => console.log(3));\n                Promise.resolve().then(() => console.log(4));\n            });\n        });\n        Promise.resolve().then(() => console.log(5));\n    }).then(() => {\n        console.log(6);\n        Promise.resolve().then(() => console.log(7));\n        setTimeout(() => console.log(8));\n    });\n    console.log(9);\n})();\n```\n\n我们先放上结果：\n\n```js\n1 9 5 0 6 2 7 4 8 3\n```\n\n### 简要讲述\n\n首先我们知道JS分为了同步和异步，并且是顺序是先同步后异步，也就是同步代码执行完成后，哪怕异步代码到了它执行的时候，也会先让同步执行完。但是JS的执行顺序还可以分得更细，那就是异步的顺序。 我们知道很多异步任务，比如：\n\n```js\nsetTimeout, setInterval, setImmediate, Promises.then, Promise.catch\n```\n\n甚至还有nodejs中的process.nextTick等，就像我们知道process.nextTick比promise先执行一样。那么这些异步事件是谁先执行谁后执行呢。 这涉及到了事件循环(event loop)。事件循环也就是事件出入栈。 上面说了这么多异步任务，我们先把它们分为两类： **宏任务（macro-task）**：setTimeout, setInterval, setImmediate **微任务（micro-task）**：Promises.then, Promise.catch\n\n然后我们再明白一个概念：**先执行微任务，再执行宏任务**。这种执行是，**先执行清空微任务队列，再执行宏任务，当当前宏任务执行完后，微任务队列中又有微任务，再次将微任务队列执行完，再执行下一个宏任务**。\n\n在异步任务执行过程中遇到宏任务与微任务，将其依次放入当前事件循环队列中。\n\n### 例题描述\n\n首先执行主线程，也就是script（script是宏任务），因为此时没有微任务\n\n然后遇到`setTimeout(() => { console.log(0);});` 这是宏任务，将其放入宏任务队列中 记为 -- 宏任务1\n\npromise新建后会立即执行，输出`1`\n\n然后将\n\n```js\n        setTimeout(() => {\n            resolve();\n            Promise.resolve().then(() => {\n                console.log(2);\n                setTimeout(() => console.log(3));\n                Promise.resolve().then(() => console.log(4));\n            });\n        });\n```\n\n继续放入宏任务队列中 记为 -- 宏任务2\n\n将`Promise.resolve().then(() => console.log(5));`放入微任务队列中 记为 -- 微任务1\n\n继续往下走，输出`9`\n\n此时当前宏任务执行完毕，开始执行微任务队列，目前微任务队列中只有微任务1，执行，输出`5`\n\n微任务队列此时清空，然后执行宏任务1，输出`0`\n\n微任务队列依然没有任务，继续执行宏任务2，遇见 `resolve();`，于是将\n\n```js\n.then(() => {\n        console.log(6);\n        Promise.resolve().then(() => console.log(7));\n        setTimeout(() => console.log(8));\n    });\n    console.log(9);\n})\n```\n\n放入微任务队列中，记为 -- 微任务2，再将\n\n```js\nPromise.resolve().then(() => {\n      console.log(2);\n      setTimeout(() => console.log(3));\n      Promise.resolve().then(() => console.log(4));\n});\n```\n\n记为 -- 微任务3\n\n当前宏任务执行完毕，开始执行微任务，先执行微任务2，输出`6`；将`Promise.resolve().then(() => console.log(7));`记为 -- 微任务4；`setTimeout(() => console.log(8));`记为 -- 宏任务3\n\n执行微任务3，输出`2`；将`setTimeout(() => console.log(3));`记为 -- 宏任务4；将`Promise.resolve().then(() => console.log(4));`记为 -- 微任务5；\n\n此时队列中依然有微任务，执行微任务4，输出`7`；执行微任务5，输出`4`；微任务队列执行完毕\n\n执行宏任务3，输出`8`；执行宏任务4，输出`3`；全部执行完毕\n\n那么我们的结果为`1 9 5 0 6 2 7 4 8 3`\n\n\n\n","slug":"JS异步讲解-Asynchronous JavaScript","published":1,"updated":"2020-03-29T06:59:20.717Z","photos":[],"link":"","_id":"ck8ct7kh1003qgtvi166e4xbl","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>头都被JavaScript的异步处理搞炸了，而且脑子不太好使，经常学一点忘一点。做个笔记记录一下几个学习JavaScript过程中的痛点</p>\n<p>部分笔记来源：udemy-modern JavaScript from the beginning</p>\n<p><a href=\"https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html\" target=\"_blank\" rel=\"noopener\">cnblog</a> &amp; <a href=\"https://juejin.im/post/5d89844ae51d4561ff6668f3\" target=\"_blank\" rel=\"noopener\">dayTimeAffect</a> &amp; <a href=\"https://juejin.im/post/5bc76ff56fb9a05cee1e14a9\" target=\"_blank\" rel=\"noopener\">Jiasm</a></p>\n<h2 id=\"什么是异步-Asynchronous\"><a href=\"#什么是异步-Asynchronous\" class=\"headerlink\" title=\"什么是异步 Asynchronous\"></a>什么是异步 Asynchronous</h2><p>要说清楚异步，需要先把同步说明清楚。所谓同步就是一步步向下走</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">posts = loadPostsSync();</span><br><span class=\"line\">doTheNextThing();</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，必须先把第一个函数执行完了，第二个函数才能执行。众所周知，JavaScript约等于没有多线程，那么node.js又是怎么实现高并发的呢？就是靠异步。现在的环境下一个工程往往会受制于读写时间，而不是真正的处理运算时间。假如我们遇到了读写瓶颈，我们就暂时先搁置手上的工作，优先去处理下一步的内容，随后等到读写完成，再次回来捡起过去仍在地上的工作，这就实现了异步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadPostsAsync(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//wait til posts are fetched</span></span><br><span class=\"line\">\t<span class=\"comment\">//do something with posts</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doTheNextThing();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p>首先要把callback说清楚，callback就我理解，就是在一个函数中call另外一个函数，避免在异步过程中出错。从简单的setTimeOut到匿名函数，都算callback。在JavaScript中，函数属于对象，是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以这样创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"arg1\"</span>, <span class=\"string\">\"arg2\"</span>, <span class=\"string\">\"return arg1 * arg2;\"</span>);</span><br><span class=\"line\">fn(<span class=\"number\">2</span>, <span class=\"number\">3</span>);   <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"传递函数作为回调\"><a href=\"#传递函数作为回调\" class=\"headerlink\" title=\"传递函数作为回调\"></a>传递函数作为回调</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">arg1, arg2, callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * (arg1 - arg2) + arg2);</span><br><span class=\"line\">    callback(num);　　<span class=\"comment\">//传递结果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Callback called! Num: \"</span> + num);</span><br><span class=\"line\">&#125;);　　　　<span class=\"comment\">//结果为10和20之间的随机数</span></span><br></pre></td></tr></table></figure>\n\n<p>这里看到我们把function拿来当参数直接传入函数中，这其实就是回调</p>\n<p>传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。</p>\n<p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在JavaScript中使用异步调用，甚至在这里强烈推荐使用！</p>\n<p>下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">url, callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> httpRequest;　　　　<span class=\"comment\">//创建XHR</span></span><br><span class=\"line\">    httpRequest = <span class=\"built_in\">window</span>.XMLHttpRequest ? <span class=\"keyword\">new</span> XMLHttpRequest() :　　　<span class=\"comment\">//针对IE进行功能性检测</span></span><br><span class=\"line\">　　　　<span class=\"built_in\">window</span>.ActiveXObject ? <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>) : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    httpRequest.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(httpRequest.readystate === <span class=\"number\">4</span> &amp;&amp; httpRequest.status === <span class=\"number\">200</span>)&#123;　　<span class=\"comment\">//状态判断</span></span><br><span class=\"line\">          callback.call(httpRequest.responseXML);  </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    httpRequest.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    httpRequest.send();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">\"text.xml\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;　　　　<span class=\"comment\">//调用函数</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); 　　<span class=\"comment\">//此语句后输出</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"this will run before the above callback.\"</span>);　　<span class=\"comment\">//此语句先输出</span></span><br></pre></td></tr></table></figure>\n\n<p>我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。</p>\n<p>最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。</p>\n<p>上述例子不太易于理解，那看看下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        a *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;       </span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = foo();</span><br><span class=\"line\">f(); <span class=\"comment\">//return 20.</span></span><br><span class=\"line\">f(); <span class=\"comment\">//return 40.</span></span><br></pre></td></tr></table></figure>\n\n<p>函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。<strong>函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。</strong>只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。</p>\n<h3 id=\"经典面试题\"><a href=\"#经典面试题\" class=\"headerlink\" title=\"经典面试题\"></a>经典面试题</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'i: '</span>,i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这道题的答案是五个五。那么为什么是五个五呢？</p>\n<p>1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）</p>\n<p>2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）</p>\n<p>那么，为什么我们最先输出的是5呢？</p>\n<p>非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。</p>\n<p>这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 <a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志</a>，或者看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">并发模型与Event Loop</a></p>\n<p>我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。</p>\n<p>在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。</p>\n<p>那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？</p>\n<p>现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。</p>\n<p>在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。</p>\n<p><strong>注意，换作let的话那么输出结果就不一样了，let的结果会是0 1 2 3 4</strong></p>\n<p>ES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。</p>\n<h2 id=\"Promises\"><a href=\"#Promises\" class=\"headerlink\" title=\"Promises\"></a>Promises</h2><p>被叫做promise是因为当他们在处理async的任务时他们可以promise去做一些async结束后的事。一个简单的案例。其中resolve表示接下去要做的事，而reject表示出现error等问题后如何handle</p>\n<p>值得一提的是，你new一个promise后，这个promise会执行其中的所有内容直到出现回调函数（或到定义尾部）为止，随后进入pending状态</p>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><p><code>pending</code>: 初始状态, 非 <code>fulfilled</code> 或 <code>rejected</code>.</p>\n<p><code>fulfilled</code>: 成功的操作.</p>\n<p><code>rejected</code>: 失败的操作.</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then()\"></a>then()</h3><p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>\n<h3 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch()\"></a>catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all()\"></a>all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>\n<p>p的状态由p1、p2、p3决定，分成两种情况。</p>\n<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时<strong>第一个被reject的实例的</strong>返回值，会传递给p的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\"race()\"></a>race()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve()\"></a>resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject()\"></a>reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h3><p><strong>使用其副作用而不是return</strong> 下面的代码有什么问题？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  someOtherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Gee, I hope someOtherPromise() has resolved!</span></span><br><span class=\"line\">  <span class=\"comment\">// Spoiler alert: it hasn't.</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>每一个promise对象都会提供一个then方法或者是catch方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I'm inside a then() function!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里能做什么呢？有三种事可以做：</p>\n<ol>\n<li>返回另一个promise；</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>返回一个同步值（或者undefined)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id];    <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>函数什么都不返回等于返回了 undefined 目前为止，我们看到给 .then() 传递的都是函数，但是其实它可以接受非函数值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">later(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  .then(later(<span class=\"number\">2000</span>))</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = later_1000</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>给 .then() 传递非函数值时，实际上会被解析成 .then(null)，从而导致上一个 promise 对象的结果被“穿透”。于是，上面的代码等价于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">later(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  .then(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = later_1000</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了避免不必要的麻烦，建议总是给 .then() 传递函数。</p>\n<ol>\n<li>抛出一个同步错误。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>); <span class=\"comment\">// throwing a synchronous error!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id];       <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);    <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Boo, I got an error!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>cacth()和then(null, …)并不完全相同</strong></p>\n<p>下面两个代码是不等价的，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了</p>\n<p><strong>promise坠落现象</strong> 这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！</p>\n<p>产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"literal\">null</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"promise数组依次执行\"><a href=\"#promise数组依次执行\" class=\"headerlink\" title=\"promise数组依次执行\"></a>promise数组依次执行</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span> (<span class=\"params\">api, ms, err = false</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`fetch-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span> start`</span>)</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      err ? reject(<span class=\"string\">`reject-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span>`</span>) : resolve(<span class=\"string\">`resolve-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;, ms)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解法一</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [fetch(<span class=\"string\">'API1'</span>, <span class=\"number\">3000</span>), fetch(<span class=\"string\">'API2'</span>, <span class=\"number\">2000</span>), fetch(<span class=\"string\">'API3'</span>, <span class=\"number\">5000</span>)]</span><br><span class=\"line\">  promises.reduce(<span class=\"function\">(<span class=\"params\">chain, promise</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'haha'</span>)).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadData()</span><br><span class=\"line\"><span class=\"comment\">// 解法二</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [fetch(<span class=\"string\">'API1'</span>, <span class=\"number\">3000</span>), fetch(<span class=\"string\">'API2'</span>, <span class=\"number\">2000</span>), fetch(<span class=\"string\">'API3'</span>, <span class=\"number\">5000</span>)]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> promise.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log(res))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"promise常见面试题\"><a href=\"#promise常见面试题\" class=\"headerlink\" title=\"promise常见面试题\"></a>promise常见面试题</h3><ol>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果为：1，2，4，3。</p>\n<p>  解题思路：then方法是异步执行的。</p>\n<ol start=\"2\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">    reject(<span class=\"string\">'error'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(err)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：success</p>\n<p>  解题思路：Promise状态一旦改变，无法在发生变更。</p>\n<ol start=\"3\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .then(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">3</span>))</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：1</p>\n<p>  解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。</p>\n<ol start=\"4\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise1'</span>)</span><br><span class=\"line\">  resolve(<span class=\"string\">'Promise2'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：Promise1    1    Promise2    setTimeout</p>\n<p>解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列<strong>microtask queue</strong>中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有<strong>microtask queue</strong>顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36972010\">www.zhihu.com/question/36…</a>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<p>结果是：3 4 6 8 7 5 2 1,优先级关系如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</span><br></pre></td></tr></table></figure>\n\n<p>V8实现中，两个队列各包含不同的任务：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</span><br><span class=\"line\">microtasks: process.nextTick, Promises, <span class=\"built_in\">Object</span>.observe, MutationObserver</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行过程如下：\\</strong>JavaScript引擎首先从macrotask queue中取出*<em>第一个任务*</em>，执行完毕后，将<strong>microtask queue</strong>中的<strong>所有任务</strong>取出，按顺序<strong>全部执行</strong>；然后再从macrotask queue中取<strong>下一个</strong>，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。</p>\n<p><strong>解释：\\</strong>代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，**放入到了另一个队列microtask queue**。等整个execution context stack执行完后，下一步该取的是*<em>microtask queue*</em>中的任务了。因此promise.then的回调比setTimeout先执行。 </p>\n<ol start=\"5\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：1  2</p>\n<p>解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。</p>\n<ol start=\"6\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">resolve(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">Date</span>.now() - start);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">Date</span>.now() - start);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：</p>\n<p>开始</p>\n<p>success 5002</p>\n<p>success 5002</p>\n<p>解题思路：promise 的<strong>.then</strong>或者<strong>.catch</strong>可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用<strong>.then</strong> 或者<strong>.catch</strong>都会直接拿到该值。</p>\n<ol start=\"7\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">6</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve1'</span>)</span><br><span class=\"line\">    resolve(num)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject1'</span>)</span><br><span class=\"line\">    reject(num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve2'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(rej)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rej*<span class=\"number\">2</span>&gt;<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve3'</span>)</span><br><span class=\"line\">      resolve(rej*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject3'</span>)</span><br><span class=\"line\">      reject(rej*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&amp;emsp;&amp;emsp;<span class=\"keyword\">return</span> p2</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve4'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(rej)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject4'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(rej)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：</p>\n<p>    reject1    reject2    resolve3    resolve4    12</p>\n<p>  解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。</p>\n<ol start=\"8\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">  resolve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((<span class=\"function\"><span class=\"params\">resolve2</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve2(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;)).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出1 2 4 3</p>\n<ol start=\"9\">\n<li>重头戏！！！！实现一个简单的Promise</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> status = <span class=\"string\">'pending'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">successNotify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      status = <span class=\"string\">'fulfilled'</span><span class=\"comment\">//状态变为fulfilled</span></span><br><span class=\"line\">      toDoThen.apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failNotify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      status = <span class=\"string\">'rejected'</span><span class=\"comment\">//状态变为rejected</span></span><br><span class=\"line\">      toDoThen.apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toDoThen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; <span class=\"comment\">// 保证回调是异步执行的</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(status === <span class=\"string\">'fulfilled'</span>)&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>; i&lt; successArray.length;i ++)    &#123;</span><br><span class=\"line\">                  successArray[i].apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行then里面的回掉函数</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(status === <span class=\"string\">'rejected'</span>)&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>; i&lt; failArray.length;i ++)    &#123;</span><br><span class=\"line\">                  failArray[i].apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行then里面的回掉函数</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> successArray = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> failArray = []</span><br><span class=\"line\">  fn.call(<span class=\"literal\">undefined</span>, successNotify, failNotify)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">successFn, failFn</span>)</span>&#123;</span><br><span class=\"line\">          successArray.push(successFn)</span><br><span class=\"line\">          failArray.push(failFn)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// 此处应该返回一个Promise</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。</p>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async await\"></a>async await</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>（1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。</p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。</p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>\n<p>（4）返回值是 Promise。</p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会<strong>先返回，等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">'goog'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定50毫秒以后，输出<code>hello world</code>。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<p>async 函数有多种使用形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> foo() &#123;&#125; &#125;;</span><br><span class=\"line\">obj.foo().then(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class 的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cachePromise = caches.open(<span class=\"string\">'avatars'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">async</span> getAvatar(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.cachePromise;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.match(<span class=\"string\">`/avatars/<span class=\"subst\">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = <span class=\"keyword\">new</span> Storage();</span><br><span class=\"line\">storage.getAvatar(<span class=\"string\">'jake'</span>).then(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<h4 id=\"返回-Promise-对象\"><a href=\"#返回-Promise-对象\" class=\"headerlink\" title=\"返回 Promise 对象\"></a>返回 Promise 对象</h4><p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><strong><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// \"hello world\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  v =&gt; <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  e =&gt; <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise-对象的状态变化\"><a href=\"#Promise-对象的状态变化\" class=\"headerlink\" title=\"Promise 对象的状态变化\"></a>Promise 对象的状态变化</h4><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">'https://tc39.github.io/ecma262/'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// \"ECMAScript 2017 Language Specification\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<h4 id=\"await-命令\"><a href=\"#await-命令\" class=\"headerlink\" title=\"await 命令\"></a>await 命令</h4><p>正常情况下，<strong><code>await</code>命令后面是一个 Promise 对象。如果不是，会被转成一个立即<code>resolve</code>的 Promise 对象。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，它被转成 Promise 对象，并立即<code>resolve</code>。</p>\n<p><strong><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</strong>也就是说假如async中有await函数被reject了，那么这段报错会出现在async的catch中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>只要一个<code>await</code>语句后面的 Promise 变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// Error：出错了</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span>(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val1 = <span class=\"keyword\">await</span> firstStep();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val2 = <span class=\"keyword\">await</span> secondStep(val1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val3 = <span class=\"keyword\">await</span> thirdStep(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Final: '</span>, val3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> NUM_RETRIES = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.get(<span class=\"string\">'http://google.com/this-throws-an-error'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<h4 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h4><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise()</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123; <span class=\"comment\">//这里不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到错误结果</span></span><br><span class=\"line\">  docs.forEach(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-函数的实现原理\"><a href=\"#async-函数的实现原理\" class=\"headerlink\" title=\"async 函数的实现原理\"></a>async 函数的实现原理</h3><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spawn</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> gen = genF();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">nextF</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> next = nextF();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(next.done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(next.value).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(v); &#125;);</span><br><span class=\"line\">      &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.throw(e); &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(<span class=\"literal\">undefined</span>); &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与其他异步处理方法的比较\"><a href=\"#与其他异步处理方法的比较\" class=\"headerlink\" title=\"与其他异步处理方法的比较\"></a>与其他异步处理方法的比较</h3><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsPromise</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 变量ret用来保存上一个动画的返回值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 新建一个空的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 使用then方法，添加所有动画</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">    p = p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">      ret = val;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> anim(elem);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsGenerator</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">        ret = <span class=\"keyword\">yield</span> anim(elem);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>\n<p>最后是 async 函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsAsync</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">      ret = <span class=\"keyword\">await</span> anim(elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>\n<h3 id=\"实例：按顺序完成异步操作\"><a href=\"#实例：按顺序完成异步操作\" class=\"headerlink\" title=\"实例：按顺序完成异步操作\"></a>实例：按顺序完成异步操作</h3><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>\n<p>Promise 的写法如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程读取所有URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.text());</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  textPromises.reduce(<span class=\"function\">(<span class=\"params\">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> textPromise)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">text</span> =&gt;</span> <span class=\"built_in\">console</span>.log(text));</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>\n<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url <span class=\"keyword\">of</span> urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> response.text());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>\n<h3 id=\"异步遍历器\"><a href=\"#异步遍历器\" class=\"headerlink\" title=\"异步遍历器\"></a>异步遍历器</h3><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n<p>这里隐含着一个规定，<code>next</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>next</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-async-iteration\" target=\"_blank\" rel=\"noopener\">提案</a>，为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p>\n<h4 id=\"异步遍历的接口\"><a href=\"#异步遍历的接口\" class=\"headerlink\" title=\"异步遍历的接口\"></a>异步遍历的接口</h4><p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncIterator</span><br><span class=\"line\">  .next()</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (&#123; value, done &#125;) =&gt; <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p>\n<p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p>\n<p>下面是一个异步遍历器的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncIterable = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncIterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">asyncIterator</span><br><span class=\"line\">.next()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult1); <span class=\"comment\">// &#123; value: 'a', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncIterator.next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult2</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult2); <span class=\"comment\">// &#123; value: 'b', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncIterator.next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult3</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult3); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p>\n<p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> asyncIterable = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> asyncIterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: 'a', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: 'b', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p>\n<p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的Promise对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncGenObj = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [&#123;<span class=\"attr\">value</span>: v1&#125;, &#123;<span class=\"attr\">value</span>: v2&#125;] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">  asyncGenObj.next(), asyncGenObj.next()</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v1, v2); <span class=\"comment\">// a b</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> writer = openFile(<span class=\"string\">'someFile.txt'</span>);</span><br><span class=\"line\">writer.next(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">writer.next(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"keyword\">await</span> writer.return();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-await…of\"><a href=\"#for-await…of\" class=\"headerlink\" title=\"for await…of\"></a>for await…of</h4><p>前面介绍过，<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>createAsyncIterable()</code>返回一个异步遍历器，<code>for...of</code>循环自动调用这个遍历器的<code>next</code>方法，会得到一个Promise对象。<code>await</code>用来处理这个Promise对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p>\n<p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> body = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">await</span>(<span class=\"keyword\">const</span> data <span class=\"keyword\">of</span> req) body += data;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parsed = <span class=\"built_in\">JSON</span>.parse(body);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'got'</span>, parsed);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p>\n<p>如果<code>next</code>方法返回的Promise对象被<code>reject</code>，那么就要用<code>try...catch</code>捕捉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> createRejectingIterable()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步Generator函数\"><a href=\"#异步Generator函数\" class=\"headerlink\" title=\"异步Generator函数\"></a>异步Generator函数</h4><p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p>\n<p>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">readLines</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> file = <span class=\"keyword\">await</span> fileOpen(path);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!file.EOF) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> file.readLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> file.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回Promise对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法的停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是于同步Generator函数一致的。</p>\n<p>可以像下面这样，使用上面代码定义的异步Generator函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> line <span class=\"keyword\">of</span> readLines(filePath)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(line);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">prefixLines</span>(<span class=\"params\">asyncIterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> line <span class=\"keyword\">of</span> asyncIterable) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'&gt; '</span> + line;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code>命令依然是立刻返回的，但是返回的是一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Start'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> doSomethingAsync(); <span class=\"comment\">// (A)</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'Result: '</span>+ result; <span class=\"comment\">// (B)</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，调用<code>next</code>方法以后，会在<code>B</code>处暂停执行，<code>yield</code>命令立刻返回一个Promise对象。这个Promise对象不同于<code>A</code>处<code>await</code>命令后面的那个 Promise 对象。主要有两点不同，一是<code>A</code>处的Promise对象<code>resolve</code>以后产生的值，会放入<code>result</code>变量；二是<code>B</code>处的Promise对象<code>resolve</code>以后产生的值，是表达式<code>&#39;Result： &#39; + result</code>的值；二是<code>A</code>处的 Promise 对象一定先于<code>B</code>处的 Promise 对象<code>resolve</code>。</p>\n<p>如果异步 Generator 函数抛出错误，会被 Promise 对象<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Problem!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncGenerator()</span><br><span class=\"line\">.next()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err)); <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，<code>async</code>函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeAsync</span>(<span class=\"params\">asyncIterable, count=Infinity</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> iterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (result.length &lt; count) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;value,done&#125; = <span class=\"keyword\">await</span> iterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    result.push(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步Generator函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。</p>\n<p>下面是这个自动执行器的一个使用实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'c'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> takeAsync(gen());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。</p>\n<p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">createAsyncIterable</span>(<span class=\"params\">syncIterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> elem <span class=\"keyword\">of</span> syncIterable) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> elem;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p>\n<h4 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">yield</span>* gen1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p>\n<p>与同步Generator函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> gen2()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promisify\"><a href=\"#Promisify\" class=\"headerlink\" title=\"Promisify\"></a>Promisify</h2><p><code>util.promisify</code>是在<code>node.js 8.x</code>版本中新增的一个工具，用于将老式的<code>Error first callback</code>转换为<code>Promise</code>对象，让老项目改造变得更为轻松。</p>\n<p>在官方推出这个工具之前，民间已经有很多类似的工具了，比如<a href=\"https://www.npmjs.com/package/es6-promisify\" target=\"_blank\" rel=\"noopener\">es6-promisify</a>、<a href=\"https://www.npmjs.com/package/thenify\" target=\"_blank\" rel=\"noopener\">thenify</a>、<a href=\"http://bluebirdjs.com/docs/api/promise.promisify.html\" target=\"_blank\" rel=\"noopener\">bluebird.promisify</a>。</p>\n<p>以及很多其他优秀的工具，都是实现了这样的功能，帮助我们在处理老项目的时候，不必费神将各种代码使用<code>Promise</code>再重新实现一遍。</p>\n<h3 id=\"工具实现的大致思路\"><a href=\"#工具实现的大致思路\" class=\"headerlink\" title=\"工具实现的大致思路\"></a>工具实现的大致思路</h3><p>首先要解释一下这种工具大致的实现思路，因为在<code>Node</code>中异步回调有一个约定：<code>Error first</code>，也就是说回调函数中的第一个参数一定要是<code>Error</code>对象，其余参数才是正确时的数据。</p>\n<p>知道了这样的规律以后，工具就很好实现了，在匹配到第一个参数有值的情况下，触发<code>reject</code>，其余情况触发<code>resolve</code>，一个简单的示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">util</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(...arg, (err, arg) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) reject(err)</span><br><span class=\"line\">      <span class=\"keyword\">else</span> resolve(arg)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>调用工具函数返回一个匿名函数，匿名函数接收原函数的参数。</li>\n<li>匿名函数被调用后根据这些参数来调用真实的函数，同时拼接一个用来处理结果的<code>callback</code>。</li>\n<li>检测到<code>err</code>有值，触发<code>reject</code>，其他情况触发<code>resolve</code></li>\n</ol>\n<p><strong>resolve 只能传入一个参数，所以<code>callback</code>中没有必要使用<code>...arg</code>获取所有的返回值</strong></p>\n<h3 id=\"常规的使用方式\"><a href=\"#常规的使用方式\" class=\"headerlink\" title=\"常规的使用方式\"></a>常规的使用方式</h3><blockquote>\n<p>拿一个官方文档中的示例</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> statAsync = promisify(fs.stat)</span><br><span class=\"line\"></span><br><span class=\"line\">statAsync(<span class=\"string\">'.'</span>).then(<span class=\"function\"><span class=\"params\">stats</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 拿到了正确的数据</span></span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 出现了异常</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以及因为是<code>Promise</code>，我们可以使用<code>await</code>来进一步简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> statAsync = promisify(fs.stat)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设在 async 函数中</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stats = <span class=\"keyword\">await</span> statAsync(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 拿到正确结果</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 出现异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法与其他工具并没有太大的区别，我们可以很轻易的将回调转换为<code>Promise</code>，然后应用于新的项目中。</p>\n<h3 id=\"自定义的-Promise-化\"><a href=\"#自定义的-Promise-化\" class=\"headerlink\" title=\"自定义的 Promise 化\"></a>自定义的 Promise 化</h3><p>有那么一些场景，是不能够直接使用<code>promisify</code>来进行转换的，有大概这么两种情况：</p>\n<ol>\n<li>没有遵循<code>Error first callback</code>约定的回调函数</li>\n<li>返回多个参数的回调函数</li>\n</ol>\n<p>首先是第一个，如果没有遵循我们的约定，很可能导致<code>reject</code>的误判，得不到正确的反馈。<br>而第二项呢，则是因为<code>Promise.resolve</code>只能接收一个参数，多余的参数会被忽略。</p>\n<p>所以为了实现正确的结果，我们可能需要手动实现对应的<code>Promise</code>函数，但是自己实现了以后并不能够确保使用方不会针对你的函数调用<code>promisify</code>。</p>\n<p>所以，<code>util.promisify</code>还提供了一个<code>Symbol</code>类型的<code>key</code>，<code>util.promisify.custom</code>。</p>\n<p><code>Symbol</code>类型的大家应该都有了解，是一个唯一的值，这里是<code>util.prosimify</code>用来指定自定义的<code>Promise</code>化的结果的，使用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 比如我们有一个对象，提供了一个返回多个参数的回调版本的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  getData (callback) &#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, <span class=\"string\">'Niko'</span>, <span class=\"number\">18</span>) <span class=\"comment\">// 返回两个参数，姓名和年龄</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这时使用promisify肯定是不行的</span></span><br><span class=\"line\"><span class=\"comment\">// 因为Promise.resolve只接收一个参数，所以我们只会得到 Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\">promisify(obj.getData)().then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所以我们需要使用 promisify.custom 来自定义处理方式</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"keyword\">async</span> () =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当然了，这是一个曲线救国的方式，无论如何 Promise 不会返回多个参数过来的</span></span><br><span class=\"line\">promisify(obj.getData)().then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// &#123; name: 'Niko', age: 18 &#125;</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p><em>关于<code>Promise</code>为什么不能<code>resolve</code>多个值，我有一个大胆的想法，一个没有经过考证，强行解释的理由：如果能<code>resolve</code>多个值，你让<code>async</code>函数怎么<code>return</code>（当个乐子看这句话就好，不要当真）</em><br><em>不过应该确实跟<code>return</code>有关，因为<code>Promise</code>是可以链式调用的，每个<code>Promise</code>中执行<code>then</code>以后都会将其返回值作为一个新的<code>Promise</code>对象<code>resolve</code>的值，在<code>JavaScript</code>中并没有办法<code>return</code>多个参数，所以即便第一个<code>Promise</code>可以返回多个参数，只要经过<code>return</code>的处理就会丢失</em></p>\n<p>在使用上就是很简单的针对可能会被调用<code>promisify</code>的函数上添加<code>promisify.custom</code>对应的处理即可。<br>当后续代码调用<code>promisify</code>时就会进行判断：</p>\n<ol>\n<li><p>如果目标函数存在</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify.custom</span><br></pre></td></tr></table></figure>\n\n<p>属性，则会判断其类型：</p>\n<ol>\n<li>如果不是一个可执行的函数，抛出异常</li>\n<li>如果是可执行的函数，则直接返回其对应的函数</li>\n</ol>\n</li>\n<li><p>如果目标函数不存在对应的属性，按照<code>Error first callback</code>的约定生成对应的处理函数然后返回</p>\n</li>\n</ol>\n<p>添加了这个<code>custom</code>属性以后，就不用再担心使用方针对你的函数调用<code>promisify</code>了。<br>而且可以验证，赋值给<code>custom</code>的函数与<code>promisify</code>返回的函数地址是一处：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.getData[promisify.custom] = <span class=\"keyword\">async</span> () =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上边的赋值为 async 函数也可以改为普通函数，只要保证这个普通函数会返回 Promise 实例即可</span></span><br><span class=\"line\"><span class=\"comment\">// 这两种方式与上边的 async 都是完全相等的</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getData[promisify.custom] === promisify(obj.getData)) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一些内置的-custom-处理\"><a href=\"#一些内置的-custom-处理\" class=\"headerlink\" title=\"一些内置的 custom 处理\"></a>一些内置的 custom 处理</h4><p>在一些内置包中，也能够找到<code>promisify.custom</code>的踪迹，比如说最常用的<code>child_process.exec</code>就内置了<code>promisify.custom</code>的处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; exec &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> exec[promisify.custom]) <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>因为就像前边示例中所提到的曲线救国的方案，官方的做法也是将函数签名中的参数名作为<code>key</code>，将其所有参数存放到一个<code>Object</code>对象中进行返回，比如<code>child_process.exec</code>的返回值抛开<code>error</code>以外会包含两个，<code>stdout</code>和<code>stderr</code>，一个是命令执行后的正确输出，一个是命令执行后的错误输出：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify(exec)(<span class=\"string\">'ls'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &#123; stdout: 'XXX', stderr: '' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者我们故意输入一些错误的命令，当然了，这个只能在<code>catch</code>模块下才能够捕捉到，一般命令正常执行<code>stderr</code>都会是一个空字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify(exec)(<span class=\"string\">'lss'</span>).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &#123; ..., stdout: '', stderr: 'lss: command not found' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>包括像<code>setTimeout</code>、<code>setImmediate</code>也都实现了对应的<code>promisify.custom</code>。<br>之前为了实现<code>sleep</code>的操作，还手动使用<code>Promise</code>封装了<code>setTimeout</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sleep = promisify(setTimeout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置的-promisify-转换后函数\"><a href=\"#内置的-promisify-转换后函数\" class=\"headerlink\" title=\"内置的 promisify 转换后函数\"></a>内置的 promisify 转换后函数</h3><p>如果你的<code>Node</code>版本使用<code>10.x</code>以上的，还可以从很多内置的模块中找到类似<code>.promises</code>的子模块，这里边包含了该模块中常用的回调函数的<code>Promise</code>版本（都是<code>async</code>函数），无需再手动进行<code>promisify</code>转换了。</p>\n<p>而且我本人觉得这是一个很好的指引方向，因为之前的工具实现，有的选择直接覆盖原有函数，有的则是在原有函数名后边增加<code>Async</code>进行区分，官方的这种在模块中单独引入一个子模块，在里边实现<code>Promise</code>版本的函数，其实这个在使用上是很方便的，就拿<code>fs</code>模块进行举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前引入一些 fs 相关的 API 是这样做的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; readFile, stat &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而现在可以很简单的改为</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; readFile, stat &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).promises</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">promises</span>: &#123; readFile, stat &#125; &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>后边要做的就是将调用<code>promisify</code>相关的代码删掉即可，对于其他使用<code>API</code>的代码来讲，这个改动是无感知的。<br>所以如果你的<code>node</code>版本够高的话，可以在使用内置模块之前先去翻看文档，有没有对应的<code>promises</code>支持，如果有实现的话，就可以直接使用。</p>\n<h3 id=\"promisify-的一些注意事项\"><a href=\"#promisify-的一些注意事项\" class=\"headerlink\" title=\"promisify 的一些注意事项\"></a>promisify 的一些注意事项</h3><ol>\n<li>一定要符合<code>Error first callback</code>的约定</li>\n<li>不能返回多个参数</li>\n<li>注意进行转换的函数是否包含<code>this</code>的引用</li>\n</ol>\n<p>前两个问题，使用前边提到的<code>promisify.custom</code>都可以解决掉。<br>但是第三项可能会在某些情况下被我们所忽视，这并不是<code>promisify</code>独有的问题，就一个很简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Niko'</span>,</span><br><span class=\"line\">  getName () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName() <span class=\"comment\">// Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func = obj.getName</span><br><span class=\"line\"></span><br><span class=\"line\">func() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，如果我们在进行<code>Promise</code>转换的时候，也是类似这样的操作，那么可能会导致生成后的函数<code>this</code>指向出现问题。<br>修复这样的问题有两种途径：</p>\n<ol>\n<li>使用箭头函数，也是推荐的做法</li>\n<li>在调用<code>promisify</code>之前使用<code>bind</code>绑定对应的<code>this</code></li>\n</ol>\n<p>不过这样的问题也是建立在<code>promisify</code>转换后的函数被赋值给其他变量的情况下会发生。<br>如果是类似这样的代码，那么完全不必担心<code>this</code>指向的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Niko'</span>,</span><br><span class=\"line\">  getName (callback) &#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样的操作是不需要担心 this 指向问题的</span></span><br><span class=\"line\">obj.XXX = promisify(obj.getName)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果赋值给了其他变量，那么这里就需要注意 this 的指向了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> func = promisify(obj.getName) <span class=\"comment\">// 错误的 this</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>个人认为<code>Promise</code>作为当代<code>javaScript</code>异步编程中最核心的一部分，了解如何将老旧代码转换为<code>Promise</code>是一件很有意思的事儿。<br>而我去了解官方的这个工具，原因是在搜索<code>Redis</code>相关的<code>Promise</code>版本时看到了这个<a href=\"https://github.com/mjackson/then-redis\" target=\"_blank\" rel=\"noopener\">readme</a>：</p>\n<blockquote>\n<p>This package is no longer maintained. node_redis now includes support for promises in core, so this is no longer needed.</p>\n</blockquote>\n<p>然后跳到了<code>node_redis</code>里边的实现方案，里边提到了<code>util.promisify</code>，遂抓过来研究了一下，感觉还挺有意思，总结了下分享给大家。</p>\n<h2 id=\"Js异步执行顺序\"><a href=\"#Js异步执行顺序\" class=\"headerlink\" title=\"Js异步执行顺序\"></a>Js异步执行顺序</h2><p>今天在重温promise的时候，突然发现了一个有趣的题目：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">                setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">                <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>));</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>));</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>我们先放上结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">9</span> <span class=\"number\">5</span> <span class=\"number\">0</span> <span class=\"number\">6</span> <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">4</span> <span class=\"number\">8</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简要讲述\"><a href=\"#简要讲述\" class=\"headerlink\" title=\"简要讲述\"></a>简要讲述</h3><p>首先我们知道JS分为了同步和异步，并且是顺序是先同步后异步，也就是同步代码执行完成后，哪怕异步代码到了它执行的时候，也会先让同步执行完。但是JS的执行顺序还可以分得更细，那就是异步的顺序。 我们知道很多异步任务，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout, setInterval, setImmediate, Promises.then, <span class=\"built_in\">Promise</span>.catch</span><br></pre></td></tr></table></figure>\n\n<p>甚至还有nodejs中的process.nextTick等，就像我们知道process.nextTick比promise先执行一样。那么这些异步事件是谁先执行谁后执行呢。 这涉及到了事件循环(event loop)。事件循环也就是事件出入栈。 上面说了这么多异步任务，我们先把它们分为两类： <strong>宏任务（macro-task）</strong>：setTimeout, setInterval, setImmediate <strong>微任务（micro-task）</strong>：Promises.then, Promise.catch</p>\n<p>然后我们再明白一个概念：<strong>先执行微任务，再执行宏任务</strong>。这种执行是，<strong>先执行清空微任务队列，再执行宏任务，当当前宏任务执行完后，微任务队列中又有微任务，再次将微任务队列执行完，再执行下一个宏任务</strong>。</p>\n<p>在异步任务执行过程中遇到宏任务与微任务，将其依次放入当前事件循环队列中。</p>\n<h3 id=\"例题描述\"><a href=\"#例题描述\" class=\"headerlink\" title=\"例题描述\"></a>例题描述</h3><p>首先执行主线程，也就是script（script是宏任务），因为此时没有微任务</p>\n<p>然后遇到<code>setTimeout(() =&gt; { console.log(0);});</code> 这是宏任务，将其放入宏任务队列中 记为 – 宏任务1</p>\n<p>promise新建后会立即执行，输出<code>1</code></p>\n<p>然后将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续放入宏任务队列中 记为 – 宏任务2</p>\n<p>将<code>Promise.resolve().then(() =&gt; console.log(5));</code>放入微任务队列中 记为 – 微任务1</p>\n<p>继续往下走，输出<code>9</code></p>\n<p>此时当前宏任务执行完毕，开始执行微任务队列，目前微任务队列中只有微任务1，执行，输出<code>5</code></p>\n<p>微任务队列此时清空，然后执行宏任务1，输出<code>0</code></p>\n<p>微任务队列依然没有任务，继续执行宏任务2，遇见 <code>resolve();</code>，于是将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>));</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>放入微任务队列中，记为 – 微任务2，再将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>记为 – 微任务3</p>\n<p>当前宏任务执行完毕，开始执行微任务，先执行微任务2，输出<code>6</code>；将<code>Promise.resolve().then(() =&gt; console.log(7));</code>记为 – 微任务4；<code>setTimeout(() =&gt; console.log(8));</code>记为 – 宏任务3</p>\n<p>执行微任务3，输出<code>2</code>；将<code>setTimeout(() =&gt; console.log(3));</code>记为 – 宏任务4；将<code>Promise.resolve().then(() =&gt; console.log(4));</code>记为 – 微任务5；</p>\n<p>此时队列中依然有微任务，执行微任务4，输出<code>7</code>；执行微任务5，输出<code>4</code>；微任务队列执行完毕</p>\n<p>执行宏任务3，输出<code>8</code>；执行宏任务4，输出<code>3</code>；全部执行完毕</p>\n<p>那么我们的结果为<code>1 9 5 0 6 2 7 4 8 3</code></p>\n","site":{"data":{"butterfly":{"menu":{"Home":"/ || fa fa-home","Archives":"/archives/ || fa fa-archive","Tags":"/tags/ || fa fa-tags","Categories":"/categories/ || fa fa-folder-open","Link":"/link/ || fa fa-link"},"favicon":"/img/favicon.ico","highlight_theme":"ocean","highlight_copy":true,"highlight_lang":true,"highlight_shrink":false,"code_word_wrap":true,"copy":{"enable":true,"copyright":false},"social":{"fa fa-github":"https://github.com/8128 || Github","fa fa-envelope":"mailto:tty8128@outlook.com || Email"},"algolia_search":{"enable":false,"hits":{"per_page":6},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"per_page":false},"katex":{"enable":false,"per_page":false,"hide_scrollbar":true},"mermaid":{"enable":false,"theme":"default"},"avatar":{"img":"/img/avatar.png","effect":false},"index_img":"/img/ind.jpg","default_top_img":"/img/ind.jpg","archive_img":null,"tag_img":null,"category_img":null,"cover":{"index_enable":true,"aside_enable":true,"archives_enable":true,"position":"both","default_cover":["/img/post.jpg"]},"lodding_bg":{"flink":"/img/friend_404.gif","post_page":"/img/404.jpg"},"error_404":{"enable":false,"subtitle":"Page Not Found","background":null},"post_meta":{"page":{"date_type":"both","categories":true,"tags":true},"post":{"date_type":"both","categories":true,"tags":true}},"wordcount":{"enable":true,"post_wordcount":true,"min2read":true,"total_wordcount":true},"toc":{"enable":true,"number":false},"auto_open_sidebar":{"enable":true},"post_copyright":{"enable":true,"decode":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":false,"length":150},"addThis":{"enable":false,"pubid":null},"sharejs":{"enable":true,"sites":"facebook,twitter,wechat,weibo,qq"},"addtoany":{"enable":false,"item":["facebook","twitter","wechat","sina_weibo","facebook_messenger","email","copy_link"]},"disqus":{"enable":true,"shortname":"8128g","count":false},"disqusjs":{"enable":true,"shortname":"8128g","siteName":"github8128","apikey":"3mdOv67CFegsC5BP16Sy76xZJuU7pq8Pyg8fFIv79Zlq1UY8w5hWRUxe4Xk8Tkd8","api":"https://disqus.skk.moe/disqus/","admin":null,"adminLabel":null,"count":true},"laibili":{"enable":false,"uid":null},"gitalk":{"enable":false,"client_id":null,"client_secret":null,"repo":null,"owner":null,"admin":null,"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","createIssueManually":false,"count":true},"valine":{"enable":false,"appId":null,"appKey":null,"notify":false,"verify":false,"pageSize":10,"avatar":"monsterid","lang":"en","placeholder":"Please leave your footprints","guest_info":"nick,mail,link","recordIP":false,"serverURLs":null,"bg":"/img/comment_bg.png","count":true},"utterances":{"enable":false,"repo":null,"issue_term":"pathname","light_theme":"github-light","dark_theme":"photon-dark"},"since":2020,"footer_custom_text":"Hi, welcome to my <a href=\"http://8128.me/\">blog</a>!","footer_copyright":{"enable":true},"ICP":{"enable":false,"url":null,"text":null,"icon":"/img/icp.png"},"baidu_analytics":null,"google_analytics":"UA-158741918-1","tencent_analytics":null,"google_adsense":{"enable":false,"js":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":null,"enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"reward":{"enable":true,"QR_code":[{"itemlist":{"img":"/img/wechat.jpg","text":"微信"}},{"itemlist":{"img":"/img/alipay.jpg","text":"支付寶"}}]},"related_post":{"enable":true,"limit":6,"date_type":"created"},"photofigcaption":false,"theme_color":{"enable":true,"main":"#000000","paginator":"#000000","button_hover":"#B22222","text_selection":"#A9A9A9","link_color":"#99a9bf","meta_color":"#858585","hr_color":"#99a9bf","code_foreground":"#F47466","code_background":"rgba(27, 31, 35, .05)","toc_color":"#D3D3D3","blockquote_padding_color":"#DCDCDC","blockquote_background_color":"#DCDCDC"},"index_site_info_top":null,"index_top_img_height":null,"category_ui":"index","tag_ui":"index","background":null,"footer_bg":false,"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false,"mobile":false},"canvas_ribbon_piao":{"enable":false,"mobile":false},"canvas_nest":{"enable":false,"color":"0,0,255","opacity":0.7,"zIndex":-1,"count":99,"mobile":false},"activate_power_mode":{"enable":false,"colorful":false,"shake":false},"fireworks":{"enable":false},"click_heart":{"enable":false},"ClickShowText":{"enable":false,"text":["本人","超帥"],"fontSize":"15px"},"display_mode":"light","beautify":{"enable":false,"title-prefix-icon":"\\f0c1","title-prefix-icon-color":"#F47466"},"font":{"enable":false,"font-family":"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif","code-font":"consolas, Menlo, \"PingFang SC\", \"Microsoft YaHei\", monospace, Helvetica Neue For Number"},"blog_title_font":{"font_link":"https://fonts.googleapis.com/css?family=Titillium+Web","font-family":"Titillium Web, PingFang SC, Hiragino Sans GB, \"Microsoft YaHei\", Helvetica Neue, Helvetica, Arial, sans-serif"},"hr":{"enable":false,"icon":"\\f21c","icon-top":"-20px"},"subtitle":{"enable":true,"effect":true,"loop":true,"source":false,"sub":["Code","Life"]},"fontawesome_v5":{"enable":false},"aside":{"enable":true,"mobile":true,"position":"right","card_author":true,"card_announcement":false,"card_recent_post":true,"card_categories":true,"card_tags":true,"card_archives":true,"card_webinfo":true},"announcement":{"content":"Hello world!"},"busuanzi":{"site_uv":true,"site_pv":true,"page_pv":true},"runtimeshow":{"enable":true,"start_date":"2/3/2020 00:00:00"},"translate":{"enable":true,"default":"繁","defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://8128.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},"readmode":{"enable":true},"darkmode":{"enable":true,"button":true,"autoChangeMode":1},"medium_zoom":{"enable":false},"fancybox":{"enable":true},"snackbar":{"enable":true,"position":"bottom-left","bg_light":"#49b1f5","bg_dark":"#2d3035"},"baidu_push":{"enable":false},"instantpage":{"enable":true},"pangu":{"enable":false,"field":"page"},"note":{"style":"flat","icons":true,"border_radius":3,"light_bg_offset":0},"lazyload":{"enable":true},"canonical":true,"disable_baidu_transformation":true,"twitter_meta":true,"Open_Graph_meta":true,"fragment_cache":true,"CDN_USE":{"css":["/css/index.css"],"js":["https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","/js/utils.js","/js/main.js"]},"CDN":{"blueimp_md5":"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js","gitalk":"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js","gitalk_css":"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css","valine":"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js","disqusjs":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js","disqusjs_css":"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css","utterances":"https://utteranc.es/client.js","addtoany":"https://static.addtoany.com/menu/page.js","sharejs":"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js","sharejs_css":"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css","local_search":"/js/search/local-search.js","algolia_js":"/js/search/algolia.js","algolia_search":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js","algolia_search_css":"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css","mathjax":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML","katex":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css","katex_copytex":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js","katex_copytex_css":"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css","mermaid":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","canvas_ribbon":"/js/third-party/canvas-ribbon.js","canvas_ribbon_piao":"/js/third-party/piao.js","canvas_nest":"/js/third-party/canvas-nest.js","lazyload":"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js","instantpage":"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js","typed":"https://cdn.jsdelivr.net/npm/typed.js","js_cookies":"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js","pangu":"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js","fancybox_css":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","medium_zoom":"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js","snackbar_css":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css","snackbar":"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js","anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","activate_power_mode":"/js/third-party/activate-power-mode.js","fireworks":"/js/third-party/fireworks.js","click_heart":"/js/third-party/click_heart.js","ClickShowText":"/js/third-party/ClickShowText.js","fontawesome_v4":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesome_v5":"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css","translate":"/js/tw_cn.js"},"rootConfig":{"title":"8128's Blog","subtitle":"Code & Life","description":"8128's blog powered by Butterfly","author":8128,"language":"zh-CN","timezone":"America/Los_Angeles","url":"http://8128.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":false,"trailing_html":false},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":"","wrap":true,"hljs":false,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"Butterfly","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":{"type":"git","repo":"https://github.com/8128/8128.github.io","branch":"master"},"ignore":null,"meta_generator":true,"keywords":"code,life,blog","index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"search":{"path":"search.xml","field":"post"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true}}},"link":{"class":{"class_name":"友情链接","link_list":{"1":{"name":"JerryC","link":"https://https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"Theme Designer"}}}}}},"excerpt":"","more":"<p>头都被JavaScript的异步处理搞炸了，而且脑子不太好使，经常学一点忘一点。做个笔记记录一下几个学习JavaScript过程中的痛点</p>\n<p>部分笔记来源：udemy-modern JavaScript from the beginning</p>\n<p><a href=\"https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html\" target=\"_blank\" rel=\"noopener\">cnblog</a> &amp; <a href=\"https://juejin.im/post/5d89844ae51d4561ff6668f3\" target=\"_blank\" rel=\"noopener\">dayTimeAffect</a> &amp; <a href=\"https://juejin.im/post/5bc76ff56fb9a05cee1e14a9\" target=\"_blank\" rel=\"noopener\">Jiasm</a></p>\n<h2 id=\"什么是异步-Asynchronous\"><a href=\"#什么是异步-Asynchronous\" class=\"headerlink\" title=\"什么是异步 Asynchronous\"></a>什么是异步 Asynchronous</h2><p>要说清楚异步，需要先把同步说明清楚。所谓同步就是一步步向下走</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">posts = loadPostsSync();</span><br><span class=\"line\">doTheNextThing();</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，必须先把第一个函数执行完了，第二个函数才能执行。众所周知，JavaScript约等于没有多线程，那么node.js又是怎么实现高并发的呢？就是靠异步。现在的环境下一个工程往往会受制于读写时间，而不是真正的处理运算时间。假如我们遇到了读写瓶颈，我们就暂时先搁置手上的工作，优先去处理下一步的内容，随后等到读写完成，再次回来捡起过去仍在地上的工作，这就实现了异步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadPostsAsync(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//wait til posts are fetched</span></span><br><span class=\"line\">\t<span class=\"comment\">//do something with posts</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doTheNextThing();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p>首先要把callback说清楚，callback就我理解，就是在一个函数中call另外一个函数，避免在异步过程中出错。从简单的setTimeOut到匿名函数，都算callback。在JavaScript中，函数属于对象，是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以这样创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"arg1\"</span>, <span class=\"string\">\"arg2\"</span>, <span class=\"string\">\"return arg1 * arg2;\"</span>);</span><br><span class=\"line\">fn(<span class=\"number\">2</span>, <span class=\"number\">3</span>);   <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"传递函数作为回调\"><a href=\"#传递函数作为回调\" class=\"headerlink\" title=\"传递函数作为回调\"></a>传递函数作为回调</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">arg1, arg2, callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * (arg1 - arg2) + arg2);</span><br><span class=\"line\">    callback(num);　　<span class=\"comment\">//传递结果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Callback called! Num: \"</span> + num);</span><br><span class=\"line\">&#125;);　　　　<span class=\"comment\">//结果为10和20之间的随机数</span></span><br></pre></td></tr></table></figure>\n\n<p>这里看到我们把function拿来当参数直接传入函数中，这其实就是回调</p>\n<p>传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。</p>\n<p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在JavaScript中使用异步调用，甚至在这里强烈推荐使用！</p>\n<p>下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">url, callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> httpRequest;　　　　<span class=\"comment\">//创建XHR</span></span><br><span class=\"line\">    httpRequest = <span class=\"built_in\">window</span>.XMLHttpRequest ? <span class=\"keyword\">new</span> XMLHttpRequest() :　　　<span class=\"comment\">//针对IE进行功能性检测</span></span><br><span class=\"line\">　　　　<span class=\"built_in\">window</span>.ActiveXObject ? <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>) : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    httpRequest.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(httpRequest.readystate === <span class=\"number\">4</span> &amp;&amp; httpRequest.status === <span class=\"number\">200</span>)&#123;　　<span class=\"comment\">//状态判断</span></span><br><span class=\"line\">          callback.call(httpRequest.responseXML);  </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    httpRequest.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    httpRequest.send();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">\"text.xml\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;　　　　<span class=\"comment\">//调用函数</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); 　　<span class=\"comment\">//此语句后输出</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"this will run before the above callback.\"</span>);　　<span class=\"comment\">//此语句先输出</span></span><br></pre></td></tr></table></figure>\n\n<p>我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。</p>\n<p>最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。</p>\n<p>上述例子不太易于理解，那看看下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        a *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;       </span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = foo();</span><br><span class=\"line\">f(); <span class=\"comment\">//return 20.</span></span><br><span class=\"line\">f(); <span class=\"comment\">//return 40.</span></span><br></pre></td></tr></table></figure>\n\n<p>函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。<strong>函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。</strong>只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。</p>\n<h3 id=\"经典面试题\"><a href=\"#经典面试题\" class=\"headerlink\" title=\"经典面试题\"></a>经典面试题</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'i: '</span>,i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这道题的答案是五个五。那么为什么是五个五呢？</p>\n<p>1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）</p>\n<p>2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）</p>\n<p>那么，为什么我们最先输出的是5呢？</p>\n<p>非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。</p>\n<p>这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 <a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志</a>，或者看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">并发模型与Event Loop</a></p>\n<p>我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。</p>\n<p>在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。</p>\n<p>那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？</p>\n<p>现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。</p>\n<p>在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。</p>\n<p><strong>注意，换作let的话那么输出结果就不一样了，let的结果会是0 1 2 3 4</strong></p>\n<p>ES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。</p>\n<h2 id=\"Promises\"><a href=\"#Promises\" class=\"headerlink\" title=\"Promises\"></a>Promises</h2><p>被叫做promise是因为当他们在处理async的任务时他们可以promise去做一些async结束后的事。一个简单的案例。其中resolve表示接下去要做的事，而reject表示出现error等问题后如何handle</p>\n<p>值得一提的是，你new一个promise后，这个promise会执行其中的所有内容直到出现回调函数（或到定义尾部）为止，随后进入pending状态</p>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><p><code>pending</code>: 初始状态, 非 <code>fulfilled</code> 或 <code>rejected</code>.</p>\n<p><code>fulfilled</code>: 成功的操作.</p>\n<p><code>rejected</code>: 失败的操作.</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then()\"></a>then()</h3><p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>\n<h3 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch()\"></a>catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all()\"></a>all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>\n<p>p的状态由p1、p2、p3决定，分成两种情况。</p>\n<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时<strong>第一个被reject的实例的</strong>返回值，会传递给p的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\"race()\"></a>race()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve()\"></a>resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject()\"></a>reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h3><p><strong>使用其副作用而不是return</strong> 下面的代码有什么问题？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  someOtherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Gee, I hope someOtherPromise() has resolved!</span></span><br><span class=\"line\">  <span class=\"comment\">// Spoiler alert: it hasn't.</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>每一个promise对象都会提供一个then方法或者是catch方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I'm inside a then() function!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里能做什么呢？有三种事可以做：</p>\n<ol>\n<li>返回另一个promise；</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>返回一个同步值（或者undefined)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id];    <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>函数什么都不返回等于返回了 undefined 目前为止，我们看到给 .then() 传递的都是函数，但是其实它可以接受非函数值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">later(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  .then(later(<span class=\"number\">2000</span>))</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = later_1000</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>给 .then() 传递非函数值时，实际上会被解析成 .then(null)，从而导致上一个 promise 对象的结果被“穿透”。于是，上面的代码等价于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">later(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  .then(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = later_1000</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了避免不必要的麻烦，建议总是给 .then() 传递函数。</p>\n<ol>\n<li>抛出一个同步错误。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>); <span class=\"comment\">// throwing a synchronous error!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id];       <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);    <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Boo, I got an error!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>cacth()和then(null, …)并不完全相同</strong></p>\n<p>下面两个代码是不等价的，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了</p>\n<p><strong>promise坠落现象</strong> 这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！</p>\n<p>产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"literal\">null</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"promise数组依次执行\"><a href=\"#promise数组依次执行\" class=\"headerlink\" title=\"promise数组依次执行\"></a>promise数组依次执行</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span> (<span class=\"params\">api, ms, err = false</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`fetch-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span> start`</span>)</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      err ? reject(<span class=\"string\">`reject-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span>`</span>) : resolve(<span class=\"string\">`resolve-<span class=\"subst\">$&#123;api&#125;</span>-<span class=\"subst\">$&#123;ms&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;, ms)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解法一</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [fetch(<span class=\"string\">'API1'</span>, <span class=\"number\">3000</span>), fetch(<span class=\"string\">'API2'</span>, <span class=\"number\">2000</span>), fetch(<span class=\"string\">'API3'</span>, <span class=\"number\">5000</span>)]</span><br><span class=\"line\">  promises.reduce(<span class=\"function\">(<span class=\"params\">chain, promise</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'haha'</span>)).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadData()</span><br><span class=\"line\"><span class=\"comment\">// 解法二</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [fetch(<span class=\"string\">'API1'</span>, <span class=\"number\">3000</span>), fetch(<span class=\"string\">'API2'</span>, <span class=\"number\">2000</span>), fetch(<span class=\"string\">'API3'</span>, <span class=\"number\">5000</span>)]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> promise.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log(res))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"promise常见面试题\"><a href=\"#promise常见面试题\" class=\"headerlink\" title=\"promise常见面试题\"></a>promise常见面试题</h3><ol>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果为：1，2，4，3。</p>\n<p>  解题思路：then方法是异步执行的。</p>\n<ol start=\"2\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">    reject(<span class=\"string\">'error'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(err)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：success</p>\n<p>  解题思路：Promise状态一旦改变，无法在发生变更。</p>\n<ol start=\"3\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .then(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">3</span>))</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：1</p>\n<p>  解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。</p>\n<ol start=\"4\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise1'</span>)</span><br><span class=\"line\">  resolve(<span class=\"string\">'Promise2'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：Promise1    1    Promise2    setTimeout</p>\n<p>解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列<strong>microtask queue</strong>中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有<strong>microtask queue</strong>顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36972010\">www.zhihu.com/question/36…</a>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<p>结果是：3 4 6 8 7 5 2 1,优先级关系如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</span><br></pre></td></tr></table></figure>\n\n<p>V8实现中，两个队列各包含不同的任务：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</span><br><span class=\"line\">microtasks: process.nextTick, Promises, <span class=\"built_in\">Object</span>.observe, MutationObserver</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行过程如下：\\</strong>JavaScript引擎首先从macrotask queue中取出*<em>第一个任务*</em>，执行完毕后，将<strong>microtask queue</strong>中的<strong>所有任务</strong>取出，按顺序<strong>全部执行</strong>；然后再从macrotask queue中取<strong>下一个</strong>，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。</p>\n<p><strong>解释：\\</strong>代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，**放入到了另一个队列microtask queue**。等整个execution context stack执行完后，下一步该取的是*<em>microtask queue*</em>中的任务了。因此promise.then的回调比setTimeout先执行。 </p>\n<ol start=\"5\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：1  2</p>\n<p>解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。</p>\n<ol start=\"6\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">resolve(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">Date</span>.now() - start);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">Date</span>.now() - start);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出结果：</p>\n<p>开始</p>\n<p>success 5002</p>\n<p>success 5002</p>\n<p>解题思路：promise 的<strong>.then</strong>或者<strong>.catch</strong>可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用<strong>.then</strong> 或者<strong>.catch</strong>都会直接拿到该值。</p>\n<ol start=\"7\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">6</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve1'</span>)</span><br><span class=\"line\">    resolve(num)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject1'</span>)</span><br><span class=\"line\">    reject(num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve2'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(rej)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rej*<span class=\"number\">2</span>&gt;<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve3'</span>)</span><br><span class=\"line\">      resolve(rej*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject3'</span>)</span><br><span class=\"line\">      reject(rej*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&amp;emsp;&amp;emsp;<span class=\"keyword\">return</span> p2</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve4'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;,(rej)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject4'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(rej)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>  输出结果：</p>\n<p>    reject1    reject2    resolve3    resolve4    12</p>\n<p>  解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。</p>\n<ol start=\"8\">\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">  resolve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((<span class=\"function\"><span class=\"params\">resolve2</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve2(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;)).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>输出1 2 4 3</p>\n<ol start=\"9\">\n<li>重头戏！！！！实现一个简单的Promise</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> status = <span class=\"string\">'pending'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">successNotify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      status = <span class=\"string\">'fulfilled'</span><span class=\"comment\">//状态变为fulfilled</span></span><br><span class=\"line\">      toDoThen.apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failNotify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      status = <span class=\"string\">'rejected'</span><span class=\"comment\">//状态变为rejected</span></span><br><span class=\"line\">      toDoThen.apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toDoThen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; <span class=\"comment\">// 保证回调是异步执行的</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(status === <span class=\"string\">'fulfilled'</span>)&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>; i&lt; successArray.length;i ++)    &#123;</span><br><span class=\"line\">                  successArray[i].apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行then里面的回掉函数</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(status === <span class=\"string\">'rejected'</span>)&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>; i&lt; failArray.length;i ++)    &#123;</span><br><span class=\"line\">                  failArray[i].apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>)<span class=\"comment\">//执行then里面的回掉函数</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> successArray = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> failArray = []</span><br><span class=\"line\">  fn.call(<span class=\"literal\">undefined</span>, successNotify, failNotify)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">successFn, failFn</span>)</span>&#123;</span><br><span class=\"line\">          successArray.push(successFn)</span><br><span class=\"line\">          failArray.push(failFn)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// 此处应该返回一个Promise</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。</p>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async await\"></a>async await</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>（1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。</p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。</p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>\n<p>（4）返回值是 Promise。</p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会<strong>先返回，等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">'goog'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码指定50毫秒以后，输出<code>hello world</code>。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<p>async 函数有多种使用形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> foo() &#123;&#125; &#125;;</span><br><span class=\"line\">obj.foo().then(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class 的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cachePromise = caches.open(<span class=\"string\">'avatars'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">async</span> getAvatar(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.cachePromise;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.match(<span class=\"string\">`/avatars/<span class=\"subst\">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = <span class=\"keyword\">new</span> Storage();</span><br><span class=\"line\">storage.getAvatar(<span class=\"string\">'jake'</span>).then(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<h4 id=\"返回-Promise-对象\"><a href=\"#返回-Promise-对象\" class=\"headerlink\" title=\"返回 Promise 对象\"></a>返回 Promise 对象</h4><p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><strong><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// \"hello world\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  v =&gt; <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  e =&gt; <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise-对象的状态变化\"><a href=\"#Promise-对象的状态变化\" class=\"headerlink\" title=\"Promise 对象的状态变化\"></a>Promise 对象的状态变化</h4><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">'https://tc39.github.io/ecma262/'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// \"ECMAScript 2017 Language Specification\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<h4 id=\"await-命令\"><a href=\"#await-命令\" class=\"headerlink\" title=\"await 命令\"></a>await 命令</h4><p>正常情况下，<strong><code>await</code>命令后面是一个 Promise 对象。如果不是，会被转成一个立即<code>resolve</code>的 Promise 对象。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，它被转成 Promise 对象，并立即<code>resolve</code>。</p>\n<p><strong><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</strong>也就是说假如async中有await函数被reject了，那么这段报错会出现在async的catch中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>只要一个<code>await</code>语句后面的 Promise 变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// Error：出错了</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span>(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val1 = <span class=\"keyword\">await</span> firstStep();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val2 = <span class=\"keyword\">await</span> secondStep(val1);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val3 = <span class=\"keyword\">await</span> thirdStep(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Final: '</span>, val3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> NUM_RETRIES = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.get(<span class=\"string\">'http://google.com/this-throws-an-error'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<h4 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h4><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise()</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123; <span class=\"comment\">//这里不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到错误结果</span></span><br><span class=\"line\">  docs.forEach(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-函数的实现原理\"><a href=\"#async-函数的实现原理\" class=\"headerlink\" title=\"async 函数的实现原理\"></a>async 函数的实现原理</h3><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spawn</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> gen = genF();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">nextF</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> next = nextF();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(next.done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(next.value).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(v); &#125;);</span><br><span class=\"line\">      &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.throw(e); &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> gen.next(<span class=\"literal\">undefined</span>); &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与其他异步处理方法的比较\"><a href=\"#与其他异步处理方法的比较\" class=\"headerlink\" title=\"与其他异步处理方法的比较\"></a>与其他异步处理方法的比较</h3><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsPromise</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 变量ret用来保存上一个动画的返回值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 新建一个空的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 使用then方法，添加所有动画</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">    p = p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">      ret = val;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> anim(elem);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsGenerator</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">        ret = <span class=\"keyword\">yield</span> anim(elem);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>\n<p>最后是 async 函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsAsync</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">      ret = <span class=\"keyword\">await</span> anim(elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>\n<h3 id=\"实例：按顺序完成异步操作\"><a href=\"#实例：按顺序完成异步操作\" class=\"headerlink\" title=\"实例：按顺序完成异步操作\"></a>实例：按顺序完成异步操作</h3><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>\n<p>Promise 的写法如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程读取所有URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.text());</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  textPromises.reduce(<span class=\"function\">(<span class=\"params\">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> textPromise)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">text</span> =&gt;</span> <span class=\"built_in\">console</span>.log(text));</span><br><span class=\"line\">  &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>\n<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url <span class=\"keyword\">of</span> urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> response.text());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>\n<h3 id=\"异步遍历器\"><a href=\"#异步遍历器\" class=\"headerlink\" title=\"异步遍历器\"></a>异步遍历器</h3><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n<p>这里隐含着一个规定，<code>next</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>next</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-async-iteration\" target=\"_blank\" rel=\"noopener\">提案</a>，为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p>\n<h4 id=\"异步遍历的接口\"><a href=\"#异步遍历的接口\" class=\"headerlink\" title=\"异步遍历的接口\"></a>异步遍历的接口</h4><p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncIterator</span><br><span class=\"line\">  .next()</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (&#123; value, done &#125;) =&gt; <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p>\n<p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p>\n<p>下面是一个异步遍历器的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncIterable = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncIterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">asyncIterator</span><br><span class=\"line\">.next()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult1); <span class=\"comment\">// &#123; value: 'a', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncIterator.next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult2</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult2); <span class=\"comment\">// &#123; value: 'b', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> asyncIterator.next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">iterResult3</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(iterResult3); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p>\n<p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> asyncIterable = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> asyncIterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: 'a', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: 'b', done: false &#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> asyncIterator.next());</span><br><span class=\"line\">  <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p>\n<p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的Promise对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncGenObj = createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [&#123;<span class=\"attr\">value</span>: v1&#125;, &#123;<span class=\"attr\">value</span>: v2&#125;] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">  asyncGenObj.next(), asyncGenObj.next()</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v1, v2); <span class=\"comment\">// a b</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> writer = openFile(<span class=\"string\">'someFile.txt'</span>);</span><br><span class=\"line\">writer.next(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">writer.next(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"keyword\">await</span> writer.return();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-await…of\"><a href=\"#for-await…of\" class=\"headerlink\" title=\"for await…of\"></a>for await…of</h4><p>前面介绍过，<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> createAsyncIterable([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>createAsyncIterable()</code>返回一个异步遍历器，<code>for...of</code>循环自动调用这个遍历器的<code>next</code>方法，会得到一个Promise对象。<code>await</code>用来处理这个Promise对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p>\n<p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> body = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">await</span>(<span class=\"keyword\">const</span> data <span class=\"keyword\">of</span> req) body += data;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parsed = <span class=\"built_in\">JSON</span>.parse(body);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'got'</span>, parsed);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p>\n<p>如果<code>next</code>方法返回的Promise对象被<code>reject</code>，那么就要用<code>try...catch</code>捕捉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> createRejectingIterable()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步Generator函数\"><a href=\"#异步Generator函数\" class=\"headerlink\" title=\"异步Generator函数\"></a>异步Generator函数</h4><p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p>\n<p>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">readLines</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> file = <span class=\"keyword\">await</span> fileOpen(path);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!file.EOF) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> file.readLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> file.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回Promise对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法的停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是于同步Generator函数一致的。</p>\n<p>可以像下面这样，使用上面代码定义的异步Generator函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> line <span class=\"keyword\">of</span> readLines(filePath)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(line);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">prefixLines</span>(<span class=\"params\">asyncIterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> line <span class=\"keyword\">of</span> asyncIterable) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'&gt; '</span> + line;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code>命令依然是立刻返回的，但是返回的是一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Start'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> doSomethingAsync(); <span class=\"comment\">// (A)</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'Result: '</span>+ result; <span class=\"comment\">// (B)</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，调用<code>next</code>方法以后，会在<code>B</code>处暂停执行，<code>yield</code>命令立刻返回一个Promise对象。这个Promise对象不同于<code>A</code>处<code>await</code>命令后面的那个 Promise 对象。主要有两点不同，一是<code>A</code>处的Promise对象<code>resolve</code>以后产生的值，会放入<code>result</code>变量；二是<code>B</code>处的Promise对象<code>resolve</code>以后产生的值，是表达式<code>&#39;Result： &#39; + result</code>的值；二是<code>A</code>处的 Promise 对象一定先于<code>B</code>处的 Promise 对象<code>resolve</code>。</p>\n<p>如果异步 Generator 函数抛出错误，会被 Promise 对象<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Problem!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncGenerator()</span><br><span class=\"line\">.next()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err)); <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，<code>async</code>函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeAsync</span>(<span class=\"params\">asyncIterable, count=Infinity</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> iterator = asyncIterable[<span class=\"built_in\">Symbol</span>.asyncIterator]();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (result.length &lt; count) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;value,done&#125; = <span class=\"keyword\">await</span> iterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    result.push(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，异步Generator函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。</p>\n<p>下面是这个自动执行器的一个使用实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'c'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> takeAsync(gen());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。</p>\n<p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">createAsyncIterable</span>(<span class=\"params\">syncIterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> elem <span class=\"keyword\">of</span> syncIterable) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> elem;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p>\n<h4 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">yield</span>* gen1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p>\n<p>与同步Generator函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> gen2()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// b</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promisify\"><a href=\"#Promisify\" class=\"headerlink\" title=\"Promisify\"></a>Promisify</h2><p><code>util.promisify</code>是在<code>node.js 8.x</code>版本中新增的一个工具，用于将老式的<code>Error first callback</code>转换为<code>Promise</code>对象，让老项目改造变得更为轻松。</p>\n<p>在官方推出这个工具之前，民间已经有很多类似的工具了，比如<a href=\"https://www.npmjs.com/package/es6-promisify\" target=\"_blank\" rel=\"noopener\">es6-promisify</a>、<a href=\"https://www.npmjs.com/package/thenify\" target=\"_blank\" rel=\"noopener\">thenify</a>、<a href=\"http://bluebirdjs.com/docs/api/promise.promisify.html\" target=\"_blank\" rel=\"noopener\">bluebird.promisify</a>。</p>\n<p>以及很多其他优秀的工具，都是实现了这样的功能，帮助我们在处理老项目的时候，不必费神将各种代码使用<code>Promise</code>再重新实现一遍。</p>\n<h3 id=\"工具实现的大致思路\"><a href=\"#工具实现的大致思路\" class=\"headerlink\" title=\"工具实现的大致思路\"></a>工具实现的大致思路</h3><p>首先要解释一下这种工具大致的实现思路，因为在<code>Node</code>中异步回调有一个约定：<code>Error first</code>，也就是说回调函数中的第一个参数一定要是<code>Error</code>对象，其余参数才是正确时的数据。</p>\n<p>知道了这样的规律以后，工具就很好实现了，在匹配到第一个参数有值的情况下，触发<code>reject</code>，其余情况触发<code>resolve</code>，一个简单的示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">util</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(...arg, (err, arg) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) reject(err)</span><br><span class=\"line\">      <span class=\"keyword\">else</span> resolve(arg)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>调用工具函数返回一个匿名函数，匿名函数接收原函数的参数。</li>\n<li>匿名函数被调用后根据这些参数来调用真实的函数，同时拼接一个用来处理结果的<code>callback</code>。</li>\n<li>检测到<code>err</code>有值，触发<code>reject</code>，其他情况触发<code>resolve</code></li>\n</ol>\n<p><strong>resolve 只能传入一个参数，所以<code>callback</code>中没有必要使用<code>...arg</code>获取所有的返回值</strong></p>\n<h3 id=\"常规的使用方式\"><a href=\"#常规的使用方式\" class=\"headerlink\" title=\"常规的使用方式\"></a>常规的使用方式</h3><blockquote>\n<p>拿一个官方文档中的示例</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> statAsync = promisify(fs.stat)</span><br><span class=\"line\"></span><br><span class=\"line\">statAsync(<span class=\"string\">'.'</span>).then(<span class=\"function\"><span class=\"params\">stats</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 拿到了正确的数据</span></span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 出现了异常</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以及因为是<code>Promise</code>，我们可以使用<code>await</code>来进一步简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> statAsync = promisify(fs.stat)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设在 async 函数中</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stats = <span class=\"keyword\">await</span> statAsync(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 拿到正确结果</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 出现异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法与其他工具并没有太大的区别，我们可以很轻易的将回调转换为<code>Promise</code>，然后应用于新的项目中。</p>\n<h3 id=\"自定义的-Promise-化\"><a href=\"#自定义的-Promise-化\" class=\"headerlink\" title=\"自定义的 Promise 化\"></a>自定义的 Promise 化</h3><p>有那么一些场景，是不能够直接使用<code>promisify</code>来进行转换的，有大概这么两种情况：</p>\n<ol>\n<li>没有遵循<code>Error first callback</code>约定的回调函数</li>\n<li>返回多个参数的回调函数</li>\n</ol>\n<p>首先是第一个，如果没有遵循我们的约定，很可能导致<code>reject</code>的误判，得不到正确的反馈。<br>而第二项呢，则是因为<code>Promise.resolve</code>只能接收一个参数，多余的参数会被忽略。</p>\n<p>所以为了实现正确的结果，我们可能需要手动实现对应的<code>Promise</code>函数，但是自己实现了以后并不能够确保使用方不会针对你的函数调用<code>promisify</code>。</p>\n<p>所以，<code>util.promisify</code>还提供了一个<code>Symbol</code>类型的<code>key</code>，<code>util.promisify.custom</code>。</p>\n<p><code>Symbol</code>类型的大家应该都有了解，是一个唯一的值，这里是<code>util.prosimify</code>用来指定自定义的<code>Promise</code>化的结果的，使用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 比如我们有一个对象，提供了一个返回多个参数的回调版本的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  getData (callback) &#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, <span class=\"string\">'Niko'</span>, <span class=\"number\">18</span>) <span class=\"comment\">// 返回两个参数，姓名和年龄</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这时使用promisify肯定是不行的</span></span><br><span class=\"line\"><span class=\"comment\">// 因为Promise.resolve只接收一个参数，所以我们只会得到 Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\">promisify(obj.getData)().then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所以我们需要使用 promisify.custom 来自定义处理方式</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"keyword\">async</span> () =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当然了，这是一个曲线救国的方式，无论如何 Promise 不会返回多个参数过来的</span></span><br><span class=\"line\">promisify(obj.getData)().then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// &#123; name: 'Niko', age: 18 &#125;</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p><em>关于<code>Promise</code>为什么不能<code>resolve</code>多个值，我有一个大胆的想法，一个没有经过考证，强行解释的理由：如果能<code>resolve</code>多个值，你让<code>async</code>函数怎么<code>return</code>（当个乐子看这句话就好，不要当真）</em><br><em>不过应该确实跟<code>return</code>有关，因为<code>Promise</code>是可以链式调用的，每个<code>Promise</code>中执行<code>then</code>以后都会将其返回值作为一个新的<code>Promise</code>对象<code>resolve</code>的值，在<code>JavaScript</code>中并没有办法<code>return</code>多个参数，所以即便第一个<code>Promise</code>可以返回多个参数，只要经过<code>return</code>的处理就会丢失</em></p>\n<p>在使用上就是很简单的针对可能会被调用<code>promisify</code>的函数上添加<code>promisify.custom</code>对应的处理即可。<br>当后续代码调用<code>promisify</code>时就会进行判断：</p>\n<ol>\n<li><p>如果目标函数存在</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify.custom</span><br></pre></td></tr></table></figure>\n\n<p>属性，则会判断其类型：</p>\n<ol>\n<li>如果不是一个可执行的函数，抛出异常</li>\n<li>如果是可执行的函数，则直接返回其对应的函数</li>\n</ol>\n</li>\n<li><p>如果目标函数不存在对应的属性，按照<code>Error first callback</code>的约定生成对应的处理函数然后返回</p>\n</li>\n</ol>\n<p>添加了这个<code>custom</code>属性以后，就不用再担心使用方针对你的函数调用<code>promisify</code>了。<br>而且可以验证，赋值给<code>custom</code>的函数与<code>promisify</code>返回的函数地址是一处：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.getData[promisify.custom] = <span class=\"keyword\">async</span> () =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上边的赋值为 async 函数也可以改为普通函数，只要保证这个普通函数会返回 Promise 实例即可</span></span><br><span class=\"line\"><span class=\"comment\">// 这两种方式与上边的 async 都是完全相等的</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;)</span><br><span class=\"line\">obj.getData[promisify.custom] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Niko'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getData[promisify.custom] === promisify(obj.getData)) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一些内置的-custom-处理\"><a href=\"#一些内置的-custom-处理\" class=\"headerlink\" title=\"一些内置的 custom 处理\"></a>一些内置的 custom 处理</h4><p>在一些内置包中，也能够找到<code>promisify.custom</code>的踪迹，比如说最常用的<code>child_process.exec</code>就内置了<code>promisify.custom</code>的处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; exec &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> exec[promisify.custom]) <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>因为就像前边示例中所提到的曲线救国的方案，官方的做法也是将函数签名中的参数名作为<code>key</code>，将其所有参数存放到一个<code>Object</code>对象中进行返回，比如<code>child_process.exec</code>的返回值抛开<code>error</code>以外会包含两个，<code>stdout</code>和<code>stderr</code>，一个是命令执行后的正确输出，一个是命令执行后的错误输出：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify(exec)(<span class=\"string\">'ls'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &#123; stdout: 'XXX', stderr: '' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者我们故意输入一些错误的命令，当然了，这个只能在<code>catch</code>模块下才能够捕捉到，一般命令正常执行<code>stderr</code>都会是一个空字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promisify(exec)(<span class=\"string\">'lss'</span>).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &#123; ..., stdout: '', stderr: 'lss: command not found' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>包括像<code>setTimeout</code>、<code>setImmediate</code>也都实现了对应的<code>promisify.custom</code>。<br>之前为了实现<code>sleep</code>的操作，还手动使用<code>Promise</code>封装了<code>setTimeout</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sleep = promisify(setTimeout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置的-promisify-转换后函数\"><a href=\"#内置的-promisify-转换后函数\" class=\"headerlink\" title=\"内置的 promisify 转换后函数\"></a>内置的 promisify 转换后函数</h3><p>如果你的<code>Node</code>版本使用<code>10.x</code>以上的，还可以从很多内置的模块中找到类似<code>.promises</code>的子模块，这里边包含了该模块中常用的回调函数的<code>Promise</code>版本（都是<code>async</code>函数），无需再手动进行<code>promisify</code>转换了。</p>\n<p>而且我本人觉得这是一个很好的指引方向，因为之前的工具实现，有的选择直接覆盖原有函数，有的则是在原有函数名后边增加<code>Async</code>进行区分，官方的这种在模块中单独引入一个子模块，在里边实现<code>Promise</code>版本的函数，其实这个在使用上是很方便的，就拿<code>fs</code>模块进行举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前引入一些 fs 相关的 API 是这样做的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; readFile, stat &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而现在可以很简单的改为</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; readFile, stat &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).promises</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">promises</span>: &#123; readFile, stat &#125; &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>后边要做的就是将调用<code>promisify</code>相关的代码删掉即可，对于其他使用<code>API</code>的代码来讲，这个改动是无感知的。<br>所以如果你的<code>node</code>版本够高的话，可以在使用内置模块之前先去翻看文档，有没有对应的<code>promises</code>支持，如果有实现的话，就可以直接使用。</p>\n<h3 id=\"promisify-的一些注意事项\"><a href=\"#promisify-的一些注意事项\" class=\"headerlink\" title=\"promisify 的一些注意事项\"></a>promisify 的一些注意事项</h3><ol>\n<li>一定要符合<code>Error first callback</code>的约定</li>\n<li>不能返回多个参数</li>\n<li>注意进行转换的函数是否包含<code>this</code>的引用</li>\n</ol>\n<p>前两个问题，使用前边提到的<code>promisify.custom</code>都可以解决掉。<br>但是第三项可能会在某些情况下被我们所忽视，这并不是<code>promisify</code>独有的问题，就一个很简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Niko'</span>,</span><br><span class=\"line\">  getName () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName() <span class=\"comment\">// Niko</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func = obj.getName</span><br><span class=\"line\"></span><br><span class=\"line\">func() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，如果我们在进行<code>Promise</code>转换的时候，也是类似这样的操作，那么可能会导致生成后的函数<code>this</code>指向出现问题。<br>修复这样的问题有两种途径：</p>\n<ol>\n<li>使用箭头函数，也是推荐的做法</li>\n<li>在调用<code>promisify</code>之前使用<code>bind</code>绑定对应的<code>this</code></li>\n</ol>\n<p>不过这样的问题也是建立在<code>promisify</code>转换后的函数被赋值给其他变量的情况下会发生。<br>如果是类似这样的代码，那么完全不必担心<code>this</code>指向的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Niko'</span>,</span><br><span class=\"line\">  getName (callback) &#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样的操作是不需要担心 this 指向问题的</span></span><br><span class=\"line\">obj.XXX = promisify(obj.getName)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果赋值给了其他变量，那么这里就需要注意 this 的指向了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> func = promisify(obj.getName) <span class=\"comment\">// 错误的 this</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>个人认为<code>Promise</code>作为当代<code>javaScript</code>异步编程中最核心的一部分，了解如何将老旧代码转换为<code>Promise</code>是一件很有意思的事儿。<br>而我去了解官方的这个工具，原因是在搜索<code>Redis</code>相关的<code>Promise</code>版本时看到了这个<a href=\"https://github.com/mjackson/then-redis\" target=\"_blank\" rel=\"noopener\">readme</a>：</p>\n<blockquote>\n<p>This package is no longer maintained. node_redis now includes support for promises in core, so this is no longer needed.</p>\n</blockquote>\n<p>然后跳到了<code>node_redis</code>里边的实现方案，里边提到了<code>util.promisify</code>，遂抓过来研究了一下，感觉还挺有意思，总结了下分享给大家。</p>\n<h2 id=\"Js异步执行顺序\"><a href=\"#Js异步执行顺序\" class=\"headerlink\" title=\"Js异步执行顺序\"></a>Js异步执行顺序</h2><p>今天在重温promise的时候，突然发现了一个有趣的题目：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">                setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">                <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>));</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>));</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>我们先放上结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">9</span> <span class=\"number\">5</span> <span class=\"number\">0</span> <span class=\"number\">6</span> <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">4</span> <span class=\"number\">8</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简要讲述\"><a href=\"#简要讲述\" class=\"headerlink\" title=\"简要讲述\"></a>简要讲述</h3><p>首先我们知道JS分为了同步和异步，并且是顺序是先同步后异步，也就是同步代码执行完成后，哪怕异步代码到了它执行的时候，也会先让同步执行完。但是JS的执行顺序还可以分得更细，那就是异步的顺序。 我们知道很多异步任务，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout, setInterval, setImmediate, Promises.then, <span class=\"built_in\">Promise</span>.catch</span><br></pre></td></tr></table></figure>\n\n<p>甚至还有nodejs中的process.nextTick等，就像我们知道process.nextTick比promise先执行一样。那么这些异步事件是谁先执行谁后执行呢。 这涉及到了事件循环(event loop)。事件循环也就是事件出入栈。 上面说了这么多异步任务，我们先把它们分为两类： <strong>宏任务（macro-task）</strong>：setTimeout, setInterval, setImmediate <strong>微任务（micro-task）</strong>：Promises.then, Promise.catch</p>\n<p>然后我们再明白一个概念：<strong>先执行微任务，再执行宏任务</strong>。这种执行是，<strong>先执行清空微任务队列，再执行宏任务，当当前宏任务执行完后，微任务队列中又有微任务，再次将微任务队列执行完，再执行下一个宏任务</strong>。</p>\n<p>在异步任务执行过程中遇到宏任务与微任务，将其依次放入当前事件循环队列中。</p>\n<h3 id=\"例题描述\"><a href=\"#例题描述\" class=\"headerlink\" title=\"例题描述\"></a>例题描述</h3><p>首先执行主线程，也就是script（script是宏任务），因为此时没有微任务</p>\n<p>然后遇到<code>setTimeout(() =&gt; { console.log(0);});</code> 这是宏任务，将其放入宏任务队列中 记为 – 宏任务1</p>\n<p>promise新建后会立即执行，输出<code>1</code></p>\n<p>然后将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续放入宏任务队列中 记为 – 宏任务2</p>\n<p>将<code>Promise.resolve().then(() =&gt; console.log(5));</code>放入微任务队列中 记为 – 微任务1</p>\n<p>继续往下走，输出<code>9</code></p>\n<p>此时当前宏任务执行完毕，开始执行微任务队列，目前微任务队列中只有微任务1，执行，输出<code>5</code></p>\n<p>微任务队列此时清空，然后执行宏任务1，输出<code>0</code></p>\n<p>微任务队列依然没有任务，继续执行宏任务2，遇见 <code>resolve();</code>，于是将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">7</span>));</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>放入微任务队列中，记为 – 微任务2，再将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>));</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>记为 – 微任务3</p>\n<p>当前宏任务执行完毕，开始执行微任务，先执行微任务2，输出<code>6</code>；将<code>Promise.resolve().then(() =&gt; console.log(7));</code>记为 – 微任务4；<code>setTimeout(() =&gt; console.log(8));</code>记为 – 宏任务3</p>\n<p>执行微任务3，输出<code>2</code>；将<code>setTimeout(() =&gt; console.log(3));</code>记为 – 宏任务4；将<code>Promise.resolve().then(() =&gt; console.log(4));</code>记为 – 微任务5；</p>\n<p>此时队列中依然有微任务，执行微任务4，输出<code>7</code>；执行微任务5，输出<code>4</code>；微任务队列执行完毕</p>\n<p>执行宏任务3，输出<code>8</code>；执行宏任务4，输出<code>3</code>；全部执行完毕</p>\n<p>那么我们的结果为<code>1 9 5 0 6 2 7 4 8 3</code></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8ct7j540000gtvi594i1te1","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5i000bgtvib9a991u2"},{"post_id":"ck8ct7j580001gtviflg7hzcj","category_id":"ck8ct7j5f0007gtvicc919usp","_id":"ck8ct7j5p000hgtviem9ob814"},{"post_id":"ck8ct7j5i000agtvievlbgbkx","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5r000kgtvi55shai06"},{"post_id":"ck8ct7j5k000egtvi52cphgi5","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5s000ogtvi70oq322m"},{"post_id":"ck8ct7j5c0004gtvi7cvt5opm","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5t000sgtvidelrh71f"},{"post_id":"ck8ct7j5q000jgtvi3sgbhx2v","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5u000vgtvi7h5c0cr1"},{"post_id":"ck8ct7j5d0005gtvi3pxl3qlw","category_id":"ck8ct7j5f0007gtvicc919usp","_id":"ck8ct7j5w0010gtvicl5odiwn"},{"post_id":"ck8ct7j5r000mgtviatsyal1r","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5x0013gtvi6h0ke60q"},{"post_id":"ck8ct7j5t000rgtviegtp24vq","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j5y0018gtvi6paif0cy"},{"post_id":"ck8ct7j5e0006gtvi09lp7lb2","category_id":"ck8ct7j5s000ngtvibpgc5puk","_id":"ck8ct7j5z001bgtvigdv8hauv"},{"post_id":"ck8ct7j5u000ugtvibfvdgidv","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j60001egtvi8rzgegtm"},{"post_id":"ck8ct7j5v000ygtvi9j9w0hzs","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j61001igtvi730hafjh"},{"post_id":"ck8ct7j5g0009gtvi9odq7ojg","category_id":"ck8ct7j5u000xgtvi0qj4geyf","_id":"ck8ct7j62001mgtvibar8hu4i"},{"post_id":"ck8ct7j5w0012gtvifhvta6ua","category_id":"ck8ct7j5f0007gtvicc919usp","_id":"ck8ct7j63001qgtvidxr629o8"},{"post_id":"ck8ct7j5x0016gtviexk25cro","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j64001ugtvihii36v3p"},{"post_id":"ck8ct7j5y001agtvi9qm7ffbs","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j64001xgtvi4ozy05v1"},{"post_id":"ck8ct7j5l000fgtvi891mhoho","category_id":"ck8ct7j5x0015gtvif9cq2pwp","_id":"ck8ct7j650020gtvi8jwy425c"},{"post_id":"ck8ct7j5z001dgtvi77ng2i0n","category_id":"ck8ct7j61001kgtvig9lc5qr2","_id":"ck8ct7j650023gtvielcvbtbf"},{"post_id":"ck8ct7j63001sgtvi42ox43mq","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7j650025gtvig0rj13ww"},{"post_id":"ck8ct7j60001hgtvi1u0td7c9","category_id":"ck8ct7j63001tgtvigpgr4trq","_id":"ck8ct7j660029gtviddqzhxth"},{"post_id":"ck8ct7j61001lgtvi0kojd427","category_id":"ck8ct7j65001zgtvib6ha3y0n","_id":"ck8ct7j66002cgtvi9sfs8dxl"},{"post_id":"ck8ct7j62001pgtvi97lv2qkg","category_id":"ck8ct7j65001zgtvib6ha3y0n","_id":"ck8ct7j67002ggtvigipvd88g"},{"post_id":"ck8ct7kgy003lgtvi3zut29bc","category_id":"ck8ct7j61001kgtvig9lc5qr2","_id":"ck8ct7kh2003tgtvi3zxzg9zo"},{"post_id":"ck8ct7kgz003ngtvi7lfge1by","category_id":"ck8ct7j5a0002gtvigu1286un","_id":"ck8ct7kh2003vgtvi144m7g0a"},{"post_id":"ck8ct7kh1003qgtvi166e4xbl","category_id":"ck8ct7j65001zgtvib6ha3y0n","_id":"ck8ct7kh3003ygtvi4rgl7s1y"}],"PostTag":[{"post_id":"ck8ct7j540000gtvi594i1te1","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j5r000lgtvi8w1ugkym"},{"post_id":"ck8ct7j540000gtvi594i1te1","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j5s000pgtvi4lsh7jnc"},{"post_id":"ck8ct7j540000gtvi594i1te1","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7j5t000tgtvibi689aur"},{"post_id":"ck8ct7j5q000jgtvi3sgbhx2v","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j5u000wgtvighjo4oa7"},{"post_id":"ck8ct7j5q000jgtvi3sgbhx2v","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j5w0011gtvie2m71qwp"},{"post_id":"ck8ct7j5r000mgtviatsyal1r","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j5x0014gtvi7voz1he8"},{"post_id":"ck8ct7j5r000mgtviatsyal1r","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j5y0019gtvi5uqccaa3"},{"post_id":"ck8ct7j5t000rgtviegtp24vq","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j5z001cgtvi35pfhaf0"},{"post_id":"ck8ct7j5t000rgtviegtp24vq","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j60001ggtvibcz97i6z"},{"post_id":"ck8ct7j5u000ugtvibfvdgidv","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j61001jgtvi93j8e5bt"},{"post_id":"ck8ct7j5u000ugtvibfvdgidv","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j62001ogtvihrrfgm3j"},{"post_id":"ck8ct7j580001gtviflg7hzcj","tag_id":"ck8ct7j5p000igtviea918uv0","_id":"ck8ct7j63001rgtvi3e83fdlr"},{"post_id":"ck8ct7j580001gtviflg7hzcj","tag_id":"ck8ct7j5s000qgtvig401ehvt","_id":"ck8ct7j64001wgtvi1d9i5c44"},{"post_id":"ck8ct7j5y001agtvi9qm7ffbs","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j64001ygtvi5onv2g8d"},{"post_id":"ck8ct7j5y001agtvi9qm7ffbs","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j650021gtvicx2q48o6"},{"post_id":"ck8ct7j5c0004gtvi7cvt5opm","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j650024gtvibnvjd7ul"},{"post_id":"ck8ct7j5c0004gtvi7cvt5opm","tag_id":"ck8ct7j5y0017gtvibd0415l2","_id":"ck8ct7j660026gtvi6o3nat3d"},{"post_id":"ck8ct7j61001lgtvi0kojd427","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j66002agtviefhf6yzw"},{"post_id":"ck8ct7j61001lgtvi0kojd427","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7j66002bgtvia24a7apn"},{"post_id":"ck8ct7j62001pgtvi97lv2qkg","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j67002egtvi216c3dbz"},{"post_id":"ck8ct7j62001pgtvi97lv2qkg","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7j67002fgtvige3fhmg3"},{"post_id":"ck8ct7j5d0005gtvi3pxl3qlw","tag_id":"ck8ct7j5p000igtviea918uv0","_id":"ck8ct7j67002igtvi0cpxfiq4"},{"post_id":"ck8ct7j5d0005gtvi3pxl3qlw","tag_id":"ck8ct7j5s000qgtvig401ehvt","_id":"ck8ct7j67002jgtvi5y1ac5ir"},{"post_id":"ck8ct7j63001sgtvi42ox43mq","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j68002lgtvi4vvjctik"},{"post_id":"ck8ct7j63001sgtvi42ox43mq","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7j68002mgtviggny59cg"},{"post_id":"ck8ct7j63001sgtvi42ox43mq","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j68002ogtviclsv9791"},{"post_id":"ck8ct7j5e0006gtvi09lp7lb2","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j68002pgtvicuo1g98l"},{"post_id":"ck8ct7j5e0006gtvi09lp7lb2","tag_id":"ck8ct7j64001vgtvif0vr04vf","_id":"ck8ct7j69002rgtviby1h4hh9"},{"post_id":"ck8ct7j5g0009gtvi9odq7ojg","tag_id":"ck8ct7j5s000qgtvig401ehvt","_id":"ck8ct7j69002sgtvifho67gp2"},{"post_id":"ck8ct7j5g0009gtvi9odq7ojg","tag_id":"ck8ct7j660028gtvi7i345xju","_id":"ck8ct7j69002ugtvib2i9c3fk"},{"post_id":"ck8ct7j5i000agtvievlbgbkx","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j6a002vgtvi7hgy34we"},{"post_id":"ck8ct7j5i000agtvievlbgbkx","tag_id":"ck8ct7j5y0017gtvibd0415l2","_id":"ck8ct7j6a002xgtvi3grxctwk"},{"post_id":"ck8ct7j5k000egtvi52cphgi5","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j6a002ygtvi0dah9y3t"},{"post_id":"ck8ct7j5k000egtvi52cphgi5","tag_id":"ck8ct7j5y0017gtvibd0415l2","_id":"ck8ct7j6b0030gtvi6uu791yj"},{"post_id":"ck8ct7j5l000fgtvi891mhoho","tag_id":"ck8ct7j660028gtvi7i345xju","_id":"ck8ct7j6b0031gtvi9cw3ghuc"},{"post_id":"ck8ct7j5l000fgtvi891mhoho","tag_id":"ck8ct7j5y0017gtvibd0415l2","_id":"ck8ct7j6b0033gtvi6oqm5h50"},{"post_id":"ck8ct7j5l000fgtvi891mhoho","tag_id":"ck8ct7j64001vgtvif0vr04vf","_id":"ck8ct7j6b0034gtvigc5dartn"},{"post_id":"ck8ct7j5v000ygtvi9j9w0hzs","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j6b0036gtvi705uep0i"},{"post_id":"ck8ct7j5v000ygtvi9j9w0hzs","tag_id":"ck8ct7j5y0017gtvibd0415l2","_id":"ck8ct7j6c0037gtvi124g9bpy"},{"post_id":"ck8ct7j5w0012gtvifhvta6ua","tag_id":"ck8ct7j5p000igtviea918uv0","_id":"ck8ct7j6c0039gtvibmyqbqwb"},{"post_id":"ck8ct7j5w0012gtvifhvta6ua","tag_id":"ck8ct7j660028gtvi7i345xju","_id":"ck8ct7j6c003agtvi5phx9v4g"},{"post_id":"ck8ct7j5w0012gtvifhvta6ua","tag_id":"ck8ct7j5s000qgtvig401ehvt","_id":"ck8ct7j6c003bgtvif4ux0iog"},{"post_id":"ck8ct7j5x0016gtviexk25cro","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j6c003cgtvibas55gnf"},{"post_id":"ck8ct7j5x0016gtviexk25cro","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j6c003dgtvib7nsfghu"},{"post_id":"ck8ct7j5x0016gtviexk25cro","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7j6d003egtvi773cb6bp"},{"post_id":"ck8ct7j5x0016gtviexk25cro","tag_id":"ck8ct7j6a002zgtvi5uwe1qhn","_id":"ck8ct7j6d003fgtvi2go2c2ej"},{"post_id":"ck8ct7j5z001dgtvi77ng2i0n","tag_id":"ck8ct7j6b0032gtvi4793184k","_id":"ck8ct7j6d003ggtvi8hpn1831"},{"post_id":"ck8ct7j5z001dgtvi77ng2i0n","tag_id":"ck8ct7j660028gtvi7i345xju","_id":"ck8ct7j6d003hgtvigz76blkq"},{"post_id":"ck8ct7j60001hgtvi1u0td7c9","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7j6d003igtviexp10aqw"},{"post_id":"ck8ct7j60001hgtvi1u0td7c9","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7j6d003jgtvi33447jgw"},{"post_id":"ck8ct7j60001hgtvi1u0td7c9","tag_id":"ck8ct7j6c0038gtvi4k3r8twd","_id":"ck8ct7j6d003kgtvi44ksep3a"},{"post_id":"ck8ct7kgz003ngtvi7lfge1by","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7kh2003sgtvi2awmbvyp"},{"post_id":"ck8ct7kgz003ngtvi7lfge1by","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7kh2003ugtvi55kqck7g"},{"post_id":"ck8ct7kgz003ngtvi7lfge1by","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7kh3003xgtviclnydiz8"},{"post_id":"ck8ct7kh1003qgtvi166e4xbl","tag_id":"ck8ct7j5b0003gtvi2dzccdtp","_id":"ck8ct7kh3003zgtvigyo4fup4"},{"post_id":"ck8ct7kh1003qgtvi166e4xbl","tag_id":"ck8ct7j5f0008gtvi2e6igsd9","_id":"ck8ct7kh30040gtvi6c493g98"},{"post_id":"ck8ct7kh1003qgtvi166e4xbl","tag_id":"ck8ct7j5j000dgtvi440sadc9","_id":"ck8ct7kh30041gtvi2mve8azq"},{"post_id":"ck8ct7kgy003lgtvi3zut29bc","tag_id":"ck8ct7j6b0032gtvi4793184k","_id":"ck8ct7kh40042gtviakolgxnd"},{"post_id":"ck8ct7kgy003lgtvi3zut29bc","tag_id":"ck8ct7kh0003pgtvidfwrfoae","_id":"ck8ct7kh40043gtvig2oh8rqi"},{"post_id":"ck8ct7kgy003lgtvi3zut29bc","tag_id":"ck8ct7kh2003wgtvi3f7ggxu6","_id":"ck8ct7kh40044gtvih0j41ox2"},{"post_id":"ck8ct7kgy003lgtvi3zut29bc","tag_id":"ck8ct7j660028gtvi7i345xju","_id":"ck8ct7kh40045gtvigd426tn6"}],"Tag":[{"name":"tutorial","_id":"ck8ct7j5b0003gtvi2dzccdtp"},{"name":"code","_id":"ck8ct7j5f0008gtvi2e6igsd9"},{"name":"javascript","_id":"ck8ct7j5j000dgtvi440sadc9"},{"name":"travel","_id":"ck8ct7j5p000igtviea918uv0"},{"name":"blog","_id":"ck8ct7j5s000qgtvig401ehvt"},{"name":"tips","_id":"ck8ct7j5y0017gtvibd0415l2"},{"name":"financial","_id":"ck8ct7j64001vgtvif0vr04vf"},{"name":"life","_id":"ck8ct7j660028gtvi7i345xju"},{"name":"node","_id":"ck8ct7j6a002zgtvi5uwe1qhn"},{"name":"review","_id":"ck8ct7j6b0032gtvi4793184k"},{"name":"database","_id":"ck8ct7j6c0038gtvi4k3r8twd"},{"name":"tech","_id":"ck8ct7kh0003pgtvidfwrfoae"},{"name":"mouse","_id":"ck8ct7kh2003wgtvi3f7ggxu6"}]}}